{
  "version": 3,
  "sources": ["../../@vaadin/a11y-base/src/aria-hidden.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2017 Anton Korzunov\n * SPDX-License-Identifier: MIT\n */\n\n/**\n * @fileoverview\n *\n * This module includes JS code copied from the `aria-hidden` package:\n * https://github.com/theKashey/aria-hidden/blob/master/src/index.ts\n */\n\n/** @type {WeakMap<Element, number>} */\nlet counterMap = new WeakMap();\n\n/** @type {WeakMap<Element, boolean>} */\nlet uncontrolledNodes = new WeakMap();\n\n/** @type {Record<string, WeakMap<Element, number>>} */\nlet markerMap = {};\n\n/** @type {number} */\nlet lockCount = 0;\n\n/**\n * @param {?Node} node\n * @return {boolean}\n */\nconst isElement = (node) => node && node.nodeType === Node.ELEMENT_NODE;\n\n/**\n * @param  {...unknown} args\n */\nconst logError = (...args) => {\n  console.error(`Error: ${args.join(' ')}. Skip setting aria-hidden.`);\n};\n\n/**\n * @param {HTMLElement} parent\n * @param {Element[]} targets\n * @return {Element[]}\n */\nconst correctTargets = (parent, targets) => {\n  if (!isElement(parent)) {\n    logError(parent, 'is not a valid element');\n    return [];\n  }\n\n  return targets\n    .map((target) => {\n      if (!isElement(target)) {\n        logError(target, 'is not a valid element');\n        return null;\n      }\n\n      let node = target;\n      while (node && node !== parent) {\n        if (parent.contains(node)) {\n          return target;\n        }\n        node = node.getRootNode().host;\n      }\n\n      logError(target, 'is not contained inside', parent);\n      return null;\n    })\n    .filter((x) => Boolean(x));\n};\n\n/**\n * Marks everything except given node(or nodes) as aria-hidden\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param {HTMLElement} [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @param {String} [controlAttribute] - html Attribute to control\n * @return {Function}\n */\nconst applyAttributeToOthers = (originalTarget, parentNode, markerName, controlAttribute) => {\n  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = new WeakMap();\n  }\n\n  const markerCounter = markerMap[markerName];\n\n  /** @type {Element[]} */\n  const hiddenNodes = [];\n\n  /** @type {Set<Node>} */\n  const elementsToKeep = new Set();\n\n  /** @type {Set<Node>} */\n  const elementsToStop = new Set(targets);\n\n  /**\n   * @param {?Node} el\n   */\n  const keep = (el) => {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n\n    elementsToKeep.add(el);\n\n    const slot = el.assignedSlot;\n    if (slot) {\n      keep(slot);\n    }\n\n    keep(el.parentNode || el.host);\n  };\n\n  targets.forEach(keep);\n\n  /**\n   * @param {?Node} parent\n   */\n  const deep = (parent) => {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n\n    const root = parent.shadowRoot;\n    const children = root ? [...parent.children, ...root.children] : [...parent.children];\n    children.forEach((node) => {\n      // Skip elements that don't need to be hidden\n      if (['template', 'script', 'style'].includes(node.localName)) {\n        return;\n      }\n\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        const attr = node.getAttribute(controlAttribute);\n        const alreadyHidden = attr !== null && attr !== 'false';\n        const counterValue = (counterMap.get(node) || 0) + 1;\n        const markerValue = (markerCounter.get(node) || 0) + 1;\n\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenNodes.push(node);\n\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledNodes.set(node, true);\n        }\n\n        if (markerValue === 1) {\n          node.setAttribute(markerName, 'true');\n        }\n\n        if (!alreadyHidden) {\n          node.setAttribute(controlAttribute, 'true');\n        }\n      }\n    });\n  };\n\n  deep(parentNode);\n\n  elementsToKeep.clear();\n\n  lockCount += 1;\n\n  return () => {\n    hiddenNodes.forEach((node) => {\n      const counterValue = counterMap.get(node) - 1;\n      const markerValue = markerCounter.get(node) - 1;\n\n      counterMap.set(node, counterValue);\n      markerCounter.set(node, markerValue);\n\n      if (!counterValue) {\n        if (uncontrolledNodes.has(node)) {\n          uncontrolledNodes.delete(node);\n        } else {\n          node.removeAttribute(controlAttribute);\n        }\n      }\n\n      if (!markerValue) {\n        node.removeAttribute(markerName);\n      }\n    });\n\n    lockCount -= 1;\n\n    if (!lockCount) {\n      // clear\n      counterMap = new WeakMap();\n      counterMap = new WeakMap();\n      uncontrolledNodes = new WeakMap();\n      markerMap = {};\n    }\n  };\n};\n\n/**\n * Marks everything except given node(or nodes) as aria-hidden\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param {HTMLElement} [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Function} undo command\n */\nexport const hideOthers = (originalTarget, parentNode = document.body, markerName = 'data-aria-hidden') => {\n  const targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n\n  if (parentNode) {\n    // We should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10\n    targets.push(...Array.from(parentNode.querySelectorAll('[aria-live]')));\n  }\n\n  return applyAttributeToOthers(targets, parentNode, markerName, 'aria-hidden');\n};\n\n/**\n * Marks everything except given node(or nodes) as inert\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param {HTMLElement} [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Function} undo command\n */\nexport const inertOthers = (originalTarget, parentNode = document.body, markerName = 'data-inert-ed') => {\n  return applyAttributeToOthers(originalTarget, parentNode, markerName, 'inert');\n};\n\n/**\n * @return if current browser supports inert\n */\nexport const supportsInert = 'inert' in HTMLElement.prototype;\n\n/**\n * Automatic function to \"suppress\" DOM elements - _hide_ or _inert_ in the best possible way\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param {HTMLElement} [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Function} undo command\n */\nexport const suppressOthers = (originalTarget, parentNode, markerName) =>\n  (supportsInert ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);\n"],
  "mappings": "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",
  "names": []
}
