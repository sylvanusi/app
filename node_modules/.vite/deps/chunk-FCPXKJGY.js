import {
  TemplateResultType,
  isTemplateResult
} from "./chunk-QQCLX5G7.js";
import {
  Directive,
  PartType,
  directive
} from "./chunk-2AVGUHGC.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  noChange,
  nothing,
  svg
} from "./chunk-ZCNTBWU5.js";

// node_modules/lit-html/development/directives/unsafe-html.js
var HTML_RESULT = 1;
var UnsafeHTMLDirective = class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this._value = nothing;
    if (partInfo.type !== PartType.CHILD) {
      throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
    }
  }
  render(value) {
    if (value === nothing || value == null) {
      this._templateResult = void 0;
      return this._value = value;
    }
    if (value === noChange) {
      return value;
    }
    if (typeof value != "string") {
      throw new Error(`${this.constructor.directiveName}() called with a non-string value`);
    }
    if (value === this._value) {
      return this._templateResult;
    }
    this._value = value;
    const strings = [value];
    strings.raw = strings;
    return this._templateResult = {
      // Cast to a known set of integers that satisfy ResultType so that we
      // don't have to export ResultType and possibly encourage this pattern.
      // This property needs to remain unminified.
      ["_$litType$"]: this.constructor.resultType,
      strings,
      values: []
    };
  }
};
UnsafeHTMLDirective.directiveName = "unsafeHTML";
UnsafeHTMLDirective.resultType = HTML_RESULT;
var unsafeHTML = directive(UnsafeHTMLDirective);

// node_modules/lit-html/development/directives/unsafe-svg.js
var SVG_RESULT = 2;
var UnsafeSVGDirective = class extends UnsafeHTMLDirective {
};
UnsafeSVGDirective.directiveName = "unsafeSVG";
UnsafeSVGDirective.resultType = SVG_RESULT;
var unsafeSVG = directive(UnsafeSVGDirective);

// node_modules/@vaadin/icon/src/vaadin-icon-svg.js
function cloneSvgNode(source) {
  let result = nothing;
  if (source) {
    const content = source.cloneNode(true);
    content.removeAttribute("id");
    result = svg`${unsafeSVG(content.outerHTML)}`;
  }
  return result;
}
function isValidSvg(source) {
  return isTemplateResult(source, TemplateResultType.SVG) || source === nothing;
}
function ensureSvgLiteral(source) {
  let result = source == null || source === "" ? nothing : source;
  if (!isValidSvg(result)) {
    console.error("[vaadin-icon] Invalid svg passed, please use Lit svg literal.");
    result = nothing;
  }
  return result;
}
function unsafeSvgLiteral(source) {
  return svg`${unsafeSVG(source)}`;
}

// node_modules/@vaadin/icon/src/vaadin-iconset-mixin.js
var iconsetRegistry = {};
var attachedIcons = /* @__PURE__ */ new Set();
function getIconId(id, name) {
  return (id || "").replace(`${name}:`, "");
}
function getIconsetName(icon) {
  if (!icon) {
    return;
  }
  const parts = icon.split(":");
  return parts[0] || "vaadin";
}
function initIconsMap(iconset, name) {
  iconset._icons = [...iconset.querySelectorAll("[id]")].reduce((map, svg2) => {
    const key = getIconId(svg2.id, name);
    map[key] = svg2;
    return map;
  }, {});
}
var IconsetMixin = (superClass) => class extends superClass {
  static get observedAttributes() {
    return ["name", "size"];
  }
  /**
   * Set of the `vaadin-icon` instances in the DOM.
   *
   * @return {Set<Icon>}
   */
  static get attachedIcons() {
    return attachedIcons;
  }
  /**
   * Returns an instance of the iconset by its name.
   *
   * @param {string} name
   * @return {Iconset}
   */
  static getIconset(name) {
    return iconsetRegistry[name];
  }
  /**
   * Returns SVGTemplateResult for the `icon` ID matching `name` of the
   * iconset, or `nothing` literal if there is no matching icon found.
   *
   * @param {string} icon
   * @param {?string} name
   */
  static getIconSvg(icon, name) {
    const iconsetName = name || getIconsetName(icon);
    const iconset = this.getIconset(iconsetName);
    if (!icon || !iconset) {
      return {
        svg: cloneSvgNode(null)
      };
    }
    const iconId = getIconId(icon, iconsetName);
    const iconSvg = iconset._icons[iconId];
    return {
      preserveAspectRatio: iconSvg ? iconSvg.getAttribute("preserveAspectRatio") : null,
      svg: cloneSvgNode(iconSvg),
      size: iconset.size,
      viewBox: iconSvg ? iconSvg.getAttribute("viewBox") : null
    };
  }
  /**
   * Register an iconset without adding to the DOM.
   *
   * @param {string} name
   * @param {number} size
   * @param {?HTMLTemplateElement} template
   */
  static register(name, size, template) {
    if (!iconsetRegistry[name]) {
      const iconset = document.createElement("vaadin-iconset");
      iconset.appendChild(template.content.cloneNode(true));
      iconsetRegistry[name] = iconset;
      initIconsMap(iconset, name);
      iconset.size = size;
      iconset.name = name;
    }
  }
  /**
   * The name of the iconset. Every iconset is required to have its own unique name.
   * All the SVG icons in the iconset must have IDs conforming to its name.
   *
   * See also [`name`](#/elements/vaadin-icon#property-name) property of `vaadin-icon`.
   *
   * @return {string}
   */
  get name() {
    return this.__name;
  }
  /**
   * @type {string}
   */
  set name(name) {
    const oldName = this.__name;
    this.__name = name;
    this.__nameChanged(name, oldName);
  }
  /**
   * The size of an individual icon. Note that icons must be square.
   *
   * When using `vaadin-icon`, the size of the iconset will take precedence
   * over the size defined by the user to ensure correct appearance.
   *
   * @return {number}
   */
  get size() {
    return this.__size !== void 0 ? this.__size : 24;
  }
  /**
   * @type {number}
   */
  set size(size) {
    this.__size = size;
  }
  /** @protected */
  connectedCallback() {
    ["name", "size"].forEach((prop) => {
      if (this.hasOwnProperty(prop)) {
        const value = this[prop];
        delete this[prop];
        this[prop] = value;
      }
    });
    this.style.display = "none";
  }
  /** @protected */
  attributeChangedCallback(attr, _oldValue, newValue) {
    if (attr === "name") {
      this.name = newValue;
    } else if (attr === "size") {
      this.size = newValue == null ? null : Number(newValue);
    }
  }
  /**
   * Update all the icons instances in the DOM.
   *
   * @param {string} name
   * @private
   */
  __updateIcons(name) {
    attachedIcons.forEach((element) => {
      if (name === getIconsetName(element.icon)) {
        element._applyIcon();
      }
    });
  }
  /** @private */
  __nameChanged(name, oldName) {
    if (oldName) {
      delete iconsetRegistry[oldName];
    }
    if (name) {
      iconsetRegistry[name] = this;
      initIconsMap(this, name);
      this.__updateIcons(name);
    }
  }
};

// node_modules/@vaadin/icon/src/vaadin-iconset.js
var Iconset = class extends IconsetMixin(HTMLElement) {
  static get is() {
    return "vaadin-iconset";
  }
};
defineCustomElement(Iconset);

export {
  cloneSvgNode,
  isValidSvg,
  ensureSvgLiteral,
  unsafeSvgLiteral,
  Iconset
};
//# sourceMappingURL=chunk-FCPXKJGY.js.map
