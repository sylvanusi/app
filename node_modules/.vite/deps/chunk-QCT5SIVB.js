import {
  ContextMenuMixin,
  MenuOverlayMixin,
  contextMenuItemStyles,
  menuOverlayStyles
} from "./chunk-B3S5CQFG.js";
import {
  listBoxStyles
} from "./chunk-TYZ7RCV5.js";
import {
  ItemMixin
} from "./chunk-3V4YUPS4.js";
import {
  ListMixin
} from "./chunk-GDVAXDUZ.js";
import {
  ifDefined
} from "./chunk-OSWHV746.js";
import {
  OverlayMixin,
  overlayStyles
} from "./chunk-PFI4EOEJ.js";
import {
  isFirefox,
  isIOS
} from "./chunk-T3UXCKHJ.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  prevent,
  register
} from "./chunk-5W5MB6YY.js";
import {
  isKeyboardActive
} from "./chunk-5DESY7LS.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  ThemableMixin,
  ThemePropertyMixin
} from "./chunk-MKNWHZM7.js";
import {
  DirMixin
} from "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/context-menu/src/vaadin-contextmenu-event.js
register({
  name: "vaadin-contextmenu",
  deps: ["touchstart", "touchmove", "touchend", "contextmenu"],
  flow: {
    start: ["touchstart", "contextmenu"],
    end: ["contextmenu"]
  },
  emits: ["vaadin-contextmenu"],
  info: {
    sourceEvent: null
  },
  reset() {
    this.info.sourceEvent = null;
    this._cancelTimer();
    this.info.touchJob = null;
    this.info.touchStartCoords = null;
  },
  _cancelTimer() {
    if (this._timerId) {
      clearTimeout(this._timerId);
      delete this._fired;
    }
  },
  _setSourceEvent(e) {
    this.info.sourceEvent = e;
    const path = e.composedPath();
    this.info.sourceEvent.__composedPath = path;
  },
  touchstart(e) {
    this._setSourceEvent(e);
    this.info.touchStartCoords = {
      x: e.changedTouches[0].clientX,
      y: e.changedTouches[0].clientY
    };
    const t = e.composedPath()[0] || e.target;
    this._timerId = setTimeout(() => {
      const ct = e.changedTouches[0];
      if (!e.shiftKey) {
        if (isIOS) {
          this._fired = true;
          this.fire(t, ct.clientX, ct.clientY);
        }
        prevent("tap");
      }
    }, 500);
  },
  touchmove(e) {
    const moveThreshold = 15;
    const touchStartCoords = this.info.touchStartCoords;
    if (Math.abs(touchStartCoords.x - e.changedTouches[0].clientX) > moveThreshold || Math.abs(touchStartCoords.y - e.changedTouches[0].clientY) > moveThreshold) {
      this._cancelTimer();
    }
  },
  touchend(e) {
    if (this._fired) {
      e.preventDefault();
    }
    this._cancelTimer();
  },
  contextmenu(e) {
    if (!e.shiftKey) {
      this._setSourceEvent(e);
      if (isFirefox && isKeyboardActive()) {
        const keyboardTarget = e.composedPath()[0];
        const targetRect = keyboardTarget.getBoundingClientRect();
        this.fire(keyboardTarget, targetRect.left, targetRect.bottom);
      } else {
        this.fire(e.target, e.clientX, e.clientY);
      }
      prevent("tap");
    }
  },
  fire(target, x, y) {
    const sourceEvent = this.info.sourceEvent;
    const ev = new Event("vaadin-contextmenu", { bubbles: true, cancelable: true, composed: true });
    ev.detail = { x, y, sourceEvent };
    target.dispatchEvent(ev);
    if (ev.defaultPrevented && sourceEvent && sourceEvent.preventDefault) {
      sourceEvent.preventDefault();
    }
  }
});

// node_modules/@vaadin/context-menu/src/vaadin-context-menu-item.js
var ContextMenuItem = class extends ItemMixin(ThemableMixin(DirMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-context-menu-item";
  }
  static get styles() {
    return contextMenuItemStyles;
  }
  /** @protected */
  render() {
    return html`
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menuitem");
  }
};
defineCustomElement(ContextMenuItem);

// node_modules/@vaadin/context-menu/src/vaadin-context-menu-list-box.js
var ContextMenuListBox = class extends ListMixin(ThemableMixin(DirMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-context-menu-list-box";
  }
  static get styles() {
    return listBoxStyles;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        type: String,
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  render() {
    return html`
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menu");
  }
};
defineCustomElement(ContextMenuListBox);

// node_modules/@vaadin/context-menu/src/styles/vaadin-context-menu-overlay-base-styles.js
var contextMenuOverlay = css`
  :host {
    --_default-offset: 4px;
  }

  :host([position^='top'][top-aligned]) [part='overlay'],
  :host([position^='bottom'][top-aligned]) [part='overlay'] {
    margin-top: var(--vaadin-context-menu-offset-top, var(--_default-offset));
  }

  :host([position^='top'][bottom-aligned]) [part='overlay'],
  :host([position^='bottom'][bottom-aligned]) [part='overlay'] {
    margin-bottom: var(--vaadin-context-menu-offset-bottom, var(--_default-offset));
  }

  :host([position^='start'][start-aligned]) [part='overlay'],
  :host([position^='end'][start-aligned]) [part='overlay'] {
    margin-inline-start: var(--vaadin-context-menu-offset-start, var(--_default-offset));
  }

  :host([position^='start'][end-aligned]) [part='overlay'],
  :host([position^='end'][end-aligned]) [part='overlay'] {
    margin-inline-end: var(--vaadin-context-menu-offset-end, var(--_default-offset));
  }
`;
var contextMenuOverlayStyles = [overlayStyles, menuOverlayStyles, contextMenuOverlay];

// node_modules/@vaadin/context-menu/src/vaadin-context-menu-overlay.js
var ContextMenuOverlay = class extends MenuOverlayMixin(
  OverlayMixin(DirMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement)))))
) {
  static get is() {
    return "vaadin-context-menu-overlay";
  }
  static get properties() {
    return {
      /**
       * Position of the overlay with respect to the target.
       * Supported values: null, `top-start`, `top`, `top-end`,
       * `bottom-start`, `bottom`, `bottom-end`, `start-top`,
       * `start`, `start-bottom`, `end-top`, `end`, `end-bottom`.
       */
      position: {
        type: String,
        reflectToAttribute: true
      }
    };
  }
  static get styles() {
    return contextMenuOverlayStyles;
  }
  /**
   * @protected
   * @override
   */
  _updatePosition() {
    super._updatePosition();
    if (this.parentOverlay == null && this.positionTarget && this.position && this.opened) {
      if (this.position === "bottom" || this.position === "top") {
        const targetRect = this.positionTarget.getBoundingClientRect();
        const overlayRect = this.$.overlay.getBoundingClientRect();
        const offset = targetRect.width / 2 - overlayRect.width / 2;
        if (this.style.left) {
          const left = overlayRect.left + offset;
          if (left > 0) {
            this.style.left = `${left}px`;
          }
        }
        if (this.style.right) {
          const right = parseFloat(this.style.right) + offset;
          if (right > 0) {
            this.style.right = `${right}px`;
          }
        }
      }
      if (this.position === "start" || this.position === "end") {
        const targetRect = this.positionTarget.getBoundingClientRect();
        const overlayRect = this.$.overlay.getBoundingClientRect();
        const offset = targetRect.height / 2 - overlayRect.height / 2;
        this.style.top = `${overlayRect.top + offset}px`;
      }
    }
  }
  /** @protected */
  render() {
    return html`
      <div id="backdrop" part="backdrop" ?hidden="${!this.withBackdrop}"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
          <slot name="submenu"></slot>
        </div>
      </div>
    `;
  }
};
defineCustomElement(ContextMenuOverlay);

// node_modules/@vaadin/context-menu/src/vaadin-context-menu.js
var ContextMenu = class extends ContextMenuMixin(ElementMixin(ThemePropertyMixin(PolylitMixin(LitElement)))) {
  static get is() {
    return "vaadin-context-menu";
  }
  static get styles() {
    return css`
      :host {
        display: block;
      }

      :host([hidden]) {
        display: none !important;
      }
    `;
  }
  static get properties() {
    return {
      /**
       * Position of the overlay with respect to the target.
       * Supported values: null, `top-start`, `top`, `top-end`,
       * `bottom-start`, `bottom`, `bottom-end`, `start-top`,
       * `start`, `start-bottom`, `end-top`, `end`, `end-bottom`.
       */
      position: {
        type: String
      }
    };
  }
  /** @protected */
  render() {
    const { _context: context, position } = this;
    return html`
      <slot id="slot"></slot>
      <vaadin-context-menu-overlay
        id="overlay"
        .owner="${this}"
        .opened="${this.opened}"
        .model="${context}"
        .modeless="${this._modeless}"
        .renderer="${this.items ? this.__itemsRenderer : this.renderer}"
        .position="${position}"
        .positionTarget="${position ? context && context.target : this._positionTarget}"
        .horizontalAlign="${this.__computeHorizontalAlign(position)}"
        .verticalAlign="${this.__computeVerticalAlign(position)}"
        ?no-horizontal-overlap="${this.__computeNoHorizontalOverlap(position)}"
        ?no-vertical-overlap="${this.__computeNoVerticalOverlap(position)}"
        .withBackdrop="${this._phone}"
        ?phone="${this._phone}"
        theme="${ifDefined(this._theme)}"
        exportparts="backdrop, overlay, content"
        @opened-changed="${this._onOverlayOpened}"
        @vaadin-overlay-open="${this._onVaadinOverlayOpen}"
        @vaadin-overlay-closed="${this._onVaadinOverlayClosed}"
      >
        <slot name="overlay"></slot>
        <slot name="submenu" slot="submenu"></slot>
      </vaadin-context-menu-overlay>
    `;
  }
  /** @private */
  __computeHorizontalAlign(position) {
    if (!position) {
      return "start";
    }
    return ["top-end", "bottom-end", "start-top", "start", "start-bottom"].includes(position) ? "end" : "start";
  }
  /** @private */
  __computeNoHorizontalOverlap(position) {
    if (!position) {
      return !!this._positionTarget;
    }
    return ["start-top", "start", "start-bottom", "end-top", "end", "end-bottom"].includes(position);
  }
  /** @private */
  __computeNoVerticalOverlap(position) {
    if (!position) {
      return false;
    }
    return ["top-start", "top-end", "top", "bottom-start", "bottom", "bottom-end"].includes(position);
  }
  /** @private */
  __computeVerticalAlign(position) {
    if (!position) {
      return "top";
    }
    return ["top-start", "top-end", "top", "start-bottom", "end-bottom"].includes(position) ? "bottom" : "top";
  }
  /**
   * Fired when an item is selected when the context menu is populated using the `items` API.
   *
   * @event item-selected
   * @param {Object} detail
   * @param {Object} detail.value the selected menu item
   */
};
defineCustomElement(ContextMenu);

export {
  ContextMenu
};
//# sourceMappingURL=chunk-QCT5SIVB.js.map
