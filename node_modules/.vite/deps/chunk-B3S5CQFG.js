import {
  MediaQueryController
} from "./chunk-QMCKCKIE.js";
import {
  itemStyles
} from "./chunk-WEJ2XI2Y.js";
import {
  PositionMixin
} from "./chunk-FOQZPEJP.js";
import {
  OverlayFocusMixin
} from "./chunk-PFI4EOEJ.js";
import {
  isAndroid,
  isIOS,
  isTouch
} from "./chunk-T3UXCKHJ.js";
import {
  addListener,
  deepTargetFind,
  gestures,
  removeListener
} from "./chunk-5W5MB6YY.js";
import {
  isElementFocusable,
  isKeyboardActive
} from "./chunk-5DESY7LS.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/context-menu/src/vaadin-contextmenu-items-mixin.js
var ItemsMixin = (superClass) => class ItemsMixin extends superClass {
  static get properties() {
    return {
      /**
       * @typedef ContextMenuItem
       * @type {object}
       * @property {string} text - Text to be set as the menu item component's textContent
       * @property {string | HTMLElement} component - The component to represent the item.
       * Either a tagName or an element instance. Defaults to "vaadin-context-menu-item".
       * @property {boolean} disabled - If true, the item is disabled and cannot be selected
       * @property {boolean} checked - If true, the item shows a checkmark next to it
       * @property {boolean} keepOpen - If true, the menu will not be closed on item selection
       * @property {string} className - A space-delimited list of CSS class names to be set on the menu item component.
       * @property {string | string[]} theme - If set, sets the given theme(s) as an attribute to the menu item component, overriding any theme set on the context menu.
       * @property {ContextMenuItem[]} children - Array of child menu items
       */
      /**
       * Defines a (hierarchical) menu structure for the component.
       * If a menu item has a non-empty `children` set, a sub-menu with the child items is opened
       * next to the parent menu on mouseover, tap or a right arrow keypress.
       *
       * The items API can't be used together with a renderer!
       *
       * #### Example
       *
       * ```javascript
       * contextMenu.items = [
       *   { text: 'Menu Item 1', theme: 'primary', className: 'first', children:
       *     [
       *       { text: 'Menu Item 1-1', checked: true, keepOpen: true },
       *       { text: 'Menu Item 1-2' }
       *     ]
       *   },
       *   { component: 'hr' },
       *   { text: 'Menu Item 2', children:
       *     [
       *       { text: 'Menu Item 2-1' },
       *       { text: 'Menu Item 2-2', disabled: true }
       *     ]
       *   },
       *   { text: 'Menu Item 3', disabled: true, className: 'last' }
       * ];
       * ```
       *
       * @type {!Array<!ContextMenuItem> | undefined}
       */
      items: {
        type: Array,
        sync: true
      },
      /** @protected */
      _positionTarget: {
        type: Object,
        sync: true
      }
    };
  }
  constructor() {
    super();
    this.__itemsOutsideClickListener = (e) => {
      if (this._shouldCloseOnOutsideClick(e)) {
        this.dispatchEvent(new CustomEvent("items-outside-click"));
      }
    };
    this.addEventListener("items-outside-click", () => {
      this.items && this.close();
    });
  }
  /**
   * Tag name prefix used by overlay, list-box and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-context-menu";
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.documentElement.addEventListener("click", this.__itemsOutsideClickListener);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.documentElement.removeEventListener("click", this.__itemsOutsideClickListener);
  }
  /**
   * Whether to close the overlay on outside click or not.
   * Override this method to customize the closing logic.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(event) {
    return !event.composedPath().some((el) => el.localName === `${this._tagNamePrefix}-overlay`);
  }
  /** @protected */
  __forwardFocus() {
    const overlay = this._overlayElement;
    const child = overlay._contentRoot.firstElementChild;
    if (overlay.parentOverlay) {
      const parent = overlay.parentOverlay._contentRoot.querySelector("[expanded]");
      if (parent && parent.hasAttribute("focused") && child) {
        child.focus();
      } else {
        overlay.$.overlay.focus();
      }
    } else if (child) {
      child.focus();
    }
  }
  /** @private */
  __openSubMenu(subMenu, itemElement) {
    this.__updateSubMenuForItem(subMenu, itemElement);
    const parent = this._overlayElement;
    const subMenuOverlay = subMenu._overlayElement;
    subMenuOverlay._setParentOverlay(parent);
    if (parent.hasAttribute("theme")) {
      subMenu.setAttribute("theme", parent.getAttribute("theme"));
    } else {
      subMenu.removeAttribute("theme");
    }
    const content = subMenuOverlay.$.content;
    content.style.minWidth = "";
    itemElement.dispatchEvent(
      new CustomEvent("opensubmenu", {
        detail: {
          children: itemElement._item.children
        }
      })
    );
  }
  /** @private */
  __updateSubMenuForItem(subMenu, itemElement) {
    subMenu.items = itemElement._item.children;
    subMenu.listenOn = itemElement;
    subMenu._positionTarget = itemElement;
    subMenu._overlayElement.requestContentUpdate();
  }
  /**
   * @param {!ContextMenuItem} item
   * @return {HTMLElement}
   * @private
   */
  __createComponent(item) {
    let component;
    if (item.component instanceof HTMLElement) {
      component = item.component;
    } else {
      component = document.createElement(item.component || `${this._tagNamePrefix}-item`);
    }
    if (component._hasVaadinItemMixin) {
      component.setAttribute("role", "menuitem");
      component.tabIndex = -1;
    }
    if (component.localName === "hr") {
      component.setAttribute("role", "separator");
    } else {
      component.setAttribute("aria-haspopup", "false");
    }
    this._setMenuItemTheme(component, item, this._theme);
    component._item = item;
    if (item.text) {
      component.textContent = item.text;
    }
    if (item.className) {
      component.setAttribute("class", item.className);
    }
    this.__toggleMenuComponentAttribute(component, "menu-item-checked", item.checked);
    this.__toggleMenuComponentAttribute(component, "disabled", item.disabled);
    if (item.children && item.children.length) {
      this.__updateExpanded(component, false);
      component.setAttribute("aria-haspopup", "true");
    }
    return component;
  }
  /** @private */
  __initListBox() {
    const listBox = document.createElement(`${this._tagNamePrefix}-list-box`);
    if (this._theme) {
      listBox.setAttribute("theme", this._theme);
    }
    listBox.addEventListener("selected-changed", (event) => {
      const { value } = event.detail;
      if (typeof value === "number") {
        const item = listBox.items[value]._item;
        listBox.selected = null;
        if (!item.children) {
          this.dispatchEvent(new CustomEvent("item-selected", { detail: { value: item } }));
        }
      }
    });
    return listBox;
  }
  /** @private */
  __initOverlay() {
    const overlay = this._overlayElement;
    overlay.$.backdrop.addEventListener("click", () => {
      this.close();
    });
    overlay.addEventListener(isTouch ? "click" : "mouseover", (event) => {
      if (event.composedPath().includes(this._subMenu)) {
        return;
      }
      this.__showSubMenu(event);
    });
    overlay.addEventListener("keydown", (event) => {
      if (event.composedPath().includes(this._subMenu)) {
        return;
      }
      const { key } = event;
      const isRTL = this.__isRTL;
      const isArrowRight = key === "ArrowRight";
      const isArrowLeft = key === "ArrowLeft";
      if (!isRTL && isArrowRight || isRTL && isArrowLeft || key === "Enter" || key === " ") {
        this.__showSubMenu(event);
      } else if (!isRTL && isArrowLeft || isRTL && isArrowRight || key === "Escape") {
        if (key === "Escape") {
          event.stopPropagation();
        }
        this.close();
        this.listenOn.focus();
      } else if (key === "Tab" && !event.defaultPrevented) {
        this.dispatchEvent(new CustomEvent("close-all-menus"));
      }
    });
  }
  /** @private */
  __initSubMenu() {
    const subMenu = document.createElement(this.constructor.is);
    subMenu._modeless = true;
    subMenu.openOn = "opensubmenu";
    this.addEventListener("opened-changed", (event) => {
      if (!event.detail.value) {
        this._subMenu.close();
      }
    });
    subMenu.addEventListener("close-all-menus", () => {
      this.dispatchEvent(new CustomEvent("close-all-menus"));
    });
    subMenu.addEventListener("item-selected", (event) => {
      const { detail } = event;
      this.dispatchEvent(new CustomEvent("item-selected", { detail }));
    });
    this.addEventListener("close-all-menus", () => {
      this._overlayElement.close();
    });
    this.addEventListener("item-selected", (e) => {
      const menu = e.target;
      const selectedItem = e.detail.value;
      const index = menu.items.indexOf(selectedItem);
      if (!!selectedItem.keepOpen && index > -1 && menu.opened) {
        menu.__selectedIndex = index;
        menu.requestContentUpdate();
      } else if (!selectedItem.keepOpen) {
        this.close();
      }
    });
    subMenu.addEventListener("opened-changed", (event) => {
      if (!event.detail.value) {
        const expandedItem = this._listBox.querySelector("[expanded]");
        if (expandedItem) {
          this.__updateExpanded(expandedItem, false);
        }
      }
    });
    return subMenu;
  }
  /** @private */
  __showSubMenu(event, item = event.composedPath().find((node) => node.localName === `${this._tagNamePrefix}-item`)) {
    if (!this.__openListenerActive) {
      return;
    }
    if (this._overlayElement.hasAttribute("opening")) {
      requestAnimationFrame(() => {
        this.__showSubMenu(event, item);
      });
      return;
    }
    const subMenu = this._subMenu;
    const expandedItem = this._listBox.querySelector("[expanded]");
    if (item && item !== expandedItem) {
      const { children } = item._item;
      const child = subMenu._overlayElement._contentRoot.firstElementChild;
      const isSubmenuFocused = child && child.focused;
      if (expandedItem) {
        this.__updateExpanded(expandedItem, false);
      }
      if (!children || !children.length) {
        subMenu.close();
      }
      if (!this.opened) {
        return;
      }
      if (children && children.length) {
        this.__updateExpanded(item, true);
        this.__openSubMenu(subMenu, item);
      } else if (isSubmenuFocused) {
        subMenu.listenOn.focus();
      } else if (!this._listBox.focused) {
        this._overlayElement.$.overlay.focus();
      }
    }
  }
  /** @protected */
  __getListBox() {
    return this._overlayElement._contentRoot.querySelector(`${this._tagNamePrefix}-list-box`);
  }
  /**
   * @param {!HTMLElement} root
   * @param {!ContextMenu} menu
   * @protected
   */
  __itemsRenderer(root, menu) {
    this.__initMenu(root, menu);
    this._subMenu.closeOn = menu.closeOn;
    this._listBox.innerHTML = "";
    menu.items.forEach((item) => {
      const component = this.__createComponent(item);
      this._listBox.appendChild(component);
    });
  }
  /** @protected */
  _setMenuItemTheme(component, item, hostTheme) {
    let theme = component.getAttribute("theme") || hostTheme;
    if (item.theme != null) {
      theme = Array.isArray(item.theme) ? item.theme.join(" ") : item.theme;
    }
    this.__updateTheme(component, theme);
  }
  /** @private */
  __toggleMenuComponentAttribute(component, attribute, on) {
    if (on) {
      component.setAttribute(attribute, "");
      component[`__has-${attribute}`] = true;
    } else if (component[`__has-${attribute}`]) {
      component.removeAttribute(attribute);
      component[`__has-${attribute}`] = false;
    }
  }
  /** @private */
  __initMenu(root, _menu) {
    if (!root.firstElementChild) {
      this.__initOverlay();
      const listBox = this.__initListBox();
      this._listBox = listBox;
      root.appendChild(listBox);
      const subMenu = this.__initSubMenu();
      subMenu.slot = "submenu";
      this._subMenu = subMenu;
      this.appendChild(subMenu);
      requestAnimationFrame(() => {
        this.__openListenerActive = true;
      });
    } else {
      this.__updateTheme(this._listBox, this._theme);
    }
  }
  /** @private */
  __updateExpanded(component, expanded) {
    component.setAttribute("aria-expanded", expanded.toString());
    component.toggleAttribute("expanded", expanded);
  }
  /** @private */
  __updateTheme(component, theme) {
    if (theme) {
      component.setAttribute("theme", theme);
    } else {
      component.removeAttribute("theme");
    }
  }
};

// node_modules/@vaadin/context-menu/src/vaadin-context-menu-mixin.js
var ContextMenuMixin = (superClass) => class ContextMenuMixinClass extends ItemsMixin(superClass) {
  static get properties() {
    return {
      /**
       * CSS selector that can be used to target any child element
       * of the context menu to listen for `openOn` events.
       */
      selector: {
        type: String
      },
      /**
       * True if the overlay is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        reflectToAttribute: true,
        observer: "_openedChanged",
        value: false,
        notify: true,
        readOnly: true
      },
      /**
       * Event name to listen for opening the context menu.
       * @attr {string} open-on
       * @type {string}
       */
      openOn: {
        type: String,
        value: "vaadin-contextmenu",
        sync: true
      },
      /**
       * The target element that's listened to for context menu opening events.
       * By default the vaadin-context-menu listens to the target's `vaadin-contextmenu`
       * events.
       * @type {!HTMLElement}
       * @default self
       */
      listenOn: {
        type: Object,
        sync: true,
        value() {
          return this;
        }
      },
      /**
       * Event name to listen for closing the context menu.
       * @attr {string} close-on
       * @type {string}
       */
      closeOn: {
        type: String,
        value: "click",
        observer: "_closeOnChanged",
        sync: true
      },
      /**
       * Custom function for rendering the content of the menu overlay.
       * Receives three arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `contextMenu` The reference to the `<vaadin-context-menu>` element.
       * - `context` The object with the menu context, contains:
       *   - `context.target`  the target of the menu opening event,
       *   - `context.detail` the menu opening event detail.
       * @type {ContextMenuRenderer | undefined}
       */
      renderer: {
        type: Function,
        sync: true
      },
      /**
       * When true, the menu overlay is modeless.
       * @protected
       */
      _modeless: {
        type: Boolean,
        sync: true
      },
      /** @private */
      _context: {
        type: Object,
        sync: true
      },
      /** @private */
      _phone: {
        type: Boolean
      },
      _fullscreen: {
        type: Boolean
      },
      _fullscreenMediaQuery: {
        type: String,
        value: "(max-width: 450px), (max-height: 450px)"
      }
    };
  }
  static get observers() {
    return [
      "_targetOrOpenOnChanged(listenOn, openOn)",
      "_rendererChanged(renderer, items)",
      "_fullscreenChanged(_fullscreen)"
    ];
  }
  constructor() {
    super();
    this._boundOpen = this.open.bind(this);
    this._boundClose = this.close.bind(this);
    this._boundPreventDefault = this._preventDefault.bind(this);
    this._boundOnGlobalContextMenu = this._onGlobalContextMenu.bind(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__boundOnScroll = this.__onScroll.bind(this);
    window.addEventListener("scroll", this.__boundOnScroll, true);
    if (this.__restoreOpened) {
      this._setOpened(true);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("scroll", this.__boundOnScroll, true);
    this.__restoreOpened = this.opened;
    this.close();
  }
  /** @protected */
  firstUpdated() {
    super.firstUpdated();
    this._overlayElement = this.$.overlay;
    this.addController(
      new MediaQueryController(this._fullscreenMediaQuery, (matches) => {
        this._fullscreen = matches;
      })
    );
  }
  /**
   * Runs before overlay is fully rendered
   * @private
   */
  _onOverlayOpened(event) {
    if (event.target !== this._overlayElement) {
      return;
    }
    const opened = event.detail.value;
    this._setOpened(opened);
    if (opened) {
      this.__alignOverlayPosition();
    }
  }
  /**
   * Runs after overlay is fully rendered
   * @private
   */
  _onVaadinOverlayOpen(event) {
    if (event.target !== this._overlayElement) {
      return;
    }
    this.__alignOverlayPosition();
    this._overlayElement.style.visibility = "";
    this.__forwardFocus();
  }
  /**
   * Runs after overlay's closing animation is finished
   * @private
   */
  _onVaadinOverlayClosed() {
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /** @private */
  _targetOrOpenOnChanged(listenOn, openOn) {
    if (this._oldListenOn && this._oldOpenOn) {
      this._unlisten(this._oldListenOn, this._oldOpenOn, this._boundOpen);
      this._oldListenOn.style.webkitTouchCallout = "";
      this._oldListenOn.style.webkitUserSelect = "";
      this._oldListenOn.style.userSelect = "";
      this._oldListenOn = null;
      this._oldOpenOn = null;
    }
    if (listenOn && openOn) {
      this._listen(listenOn, openOn, this._boundOpen);
      this._oldListenOn = listenOn;
      this._oldOpenOn = openOn;
    }
  }
  /** @private */
  _fullscreenChanged(fullScreen) {
    this._phone = fullScreen;
  }
  /** @private */
  __setListenOnUserSelect(opened) {
    const value = opened ? "none" : "";
    this.listenOn.style.webkitTouchCallout = value;
    this.listenOn.style.webkitUserSelect = value;
    this.listenOn.style.userSelect = value;
    if (opened) {
      document.getSelection().removeAllRanges();
    }
  }
  /** @private */
  _closeOnChanged(closeOn, oldCloseOn) {
    const evtOverlay = "vaadin-overlay-outside-click";
    const overlay = this._overlayElement;
    if (oldCloseOn) {
      this._unlisten(overlay, oldCloseOn, this._boundClose);
    }
    if (closeOn) {
      this._listen(overlay, closeOn, this._boundClose);
      overlay.removeEventListener(evtOverlay, this._boundPreventDefault);
    } else {
      overlay.addEventListener(evtOverlay, this._boundPreventDefault);
    }
  }
  /** @private */
  _preventDefault(e) {
    e.preventDefault();
  }
  /** @private */
  _openedChanged(opened, oldOpened) {
    if (opened) {
      document.documentElement.addEventListener("contextmenu", this._boundOnGlobalContextMenu, true);
    } else if (oldOpened) {
      document.documentElement.removeEventListener("contextmenu", this._boundOnGlobalContextMenu, true);
    }
    this.__setListenOnUserSelect(opened);
  }
  /**
   * Requests an update for the content of the menu overlay.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this._overlayElement) {
      return;
    }
    this.__preserveMenuState();
    this._overlayElement.requestContentUpdate();
    this.__restoreMenuState();
  }
  /** @private */
  _rendererChanged(renderer, items) {
    if (items) {
      if (renderer) {
        throw new Error("The items API cannot be used together with a renderer");
      }
      if (this.closeOn === "click") {
        this.closeOn = "";
      }
    }
  }
  /**
   * Closes the overlay.
   */
  close() {
    this._setOpened(false);
  }
  /** @private */
  _contextTarget(e) {
    if (this.selector) {
      const targets = this.listenOn.querySelectorAll(this.selector);
      return Array.prototype.filter.call(targets, (el) => {
        return e.composedPath().indexOf(el) > -1;
      })[0];
    } else if (this.listenOn && this.listenOn !== this && this.position) {
      return this.listenOn;
    }
    return e.target;
  }
  /**
   * Opens the overlay.
   * @param {!Event | undefined} e used as the context for the menu. Overlay coordinates are taken from this event.
   */
  open(e) {
    if (this._overlayElement && e.composedPath().includes(this._overlayElement)) {
      return;
    }
    if (e && !this.opened) {
      this._context = {
        detail: e.detail,
        target: this._contextTarget(e)
      };
      if (this._context.target) {
        e.preventDefault();
        e.stopPropagation();
        this.__x = this._getEventCoordinate(e, "x");
        this.__pageXOffset = window.pageXOffset;
        this.__y = this._getEventCoordinate(e, "y");
        this.__pageYOffset = window.pageYOffset;
        this._overlayElement.style.visibility = "hidden";
        this._setOpened(true);
      }
    }
  }
  /** @private */
  __preserveMenuState() {
    const listBox = this.__getListBox();
    if (listBox) {
      this.__focusedIndex = listBox.items.indexOf(listBox.focused);
      if (this._subMenu && this._subMenu.opened) {
        this.__subMenuIndex = listBox.items.indexOf(this._subMenu.listenOn);
      }
    }
  }
  /** @private */
  __restoreMenuState() {
    const focusedIndex = this.__focusedIndex;
    const subMenuIndex = this.__subMenuIndex;
    const selectedIndex = this.__selectedIndex;
    const listBox = this.__getListBox();
    if (listBox) {
      listBox._observer.flush();
      if (subMenuIndex > -1) {
        const itemToOpen = listBox.items[subMenuIndex];
        if (itemToOpen) {
          if (Array.isArray(itemToOpen._item.children) && itemToOpen._item.children.length) {
            this.__updateSubMenuForItem(this._subMenu, itemToOpen);
            this._subMenu.requestContentUpdate();
          } else {
            this._subMenu.close();
            this.__focusItem(itemToOpen);
          }
        } else {
          listBox.focus();
        }
      }
      this.__focusItem(selectedIndex > -1 ? listBox.children[selectedIndex] : listBox.items[focusedIndex]);
    }
    this.__focusedIndex = void 0;
    this.__subMenuIndex = void 0;
    this.__selectedIndex = void 0;
  }
  /** @private */
  __focusItem(item) {
    if (item) {
      item.focus({ focusVisible: isKeyboardActive() });
    }
  }
  /** @private */
  __onScroll() {
    if (!this.opened || this.position) {
      return;
    }
    const yDiff = window.pageYOffset - this.__pageYOffset;
    const xDiff = window.pageXOffset - this.__pageXOffset;
    this.__adjustPosition("left", -xDiff);
    this.__adjustPosition("right", xDiff);
    this.__adjustPosition("top", -yDiff);
    this.__adjustPosition("bottom", yDiff);
    this.__pageYOffset += yDiff;
    this.__pageXOffset += xDiff;
  }
  /** @private */
  __adjustPosition(coord, diff) {
    const overlay = this._overlayElement;
    const style = overlay.style;
    style[coord] = `${(parseInt(style[coord]) || 0) + diff}px`;
  }
  /** @private */
  __alignOverlayPosition() {
    const overlay = this._overlayElement;
    if (overlay.positionTarget) {
      return;
    }
    const style = overlay.style;
    ["top", "right", "bottom", "left"].forEach((prop) => style.removeProperty(prop));
    ["right-aligned", "end-aligned", "bottom-aligned"].forEach((attr) => overlay.removeAttribute(attr));
    const { xMax, xMin, yMax } = overlay.getBoundaries();
    const x = this.__x;
    const y = this.__y;
    const wdthVport = document.documentElement.clientWidth;
    const hghtVport = document.documentElement.clientHeight;
    if (!this.__isRTL) {
      if (x < wdthVport / 2 || x < xMax) {
        style.left = `${x}px`;
      } else {
        style.right = `${Math.max(0, wdthVport - x)}px`;
        this._setEndAligned(overlay);
      }
    } else if (x > wdthVport / 2 || x > xMin) {
      style.right = `${Math.max(0, wdthVport - x)}px`;
    } else {
      style.left = `${x}px`;
      this._setEndAligned(overlay);
    }
    if (y < hghtVport / 2 || y < yMax) {
      style.top = `${y}px`;
    } else {
      style.bottom = `${Math.max(0, hghtVport - y)}px`;
      overlay.setAttribute("bottom-aligned", "");
    }
  }
  /** @private */
  _setEndAligned(element) {
    element.setAttribute("end-aligned", "");
    if (!this.__isRTL) {
      element.setAttribute("right-aligned", "");
    }
  }
  /** @private */
  _getEventCoordinate(event, coord) {
    if (event.detail instanceof Object) {
      if (event.detail[coord]) {
        return event.detail[coord];
      } else if (event.detail.sourceEvent) {
        return this._getEventCoordinate(event.detail.sourceEvent, coord);
      }
    } else {
      const prop = `client${coord.toUpperCase()}`;
      const position = event.changedTouches ? event.changedTouches[0][prop] : event[prop];
      if (position === 0) {
        const rect = event.target.getBoundingClientRect();
        return coord === "x" ? rect.left : rect.top + rect.height;
      }
      return position;
    }
  }
  /** @private */
  _listen(node, evType, handler) {
    if (gestures[evType]) {
      addListener(node, evType, handler);
    } else {
      node.addEventListener(evType, handler);
    }
  }
  /** @private */
  _unlisten(node, evType, handler) {
    if (gestures[evType]) {
      removeListener(node, evType, handler);
    } else {
      node.removeEventListener(evType, handler);
    }
  }
  /** @private */
  __createMouseEvent(name, clientX, clientY) {
    return new MouseEvent(name, {
      bubbles: true,
      composed: true,
      cancelable: true,
      clientX,
      clientY
    });
  }
  /** @private */
  __focusClosestFocusable(target) {
    let currentElement = target;
    while (currentElement) {
      if (currentElement instanceof HTMLElement && isElementFocusable(currentElement)) {
        currentElement.focus();
        return;
      }
      currentElement = currentElement.parentNode || currentElement.host;
    }
  }
  /**
   * Executes a synthetic contextmenu event on the target under the coordinates.
   * @private
   */
  __contextMenuAt(x, y) {
    const target = deepTargetFind(x, y);
    if (target) {
      queueMicrotask(() => {
        target.dispatchEvent(this.__createMouseEvent("mousedown", x, y));
        target.dispatchEvent(this.__createMouseEvent("mouseup", x, y));
        this.__focusClosestFocusable(target);
        target.dispatchEvent(this.__createMouseEvent("contextmenu", x, y));
      });
    }
  }
  /** @private */
  _onGlobalContextMenu(e) {
    if (!e.shiftKey) {
      const isTouchDevice = isAndroid || isIOS;
      if (!isTouchDevice) {
        e.stopPropagation();
        this._overlayElement.__focusRestorationController.focusNode = null;
        this._overlayElement.addEventListener(
          "vaadin-overlay-closed",
          (closeEvent) => {
            if (closeEvent.target === this._overlayElement) {
              this.__contextMenuAt(e.clientX, e.clientY);
            }
          },
          {
            once: true
          }
        );
      }
      e.preventDefault();
      this.close();
    }
  }
  /**
   * Fired when the context menu is closed.
   *
   * @event closed
   */
};

// node_modules/@vaadin/context-menu/src/styles/vaadin-context-menu-item-base-styles.js
var menuItemStyles = css`
  :host([aria-haspopup='true'])::after {
    background: var(--vaadin-text-color-secondary);
    content: '';
    display: block;
    height: var(--vaadin-icon-size, 1lh);
    mask: var(--_vaadin-icon-chevron-down) 50% / var(--vaadin-icon-visual-size, 100%) no-repeat;
    rotate: -90deg;
    width: var(--vaadin-icon-size, 1lh);
  }

  :host([dir='rtl'])::after {
    rotate: 90deg;
  }

  /* TODO would be nice to only reserve the space if
    one or mote items in the list is checkable  */
  :host([menu-item-checked]) [part='checkmark'] {
    visibility: visible;
  }
`;
var contextMenuItemStyles = [itemStyles, menuItemStyles];

// node_modules/@vaadin/context-menu/src/vaadin-menu-overlay-mixin.js
var MenuOverlayMixin = (superClass) => class MenuOverlayMixin extends OverlayFocusMixin(PositionMixin(superClass)) {
  static get properties() {
    return {
      /**
       * @protected
       */
      parentOverlay: {
        type: Object,
        readOnly: true
      },
      /**
       * @protected
       */
      _theme: {
        type: String,
        readOnly: true,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_themeChanged(_theme)"];
  }
  /**
   * Override method from OverlayFocusMixin to use slotted div as content root.
   * @protected
   * @override
   */
  get _contentRoot() {
    return this._rendererRoot;
  }
  /**
   * Override method from OverlayMixin to use slotted div as the renderer root.
   * @protected
   * @override
   */
  get _rendererRoot() {
    if (!this.__savedRoot) {
      const root = document.createElement("div");
      root.setAttribute("slot", "overlay");
      root.style.display = "contents";
      this.owner.appendChild(root);
      this.__savedRoot = root;
    }
    return this.__savedRoot;
  }
  /** @protected */
  ready() {
    super.ready();
    this.restoreFocusOnClose = true;
    this.addEventListener("keydown", (e) => {
      if (!e.defaultPrevented && e.composedPath()[0] === this.$.overlay && [38, 40].indexOf(e.keyCode) > -1) {
        const child = this._contentRoot.firstElementChild;
        if (child && Array.isArray(child.items) && child.items.length) {
          e.preventDefault();
          if (e.keyCode === 38) {
            child.items[child.items.length - 1].focus();
          } else {
            child.focus();
          }
        }
      }
    });
  }
  /** @private */
  _themeChanged() {
    this.close();
  }
  /**
   * Returns the adjusted boundaries of the overlay.
   *
   * @returns {object}
   */
  getBoundaries() {
    const overlayRect = this.getBoundingClientRect();
    const contentRect = this.$.overlay.getBoundingClientRect();
    let yMax = overlayRect.bottom - contentRect.height;
    const parent = this.parentOverlay;
    if (parent && parent.hasAttribute("bottom-aligned")) {
      const parentStyle = getComputedStyle(parent);
      yMax = yMax - parseFloat(parentStyle.bottom) - parseFloat(parentStyle.height);
    }
    return {
      xMax: overlayRect.right - contentRect.width,
      xMin: overlayRect.left + contentRect.width,
      yMax
    };
  }
  /**
   * @protected
   * @override
   */
  _updatePosition() {
    super._updatePosition();
    if (this.positionTarget && this.parentOverlay && this.opened) {
      const content = this.$.content;
      const style = getComputedStyle(content);
      const isLeftAligned = !!this.style.left;
      if (isLeftAligned) {
        this.style.left = `${parseFloat(this.style.left) + parseFloat(style.paddingLeft)}px`;
      } else {
        this.style.right = `${parseFloat(this.style.right) + parseFloat(style.paddingRight)}px`;
      }
      const isBottomAligned = !!this.style.bottom;
      if (isBottomAligned) {
        this.style.bottom = `${parseFloat(this.style.bottom) - parseFloat(style.paddingBottom)}px`;
      } else {
        this.style.top = `${parseFloat(this.style.top) - parseFloat(style.paddingTop)}px`;
      }
    }
  }
  /**
   * Override method inherited from `OverlayFocusMixin` to disable
   * focus restoration on sub-menu overlay close. Focus should
   * be only restored when the root menu closes.
   *
   * @protected
   * @override
   * @return {boolean}
   */
  _shouldRestoreFocus() {
    if (this.parentOverlay) {
      return false;
    }
    return super._shouldRestoreFocus();
  }
  /**
   * Override method inherited from `OverlayFocusMixin` to check if the
   * node is contained within the overlay's owner element (the menu),
   * where all content (overlay content, sub-menus, etc.) is slotted.
   *
   * @protected
   * @override
   * @param {Node} node
   * @return {boolean}
   */
  _deepContains(node) {
    return this.owner.contains(node);
  }
};

// node_modules/@vaadin/context-menu/src/styles/vaadin-menu-overlay-base-styles.js
var menuOverlayStyles = css`
  :host {
    align-items: flex-start;
    justify-content: flex-start;
  }

  :host([right-aligned]),
  :host([end-aligned]) {
    align-items: flex-end;
  }

  :host([bottom-aligned]) {
    justify-content: flex-end;
  }

  [part='backdrop'] {
    background: transparent;
  }

  [part='content'] {
    padding: var(--vaadin-item-overlay-padding, 4px);
  }

  /* TODO keyboard focus becomes visible even when navigating the menu with the mouse */
  [part='overlay']:focus-visible {
    outline: none;
  }
`;

export {
  contextMenuItemStyles,
  menuOverlayStyles,
  MenuOverlayMixin,
  ContextMenuMixin
};
//# sourceMappingURL=chunk-B3S5CQFG.js.map
