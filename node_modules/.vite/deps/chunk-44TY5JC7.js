// node_modules/@vaadin/time-picker/src/vaadin-time-picker-helper.js
function formatISOTime(time) {
  if (!time) {
    return "";
  }
  const pad = (num = 0, fmt = "00") => (fmt + num).substr((fmt + num).length - fmt.length);
  let timeString = `${pad(time.hours)}:${pad(time.minutes)}`;
  if (time.seconds !== void 0) {
    timeString += `:${pad(time.seconds)}`;
  }
  if (time.milliseconds !== void 0) {
    timeString += `.${pad(time.milliseconds, "000")}`;
  }
  return timeString;
}
var MATCH_HOURS = "(\\d|[0-1]\\d|2[0-3])";
var MATCH_MINUTES = "(\\d|[0-5]\\d)";
var MATCH_SECONDS = MATCH_MINUTES;
var MATCH_MILLISECONDS = "(\\d{1,3})";
var re = new RegExp(`^${MATCH_HOURS}(?::${MATCH_MINUTES}(?::${MATCH_SECONDS}(?:\\.${MATCH_MILLISECONDS})?)?)?$`, "u");
function parseISOTime(timeString) {
  const parts = re.exec(timeString);
  if (parts) {
    if (parts[4]) {
      while (parts[4].length < 3) {
        parts[4] += "0";
      }
    }
    return { hours: parts[1], minutes: parts[2], seconds: parts[3], milliseconds: parts[4] };
  }
}
function getStepSegment(stepValue) {
  const step = stepValue == null ? 60 : parseFloat(stepValue);
  if (step % 3600 === 0) {
    return 1;
  } else if (step % 60 === 0 || !step) {
    return 2;
  } else if (step % 1 === 0) {
    return 3;
  } else if (step < 1) {
    return 4;
  }
}
function validateTime(timeObject, step) {
  if (timeObject) {
    const stepSegment = getStepSegment(step);
    timeObject.hours = parseInt(timeObject.hours);
    timeObject.minutes = parseInt(timeObject.minutes || 0);
    timeObject.seconds = stepSegment < 3 ? void 0 : parseInt(timeObject.seconds || 0);
    timeObject.milliseconds = stepSegment < 4 ? void 0 : parseInt(timeObject.milliseconds || 0);
  }
  return timeObject;
}

export {
  formatISOTime,
  parseISOTime,
  validateTime
};
//# sourceMappingURL=chunk-44TY5JC7.js.map
