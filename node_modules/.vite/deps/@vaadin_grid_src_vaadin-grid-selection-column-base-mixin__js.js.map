{
  "version": 3,
  "sources": ["../../@vaadin/grid/src/vaadin-grid-selection-column-base-mixin.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2016 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { addListener } from '@vaadin/component-base/src/gestures.js';\n\n/**\n * A mixin that provides basic functionality for the\n * `<vaadin-grid-selection-column>`. This includes properties, cell rendering,\n * and overridable methods for handling changes to the selection state.\n *\n * **NOTE**: This mixin is re-used by the Flow component, and as such must not\n * implement any selection state updates for the column element or the grid.\n * Web component-specific selection state updates must be implemented in the\n * `<vaadin-grid-selection-column>` itself, by overriding the protected methods\n * provided by this mixin.\n *\n * @polymerMixin\n */\nexport const GridSelectionColumnBaseMixin = (superClass) =>\n  class GridSelectionColumnBaseMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * Width of the cells for this column.\n         */\n        width: {\n          type: String,\n          value: '58px',\n          sync: true,\n        },\n\n        /**\n         * Override `autoWidth` to enable auto-width\n         */\n        autoWidth: {\n          type: Boolean,\n          value: true,\n        },\n\n        /**\n         * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.\n         * @attr {number} flex-grow\n         * @type {number}\n         */\n        flexGrow: {\n          type: Number,\n          value: 0,\n          sync: true,\n        },\n\n        /**\n         * When true, all the items are selected.\n         * @attr {boolean} select-all\n         * @type {boolean}\n         */\n        selectAll: {\n          type: Boolean,\n          value: false,\n          notify: true,\n          sync: true,\n        },\n\n        /**\n         * When true, the active item gets automatically selected.\n         * @attr {boolean} auto-select\n         * @type {boolean}\n         */\n        autoSelect: {\n          type: Boolean,\n          value: false,\n          sync: true,\n        },\n\n        /**\n         * When true, rows can be selected by dragging over the selection column.\n         * @attr {boolean} drag-select\n         * @type {boolean}\n         */\n        dragSelect: {\n          type: Boolean,\n          value: false,\n          sync: true,\n        },\n\n        /** @protected */\n        _indeterminate: {\n          type: Boolean,\n          sync: true,\n        },\n\n        /** @protected */\n        _selectAllHidden: Boolean,\n\n        /**\n         * Indicates whether the shift key is currently pressed.\n         *\n         * @protected\n         */\n        _shiftKeyDown: {\n          type: Boolean,\n          value: false,\n        },\n      };\n    }\n\n    static get observers() {\n      return [\n        '_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header, selectAll, _indeterminate, _selectAllHidden)',\n      ];\n    }\n\n    constructor() {\n      super();\n      this.__onCellTrack = this.__onCellTrack.bind(this);\n      this.__onCellClick = this.__onCellClick.bind(this);\n      this.__onCellMouseDown = this.__onCellMouseDown.bind(this);\n      this.__onGridInteraction = this.__onGridInteraction.bind(this);\n      this.__onActiveItemChanged = this.__onActiveItemChanged.bind(this);\n      this.__onSelectRowCheckboxChange = this.__onSelectRowCheckboxChange.bind(this);\n      this.__onSelectAllCheckboxChange = this.__onSelectAllCheckboxChange.bind(this);\n    }\n\n    /** @protected */\n    connectedCallback() {\n      super.connectedCallback();\n      if (this._grid) {\n        this._grid.addEventListener('keyup', this.__onGridInteraction);\n        this._grid.addEventListener('keydown', this.__onGridInteraction, { capture: true });\n        this._grid.addEventListener('mousedown', this.__onGridInteraction);\n        this._grid.addEventListener('active-item-changed', this.__onActiveItemChanged);\n      }\n    }\n\n    /** @protected */\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      if (this._grid) {\n        this._grid.removeEventListener('keyup', this.__onGridInteraction);\n        this._grid.removeEventListener('keydown', this.__onGridInteraction, { capture: true });\n        this._grid.removeEventListener('mousedown', this.__onGridInteraction);\n        this._grid.removeEventListener('active-item-changed', this.__onActiveItemChanged);\n      }\n    }\n\n    /**\n     * Renders the Select All checkbox to the header cell.\n     *\n     * @override\n     */\n    _defaultHeaderRenderer(root, _column) {\n      let checkbox = root.firstElementChild;\n      if (!checkbox) {\n        checkbox = document.createElement('vaadin-checkbox');\n        checkbox.setAttribute('aria-label', 'Select All');\n        checkbox.classList.add('vaadin-grid-select-all-checkbox');\n        checkbox.addEventListener('change', this.__onSelectAllCheckboxChange);\n        root.appendChild(checkbox);\n      }\n\n      const checked = this.__isChecked(this.selectAll, this._indeterminate);\n      checkbox.checked = checked;\n      checkbox.hidden = this._selectAllHidden;\n      checkbox.indeterminate = this._indeterminate;\n    }\n\n    /**\n     * Renders the Select Row checkbox to the body cell.\n     *\n     * @override\n     */\n    _defaultRenderer(root, _column, { item, selected }) {\n      let checkbox = root.firstElementChild;\n      if (!checkbox) {\n        checkbox = document.createElement('vaadin-checkbox');\n        checkbox.setAttribute('aria-label', 'Select Row');\n        checkbox.addEventListener('change', this.__onSelectRowCheckboxChange);\n        root.appendChild(checkbox);\n        addListener(root, 'track', this.__onCellTrack);\n        root.addEventListener('mousedown', this.__onCellMouseDown);\n        root.addEventListener('click', this.__onCellClick);\n      }\n\n      checkbox.__item = item;\n      checkbox.checked = selected;\n\n      const isSelectable = this._grid.__isItemSelectable(item);\n      checkbox.readonly = !isSelectable;\n      checkbox.hidden = !isSelectable && !selected;\n    }\n\n    /**\n     * Updates the select all state when the Select All checkbox is switched.\n     * The listener handles only user-fired events.\n     *\n     * @private\n     */\n    __onSelectAllCheckboxChange(e) {\n      if (this._indeterminate || e.currentTarget.checked) {\n        this._selectAll();\n      } else {\n        this._deselectAll();\n      }\n    }\n\n    /** @private */\n    __onGridInteraction(e) {\n      this._shiftKeyDown = e.shiftKey;\n\n      if (this.autoSelect) {\n        // Prevent text selection when shift-clicking to select a range of items.\n        this._grid.$.scroller.toggleAttribute('range-selecting', this._shiftKeyDown);\n      }\n    }\n\n    /**\n     * Selects or deselects the row when the Select Row checkbox is switched.\n     * The listener handles only user-fired events.\n     *\n     * @private\n     */\n    __onSelectRowCheckboxChange(e) {\n      this.__toggleItem(e.currentTarget.__item, e.currentTarget.checked);\n    }\n\n    /** @private */\n    __onCellTrack(event) {\n      if (!this.dragSelect) {\n        return;\n      }\n      this.__dragCurrentY = event.detail.y;\n      this.__dragDy = event.detail.dy;\n      if (event.detail.state === 'start') {\n        const renderedRows = this._grid._getRenderedRows();\n        // Get the row where the drag started\n        const dragStartRow = renderedRows.find((row) => row.contains(event.currentTarget.assignedSlot));\n        // Whether to select or deselect the items on drag\n        this.__selectOnDrag = !this._grid._isSelected(dragStartRow._item);\n        // Store the index of the row where the drag started\n        this.__dragStartIndex = dragStartRow.index;\n        // Store the item of the row where the drag started\n        this.__dragStartItem = dragStartRow._item;\n        // Start the auto scroller\n        this.__dragAutoScroller();\n      } else if (event.detail.state === 'end') {\n        // if drag start and end stays within the same item, then toggle its state\n        if (this.__dragStartItem) {\n          this.__toggleItem(this.__dragStartItem, this.__selectOnDrag);\n        }\n        // clear drag state after timeout, which allows preventing the\n        // subsequent click event if drag started and ended on the same item\n        setTimeout(() => {\n          this.__dragStartIndex = undefined;\n        });\n      }\n    }\n\n    /** @private */\n    __onCellMouseDown(e) {\n      if (this.dragSelect) {\n        // Prevent text selection when starting to drag\n        e.preventDefault();\n      }\n    }\n\n    /** @private */\n    __onCellClick(e) {\n      if (this.__dragStartIndex !== undefined) {\n        // Stop the click event if drag was enabled. This click event should\n        // only occur if drag started and stopped on the same item. In that case\n        // the selection state has already been toggled on drag end, and we\n        // don't  want to toggle it again from clicking the checkbox or changing\n        // the active item.\n        e.preventDefault();\n      }\n    }\n\n    /** @private */\n    _onCellKeyDown(e) {\n      const target = e.composedPath()[0];\n      // Toggle on Space without having to enter interaction mode first\n      if (e.keyCode !== 32) {\n        return;\n      }\n      if (target === this._headerCell) {\n        if (this.selectAll) {\n          this._deselectAll();\n        } else {\n          this._selectAll();\n        }\n      } else if (this._cells.includes(target) && !this.autoSelect) {\n        const checkbox = target._content.firstElementChild;\n        this.__toggleItem(checkbox.__item);\n      }\n    }\n\n    /** @private */\n    __onActiveItemChanged(e) {\n      const activeItem = e.detail.value;\n      if (this.autoSelect) {\n        const item = activeItem || this.__previousActiveItem;\n        if (item) {\n          this.__toggleItem(item);\n        }\n      }\n      this.__previousActiveItem = activeItem;\n    }\n\n    /** @private */\n    __dragAutoScroller() {\n      if (this.__dragStartIndex === undefined) {\n        return;\n      }\n\n      // Get the row being hovered over\n      const renderedRows = this._grid._getRenderedRows();\n      const hoveredRow = renderedRows.find((row) => {\n        const rowRect = row.getBoundingClientRect();\n        return this.__dragCurrentY >= rowRect.top && this.__dragCurrentY <= rowRect.bottom;\n      });\n\n      // Get the index of the row being hovered over or the first/last\n      // visible row if hovering outside the grid\n      let hoveredIndex = hoveredRow ? hoveredRow.index : undefined;\n      const scrollableArea = this.__getScrollableArea();\n      if (this.__dragCurrentY < scrollableArea.top) {\n        hoveredIndex = this._grid._firstVisibleIndex;\n      } else if (this.__dragCurrentY > scrollableArea.bottom) {\n        hoveredIndex = this._grid._lastVisibleIndex;\n      }\n\n      if (hoveredIndex !== undefined) {\n        // Select all items between the start and the current row\n        renderedRows.forEach((row) => {\n          if (\n            (hoveredIndex > this.__dragStartIndex && row.index >= this.__dragStartIndex && row.index <= hoveredIndex) ||\n            (hoveredIndex < this.__dragStartIndex && row.index <= this.__dragStartIndex && row.index >= hoveredIndex)\n          ) {\n            this.__toggleItem(row._item, this.__selectOnDrag);\n            this.__dragStartItem = undefined;\n          }\n        });\n      }\n\n      // Start scrolling in the top/bottom 15% of the scrollable area\n      const scrollTriggerArea = scrollableArea.height * 0.15;\n      // Maximum number of pixels to scroll per iteration\n      const maxScrollAmount = 10;\n\n      if (this.__dragDy < 0 && this.__dragCurrentY < scrollableArea.top + scrollTriggerArea) {\n        const dy = scrollableArea.top + scrollTriggerArea - this.__dragCurrentY;\n        const percentage = Math.min(1, dy / scrollTriggerArea);\n        this._grid.$.table.scrollTop -= percentage * maxScrollAmount;\n      }\n      if (this.__dragDy > 0 && this.__dragCurrentY > scrollableArea.bottom - scrollTriggerArea) {\n        const dy = this.__dragCurrentY - (scrollableArea.bottom - scrollTriggerArea);\n        const percentage = Math.min(1, dy / scrollTriggerArea);\n        this._grid.$.table.scrollTop += percentage * maxScrollAmount;\n      }\n\n      // Schedule the next auto scroll\n      setTimeout(() => this.__dragAutoScroller(), 10);\n    }\n\n    /**\n     * Gets the scrollable area of the grid as a bounding client rect. The\n     * scrollable area is the bounding rect of the grid minus the header and\n     * footer.\n     *\n     * @private\n     */\n    __getScrollableArea() {\n      const gridRect = this._grid.$.table.getBoundingClientRect();\n      const headerRect = this._grid.$.header.getBoundingClientRect();\n      const footerRect = this._grid.$.footer.getBoundingClientRect();\n\n      return {\n        top: gridRect.top + headerRect.height,\n        bottom: gridRect.bottom - footerRect.height,\n        left: gridRect.left,\n        right: gridRect.right,\n        height: gridRect.height - headerRect.height - footerRect.height,\n        width: gridRect.width,\n      };\n    }\n\n    /**\n     * Override to handle the user selecting all items.\n     * @protected\n     */\n    _selectAll() {}\n\n    /**\n     * Override to handle the user deselecting all items.\n     * @protected\n     */\n    _deselectAll() {}\n\n    /**\n     * Override to handle the user selecting an item.\n     * @param {Object} item the item to select\n     * @protected\n     */\n    _selectItem(_item) {}\n\n    /**\n     * Override to handle the user deselecting an item.\n     * @param {Object} item the item to deselect\n     * @protected\n     */\n    _deselectItem(_item) {}\n\n    /**\n     * Toggles the selected state of the given item.\n     *\n     * @param item the item to toggle\n     * @param {boolean} [selected] whether to select or deselect the item\n     * @private\n     */\n    __toggleItem(item, selected = !this._grid._isSelected(item)) {\n      if (selected === this._grid._isSelected(item)) {\n        // Skip selection if the item is already in the desired state.\n        // Note, _selectItem and _deselectItem may be overridden in custom\n        // selection column implementations, and calling them unnecessarily\n        // might affect performance (e.g. vaadin-grid-flow-selection-column).\n        return;\n      }\n\n      if (selected) {\n        this._selectItem(item);\n      } else {\n        this._deselectItem(item);\n      }\n    }\n\n    /**\n     * IOS needs indeterminate + checked at the same time\n     * @private\n     */\n    __isChecked(selectAll, indeterminate) {\n      return indeterminate || selectAll;\n    }\n  };\n"],
  "mappings": "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",
  "names": []
}
