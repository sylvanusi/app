import {
  DialogSizeMixin,
  dialogOverlayBase
} from "./chunk-7QAQCWIA.js";
import {
  ifDefined
} from "./chunk-OSWHV746.js";
import {
  OverlayMixin,
  overlayStyles
} from "./chunk-PFI4EOEJ.js";
import {
  setAriaIDReference
} from "./chunk-722MDOVI.js";
import {
  SlotController
} from "./chunk-X5EEA4XV.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  ThemableMixin,
  ThemePropertyMixin
} from "./chunk-MKNWHZM7.js";
import {
  DirMixin
} from "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/confirm-dialog/src/styles/vaadin-confirm-dialog-overlay-base-styles.js
var confirmDialogOverlay = css`
  :host {
    --vaadin-dialog-min-width: var(--vaadin-confirm-dialog-min-width, 15em);
    --vaadin-dialog-max-width: var(--vaadin-confirm-dialog-max-width, 25em);
  }

  ::slotted([slot='header']) {
    display: contents;
    font: inherit !important;
    color: inherit !important;
  }

  [part='header'] {
    color: var(--vaadin-dialog-title-color, var(--vaadin-text-color));
    font-weight: var(--vaadin-dialog-title-font-weight, 600);
    font-size: var(--vaadin-dialog-title-font-size, 1em);
    line-height: var(--vaadin-dialog-title-line-height, inherit);
  }

  [part='overlay'] {
    display: flex;
    flex-direction: column;
  }

  [part='content'] {
    flex: 1;
  }
`;
var confirmDialogOverlayStyles = [overlayStyles, dialogOverlayBase, confirmDialogOverlay];

// node_modules/@vaadin/confirm-dialog/src/vaadin-confirm-dialog-overlay.js
var ConfirmDialogOverlay = class extends OverlayMixin(DirMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-confirm-dialog-overlay";
  }
  static get styles() {
    return confirmDialogOverlayStyles;
  }
  static get properties() {
    return {
      cancelButtonVisible: {
        type: Boolean,
        value: false
      },
      rejectButtonVisible: {
        type: Boolean,
        value: false
      }
    };
  }
  /** @protected */
  render() {
    return html`
      <div part="backdrop" id="backdrop" ?hidden="${!this.withBackdrop}"></div>
      <div part="overlay" id="overlay">
        <header part="header"><slot name="header"></slot></header>
        <div part="content" id="content">
          <div part="message"><slot></slot></div>
        </div>
        <footer part="footer" role="toolbar">
          <div part="cancel-button" ?hidden="${!this.cancelButtonVisible}">
            <slot name="cancel-button"></slot>
          </div>
          <div part="reject-button" ?hidden="${!this.rejectButtonVisible}">
            <slot name="reject-button"></slot>
          </div>
          <div part="confirm-button">
            <slot name="confirm-button"></slot>
          </div>
        </footer>
      </div>
    `;
  }
  /**
   * @protected
   * @override
   */
  ready() {
    super.ready();
    this.setAttribute("has-header", "");
    this.setAttribute("has-footer", "");
  }
  /**
   * Override method from OverlayFocusMixin to use owner as content root
   * @protected
   * @override
   */
  get _contentRoot() {
    return this.owner;
  }
  /**
   * Override method from OverlayFocusMixin to use owner as focus trap root
   * @protected
   * @override
   */
  get _focusTrapRoot() {
    return this.owner;
  }
};
defineCustomElement(ConfirmDialogOverlay);

// node_modules/@vaadin/confirm-dialog/src/vaadin-confirm-dialog-mixin.js
var ConfirmDialogMixin = (superClass) => class ConfirmDialogMixinClass extends DialogSizeMixin(superClass) {
  static get properties() {
    return {
      /**
       * Sets the `aria-describedby` attribute of the dialog.
       *
       * By default, the text contents of all elements inside the message area
       * are combined into the `aria-description` attribute. However, there are
       * cases where this can confuse screen reader users (e.g. the dialog
       * may present a password confirmation form). For these cases,
       * it's better to associate only the elements that will help describe
       * the confirmation dialog through this API.
       */
      accessibleDescriptionRef: {
        type: String
      },
      /**
       * True if the dialog is visible and available for interaction.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        reflectToAttribute: true,
        value: false,
        notify: true,
        sync: true
      },
      /**
       * Set the confirmation dialog title.
       * @type {string}
       */
      header: {
        type: String,
        value: ""
      },
      /**
       * Set the message or confirmation question.
       */
      message: {
        type: String,
        value: ""
      },
      /**
       * Text displayed on confirm-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} confirm-text
       * @type {string}
       */
      confirmText: {
        type: String,
        value: "Confirm"
      },
      /**
       * Theme for a confirm-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} confirm-theme
       * @type {string}
       */
      confirmTheme: {
        type: String,
        value: "primary"
      },
      /**
       * Set to true to disable closing dialog on Escape press
       * @attr {boolean} no-close-on-esc
       * @type {boolean}
       */
      noCloseOnEsc: {
        type: Boolean,
        value: false
      },
      /**
       * Whether to show reject button or not.
       * @attr {boolean} reject-button-visible
       * @type {boolean}
       */
      rejectButtonVisible: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },
      /**
       * Text displayed on reject-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} reject-text
       * @type {string}
       */
      rejectText: {
        type: String,
        value: "Reject"
      },
      /**
       * Theme for a reject-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} reject-theme
       * @type {string}
       */
      rejectTheme: {
        type: String,
        value: "error tertiary"
      },
      /**
       * Whether to show cancel button or not.
       * @attr {boolean} cancel-button-visible
       * @type {boolean}
       */
      cancelButtonVisible: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },
      /**
       * Text displayed on cancel-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} cancel-text
       * @type {string}
       */
      cancelText: {
        type: String,
        value: "Cancel"
      },
      /**
       * Theme for a cancel-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} cancel-theme
       * @type {string}
       */
      cancelTheme: {
        type: String,
        value: "tertiary"
      },
      /**
       * A reference to the "Cancel" button which will be teleported to the overlay.
       * @private
       */
      _cancelButton: {
        type: Object
      },
      /**
       * A reference to the "Confirm" button which will be teleported to the overlay.
       * @private
       */
      _confirmButton: {
        type: Object
      },
      /**
       * A reference to the "header" node which will be teleported to the overlay.
       * @private
       */
      _headerNode: {
        type: Object
      },
      /**
       * A list of message nodes which will be placed in the overlay default slot.
       * @private
       */
      _messageNodes: {
        type: Array,
        value: () => []
      },
      /**
       * A reference to the "Reject" button which will be teleported to the overlay.
       * @private
       */
      _rejectButton: {
        type: Object
      }
    };
  }
  static get observers() {
    return [
      "__updateConfirmButton(_confirmButton, confirmText, confirmTheme)",
      "__updateCancelButton(_cancelButton, cancelText, cancelTheme, cancelButtonVisible)",
      "__updateHeaderNode(_headerNode, header)",
      "__updateMessageNodes(_messageNodes, message)",
      "__updateRejectButton(_rejectButton, rejectText, rejectTheme, rejectButtonVisible)",
      "__accessibleDescriptionRefChanged(_messageNodes, accessibleDescriptionRef)"
    ];
  }
  constructor() {
    super();
    this.__cancel = this.__cancel.bind(this);
    this.__confirm = this.__confirm.bind(this);
    this.__reject = this.__reject.bind(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this.__restoreOpened) {
      this.opened = true;
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    setTimeout(() => {
      if (!this.isConnected) {
        this.__restoreOpened = this.opened;
        this.opened = false;
      }
    });
  }
  /** @protected */
  ready() {
    super.ready();
    this.role = "alertdialog";
    this.setAttribute("aria-modal", "true");
    this.setAttribute("tabindex", "0");
    this._headerController = new SlotController(this, "header", "h3", {
      initializer: (node) => {
        this._headerNode = node;
      }
    });
    this.addController(this._headerController);
    this._messageController = new SlotController(this, "", "div", {
      // Allow providing multiple custom nodes in the default slot
      multiple: true,
      observe: false,
      initializer: (node) => {
        this._messageNodes = [...this._messageNodes, node];
      }
    });
    this.addController(this._messageController);
    this._cancelController = new SlotController(this, "cancel-button", "vaadin-button", {
      initializer: (button) => {
        this.__setupSlottedButton("cancel", button);
      }
    });
    this.addController(this._cancelController);
    this._rejectController = new SlotController(this, "reject-button", "vaadin-button", {
      initializer: (button) => {
        this.__setupSlottedButton("reject", button);
      }
    });
    this.addController(this._rejectController);
    this._confirmController = new SlotController(this, "confirm-button", "vaadin-button", {
      initializer: (button) => {
        this.__setupSlottedButton("confirm", button);
      }
    });
    this.addController(this._confirmController);
    this._overlayElement = this.$.overlay;
  }
  /** @protected */
  updated(props) {
    super.updated(props);
    if (props.has("header")) {
      this.ariaLabel = this.header || "confirmation";
    }
  }
  /** @protected */
  __onDialogOpened() {
    if (this._confirmButton) {
      this._confirmButton.focus();
    }
  }
  /** @protected */
  __onDialogClosed() {
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /** @private */
  __accessibleDescriptionRefChanged(messageNodes, accessibleDescriptionRef) {
    if (!messageNodes) {
      return;
    }
    if (accessibleDescriptionRef) {
      this.removeAttribute("aria-description");
      setAriaIDReference(this, "aria-describedby", {
        newId: accessibleDescriptionRef,
        oldId: this.__oldAccessibleDescriptionRef,
        fromUser: true
      });
    } else {
      this.removeAttribute("aria-describedby");
      const ariaDescription = messageNodes.map((node) => node.textContent.trim()).join(" ");
      this.setAttribute("aria-description", ariaDescription);
    }
    this.__oldAccessibleDescriptionRef = accessibleDescriptionRef;
  }
  /** @private */
  __setupSlottedButton(type, button) {
    const property = `_${type}Button`;
    const listener = `__${type}`;
    if (this[property] && this[property] !== button) {
      this[property].remove();
    }
    button.addEventListener("click", this[listener]);
    this[property] = button;
  }
  /** @private */
  __updateCancelButton(button, cancelText, cancelTheme, showCancel) {
    if (button) {
      if (button === this._cancelController.defaultNode) {
        button.textContent = cancelText;
        button.setAttribute("theme", cancelTheme);
      }
      button.toggleAttribute("hidden", !showCancel);
    }
  }
  /** @private */
  __updateConfirmButton(button, confirmText, confirmTheme) {
    if (button && button === this._confirmController.defaultNode) {
      button.textContent = confirmText;
      button.setAttribute("theme", confirmTheme);
    }
  }
  /** @private */
  __updateHeaderNode(headerNode, header) {
    if (headerNode && headerNode === this._headerController.defaultNode) {
      headerNode.textContent = header;
    }
  }
  /** @private */
  __updateMessageNodes(nodes, message) {
    if (nodes && nodes.length > 0) {
      const defaultNode = nodes.find((node) => node === this._messageController.defaultNode);
      if (defaultNode) {
        defaultNode.textContent = message;
      }
    }
  }
  /** @private */
  __updateRejectButton(button, rejectText, rejectTheme, showReject) {
    if (button) {
      if (button === this._rejectController.defaultNode) {
        button.textContent = rejectText;
        button.setAttribute("theme", rejectTheme);
      }
      button.toggleAttribute("hidden", !showReject);
    }
  }
  /** @protected */
  _onOverlayEscapePress(event) {
    if (this.noCloseOnEsc) {
      event.preventDefault();
    } else {
      this.__cancel();
    }
  }
  /** @protected */
  _onOverlayOutsideClick(event) {
    event.preventDefault();
  }
  /** @private */
  __confirm() {
    this.dispatchEvent(new CustomEvent("confirm"));
    this.opened = false;
  }
  /** @private */
  __cancel() {
    this.dispatchEvent(new CustomEvent("cancel"));
    this.opened = false;
  }
  /** @private */
  __reject() {
    this.dispatchEvent(new CustomEvent("reject"));
    this.opened = false;
  }
  /**
   * Fired when the confirm dialog is closed.
   *
   * @event closed
   */
};

// node_modules/@vaadin/confirm-dialog/src/vaadin-confirm-dialog.js
var ConfirmDialog = class extends ConfirmDialogMixin(ElementMixin(ThemePropertyMixin(PolylitMixin(LitElement)))) {
  static get is() {
    return "vaadin-confirm-dialog";
  }
  static get styles() {
    return css`
      :host([opened]),
      :host([opening]),
      :host([closing]) {
        display: block !important;
        position: absolute;
        outline: none;
      }

      :host,
      :host([hidden]) {
        display: none !important;
      }

      :host(:focus-visible) ::part(overlay) {
        outline: var(--vaadin-focus-ring-width) solid var(--vaadin-focus-ring-color);
      }
    `;
  }
  /** @protected */
  render() {
    return html`
      <vaadin-confirm-dialog-overlay
        id="overlay"
        .owner="${this}"
        .opened="${this.opened}"
        theme="${ifDefined(this._theme)}"
        .cancelButtonVisible="${this.cancelButtonVisible}"
        .rejectButtonVisible="${this.rejectButtonVisible}"
        with-backdrop
        restore-focus-on-close
        focus-trap
        exportparts="backdrop, overlay, header, content, message, footer, cancel-button, confirm-button, reject-button"
        @opened-changed="${this._onOpenedChanged}"
        @vaadin-overlay-open="${this.__onDialogOpened}"
        @vaadin-overlay-closed="${this.__onDialogClosed}"
        @vaadin-overlay-outside-click="${this._onOverlayOutsideClick}"
        @vaadin-overlay-escape-press="${this._onOverlayEscapePress}"
      >
        <slot name="header" slot="header"></slot>
        <slot></slot>
        <slot name="cancel-button" slot="cancel-button"></slot>
        <slot name="reject-button" slot="reject-button"></slot>
        <slot name="confirm-button" slot="confirm-button"></slot>
      </vaadin-confirm-dialog-overlay>
    `;
  }
  /** @private */
  _onOpenedChanged(event) {
    this.opened = event.detail.value;
  }
  /**
   * @event confirm
   * fired when Confirm button was pressed.
   */
  /**
   * @event cancel
   * fired when Cancel button or Escape key was pressed.
   */
  /**
   * @event reject
   * fired when Reject button was pressed.
   */
};
defineCustomElement(ConfirmDialog);

export {
  ConfirmDialog
};
//# sourceMappingURL=chunk-ZZVQ6C3W.js.map
