{
  "version": 3,
  "sources": ["../../@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js", "../../@vaadin/vaadin-themable-mixin/src/css-utils.js", "../../@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2017 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/**\n * @polymerMixin\n */\nexport const ThemePropertyMixin = (superClass) =>\n  class VaadinThemePropertyMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * Helper property with theme attribute value facilitating propagation\n         * in shadow DOM.\n         *\n         * Enables the component implementation to propagate the `theme`\n         * attribute value to the sub-components in Shadow DOM by binding\n         * the sub-component's \"theme\" attribute to the `theme` property of\n         * the host.\n         *\n         * **NOTE:** Extending the mixin only provides the property for binding,\n         * and does not make the propagation alone.\n         *\n         * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/styling-components/#sub-components).\n         * page for more information.\n         *\n         * @protected\n         */\n        _theme: {\n          type: String,\n          readOnly: true,\n        },\n      };\n    }\n\n    static get observedAttributes() {\n      return [...super.observedAttributes, 'theme'];\n    }\n\n    /** @protected */\n    attributeChangedCallback(name, oldValue, newValue) {\n      super.attributeChangedCallback(name, oldValue, newValue);\n\n      if (name === 'theme') {\n        this._set_theme(newValue);\n      }\n    }\n  };\n", "/**\n * @license\n * Copyright (c) 2021 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { adoptStyles } from 'lit';\n\n/**\n * Returns the effective styles that should apply to the component\n * in the correct order, to place injected stylesheet after styles\n * defined with `static styles` and before any custom theme styles\n * that the user provided using `registerStyles()` function.\n *\n * @param {HTMLElement} component\n * @return {CSSStyleSheet[]}\n */\nfunction getEffectiveStyles(component) {\n  const { baseStyles, themeStyles, elementStyles, lumoInjector } = component.constructor;\n  const lumoStyleSheet = component.__lumoStyleSheet;\n\n  if (lumoStyleSheet && (baseStyles || themeStyles)) {\n    return [...(lumoInjector.includeBaseStyles ? baseStyles : []), lumoStyleSheet, ...themeStyles];\n  }\n\n  return [lumoStyleSheet, ...elementStyles].filter(Boolean);\n}\n\n/**\n * Apply styles on the instance of the component in the correct order.\n *\n * @param {HTMLElement} component\n */\nexport function applyInstanceStyles(component) {\n  adoptStyles(component.shadowRoot, getEffectiveStyles(component));\n}\n\n/**\n * Injects the given stylesheet into the shadow root of the component\n * through the adoptedStyleSheets API. This will override any styles\n * that were injected previously since we only expect one stylesheet\n * to be injected into each component.\n *\n * @param {HTMLElement} component\n * @param {CSSStyleSheet} styleSheet\n */\nexport function injectLumoStyleSheet(component, styleSheet) {\n  // Store the new stylesheet so that it can be removed later.\n  component.__lumoStyleSheet = styleSheet;\n  applyInstanceStyles(component);\n}\n\n/**\n * Removes the stylesheet from the component's shadow root that was added\n * by the `injectLumoStyleSheet` function.\n *\n * @param {HTMLElement} component\n */\nexport function removeLumoStyleSheet(component) {\n  component.__lumoStyleSheet = undefined;\n  applyInstanceStyles(component);\n}\n", "/**\n * @license\n * Copyright (c) 2017 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { css, CSSResult, LitElement, unsafeCSS } from 'lit';\nimport { applyInstanceStyles } from './src/css-utils.js';\nimport { ThemePropertyMixin } from './vaadin-theme-property-mixin.js';\n\nexport { css, unsafeCSS };\n\n/**\n * @typedef {Object} Theme\n * @property {string} themeFor\n * @property {CSSResult[]} styles\n * @property {string | string[]} [include]\n * @property {string} [moduleId]\n *\n * @typedef {CSSResult[] | CSSResult} CSSResultGroup\n */\n\n/**\n * @type {Theme[]}\n */\nconst themeRegistry = [];\n\n/**\n * @type {WeakRef<HTMLElement>[]}\n */\nconst themableInstances = new Set();\n\n/**\n * @type {string[]}\n */\nconst themableTagNames = new Set();\n\n/**\n * Check if the custom element type has themes applied.\n * @param {Function} elementClass\n * @returns {boolean}\n */\nfunction classHasThemes(elementClass) {\n  return elementClass && Object.prototype.hasOwnProperty.call(elementClass, '__themes');\n}\n\n/**\n * Check if the custom element type has themes applied.\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction hasThemes(tagName) {\n  return classHasThemes(customElements.get(tagName));\n}\n\n/**\n * Flattens the styles into a single array of styles.\n * @param {CSSResultGroup} styles\n * @returns {CSSResult[]}\n */\nfunction flattenStyles(styles = []) {\n  return [styles].flat(Infinity).filter((style) => {\n    if (style instanceof CSSResult) {\n      return true;\n    }\n    console.warn('An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.');\n    return false;\n  });\n}\n\n/**\n * Returns true if the themeFor string matches the tag name\n * @param {string} themeFor\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction matchesThemeFor(themeFor, tagName) {\n  return (themeFor || '').split(' ').some((themeForToken) => {\n    return new RegExp(`^${themeForToken.split('*').join('.*')}$`, 'u').test(tagName);\n  });\n}\n\n/**\n * Returns the CSS text content from an array of CSSResults\n * @param {CSSResult[]} styles\n * @returns {string}\n */\nfunction getCssText(styles) {\n  return styles.map((style) => style.cssText).join('\\n');\n}\n\nconst STYLE_ID = 'vaadin-themable-mixin-style';\n\n/**\n * Includes the styles to the template.\n * @param {CSSResult[]} styles\n * @param {HTMLTemplateElement} template\n */\nfunction addStylesToTemplate(styles, template) {\n  const styleEl = document.createElement('style');\n  styleEl.id = STYLE_ID;\n  styleEl.textContent = getCssText(styles);\n  template.content.appendChild(styleEl);\n}\n\n/**\n * Dynamically updates the styles of the given component instance.\n * @param {HTMLElement} instance\n */\nfunction updateInstanceStyles(instance) {\n  if (!instance.shadowRoot) {\n    return;\n  }\n\n  const componentClass = instance.constructor;\n\n  if (instance instanceof LitElement) {\n    // LitElement\n    applyInstanceStyles(instance);\n  } else {\n    // PolymerElement\n\n    // Update style element content in the shadow root\n    const style = instance.shadowRoot.getElementById(STYLE_ID);\n    const template = componentClass.prototype._template;\n    style.textContent = template.content.getElementById(STYLE_ID).textContent;\n  }\n}\n\n/**\n * Dynamically updates the styles of the instances matching the given component type.\n * @param {Function} componentClass\n */\nfunction updateInstanceStylesOfType(componentClass) {\n  // Iterate over component instances and update their styles if needed\n  themableInstances.forEach((ref) => {\n    const instance = ref.deref();\n    if (instance instanceof componentClass) {\n      updateInstanceStyles(instance);\n    } else if (!instance) {\n      // Clean up the weak reference to a GC'd instance\n      themableInstances.delete(ref);\n    }\n  });\n}\n\n/**\n * Dynamically updates the styles of the given component type.\n * @param {Function} componentClass\n */\nfunction updateComponentStyles(componentClass) {\n  if (componentClass.prototype instanceof LitElement) {\n    // Update LitElement-based component's elementStyles\n    componentClass.elementStyles = componentClass.finalizeStyles(componentClass.styles);\n  } else {\n    // Update Polymer-based component's template\n    const template = componentClass.prototype._template;\n    template.content.getElementById(STYLE_ID).textContent = getCssText(componentClass.getStylesForThis());\n  }\n\n  // Update the styles of inheriting types\n  themableTagNames.forEach((inheritingTagName) => {\n    const inheritingClass = customElements.get(inheritingTagName);\n    if (inheritingClass !== componentClass && inheritingClass.prototype instanceof componentClass) {\n      updateComponentStyles(inheritingClass);\n    }\n  });\n}\n\n/**\n * Check if the component type already has a style matching the given styles.\n *\n * @param {Function} componentClass\n * @param {CSSResultGroup} styles\n * @returns {boolean}\n */\nfunction hasMatchingStyle(componentClass, styles) {\n  const themes = componentClass.__themes;\n  if (!themes || !styles) {\n    return false;\n  }\n\n  return themes.some((theme) =>\n    theme.styles.some((themeStyle) => styles.some((style) => style.cssText === themeStyle.cssText)),\n  );\n}\n\n/**\n * Registers CSS styles for a component type. Make sure to register the styles before\n * the first instance of a component of the type is attached to DOM.\n *\n * @param {string} themeFor The local/tag name of the component type to register the styles for\n * @param {CSSResultGroup} styles The CSS style rules to be registered for the component type\n * matching themeFor and included in the local scope of each component instance\n * @param {{moduleId?: string, include?: string | string[]}} options Additional options\n * @return {void}\n */\nexport function registerStyles(themeFor, styles, options = {}) {\n  styles = flattenStyles(styles);\n\n  themeRegistry.push({\n    themeFor,\n    styles,\n    include: options.include,\n    moduleId: options.moduleId,\n  });\n\n  if (themeFor) {\n    // Update styles of the component types that match themeFor and have already been finalized\n    themableTagNames.forEach((tagName) => {\n      if (matchesThemeFor(themeFor, tagName) && hasThemes(tagName)) {\n        const componentClass = customElements.get(tagName);\n\n        if (hasMatchingStyle(componentClass, styles)) {\n          // Show a warning if the component type already has some of the given styles\n          console.warn(`Registering styles that already exist for ${tagName}`);\n        } else if (!window.Vaadin || !window.Vaadin.suppressPostFinalizeStylesWarning) {\n          // Show a warning if the component type has already been finalized\n          console.warn(\n            `The custom element definition for \"${tagName}\" ` +\n              `was finalized before a style module was registered. ` +\n              `Ideally, import component specific style modules before ` +\n              `importing the corresponding custom element. ` +\n              `This warning can be suppressed by setting \"window.Vaadin.suppressPostFinalizeStylesWarning = true\".`,\n          );\n        }\n\n        // Update the styles of the component type\n        updateComponentStyles(componentClass);\n        // Update the styles of the component instances matching the component type\n        updateInstanceStylesOfType(componentClass);\n      }\n    });\n  }\n}\n\n/**\n * Maps the moduleName to an include priority number which is used for\n * determining the order in which styles are applied.\n * @param {string} moduleName\n * @returns {number}\n */\nfunction getIncludePriority(moduleName = '') {\n  let includePriority = 0;\n  if (moduleName.startsWith('lumo-') || moduleName.startsWith('material-')) {\n    includePriority = 1;\n  } else if (moduleName.startsWith('vaadin-')) {\n    includePriority = 2;\n  }\n  return includePriority;\n}\n\n/**\n * Gets an array of CSSResults matching the include property of the theme.\n * @param {Theme} theme\n * @returns {CSSResult[]}\n */\nfunction getIncludedStyles(theme) {\n  const includedStyles = [];\n  if (theme.include) {\n    [].concat(theme.include).forEach((includeModuleId) => {\n      const includedTheme = themeRegistry.find((s) => s.moduleId === includeModuleId);\n      if (includedTheme) {\n        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);\n      } else {\n        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);\n      }\n    }, theme.styles);\n  }\n  return includedStyles;\n}\n\n/**\n * Returns an array of themes that should be used for styling a component matching\n * the tag name. The array is sorted by the include order.\n * @param {string} tagName\n * @returns {Theme[]}\n */\nfunction getThemes(tagName) {\n  const defaultModuleName = `${tagName}-default-theme`;\n\n  const themes = themeRegistry\n    // Filter by matching themeFor properties\n    .filter((theme) => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName))\n    .map((theme) => ({\n      ...theme,\n      // Prepend styles from included themes\n      styles: [...getIncludedStyles(theme), ...theme.styles],\n      // Map moduleId to includePriority\n      includePriority: getIncludePriority(theme.moduleId),\n    }))\n    // Sort by includePriority\n    .sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);\n\n  if (themes.length > 0) {\n    return themes;\n  }\n  // No theme modules found, return the default module if it exists\n  return themeRegistry.filter((theme) => theme.moduleId === defaultModuleName);\n}\n\n/**\n * @polymerMixin\n * @mixes ThemePropertyMixin\n */\nexport const ThemableMixin = (superClass) =>\n  class VaadinThemableMixin extends ThemePropertyMixin(superClass) {\n    constructor() {\n      super();\n      // Store a weak reference to the instance\n      themableInstances.add(new WeakRef(this));\n    }\n\n    /**\n     * Covers PolymerElement based component styling\n     * @protected\n     */\n    static finalize() {\n      super.finalize();\n\n      if (this.is) {\n        themableTagNames.add(this.is);\n      }\n\n      // Make sure not to run the logic intended for PolymerElement when LitElement is used.\n      if (this.elementStyles) {\n        return;\n      }\n\n      const template = this.prototype._template;\n      if (!template || classHasThemes(this)) {\n        return;\n      }\n\n      addStylesToTemplate(this.getStylesForThis(), template);\n    }\n\n    /**\n     * Covers LitElement based component styling\n     *\n     * @protected\n     */\n    static finalizeStyles(styles) {\n      // Preserve the styles the user supplied via the `static get styles()` getter\n      // so that they will always be injected before styles added by `LumoInjector`.\n      this.baseStyles = styles ? [styles].flat(Infinity) : [];\n\n      // Preserve the theme styles the user supplied via the `registerStyles()` API\n      // so that they will always be injected after styles added by `LumoInjector`.\n      this.themeStyles = this.getStylesForThis();\n\n      // Merged styles are stored in `elementStyles` and passed to `adoptStyles()`.\n      return [...this.baseStyles, ...this.themeStyles];\n    }\n\n    /**\n     * Get styles for the component type\n     *\n     * @private\n     */\n    static getStylesForThis() {\n      const superClassThemes = superClass.__themes || [];\n      const parent = Object.getPrototypeOf(this.prototype);\n      const inheritedThemes = (parent ? parent.constructor.__themes : []) || [];\n      this.__themes = [...superClassThemes, ...inheritedThemes, ...getThemes(this.is)];\n      const themeStyles = this.__themes.flatMap((theme) => theme.styles);\n      // Remove duplicates\n      return themeStyles.filter((style, index) => index === themeStyles.lastIndexOf(style));\n    }\n  };\n"],
  "mappings": "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",
  "names": []
}
