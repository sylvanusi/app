import {
  adoptStyles
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js
var ThemePropertyMixin = (superClass) => class VaadinThemePropertyMixin extends superClass {
  static get properties() {
    return {
      /**
       * Helper property with theme attribute value facilitating propagation
       * in shadow DOM.
       *
       * Enables the component implementation to propagate the `theme`
       * attribute value to the sub-components in Shadow DOM by binding
       * the sub-component's "theme" attribute to the `theme` property of
       * the host.
       *
       * **NOTE:** Extending the mixin only provides the property for binding,
       * and does not make the propagation alone.
       *
       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/styling-components/#sub-components).
       * page for more information.
       *
       * @protected
       */
      _theme: {
        type: String,
        readOnly: true
      }
    };
  }
  static get observedAttributes() {
    return [...super.observedAttributes, "theme"];
  }
  /** @protected */
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (name === "theme") {
      this._set_theme(newValue);
    }
  }
};

// node_modules/@vaadin/vaadin-themable-mixin/src/css-utils.js
function getEffectiveStyles(component) {
  const { baseStyles, themeStyles, elementStyles, lumoInjector } = component.constructor;
  const lumoStyleSheet = component.__lumoStyleSheet;
  if (lumoStyleSheet && (baseStyles || themeStyles)) {
    return [...lumoInjector.includeBaseStyles ? baseStyles : [], lumoStyleSheet, ...themeStyles];
  }
  return [lumoStyleSheet, ...elementStyles].filter(Boolean);
}
function applyInstanceStyles(component) {
  adoptStyles(component.shadowRoot, getEffectiveStyles(component));
}
function injectLumoStyleSheet(component, styleSheet) {
  component.__lumoStyleSheet = styleSheet;
  applyInstanceStyles(component);
}
function removeLumoStyleSheet(component) {
  component.__lumoStyleSheet = void 0;
  applyInstanceStyles(component);
}

// node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js
var themeRegistry = [];
var themableInstances = /* @__PURE__ */ new Set();
var themableTagNames = /* @__PURE__ */ new Set();
function classHasThemes(elementClass) {
  return elementClass && Object.prototype.hasOwnProperty.call(elementClass, "__themes");
}
function matchesThemeFor(themeFor, tagName) {
  return (themeFor || "").split(" ").some((themeForToken) => {
    return new RegExp(`^${themeForToken.split("*").join(".*")}$`, "u").test(tagName);
  });
}
function getCssText(styles) {
  return styles.map((style) => style.cssText).join("\n");
}
var STYLE_ID = "vaadin-themable-mixin-style";
function addStylesToTemplate(styles, template) {
  const styleEl = document.createElement("style");
  styleEl.id = STYLE_ID;
  styleEl.textContent = getCssText(styles);
  template.content.appendChild(styleEl);
}
function getIncludePriority(moduleName = "") {
  let includePriority = 0;
  if (moduleName.startsWith("lumo-") || moduleName.startsWith("material-")) {
    includePriority = 1;
  } else if (moduleName.startsWith("vaadin-")) {
    includePriority = 2;
  }
  return includePriority;
}
function getIncludedStyles(theme) {
  const includedStyles = [];
  if (theme.include) {
    [].concat(theme.include).forEach((includeModuleId) => {
      const includedTheme = themeRegistry.find((s) => s.moduleId === includeModuleId);
      if (includedTheme) {
        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);
      } else {
        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);
      }
    }, theme.styles);
  }
  return includedStyles;
}
function getThemes(tagName) {
  const defaultModuleName = `${tagName}-default-theme`;
  const themes = themeRegistry.filter((theme) => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName)).map((theme) => ({
    ...theme,
    // Prepend styles from included themes
    styles: [...getIncludedStyles(theme), ...theme.styles],
    // Map moduleId to includePriority
    includePriority: getIncludePriority(theme.moduleId)
  })).sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);
  if (themes.length > 0) {
    return themes;
  }
  return themeRegistry.filter((theme) => theme.moduleId === defaultModuleName);
}
var ThemableMixin = (superClass) => class VaadinThemableMixin extends ThemePropertyMixin(superClass) {
  constructor() {
    super();
    themableInstances.add(new WeakRef(this));
  }
  /**
   * Covers PolymerElement based component styling
   * @protected
   */
  static finalize() {
    super.finalize();
    if (this.is) {
      themableTagNames.add(this.is);
    }
    if (this.elementStyles) {
      return;
    }
    const template = this.prototype._template;
    if (!template || classHasThemes(this)) {
      return;
    }
    addStylesToTemplate(this.getStylesForThis(), template);
  }
  /**
   * Covers LitElement based component styling
   *
   * @protected
   */
  static finalizeStyles(styles) {
    this.baseStyles = styles ? [styles].flat(Infinity) : [];
    this.themeStyles = this.getStylesForThis();
    return [...this.baseStyles, ...this.themeStyles];
  }
  /**
   * Get styles for the component type
   *
   * @private
   */
  static getStylesForThis() {
    const superClassThemes = superClass.__themes || [];
    const parent = Object.getPrototypeOf(this.prototype);
    const inheritedThemes = (parent ? parent.constructor.__themes : []) || [];
    this.__themes = [...superClassThemes, ...inheritedThemes, ...getThemes(this.is)];
    const themeStyles = this.__themes.flatMap((theme) => theme.styles);
    return themeStyles.filter((style, index) => index === themeStyles.lastIndexOf(style));
  }
};

export {
  injectLumoStyleSheet,
  removeLumoStyleSheet,
  ThemePropertyMixin,
  ThemableMixin
};
//# sourceMappingURL=chunk-MKNWHZM7.js.map
