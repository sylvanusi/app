import {
  Debouncer
} from "./chunk-OWHE56FA.js";
import {
  animationFrame
} from "./chunk-MWWP2LZ3.js";

// node_modules/@vaadin/component-base/src/overflow-controller.js
var OverflowController = class {
  constructor(host, scrollTarget) {
    this.host = host;
    this.scrollTarget = scrollTarget || host;
    this.__boundOnScroll = this.__onScroll.bind(this);
  }
  hostConnected() {
    if (!this.initialized) {
      this.initialized = true;
      this.observe();
    }
  }
  /**
   * Setup scroll listener and observers to update overflow.
   * Also performs one-time update synchronously when called.
   * @protected
   */
  observe() {
    const { host } = this;
    this.__resizeObserver = new ResizeObserver(() => {
      this.__debounceOverflow = Debouncer.debounce(this.__debounceOverflow, animationFrame, () => {
        this.__updateOverflow();
      });
    });
    this.__resizeObserver.observe(host);
    [...host.children].forEach((child) => {
      this.__resizeObserver.observe(child);
    });
    this.__childObserver = new MutationObserver((mutations) => {
      mutations.forEach(({ addedNodes, removedNodes }) => {
        addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            this.__resizeObserver.observe(node);
          }
        });
        removedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            this.__resizeObserver.unobserve(node);
          }
        });
      });
      this.__updateOverflow();
    });
    this.__childObserver.observe(host, { childList: true });
    this.scrollTarget.addEventListener("scroll", this.__boundOnScroll);
    this.__updateOverflow();
  }
  /** @private */
  __onScroll() {
    this.__updateOverflow();
  }
  /** @private */
  __updateOverflow() {
    const target = this.scrollTarget;
    let overflow = "";
    if (target.scrollTop > 0) {
      overflow += " top";
    }
    if (Math.ceil(target.scrollTop) < Math.ceil(target.scrollHeight - target.clientHeight)) {
      overflow += " bottom";
    }
    const scrollLeft = Math.abs(target.scrollLeft);
    if (scrollLeft > 0) {
      overflow += " start";
    }
    if (Math.ceil(scrollLeft) < Math.ceil(target.scrollWidth - target.clientWidth)) {
      overflow += " end";
    }
    overflow = overflow.trim();
    if (overflow.length > 0 && this.host.getAttribute("overflow") !== overflow) {
      this.host.setAttribute("overflow", overflow);
    } else if (overflow.length === 0 && this.host.hasAttribute("overflow")) {
      this.host.removeAttribute("overflow");
    }
  }
};

export {
  OverflowController
};
//# sourceMappingURL=chunk-NSMHBY24.js.map
