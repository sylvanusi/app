{
  "version": 3,
  "sources": ["../../dompurify/src/utils.ts", "../../dompurify/src/tags.ts", "../../dompurify/src/attrs.ts", "../../dompurify/src/regexp.ts", "../../dompurify/src/purify.ts", "../../marked/src/defaults.ts", "../../marked/src/rules.ts", "../../marked/src/helpers.ts", "../../marked/src/Tokenizer.ts", "../../marked/src/Lexer.ts", "../../marked/src/Renderer.ts", "../../marked/src/TextRenderer.ts", "../../marked/src/Parser.ts", "../../marked/src/Hooks.ts", "../../marked/src/Instance.ts", "../../marked/src/marked.ts", "../../@vaadin/markdown/src/markdown-helpers.js"],
  "sourcesContent": ["const {\n  entries,\n  setPrototypeOf,\n  isFrozen,\n  getPrototypeOf,\n  getOwnPropertyDescriptor,\n} = Object;\n\nlet { freeze, seal, create } = Object; // eslint-disable-line import/no-mutable-exports\nlet { apply, construct } = typeof Reflect !== 'undefined' && Reflect;\n\nif (!freeze) {\n  freeze = function <T>(x: T): T {\n    return x;\n  };\n}\n\nif (!seal) {\n  seal = function <T>(x: T): T {\n    return x;\n  };\n}\n\nif (!apply) {\n  apply = function <T>(\n    func: (thisArg: any, ...args: any[]) => T,\n    thisArg: any,\n    ...args: any[]\n  ): T {\n    return func.apply(thisArg, args);\n  };\n}\n\nif (!construct) {\n  construct = function <T>(Func: new (...args: any[]) => T, ...args: any[]): T {\n    return new Func(...args);\n  };\n}\n\nconst arrayForEach = unapply(Array.prototype.forEach);\nconst arrayIndexOf = unapply(Array.prototype.indexOf);\nconst arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);\nconst arrayPop = unapply(Array.prototype.pop);\nconst arrayPush = unapply(Array.prototype.push);\nconst arraySlice = unapply(Array.prototype.slice);\nconst arraySplice = unapply(Array.prototype.splice);\n\nconst stringToLowerCase = unapply(String.prototype.toLowerCase);\nconst stringToString = unapply(String.prototype.toString);\nconst stringMatch = unapply(String.prototype.match);\nconst stringReplace = unapply(String.prototype.replace);\nconst stringIndexOf = unapply(String.prototype.indexOf);\nconst stringTrim = unapply(String.prototype.trim);\n\nconst objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\n\nconst regExpTest = unapply(RegExp.prototype.test);\n\nconst typeErrorCreate = unconstruct(TypeError);\n\n/**\n * Creates a new function that calls the given function with a specified thisArg and arguments.\n *\n * @param func - The function to be wrapped and called.\n * @returns A new function that calls the given function with a specified thisArg and arguments.\n */\nfunction unapply<T>(\n  func: (thisArg: any, ...args: any[]) => T\n): (thisArg: any, ...args: any[]) => T {\n  return (thisArg: any, ...args: any[]): T => {\n    if (thisArg instanceof RegExp) {\n      thisArg.lastIndex = 0;\n    }\n\n    return apply(func, thisArg, args);\n  };\n}\n\n/**\n * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n *\n * @param func - The constructor function to be wrapped and called.\n * @returns A new function that constructs an instance of the given constructor function with the provided arguments.\n */\nfunction unconstruct<T>(\n  Func: new (...args: any[]) => T\n): (...args: any[]) => T {\n  return (...args: any[]): T => construct(Func, args);\n}\n\n/**\n * Add properties to a lookup table\n *\n * @param set - The set to which elements will be added.\n * @param array - The array containing elements to be added to the set.\n * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n * @returns The modified set with added elements.\n */\nfunction addToSet(\n  set: Record<string, any>,\n  array: readonly any[],\n  transformCaseFunc: ReturnType<typeof unapply<string>> = stringToLowerCase\n): Record<string, any> {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  let l = array.length;\n  while (l--) {\n    let element = array[l];\n    if (typeof element === 'string') {\n      const lcElement = transformCaseFunc(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          (array as any[])[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/**\n * Clean up an array to harden against CSPP\n *\n * @param array - The array to be cleaned.\n * @returns The cleaned version of the array\n */\nfunction cleanArray<T>(array: T[]): Array<T | null> {\n  for (let index = 0; index < array.length; index++) {\n    const isPropertyExist = objectHasOwnProperty(array, index);\n\n    if (!isPropertyExist) {\n      array[index] = null;\n    }\n  }\n\n  return array;\n}\n\n/**\n * Shallow clone an object\n *\n * @param object - The object to be cloned.\n * @returns A new object that copies the original.\n */\nfunction clone<T extends Record<string, any>>(object: T): T {\n  const newObject = create(null);\n\n  for (const [property, value] of entries(object)) {\n    const isPropertyExist = objectHasOwnProperty(object, property);\n\n    if (isPropertyExist) {\n      if (Array.isArray(value)) {\n        newObject[property] = cleanArray(value);\n      } else if (\n        value &&\n        typeof value === 'object' &&\n        value.constructor === Object\n      ) {\n        newObject[property] = clone(value);\n      } else {\n        newObject[property] = value;\n      }\n    }\n  }\n\n  return newObject;\n}\n\n/**\n * This method automatically checks if the prop is function or getter and behaves accordingly.\n *\n * @param object - The object to look up the getter function in its prototype chain.\n * @param prop - The property name for which to find the getter function.\n * @returns The getter function found in the prototype chain or a fallback function.\n */\nfunction lookupGetter<T extends Record<string, any>>(\n  object: T,\n  prop: string\n): ReturnType<typeof unapply<any>> | (() => null) {\n  while (object !== null) {\n    const desc = getOwnPropertyDescriptor(object, prop);\n\n    if (desc) {\n      if (desc.get) {\n        return unapply(desc.get);\n      }\n\n      if (typeof desc.value === 'function') {\n        return unapply(desc.value);\n      }\n    }\n\n    object = getPrototypeOf(object);\n  }\n\n  function fallbackValue(): null {\n    return null;\n  }\n\n  return fallbackValue;\n}\n\nexport {\n  // Array\n  arrayForEach,\n  arrayIndexOf,\n  arrayLastIndexOf,\n  arrayPop,\n  arrayPush,\n  arraySlice,\n  arraySplice,\n  // Object\n  entries,\n  freeze,\n  getPrototypeOf,\n  getOwnPropertyDescriptor,\n  isFrozen,\n  setPrototypeOf,\n  seal,\n  clone,\n  create,\n  objectHasOwnProperty,\n  // RegExp\n  regExpTest,\n  // String\n  stringIndexOf,\n  stringMatch,\n  stringReplace,\n  stringToLowerCase,\n  stringToString,\n  stringTrim,\n  // Errors\n  typeErrorCreate,\n  // Other\n  lookupGetter,\n  addToSet,\n  // Reflect\n  unapply,\n  unconstruct,\n};\n", "import { freeze } from './utils.js';\n\nexport const html = freeze([\n  'a',\n  'abbr',\n  'acronym',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'bdi',\n  'bdo',\n  'big',\n  'blink',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'center',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'content',\n  'data',\n  'datalist',\n  'dd',\n  'decorator',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'element',\n  'em',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'font',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'label',\n  'legend',\n  'li',\n  'main',\n  'map',\n  'mark',\n  'marquee',\n  'menu',\n  'menuitem',\n  'meter',\n  'nav',\n  'nobr',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'picture',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'search',\n  'section',\n  'select',\n  'shadow',\n  'slot',\n  'small',\n  'source',\n  'spacer',\n  'span',\n  'strike',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'template',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'tr',\n  'track',\n  'tt',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n] as const);\n\nexport const svg = freeze([\n  'svg',\n  'a',\n  'altglyph',\n  'altglyphdef',\n  'altglyphitem',\n  'animatecolor',\n  'animatemotion',\n  'animatetransform',\n  'circle',\n  'clippath',\n  'defs',\n  'desc',\n  'ellipse',\n  'enterkeyhint',\n  'exportparts',\n  'filter',\n  'font',\n  'g',\n  'glyph',\n  'glyphref',\n  'hkern',\n  'image',\n  'inputmode',\n  'line',\n  'lineargradient',\n  'marker',\n  'mask',\n  'metadata',\n  'mpath',\n  'part',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'radialgradient',\n  'rect',\n  'stop',\n  'style',\n  'switch',\n  'symbol',\n  'text',\n  'textpath',\n  'title',\n  'tref',\n  'tspan',\n  'view',\n  'vkern',\n] as const);\n\nexport const svgFilters = freeze([\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n] as const);\n\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nexport const svgDisallowed = freeze([\n  'animate',\n  'color-profile',\n  'cursor',\n  'discard',\n  'font-face',\n  'font-face-format',\n  'font-face-name',\n  'font-face-src',\n  'font-face-uri',\n  'foreignobject',\n  'hatch',\n  'hatchpath',\n  'mesh',\n  'meshgradient',\n  'meshpatch',\n  'meshrow',\n  'missing-glyph',\n  'script',\n  'set',\n  'solidcolor',\n  'unknown',\n  'use',\n] as const);\n\nexport const mathMl = freeze([\n  'math',\n  'menclose',\n  'merror',\n  'mfenced',\n  'mfrac',\n  'mglyph',\n  'mi',\n  'mlabeledtr',\n  'mmultiscripts',\n  'mn',\n  'mo',\n  'mover',\n  'mpadded',\n  'mphantom',\n  'mroot',\n  'mrow',\n  'ms',\n  'mspace',\n  'msqrt',\n  'mstyle',\n  'msub',\n  'msup',\n  'msubsup',\n  'mtable',\n  'mtd',\n  'mtext',\n  'mtr',\n  'munder',\n  'munderover',\n  'mprescripts',\n] as const);\n\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nexport const mathMlDisallowed = freeze([\n  'maction',\n  'maligngroup',\n  'malignmark',\n  'mlongdiv',\n  'mscarries',\n  'mscarry',\n  'msgroup',\n  'mstack',\n  'msline',\n  'msrow',\n  'semantics',\n  'annotation',\n  'annotation-xml',\n  'mprescripts',\n  'none',\n] as const);\n\nexport const text = freeze(['#text'] as const);\n", "import { freeze } from './utils.js';\n\nexport const html = freeze([\n  'accept',\n  'action',\n  'align',\n  'alt',\n  'autocapitalize',\n  'autocomplete',\n  'autopictureinpicture',\n  'autoplay',\n  'background',\n  'bgcolor',\n  'border',\n  'capture',\n  'cellpadding',\n  'cellspacing',\n  'checked',\n  'cite',\n  'class',\n  'clear',\n  'color',\n  'cols',\n  'colspan',\n  'controls',\n  'controlslist',\n  'coords',\n  'crossorigin',\n  'datetime',\n  'decoding',\n  'default',\n  'dir',\n  'disabled',\n  'disablepictureinpicture',\n  'disableremoteplayback',\n  'download',\n  'draggable',\n  'enctype',\n  'enterkeyhint',\n  'exportparts',\n  'face',\n  'for',\n  'headers',\n  'height',\n  'hidden',\n  'high',\n  'href',\n  'hreflang',\n  'id',\n  'inert',\n  'inputmode',\n  'integrity',\n  'ismap',\n  'kind',\n  'label',\n  'lang',\n  'list',\n  'loading',\n  'loop',\n  'low',\n  'max',\n  'maxlength',\n  'media',\n  'method',\n  'min',\n  'minlength',\n  'multiple',\n  'muted',\n  'name',\n  'nonce',\n  'noshade',\n  'novalidate',\n  'nowrap',\n  'open',\n  'optimum',\n  'part',\n  'pattern',\n  'placeholder',\n  'playsinline',\n  'popover',\n  'popovertarget',\n  'popovertargetaction',\n  'poster',\n  'preload',\n  'pubdate',\n  'radiogroup',\n  'readonly',\n  'rel',\n  'required',\n  'rev',\n  'reversed',\n  'role',\n  'rows',\n  'rowspan',\n  'spellcheck',\n  'scope',\n  'selected',\n  'shape',\n  'size',\n  'sizes',\n  'slot',\n  'span',\n  'srclang',\n  'start',\n  'src',\n  'srcset',\n  'step',\n  'style',\n  'summary',\n  'tabindex',\n  'title',\n  'translate',\n  'type',\n  'usemap',\n  'valign',\n  'value',\n  'width',\n  'wrap',\n  'xmlns',\n  'slot',\n] as const);\n\nexport const svg = freeze([\n  'accent-height',\n  'accumulate',\n  'additive',\n  'alignment-baseline',\n  'amplitude',\n  'ascent',\n  'attributename',\n  'attributetype',\n  'azimuth',\n  'basefrequency',\n  'baseline-shift',\n  'begin',\n  'bias',\n  'by',\n  'class',\n  'clip',\n  'clippathunits',\n  'clip-path',\n  'clip-rule',\n  'color',\n  'color-interpolation',\n  'color-interpolation-filters',\n  'color-profile',\n  'color-rendering',\n  'cx',\n  'cy',\n  'd',\n  'dx',\n  'dy',\n  'diffuseconstant',\n  'direction',\n  'display',\n  'divisor',\n  'dur',\n  'edgemode',\n  'elevation',\n  'end',\n  'exponent',\n  'fill',\n  'fill-opacity',\n  'fill-rule',\n  'filter',\n  'filterunits',\n  'flood-color',\n  'flood-opacity',\n  'font-family',\n  'font-size',\n  'font-size-adjust',\n  'font-stretch',\n  'font-style',\n  'font-variant',\n  'font-weight',\n  'fx',\n  'fy',\n  'g1',\n  'g2',\n  'glyph-name',\n  'glyphref',\n  'gradientunits',\n  'gradienttransform',\n  'height',\n  'href',\n  'id',\n  'image-rendering',\n  'in',\n  'in2',\n  'intercept',\n  'k',\n  'k1',\n  'k2',\n  'k3',\n  'k4',\n  'kerning',\n  'keypoints',\n  'keysplines',\n  'keytimes',\n  'lang',\n  'lengthadjust',\n  'letter-spacing',\n  'kernelmatrix',\n  'kernelunitlength',\n  'lighting-color',\n  'local',\n  'marker-end',\n  'marker-mid',\n  'marker-start',\n  'markerheight',\n  'markerunits',\n  'markerwidth',\n  'maskcontentunits',\n  'maskunits',\n  'max',\n  'mask',\n  'mask-type',\n  'media',\n  'method',\n  'mode',\n  'min',\n  'name',\n  'numoctaves',\n  'offset',\n  'operator',\n  'opacity',\n  'order',\n  'orient',\n  'orientation',\n  'origin',\n  'overflow',\n  'paint-order',\n  'path',\n  'pathlength',\n  'patterncontentunits',\n  'patterntransform',\n  'patternunits',\n  'points',\n  'preservealpha',\n  'preserveaspectratio',\n  'primitiveunits',\n  'r',\n  'rx',\n  'ry',\n  'radius',\n  'refx',\n  'refy',\n  'repeatcount',\n  'repeatdur',\n  'restart',\n  'result',\n  'rotate',\n  'scale',\n  'seed',\n  'shape-rendering',\n  'slope',\n  'specularconstant',\n  'specularexponent',\n  'spreadmethod',\n  'startoffset',\n  'stddeviation',\n  'stitchtiles',\n  'stop-color',\n  'stop-opacity',\n  'stroke-dasharray',\n  'stroke-dashoffset',\n  'stroke-linecap',\n  'stroke-linejoin',\n  'stroke-miterlimit',\n  'stroke-opacity',\n  'stroke',\n  'stroke-width',\n  'style',\n  'surfacescale',\n  'systemlanguage',\n  'tabindex',\n  'tablevalues',\n  'targetx',\n  'targety',\n  'transform',\n  'transform-origin',\n  'text-anchor',\n  'text-decoration',\n  'text-rendering',\n  'textlength',\n  'type',\n  'u1',\n  'u2',\n  'unicode',\n  'values',\n  'viewbox',\n  'visibility',\n  'version',\n  'vert-adv-y',\n  'vert-origin-x',\n  'vert-origin-y',\n  'width',\n  'word-spacing',\n  'wrap',\n  'writing-mode',\n  'xchannelselector',\n  'ychannelselector',\n  'x',\n  'x1',\n  'x2',\n  'xmlns',\n  'y',\n  'y1',\n  'y2',\n  'z',\n  'zoomandpan',\n] as const);\n\nexport const mathMl = freeze([\n  'accent',\n  'accentunder',\n  'align',\n  'bevelled',\n  'close',\n  'columnsalign',\n  'columnlines',\n  'columnspan',\n  'denomalign',\n  'depth',\n  'dir',\n  'display',\n  'displaystyle',\n  'encoding',\n  'fence',\n  'frame',\n  'height',\n  'href',\n  'id',\n  'largeop',\n  'length',\n  'linethickness',\n  'lspace',\n  'lquote',\n  'mathbackground',\n  'mathcolor',\n  'mathsize',\n  'mathvariant',\n  'maxsize',\n  'minsize',\n  'movablelimits',\n  'notation',\n  'numalign',\n  'open',\n  'rowalign',\n  'rowlines',\n  'rowspacing',\n  'rowspan',\n  'rspace',\n  'rquote',\n  'scriptlevel',\n  'scriptminsize',\n  'scriptsizemultiplier',\n  'selection',\n  'separator',\n  'separators',\n  'stretchy',\n  'subscriptshift',\n  'supscriptshift',\n  'symmetric',\n  'voffset',\n  'width',\n  'xmlns',\n]);\n\nexport const xml = freeze([\n  'xlink:href',\n  'xml:id',\n  'xlink:title',\n  'xml:space',\n  'xmlns:xlink',\n] as const);\n", "import { seal } from './utils.js';\n\n// eslint-disable-next-line unicorn/better-regex\nexport const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nexport const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\nexport const TMPLIT_EXPR = seal(/\\$\\{[\\w\\W]*/gm); // eslint-disable-line unicorn/better-regex\nexport const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]+$/); // eslint-disable-line no-useless-escape\nexport const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nexport const IS_ALLOWED_URI = seal(\n  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nexport const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nexport const ATTR_WHITESPACE = seal(\n  /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\nexport const DOCTYPE_NAME = seal(/^html$/i);\nexport const CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\n", "/* eslint-disable @typescript-eslint/indent */\n\nimport type { TrustedHTML, TrustedTypesWindow } from 'trusted-types/lib';\nimport type { Config, UseProfilesConfig } from './config';\nimport * as TAGS from './tags.js';\nimport * as ATTRS from './attrs.js';\nimport * as EXPRESSIONS from './regexp.js';\nimport {\n  addToSet,\n  clone,\n  entries,\n  freeze,\n  arrayForEach,\n  arrayLastIndexOf,\n  arrayPop,\n  arrayPush,\n  arraySplice,\n  stringMatch,\n  stringReplace,\n  stringToLowerCase,\n  stringToString,\n  stringIndexOf,\n  stringTrim,\n  regExpTest,\n  typeErrorCreate,\n  lookupGetter,\n  create,\n  objectHasOwnProperty,\n} from './utils.js';\n\nexport type { Config } from './config';\n\ndeclare const VERSION: string;\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\nconst NODE_TYPE = {\n  element: 1,\n  attribute: 2,\n  text: 3,\n  cdataSection: 4,\n  entityReference: 5, // Deprecated\n  entityNode: 6, // Deprecated\n  progressingInstruction: 7,\n  comment: 8,\n  document: 9,\n  documentType: 10,\n  documentFragment: 11,\n  notation: 12, // Deprecated\n};\n\nconst getGlobal = function (): WindowLike {\n  return typeof window === 'undefined' ? null : window;\n};\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param trustedTypes The policy factory.\n * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n * @return The policy created (or null, if Trusted Types\n * are not supported or creating the policy failed).\n */\nconst _createTrustedTypesPolicy = function (\n  trustedTypes: TrustedTypePolicyFactory,\n  purifyHostElement: HTMLScriptElement\n) {\n  if (\n    typeof trustedTypes !== 'object' ||\n    typeof trustedTypes.createPolicy !== 'function'\n  ) {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  let suffix = null;\n  const ATTR_NAME = 'data-tt-policy-suffix';\n  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n    suffix = purifyHostElement.getAttribute(ATTR_NAME);\n  }\n\n  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML(html) {\n        return html;\n      },\n      createScriptURL(scriptUrl) {\n        return scriptUrl;\n      },\n    });\n  } catch (_) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn(\n      'TrustedTypes policy ' + policyName + ' could not be created.'\n    );\n    return null;\n  }\n};\n\nconst _createHooksMap = function (): HooksMap {\n  return {\n    afterSanitizeAttributes: [],\n    afterSanitizeElements: [],\n    afterSanitizeShadowDOM: [],\n    beforeSanitizeAttributes: [],\n    beforeSanitizeElements: [],\n    beforeSanitizeShadowDOM: [],\n    uponSanitizeAttribute: [],\n    uponSanitizeElement: [],\n    uponSanitizeShadowNode: [],\n  };\n};\n\nfunction createDOMPurify(window: WindowLike = getGlobal()): DOMPurify {\n  const DOMPurify: DOMPurify = (root: WindowLike) => createDOMPurify(root);\n\n  DOMPurify.version = VERSION;\n\n  DOMPurify.removed = [];\n\n  if (\n    !window ||\n    !window.document ||\n    window.document.nodeType !== NODE_TYPE.document ||\n    !window.Element\n  ) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  let { document } = window;\n\n  const originalDocument = document;\n  const currentScript: HTMLScriptElement =\n    originalDocument.currentScript as HTMLScriptElement;\n  const {\n    DocumentFragment,\n    HTMLTemplateElement,\n    Node,\n    Element,\n    NodeFilter,\n    NamedNodeMap = window.NamedNodeMap || (window as any).MozNamedAttrMap,\n    HTMLFormElement,\n    DOMParser,\n    trustedTypes,\n  } = window;\n\n  const ElementPrototype = Element.prototype;\n\n  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n  const remove = lookupGetter(ElementPrototype, 'remove');\n  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n  if (typeof HTMLTemplateElement === 'function') {\n    const template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  let trustedTypesPolicy;\n  let emptyHTML = '';\n\n  const {\n    implementation,\n    createNodeIterator,\n    createDocumentFragment,\n    getElementsByTagName,\n  } = document;\n  const { importNode } = originalDocument;\n\n  let hooks = _createHooksMap();\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported =\n    typeof entries === 'function' &&\n    typeof getParentNode === 'function' &&\n    implementation &&\n    implementation.createHTMLDocument !== undefined;\n\n  const {\n    MUSTACHE_EXPR,\n    ERB_EXPR,\n    TMPLIT_EXPR,\n    DATA_ATTR,\n    ARIA_ATTR,\n    IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE,\n    CUSTOM_ELEMENT,\n  } = EXPRESSIONS;\n\n  let { IS_ALLOWED_URI } = EXPRESSIONS;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n  let ALLOWED_TAGS = null;\n  const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n    ...TAGS.html,\n    ...TAGS.svg,\n    ...TAGS.svgFilters,\n    ...TAGS.mathMl,\n    ...TAGS.text,\n  ]);\n\n  /* Allowed attribute names */\n  let ALLOWED_ATTR = null;\n  const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n    ...ATTRS.html,\n    ...ATTRS.svg,\n    ...ATTRS.mathMl,\n    ...ATTRS.xml,\n  ]);\n\n  /*\n   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.\n   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n   */\n  let CUSTOM_ELEMENT_HANDLING = Object.seal(\n    create(null, {\n      tagNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null,\n      },\n      attributeNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null,\n      },\n      allowCustomizedBuiltInElements: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: false,\n      },\n    })\n  );\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  let FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  let FORBID_ATTR = null;\n\n  /* Config object to store ADD_TAGS/ADD_ATTR functions (when used as functions) */\n  const EXTRA_ELEMENT_HANDLING = Object.seal(\n    create(null, {\n      tagCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null,\n      },\n      attributeCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null,\n      },\n    })\n  );\n\n  /* Decide if ARIA attributes are okay */\n  let ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  let ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  let ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Decide if self-closing tags in attributes are allowed.\n   * Usually removed due to a mXSS issue in jQuery 3.0 */\n  let ALLOW_SELF_CLOSE_IN_ATTR = true;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  let SAFE_FOR_TEMPLATES = false;\n\n  /* Output should be safe even for XML used within HTML and alike.\n   * This means, DOMPurify removes comments when containing risky content.\n   */\n  let SAFE_FOR_XML = true;\n\n  /* Decide if document with <html>... should be returned */\n  let WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  let SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  let FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  let RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  let RETURN_DOM_FRAGMENT = false;\n\n  /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */\n  let RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks?\n   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n   */\n  let SANITIZE_DOM = true;\n\n  /* Achieve full DOM Clobbering protection by isolating the namespace of named\n   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n   *\n   * HTML/DOM spec rules that enable DOM Clobbering:\n   *   - Named Access on Window (§7.3.3)\n   *   - DOM Tree Accessors (§3.1.5)\n   *   - Form Element Parent-Child Relations (§4.10.3)\n   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n   *   - HTMLCollection (§4.2.10.2)\n   *\n   * Namespace isolation is implemented by prefixing `id` and `name` attributes\n   * with a constant string, i.e., `user-content-`\n   */\n  let SANITIZE_NAMED_PROPS = false;\n  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n\n  /* Keep element content when removing element? */\n  let KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  let IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  let USE_PROFILES: UseProfilesConfig | false = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  let FORBID_CONTENTS = null;\n  const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n    'annotation-xml',\n    'audio',\n    'colgroup',\n    'desc',\n    'foreignobject',\n    'head',\n    'iframe',\n    'math',\n    'mi',\n    'mn',\n    'mo',\n    'ms',\n    'mtext',\n    'noembed',\n    'noframes',\n    'noscript',\n    'plaintext',\n    'script',\n    'style',\n    'svg',\n    'template',\n    'thead',\n    'title',\n    'video',\n    'xmp',\n  ]);\n\n  /* Tags that are safe for data: URIs */\n  let DATA_URI_TAGS = null;\n  const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n    'audio',\n    'video',\n    'img',\n    'source',\n    'image',\n    'track',\n  ]);\n\n  /* Attributes safe for values like \"javascript:\" */\n  let URI_SAFE_ATTRIBUTES = null;\n  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n    'alt',\n    'class',\n    'for',\n    'id',\n    'label',\n    'name',\n    'pattern',\n    'placeholder',\n    'role',\n    'summary',\n    'title',\n    'value',\n    'style',\n    'xmlns',\n  ]);\n\n  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n  /* Document namespace */\n  let NAMESPACE = HTML_NAMESPACE;\n  let IS_EMPTY_INPUT = false;\n\n  /* Allowed XHTML+XML namespaces */\n  let ALLOWED_NAMESPACES = null;\n  const DEFAULT_ALLOWED_NAMESPACES = addToSet(\n    {},\n    [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE],\n    stringToString\n  );\n\n  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n    'mi',\n    'mo',\n    'mn',\n    'ms',\n    'mtext',\n  ]);\n\n  let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);\n\n  // Certain elements are allowed in both SVG and HTML\n  // namespace. We need to specify them explicitly\n  // so that they don't get erroneously deleted from\n  // HTML namespace.\n  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n    'title',\n    'style',\n    'font',\n    'a',\n    'script',\n  ]);\n\n  /* Parsing of strict XHTML documents */\n  let PARSER_MEDIA_TYPE: null | DOMParserSupportedType = null;\n  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n  let transformCaseFunc: null | Parameters<typeof addToSet>[2] = null;\n\n  /* Keep a reference to config to pass to hooks */\n  let CONFIG: Config | null = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  const formElement = document.createElement('form');\n\n  const isRegexOrFunction = function (\n    testValue: unknown\n  ): testValue is Function | RegExp {\n    return testValue instanceof RegExp || testValue instanceof Function;\n  };\n\n  /**\n   * _parseConfig\n   *\n   * @param cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  const _parseConfig = function (cfg: Config = {}): void {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || typeof cfg !== 'object') {\n      cfg = {};\n    }\n\n    /* Shield configuration object from prototype pollution */\n    cfg = clone(cfg);\n\n    PARSER_MEDIA_TYPE =\n      // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1\n        ? DEFAULT_PARSER_MEDIA_TYPE\n        : cfg.PARSER_MEDIA_TYPE;\n\n    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n    transformCaseFunc =\n      PARSER_MEDIA_TYPE === 'application/xhtml+xml'\n        ? stringToString\n        : stringToLowerCase;\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS')\n      ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc)\n      : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR')\n      ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc)\n      : DEFAULT_ALLOWED_ATTR;\n    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES')\n      ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString)\n      : DEFAULT_ALLOWED_NAMESPACES;\n    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR')\n      ? addToSet(\n          clone(DEFAULT_URI_SAFE_ATTRIBUTES),\n          cfg.ADD_URI_SAFE_ATTR,\n          transformCaseFunc\n        )\n      : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS')\n      ? addToSet(\n          clone(DEFAULT_DATA_URI_TAGS),\n          cfg.ADD_DATA_URI_TAGS,\n          transformCaseFunc\n        )\n      : DEFAULT_DATA_URI_TAGS;\n    FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS')\n      ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc)\n      : DEFAULT_FORBID_CONTENTS;\n    FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS')\n      ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc)\n      : clone({});\n    FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR')\n      ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc)\n      : clone({});\n    USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES')\n      ? cfg.USE_PROFILES\n      : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI = cfg.ALLOWED_URI_REGEXP || EXPRESSIONS.IS_ALLOWED_URI;\n    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n    MATHML_TEXT_INTEGRATION_POINTS =\n      cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;\n    HTML_INTEGRATION_POINTS =\n      cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;\n\n    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n    if (\n      cfg.CUSTOM_ELEMENT_HANDLING &&\n      isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)\n    ) {\n      CUSTOM_ELEMENT_HANDLING.tagNameCheck =\n        cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n    }\n\n    if (\n      cfg.CUSTOM_ELEMENT_HANDLING &&\n      isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)\n    ) {\n      CUSTOM_ELEMENT_HANDLING.attributeNameCheck =\n        cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n    }\n\n    if (\n      cfg.CUSTOM_ELEMENT_HANDLING &&\n      typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements ===\n        'boolean'\n    ) {\n      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements =\n        cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n    }\n\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, TAGS.text);\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, TAGS.html);\n        addToSet(ALLOWED_ATTR, ATTRS.html);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, TAGS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, TAGS.svgFilters);\n        addToSet(ALLOWED_ATTR, ATTRS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, TAGS.mathMl);\n        addToSet(ALLOWED_ATTR, ATTRS.mathMl);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (typeof cfg.ADD_TAGS === 'function') {\n        EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;\n      } else {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n      }\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (typeof cfg.ADD_ATTR === 'function') {\n        EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;\n      } else {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n      }\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n    }\n\n    if (cfg.FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n\n      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n\n    if (cfg.TRUSTED_TYPES_POLICY) {\n      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n        throw typeErrorCreate(\n          'TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.'\n        );\n      }\n\n      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n        throw typeErrorCreate(\n          'TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.'\n        );\n      }\n\n      // Overwrite existing TrustedTypes policy.\n      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n\n      // Sign local variables required by `sanitize`.\n      emptyHTML = trustedTypesPolicy.createHTML('');\n    } else {\n      // Uninitialized policy, attempt to initialize the internal dompurify policy.\n      if (trustedTypesPolicy === undefined) {\n        trustedTypesPolicy = _createTrustedTypesPolicy(\n          trustedTypes,\n          currentScript\n        );\n      }\n\n      // If creating the internal policy succeeded sign internal variables.\n      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      }\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */\n  const ALL_SVG_TAGS = addToSet({}, [\n    ...TAGS.svg,\n    ...TAGS.svgFilters,\n    ...TAGS.svgDisallowed,\n  ]);\n  const ALL_MATHML_TAGS = addToSet({}, [\n    ...TAGS.mathMl,\n    ...TAGS.mathMlDisallowed,\n  ]);\n\n  /**\n   * @param element a DOM element whose namespace is being checked\n   * @returns Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */\n  const _checkValidNamespace = function (element: Element): boolean {\n    let parent = getParentNode(element);\n\n    // In JSDOM, if we're inside shadow DOM, then parentNode\n    // can be null. We just simulate parent in this case.\n    if (!parent || !parent.tagName) {\n      parent = {\n        namespaceURI: NAMESPACE,\n        tagName: 'template',\n      };\n    }\n\n    const tagName = stringToLowerCase(element.tagName);\n    const parentTagName = stringToLowerCase(parent.tagName);\n\n    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n      return false;\n    }\n\n    if (element.namespaceURI === SVG_NAMESPACE) {\n      // The only way to switch from HTML namespace to SVG\n      // is via <svg>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'svg';\n      }\n\n      // The only way to switch from MathML to SVG is via`\n      // svg if parent is either <annotation-xml> or MathML\n      // text integration points.\n      if (parent.namespaceURI === MATHML_NAMESPACE) {\n        return (\n          tagName === 'svg' &&\n          (parentTagName === 'annotation-xml' ||\n            MATHML_TEXT_INTEGRATION_POINTS[parentTagName])\n        );\n      }\n\n      // We only allow elements that are defined in SVG\n      // spec. All others are disallowed in SVG namespace.\n      return Boolean(ALL_SVG_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === MATHML_NAMESPACE) {\n      // The only way to switch from HTML namespace to MathML\n      // is via <math>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'math';\n      }\n\n      // The only way to switch from SVG to MathML is via\n      // <math> and HTML integration points\n      if (parent.namespaceURI === SVG_NAMESPACE) {\n        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n      }\n\n      // We only allow elements that are defined in MathML\n      // spec. All others are disallowed in MathML namespace.\n      return Boolean(ALL_MATHML_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === HTML_NAMESPACE) {\n      // The only way to switch from SVG to HTML is via\n      // HTML integration points, and from MathML to HTML\n      // is via MathML text integration points\n      if (\n        parent.namespaceURI === SVG_NAMESPACE &&\n        !HTML_INTEGRATION_POINTS[parentTagName]\n      ) {\n        return false;\n      }\n\n      if (\n        parent.namespaceURI === MATHML_NAMESPACE &&\n        !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]\n      ) {\n        return false;\n      }\n\n      // We disallow tags that are specific for MathML\n      // or SVG and should never appear in HTML namespace\n      return (\n        !ALL_MATHML_TAGS[tagName] &&\n        (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName])\n      );\n    }\n\n    // For XHTML and XML documents that support custom namespaces\n    if (\n      PARSER_MEDIA_TYPE === 'application/xhtml+xml' &&\n      ALLOWED_NAMESPACES[element.namespaceURI]\n    ) {\n      return true;\n    }\n\n    // The code should never reach this place (this means\n    // that the element somehow got namespace that is not\n    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n    // Return false just in case.\n    return false;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param node a DOM node\n   */\n  const _forceRemove = function (node: Node): void {\n    arrayPush(DOMPurify.removed, { element: node });\n\n    try {\n      // eslint-disable-next-line unicorn/prefer-dom-node-remove\n      getParentNode(node).removeChild(node);\n    } catch (_) {\n      remove(node);\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param name an Attribute name\n   * @param element a DOM node\n   */\n  const _removeAttribute = function (name: string, element: Element): void {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: element.getAttributeNode(name),\n        from: element,\n      });\n    } catch (_) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: element,\n      });\n    }\n\n    element.removeAttribute(name);\n\n    // We void attribute values for unremovable \"is\" attributes\n    if (name === 'is') {\n      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n        try {\n          _forceRemove(element);\n        } catch (_) {}\n      } else {\n        try {\n          element.setAttribute(name, '');\n        } catch (_) {}\n      }\n    }\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param dirty - a string of dirty markup\n   * @return a DOM, filled with the dirty markup\n   */\n  const _initDocument = function (dirty: string): Document {\n    /* Create a HTML document */\n    let doc = null;\n    let leadingWhitespace = null;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n\n    if (\n      PARSER_MEDIA_TYPE === 'application/xhtml+xml' &&\n      NAMESPACE === HTML_NAMESPACE\n    ) {\n      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n      dirty =\n        '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' +\n        dirty +\n        '</body></html>';\n    }\n\n    const dirtyPayload = trustedTypesPolicy\n      ? trustedTypesPolicy.createHTML(dirty)\n      : dirty;\n    /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n      } catch (_) {}\n    }\n\n    /* Use createHTMLDocument in case DOMParser is not available */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createDocument(NAMESPACE, 'template', null);\n      try {\n        doc.documentElement.innerHTML = IS_EMPTY_INPUT\n          ? emptyHTML\n          : dirtyPayload;\n      } catch (_) {\n        // Syntax error if dirtyPayload is invalid xml\n      }\n    }\n\n    const body = doc.body || doc.documentElement;\n\n    if (dirty && leadingWhitespace) {\n      body.insertBefore(\n        document.createTextNode(leadingWhitespace),\n        body.childNodes[0] || null\n      );\n    }\n\n    /* Work on whole document or just its body */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      return getElementsByTagName.call(\n        doc,\n        WHOLE_DOCUMENT ? 'html' : 'body'\n      )[0];\n    }\n\n    return WHOLE_DOCUMENT ? doc.documentElement : body;\n  };\n\n  /**\n   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n   *\n   * @param root The root element or node to start traversing on.\n   * @return The created NodeIterator\n   */\n  const _createNodeIterator = function (root: Node): NodeIterator {\n    return createNodeIterator.call(\n      root.ownerDocument || root,\n      root,\n      // eslint-disable-next-line no-bitwise\n      NodeFilter.SHOW_ELEMENT |\n        NodeFilter.SHOW_COMMENT |\n        NodeFilter.SHOW_TEXT |\n        NodeFilter.SHOW_PROCESSING_INSTRUCTION |\n        NodeFilter.SHOW_CDATA_SECTION,\n      null\n    );\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param element element to check for clobbering attacks\n   * @return true if clobbered, false if safe\n   */\n  const _isClobbered = function (element: Element): boolean {\n    return (\n      element instanceof HTMLFormElement &&\n      (typeof element.nodeName !== 'string' ||\n        typeof element.textContent !== 'string' ||\n        typeof element.removeChild !== 'function' ||\n        !(element.attributes instanceof NamedNodeMap) ||\n        typeof element.removeAttribute !== 'function' ||\n        typeof element.setAttribute !== 'function' ||\n        typeof element.namespaceURI !== 'string' ||\n        typeof element.insertBefore !== 'function' ||\n        typeof element.hasChildNodes !== 'function')\n    );\n  };\n\n  /**\n   * Checks whether the given object is a DOM node.\n   *\n   * @param value object to check whether it's a DOM node\n   * @return true is object is a DOM node\n   */\n  const _isNode = function (value: unknown): value is Node {\n    return typeof Node === 'function' && value instanceof Node;\n  };\n\n  function _executeHooks<T extends HookFunction>(\n    hooks: HookFunction[],\n    currentNode: Parameters<T>[0],\n    data: Parameters<T>[1]\n  ): void {\n    arrayForEach(hooks, (hook: T) => {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  }\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   * @param currentNode to check for permission to exist\n   * @return true if node was killed, false if left alive\n   */\n  const _sanitizeElements = function (currentNode: any): boolean {\n    let content = null;\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    const tagName = transformCaseFunc(currentNode.nodeName);\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.uponSanitizeElement, currentNode, {\n      tagName,\n      allowedTags: ALLOWED_TAGS,\n    });\n\n    /* Detect mXSS attempts abusing namespace confusion */\n    if (\n      SAFE_FOR_XML &&\n      currentNode.hasChildNodes() &&\n      !_isNode(currentNode.firstElementChild) &&\n      regExpTest(/<[/\\w!]/g, currentNode.innerHTML) &&\n      regExpTest(/<[/\\w!]/g, currentNode.textContent)\n    ) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove any occurrence of processing instructions */\n    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove any kind of possibly harmful comments */\n    if (\n      SAFE_FOR_XML &&\n      currentNode.nodeType === NODE_TYPE.comment &&\n      regExpTest(/<[/\\w]/g, currentNode.data)\n    ) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove element if anything forbids its presence */\n    if (\n      !(\n        EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function &&\n        EXTRA_ELEMENT_HANDLING.tagCheck(tagName)\n      ) &&\n      (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])\n    ) {\n      /* Check if we have a custom element to handle */\n      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n        if (\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&\n          regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)\n        ) {\n          return false;\n        }\n\n        if (\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)\n        ) {\n          return false;\n        }\n      }\n\n      /* Keep content except for bad-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n        const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n        if (childNodes && parentNode) {\n          const childCount = childNodes.length;\n\n          for (let i = childCount - 1; i >= 0; --i) {\n            const childClone = cloneNode(childNodes[i], true);\n            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n            parentNode.insertBefore(childClone, getNextSibling(currentNode));\n          }\n        }\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check whether element has a valid namespace */\n    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Make sure that older browsers don't get fallback-tag mXSS */\n    if (\n      (tagName === 'noscript' ||\n        tagName === 'noembed' ||\n        tagName === 'noframes') &&\n      regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)\n    ) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n\n      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr: RegExp) => {\n        content = stringReplace(content, expr, ' ');\n      });\n\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.afterSanitizeElements, currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param lcTag Lowercase tag name of containing element.\n   * @param lcName Lowercase attribute name.\n   * @param value Attribute value.\n   * @return Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  const _isValidAttribute = function (\n    lcTag: string,\n    lcName: string,\n    value: string\n  ): boolean {\n    /* Make sure attribute cannot clobber */\n    if (\n      SANITIZE_DOM &&\n      (lcName === 'id' || lcName === 'name') &&\n      (value in document || value in formElement)\n    ) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (\n      ALLOW_DATA_ATTR &&\n      !FORBID_ATTR[lcName] &&\n      regExpTest(DATA_ATTR, lcName)\n    ) {\n      // This attribute is safe\n    } else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) {\n      // This attribute is safe\n      /* Check if ADD_ATTR function allows this attribute */\n    } else if (\n      EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function &&\n      EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)\n    ) {\n      // This attribute is safe\n      /* Otherwise, check the name is permitted */\n    } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      if (\n        // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n        (_isBasicCustomElement(lcTag) &&\n          ((CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&\n            regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag)) ||\n            (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&\n              CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag))) &&\n          ((CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp &&\n            regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName)) ||\n            (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function &&\n              CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)))) ||\n        // Alternative, second condition checks if it's an `is`-attribute, AND\n        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        (lcName === 'is' &&\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements &&\n          ((CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&\n            regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value)) ||\n            (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&\n              CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))))\n      ) {\n        // If user has supplied a regexp or function in CUSTOM_ELEMENT_HANDLING.tagNameCheck, we need to also allow derived custom elements using the same tagName test.\n        // Additionally, we need to allow attributes passing the CUSTOM_ELEMENT_HANDLING.attributeNameCheck user has configured, as custom elements can define these at their own discretion.\n      } else {\n        return false;\n      }\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) {\n      // This attribute is safe\n      /* Check no script, data or unknown possibly unsafe URI\n        unless we know URI values are safe for that attribute */\n    } else if (\n      regExpTest(IS_ALLOWED_URI, stringReplace(value, ATTR_WHITESPACE, ''))\n    ) {\n      // This attribute is safe\n      /* Keep image data URIs alive if src/xlink:href is allowed */\n      /* Further prevent gadget XSS for dynamically built script tags */\n    } else if (\n      (lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') &&\n      lcTag !== 'script' &&\n      stringIndexOf(value, 'data:') === 0 &&\n      DATA_URI_TAGS[lcTag]\n    ) {\n      // This attribute is safe\n      /* Allow unknown protocols: This provides support for links that\n        are handled by protocol handlers which may be unknown ahead of\n        time, e.g. fb:, spotify: */\n    } else if (\n      ALLOW_UNKNOWN_PROTOCOLS &&\n      !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))\n    ) {\n      // This attribute is safe\n      /* Check for binary attributes */\n    } else if (value) {\n      return false;\n    } else {\n      // Binary attributes are safe at this point\n      /* Anything else, presume unsafe, do not add it back */\n    }\n\n    return true;\n  };\n\n  /**\n   * _isBasicCustomElement\n   * checks if at least one dash is included in tagName, and it's not the first char\n   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n   *\n   * @param tagName name of the tag of the node to sanitize\n   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n   */\n  const _isBasicCustomElement = function (tagName: string): RegExpMatchArray {\n    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param currentNode to sanitize\n   */\n  const _sanitizeAttributes = function (currentNode: Element): void {\n    /* Execute a hook if present */\n    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);\n\n    const { attributes } = currentNode;\n\n    /* Check if we have attributes; if not we might have a text node */\n    if (!attributes || _isClobbered(currentNode)) {\n      return;\n    }\n\n    const hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR,\n      forceKeepAttr: undefined,\n    };\n    let l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      const attr = attributes[l];\n      const { name, namespaceURI, value: attrValue } = attr;\n      const lcName = transformCaseFunc(name);\n\n      const initValue = attrValue;\n      let value = name === 'value' ? initValue : stringTrim(initValue);\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);\n      value = hookEvent.attrValue;\n\n      /* Full DOM Clobbering protection via namespace isolation,\n       * Prefix id and name attributes with `user-content-`\n       */\n      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n        // Remove the attribute with this value\n        _removeAttribute(name, currentNode);\n\n        // Prefix the value and later re-create the attribute with the sanitized value\n        value = SANITIZE_NAMED_PROPS_PREFIX + value;\n      }\n\n      /* Work around a security issue with comments inside attributes */\n      if (\n        SAFE_FOR_XML &&\n        regExpTest(/((--!?|])>)|<\\/(style|title|textarea)/i, value)\n      ) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Make sure we cannot easily use animated hrefs, even if animations are allowed */\n      if (lcName === 'attributename' && stringMatch(value, 'href')) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Work around a security issue in jQuery 3.0 */\n      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr: RegExp) => {\n          value = stringReplace(value, expr, ' ');\n        });\n      }\n\n      /* Is `value` valid for this attribute? */\n      const lcTag = transformCaseFunc(currentNode.nodeName);\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Handle attributes that require Trusted Types */\n      if (\n        trustedTypesPolicy &&\n        typeof trustedTypes === 'object' &&\n        typeof trustedTypes.getAttributeType === 'function'\n      ) {\n        if (namespaceURI) {\n          /* Namespaces are not yet supported, see https://bugs.chromium.org/p/chromium/issues/detail?id=1305293 */\n        } else {\n          switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n            case 'TrustedHTML': {\n              value = trustedTypesPolicy.createHTML(value);\n              break;\n            }\n\n            case 'TrustedScriptURL': {\n              value = trustedTypesPolicy.createScriptURL(value);\n              break;\n            }\n\n            default: {\n              break;\n            }\n          }\n        }\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      if (value !== initValue) {\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          if (_isClobbered(currentNode)) {\n            _forceRemove(currentNode);\n          } else {\n            arrayPop(DOMPurify.removed);\n          }\n        } catch (_) {\n          _removeAttribute(name, currentNode);\n        }\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param fragment to iterate over recursively\n   */\n  const _sanitizeShadowDOM = function (fragment: DocumentFragment): void {\n    let shadowNode = null;\n    const shadowIterator = _createNodeIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);\n\n    while ((shadowNode = shadowIterator.nextNode())) {\n      /* Execute a hook if present */\n      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);\n\n      /* Sanitize tags and elements */\n      _sanitizeElements(shadowNode);\n\n      /* Check attributes next */\n      _sanitizeAttributes(shadowNode);\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);\n  };\n\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty, cfg = {}) {\n    let body = null;\n    let importedNode = null;\n    let currentNode = null;\n    let returnNode = null;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    IS_EMPTY_INPUT = !dirty;\n    if (IS_EMPTY_INPUT) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      if (typeof dirty.toString === 'function') {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw typeErrorCreate('dirty is not a string, aborting');\n        }\n      } else {\n        throw typeErrorCreate('toString is not a function');\n      }\n    }\n\n    /* Return dirty HTML if DOMPurify cannot run */\n    if (!DOMPurify.isSupported) {\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === 'string') {\n      IN_PLACE = false;\n    }\n\n    if (IN_PLACE) {\n      /* Do some early pre-sanitization to avoid unsafe root nodes */\n      if ((dirty as Node).nodeName) {\n        const tagName = transformCaseFunc((dirty as Node).nodeName);\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          throw typeErrorCreate(\n            'root node is forbidden and cannot be sanitized in-place'\n          );\n        }\n      }\n    } else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!---->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (\n        importedNode.nodeType === NODE_TYPE.element &&\n        importedNode.nodeName === 'BODY'\n      ) {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-dom-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (\n        !RETURN_DOM &&\n        !SAFE_FOR_TEMPLATES &&\n        !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1\n      ) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE\n          ? trustedTypesPolicy.createHTML(dirty)\n          : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while ((currentNode = nodeIterator.nextNode())) {\n      /* Sanitize tags and elements */\n      _sanitizeElements(currentNode);\n\n      /* Check attributes next */\n      _sanitizeAttributes(currentNode);\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n    }\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n        /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Serialize doctype if allowed */\n    if (\n      WHOLE_DOCUMENT &&\n      ALLOWED_TAGS['!doctype'] &&\n      body.ownerDocument &&\n      body.ownerDocument.doctype &&\n      body.ownerDocument.doctype.name &&\n      regExpTest(EXPRESSIONS.DOCTYPE_NAME, body.ownerDocument.doctype.name)\n    ) {\n      serializedHTML =\n        '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n    }\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr: RegExp) => {\n        serializedHTML = stringReplace(serializedHTML, expr, ' ');\n      });\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE\n      ? trustedTypesPolicy.createHTML(serializedHTML)\n      : serializedHTML;\n  };\n\n  DOMPurify.setConfig = function (cfg = {}) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    const lcTag = transformCaseFunc(tag);\n    const lcName = transformCaseFunc(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  DOMPurify.addHook = function (\n    entryPoint: keyof HooksMap,\n    hookFunction: HookFunction\n  ) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n\n  DOMPurify.removeHook = function (\n    entryPoint: keyof HooksMap,\n    hookFunction: HookFunction\n  ) {\n    if (hookFunction !== undefined) {\n      const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);\n\n      return index === -1\n        ? undefined\n        : arraySplice(hooks[entryPoint], index, 1)[0];\n    }\n\n    return arrayPop(hooks[entryPoint]);\n  };\n\n  DOMPurify.removeHooks = function (entryPoint: keyof HooksMap) {\n    hooks[entryPoint] = [];\n  };\n\n  DOMPurify.removeAllHooks = function () {\n    hooks = _createHooksMap();\n  };\n\n  return DOMPurify;\n}\n\nexport default createDOMPurify();\n\nexport interface DOMPurify {\n  /**\n   * Creates a DOMPurify instance using the given window-like object. Defaults to `window`.\n   */\n  (root?: WindowLike): DOMPurify;\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  version: string;\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  removed: Array<RemovedElement | RemovedAttribute>;\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  isSupported: boolean;\n\n  /**\n   * Set the configuration once.\n   *\n   * @param cfg configuration object\n   */\n  setConfig(cfg?: Config): void;\n\n  /**\n   * Removes the configuration.\n   */\n  clearConfig(): void;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty string or DOM node\n   * @param cfg object\n   * @returns Sanitized TrustedHTML.\n   */\n  sanitize(\n    dirty: string | Node,\n    cfg: Config & { RETURN_TRUSTED_TYPE: true }\n  ): TrustedHTML;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty DOM node\n   * @param cfg object\n   * @returns Sanitized DOM node.\n   */\n  sanitize(dirty: Node, cfg: Config & { IN_PLACE: true }): Node;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty string or DOM node\n   * @param cfg object\n   * @returns Sanitized DOM node.\n   */\n  sanitize(dirty: string | Node, cfg: Config & { RETURN_DOM: true }): Node;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty string or DOM node\n   * @param cfg object\n   * @returns Sanitized document fragment.\n   */\n  sanitize(\n    dirty: string | Node,\n    cfg: Config & { RETURN_DOM_FRAGMENT: true }\n  ): DocumentFragment;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty string or DOM node\n   * @param cfg object\n   * @returns Sanitized string.\n   */\n  sanitize(dirty: string | Node, cfg?: Config): string;\n\n  /**\n   * Checks if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   *\n   * @param tag Tag name of containing element.\n   * @param attr Attribute name.\n   * @param value Attribute value.\n   * @returns Returns true if `value` is valid. Otherwise, returns false.\n   */\n  isValidAttribute(tag: string, attr: string, value: string): boolean;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(entryPoint: BasicHookName, hookFunction: NodeHook): void;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(entryPoint: ElementHookName, hookFunction: ElementHook): void;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(\n    entryPoint: DocumentFragmentHookName,\n    hookFunction: DocumentFragmentHook\n  ): void;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(\n    entryPoint: 'uponSanitizeElement',\n    hookFunction: UponSanitizeElementHook\n  ): void;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(\n    entryPoint: 'uponSanitizeAttribute',\n    hookFunction: UponSanitizeAttributeHook\n  ): void;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: BasicHookName,\n    hookFunction?: NodeHook\n  ): NodeHook | undefined;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: ElementHookName,\n    hookFunction?: ElementHook\n  ): ElementHook | undefined;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: DocumentFragmentHookName,\n    hookFunction?: DocumentFragmentHook\n  ): DocumentFragmentHook | undefined;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: 'uponSanitizeElement',\n    hookFunction?: UponSanitizeElementHook\n  ): UponSanitizeElementHook | undefined;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: 'uponSanitizeAttribute',\n    hookFunction?: UponSanitizeAttributeHook\n  ): UponSanitizeAttributeHook | undefined;\n\n  /**\n   * Removes all DOMPurify hooks at a given entryPoint\n   *\n   * @param entryPoint entry point for the hooks to remove\n   */\n  removeHooks(entryPoint: HookName): void;\n\n  /**\n   * Removes all DOMPurify hooks.\n   */\n  removeAllHooks(): void;\n}\n\n/**\n * An element removed by DOMPurify.\n */\nexport interface RemovedElement {\n  /**\n   * The element that was removed.\n   */\n  element: Node;\n}\n\n/**\n * An element removed by DOMPurify.\n */\nexport interface RemovedAttribute {\n  /**\n   * The attribute that was removed.\n   */\n  attribute: Attr | null;\n\n  /**\n   * The element that the attribute was removed.\n   */\n  from: Node;\n}\n\ntype BasicHookName =\n  | 'beforeSanitizeElements'\n  | 'afterSanitizeElements'\n  | 'uponSanitizeShadowNode';\ntype ElementHookName = 'beforeSanitizeAttributes' | 'afterSanitizeAttributes';\ntype DocumentFragmentHookName =\n  | 'beforeSanitizeShadowDOM'\n  | 'afterSanitizeShadowDOM';\ntype UponSanitizeElementHookName = 'uponSanitizeElement';\ntype UponSanitizeAttributeHookName = 'uponSanitizeAttribute';\n\ninterface HooksMap {\n  beforeSanitizeElements: NodeHook[];\n  afterSanitizeElements: NodeHook[];\n  beforeSanitizeShadowDOM: DocumentFragmentHook[];\n  uponSanitizeShadowNode: NodeHook[];\n  afterSanitizeShadowDOM: DocumentFragmentHook[];\n  beforeSanitizeAttributes: ElementHook[];\n  afterSanitizeAttributes: ElementHook[];\n  uponSanitizeElement: UponSanitizeElementHook[];\n  uponSanitizeAttribute: UponSanitizeAttributeHook[];\n}\n\ntype ArrayElement<T> = T extends Array<infer U> ? U : never;\n\ntype HookFunction = ArrayElement<HooksMap[keyof HooksMap]>;\n\nexport type HookName =\n  | BasicHookName\n  | ElementHookName\n  | DocumentFragmentHookName\n  | UponSanitizeElementHookName\n  | UponSanitizeAttributeHookName;\n\nexport type NodeHook = (\n  this: DOMPurify,\n  currentNode: Node,\n  hookEvent: null,\n  config: Config\n) => void;\n\nexport type ElementHook = (\n  this: DOMPurify,\n  currentNode: Element,\n  hookEvent: null,\n  config: Config\n) => void;\n\nexport type DocumentFragmentHook = (\n  this: DOMPurify,\n  currentNode: DocumentFragment,\n  hookEvent: null,\n  config: Config\n) => void;\n\nexport type UponSanitizeElementHook = (\n  this: DOMPurify,\n  currentNode: Node,\n  hookEvent: UponSanitizeElementHookEvent,\n  config: Config\n) => void;\n\nexport type UponSanitizeAttributeHook = (\n  this: DOMPurify,\n  currentNode: Element,\n  hookEvent: UponSanitizeAttributeHookEvent,\n  config: Config\n) => void;\n\nexport interface UponSanitizeElementHookEvent {\n  tagName: string;\n  allowedTags: Record<string, boolean>;\n}\n\nexport interface UponSanitizeAttributeHookEvent {\n  attrName: string;\n  attrValue: string;\n  keepAttr: boolean;\n  allowedAttributes: Record<string, boolean>;\n  forceKeepAttr: boolean | undefined;\n}\n\n/**\n * A `Window`-like object containing the properties and types that DOMPurify requires.\n */\nexport type WindowLike = Pick<\n  typeof globalThis,\n  | 'DocumentFragment'\n  | 'HTMLTemplateElement'\n  | 'Node'\n  | 'Element'\n  | 'NodeFilter'\n  | 'NamedNodeMap'\n  | 'HTMLFormElement'\n  | 'DOMParser'\n> & {\n  document?: Document;\n  MozNamedAttrMap?: typeof window.NamedNodeMap;\n} & Pick<TrustedTypesWindow, 'trustedTypes'>;\n", "import type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Gets the original marked default options.\n */\nexport function _getDefaults<ParserOutput = string, RendererOutput = string>(): MarkedOptions<ParserOutput, RendererOutput> {\n  return {\n    async: false,\n    breaks: false,\n    extensions: null,\n    gfm: true,\n    hooks: null,\n    pedantic: false,\n    renderer: null,\n    silent: false,\n    tokenizer: null,\n    walkTokens: null,\n  };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport let _defaults: MarkedOptions<any, any> = _getDefaults();\n\nexport function changeDefaults<ParserOutput = string, RendererOutput = string>(newDefaults: MarkedOptions<ParserOutput, RendererOutput>) {\n  _defaults = newDefaults;\n}\n", "const noopTest = { exec: () => null } as unknown as RegExp;\n\nfunction edit(regex: string | RegExp, opt = '') {\n  let source = typeof regex === 'string' ? regex : regex.source;\n  const obj = {\n    replace: (name: string | RegExp, val: string | RegExp) => {\n      let valSource = typeof val === 'string' ? val : val.source;\n      valSource = valSource.replace(other.caret, '$1');\n      source = source.replace(name, valSource);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(source, opt);\n    },\n  };\n  return obj;\n}\n\nconst supportsLookbehind = (() => {\ntry {\n  // eslint-disable-next-line prefer-regex-literals\n  return !!new RegExp('(?<=1)(?<!1)');\n} catch {\n  // See browser support here:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Lookbehind_assertion\n  return false;\n}\n})();\n\nexport const other = {\n  codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n  outputLinkReplace: /\\\\([\\[\\]])/g,\n  indentCodeCompensation: /^(\\s+)(?:```)/,\n  beginningSpace: /^\\s+/,\n  endingHash: /#$/,\n  startingSpaceChar: /^ /,\n  endingSpaceChar: / $/,\n  nonSpaceChar: /[^ ]/,\n  newLineCharGlobal: /\\n/g,\n  tabCharGlobal: /\\t/g,\n  multipleSpaceGlobal: /\\s+/g,\n  blankLine: /^[ \\t]*$/,\n  doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n  blockquoteStart: /^ {0,3}>/,\n  blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n  blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n  listReplaceTabs: /^\\t+/,\n  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n  listIsTask: /^\\[[ xX]\\] /,\n  listReplaceTask: /^\\[[ xX]\\] +/,\n  anyLine: /\\n.*\\n/,\n  hrefBrackets: /^<(.*)>$/,\n  tableDelimiter: /[:|]/,\n  tableAlignChars: /^\\||\\| *$/g,\n  tableRowBlankLine: /\\n[ \\t]*$/,\n  tableAlignRight: /^ *-+: *$/,\n  tableAlignCenter: /^ *:-+: *$/,\n  tableAlignLeft: /^ *:-+ *$/,\n  startATag: /^<a /i,\n  endATag: /^<\\/a>/i,\n  startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n  endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n  startAngleBracket: /^</,\n  endAngleBracket: />$/,\n  pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n  unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n  escapeTest: /[&<>\"']/,\n  escapeReplace: /[&<>\"']/g,\n  escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n  escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n  unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n  caret: /(^|[^\\[])\\^/g,\n  percentDecode: /%25/g,\n  findPipe: /\\|/g,\n  splitPipe: / \\|/,\n  slashPipe: /\\\\\\|/g,\n  carriageReturn: /\\r\\n|\\r/g,\n  spaceLine: /^ +$/gm,\n  notSpaceStart: /^\\S*/,\n  endingNewline: /\\n$/,\n  listItemRegex: (bull: string) => new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n  nextBulletRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n  hrRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n  fencesBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n  headingBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n  htmlBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),\n};\n\n/**\n * Block-Level Grammar\n */\n\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\nconst lheading = edit(lheadingCore)\n  .replace(/bull/g, bullet) // lists can interrupt\n  .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n  .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n  .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n  .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n  .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n  .replace(/\\|table/g, '') // table not in commonmark\n  .getRegex();\nconst lheadingGfm = edit(lheadingCore)\n  .replace(/bull/g, bullet) // lists can interrupt\n  .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n  .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n  .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n  .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n  .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n  .replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/) // table can interrupt\n  .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\[\\s\\S]|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n  .replace('label', _blockLabel)\n  .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n  .getRegex();\n\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n  .replace(/bull/g, bullet)\n  .getRegex();\n\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n  + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit(\n  '^ {0,3}(?:' // optional indentation\n+ '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n+ '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n+ '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n+ '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n+ '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n+ '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n+ '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n+ '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n+ ')', 'i')\n  .replace('comment', _comment)\n  .replace('tag', _tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nconst paragraph = edit(_paragraph)\n  .replace('hr', hr)\n  .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n  .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n  .replace('|table', '')\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n  .replace('paragraph', paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nconst blockNormal = {\n  blockquote,\n  code: blockCode,\n  def,\n  fences,\n  heading,\n  hr,\n  html,\n  lheading,\n  list,\n  newline,\n  paragraph,\n  table: noopTest,\n  text: blockText,\n};\n\ntype BlockKeys = keyof typeof blockNormal;\n\n/**\n * GFM Block Grammar\n */\n\nconst gfmTable = edit(\n  '^ *([^\\\\n ].*)\\\\n' // Header\n+ ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n+ '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n  .replace('hr', hr)\n  .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\nconst blockGfm: Record<BlockKeys, RegExp> = {\n  ...blockNormal,\n  lheading: lheadingGfm,\n  table: gfmTable,\n  paragraph: edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('table', gfmTable) // interrupt paragraphs with table\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex(),\n};\n\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nconst blockPedantic: Record<BlockKeys, RegExp> = {\n  ...blockNormal,\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', _comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n  heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n  fences: noopTest, // fences not supported\n  lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  paragraph: edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' *#{1,6} *[^\\n]')\n    .replace('lheading', lheading)\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('|fences', '')\n    .replace('|list', '')\n    .replace('|html', '')\n    .replace('|tag', '')\n    .getRegex(),\n};\n\n/**\n * Inline-Level Grammar\n */\n\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = /[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\nconst punctuation = edit(/^((?![*_])punctSpace)/, 'u')\n  .replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n\n// GFM allows ~ inside strong and em for strikethrough\nconst _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = edit(/link|precode-code|html/, 'g')\n  .replace('link', /\\[(?:[^\\[\\]`]|(?<a>`+)[^`]+\\k<a>(?!`))*?\\]\\((?:\\\\[\\s\\S]|[^\\\\\\(\\)]|\\((?:\\\\[\\s\\S]|[^\\\\\\(\\)])*\\))*\\)/)\n  .replace('precode-', supportsLookbehind ? '(?<!`)()' : '(^^|[^`])')\n  .replace('code', /(?<b>`+)[^`]+\\k<b>(?!`)/)\n  .replace('html', /<(?! )[^<>]*?>/)\n  .getRegex();\n\nconst emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\n\nconst emStrongLDelim = edit(emStrongLDelimCore, 'u')\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')\n  .replace(/punct/g, _punctuationGfmStrongEm)\n  .getRegex();\n\nconst emStrongRDelimAstCore =\n  '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n+ '|[^*]+(?=[^*])' // Consume to delim\n+ '|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n+ '|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter\n+ '|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter\n+ '|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)' // (4) ***# can only be Left Delimiter\n+ '|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter\n+ '|notPunctSpace(\\\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter\n\nconst emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n  .replace(/punctSpace/g, _punctuationOrSpace)\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)\n  .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)\n  .replace(/punct/g, _punctuationGfmStrongEm)\n  .getRegex();\n\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit(\n  '^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n+ '|[^_]+(?=[^_])' // Consume to delim\n+ '|(?!_)punct(_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n+ '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter\n+ '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter\n+ '|[\\\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter\n+ '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter\n  .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n  .replace(/punctSpace/g, _punctuationOrSpace)\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst anyPunctuation = edit(/\\\\(punct)/, 'gu')\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n  .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n  .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n  .getRegex();\n\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit(\n  '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n  .replace('comment', _inlineComment)\n  .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nconst _inlineLabel = /(?:\\[(?:\\\\[\\s\\S]|[^\\[\\]\\\\])*\\]|\\\\[\\s\\S]|`+[^`]*?`+(?!`)|[^\\[\\]\\\\`])*?/;\n\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:(?:[ \\t]*(?:\\n[ \\t]*)?)(title))?\\s*\\)/)\n  .replace('label', _inlineLabel)\n  .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^ \\t\\n\\x00-\\x1f]*/)\n  .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n  .getRegex();\n\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n  .replace('label', _inlineLabel)\n  .replace('ref', _blockLabel)\n  .getRegex();\n\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n  .replace('ref', _blockLabel)\n  .getRegex();\n\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n  .replace('reflink', reflink)\n  .replace('nolink', nolink)\n  .getRegex();\n\nconst _caseInsensitiveProtocol = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/;\n\n/**\n * Normal Inline Grammar\n */\n\nconst inlineNormal = {\n  _backpedal: noopTest, // only used for GFM url\n  anyPunctuation,\n  autolink,\n  blockSkip,\n  br,\n  code: inlineCode,\n  del: noopTest,\n  emStrongLDelim,\n  emStrongRDelimAst,\n  emStrongRDelimUnd,\n  escape,\n  link,\n  nolink,\n  punctuation,\n  reflink,\n  reflinkSearch,\n  tag,\n  text: inlineText,\n  url: noopTest,\n};\n\ntype InlineKeys = keyof typeof inlineNormal;\n\n/**\n * Pedantic Inline Grammar\n */\n\nconst inlinePedantic: Record<InlineKeys, RegExp> = {\n  ...inlineNormal,\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', _inlineLabel)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', _inlineLabel)\n    .getRegex(),\n};\n\n/**\n * GFM Inline Grammar\n */\n\nconst inlineGfm: Record<InlineKeys, RegExp> = {\n  ...inlineNormal,\n  emStrongRDelimAst: emStrongRDelimAstGfm,\n  emStrongLDelim: emStrongLDelimGfm,\n  url: edit(/^((?:protocol):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/)\n    .replace('protocol', _caseInsensitiveProtocol)\n    .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n    .getRegex(),\n  _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n  del: /^(~~?)(?=[^\\s~])((?:\\\\[\\s\\S]|[^\\\\])*?(?:\\\\[\\s\\S]|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n  text: edit(/^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|protocol:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/)\n    .replace('protocol', _caseInsensitiveProtocol)\n    .getRegex(),\n};\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\nconst inlineBreaks: Record<InlineKeys, RegExp> = {\n  ...inlineGfm,\n  br: edit(br).replace('{2,}', '*').getRegex(),\n  text: edit(inlineGfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex(),\n};\n\n/**\n * exports\n */\n\nexport const block = {\n  normal: blockNormal,\n  gfm: blockGfm,\n  pedantic: blockPedantic,\n};\n\nexport const inline = {\n  normal: inlineNormal,\n  gfm: inlineGfm,\n  breaks: inlineBreaks,\n  pedantic: inlinePedantic,\n};\n\nexport interface Rules {\n  other: typeof other\n  block: Record<BlockKeys, RegExp>\n  inline: Record<InlineKeys, RegExp>\n}\n", "import { other } from './rules.ts';\n\n/**\n * Helpers\n */\nconst escapeReplacements: { [index: string]: string } = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch: string) => escapeReplacements[ch];\n\nexport function escape(html: string, encode?: boolean) {\n  if (encode) {\n    if (other.escapeTest.test(html)) {\n      return html.replace(other.escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (other.escapeTestNoEncode.test(html)) {\n      return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n\nexport function unescape(html: string) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(other.unescapeTest, (_, n) => {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nexport function cleanUrl(href: string) {\n  try {\n    href = encodeURI(href).replace(other.percentDecode, '%');\n  } catch {\n    return null;\n  }\n  return href;\n}\n\nexport function splitCells(tableRow: string, count?: number) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(other.findPipe, (match, offset, str) => {\n      let escaped = false;\n      let curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(other.splitPipe);\n  let i = 0;\n\n  // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n  if (!cells[0].trim()) {\n    cells.shift();\n  }\n  if (cells.length > 0 && !cells.at(-1)?.trim()) {\n    cells.pop();\n  }\n\n  if (count) {\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) cells.push('');\n    }\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(other.slashPipe, '|');\n  }\n  return cells;\n}\n\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nexport function rtrim(str: string, c: string, invert?: boolean) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.slice(0, l - suffLen);\n}\n\nexport function findClosingBracket(str: string, b: string) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n\n  let level = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  if (level > 0) {\n    return -2;\n  }\n\n  return -1;\n}\n", "import { _defaults } from './defaults.ts';\nimport {\n  rtrim,\n  splitCells,\n  findClosingBracket,\n} from './helpers.ts';\nimport type { Rules } from './rules.ts';\nimport type { _Lexer } from './Lexer.ts';\nimport type { Links, Tokens, Token } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\nfunction outputLink(cap: string[], link: Pick<Tokens.Link, 'href' | 'title'>, raw: string, lexer: _Lexer, rules: Rules): Tokens.Link | Tokens.Image {\n  const href = link.href;\n  const title = link.title || null;\n  const text = cap[1].replace(rules.other.outputLinkReplace, '$1');\n\n  lexer.state.inLink = true;\n  const token: Tokens.Link | Tokens.Image = {\n    type: cap[0].charAt(0) === '!' ? 'image' : 'link',\n    raw,\n    href,\n    title,\n    text,\n    tokens: lexer.inlineTokens(text),\n  };\n  lexer.state.inLink = false;\n  return token;\n}\n\nfunction indentCodeCompensation(raw: string, text: string, rules: Rules) {\n  const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n\n  if (matchIndentToCode === null) {\n    return text;\n  }\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(rules.other.beginningSpace);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nexport class _Tokenizer<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  rules!: Rules; // set by the lexer\n  lexer!: _Lexer<ParserOutput, RendererOutput>; // set by the lexer\n\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n  }\n\n  space(src: string): Tokens.Space | undefined {\n    const cap = this.rules.block.newline.exec(src);\n    if (cap && cap[0].length > 0) {\n      return {\n        type: 'space',\n        raw: cap[0],\n      };\n    }\n  }\n\n  code(src: string): Tokens.Code | undefined {\n    const cap = this.rules.block.code.exec(src);\n    if (cap) {\n      const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');\n      return {\n        type: 'code',\n        raw: cap[0],\n        codeBlockStyle: 'indented',\n        text: !this.options.pedantic\n          ? rtrim(text, '\\n')\n          : text,\n      };\n    }\n  }\n\n  fences(src: string): Tokens.Code | undefined {\n    const cap = this.rules.block.fences.exec(src);\n    if (cap) {\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '', this.rules);\n\n      return {\n        type: 'code',\n        raw,\n        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n        text,\n      };\n    }\n  }\n\n  heading(src: string): Tokens.Heading | undefined {\n    const cap = this.rules.block.heading.exec(src);\n    if (cap) {\n      let text = cap[2].trim();\n\n      // remove trailing #s\n      if (this.rules.other.endingHash.test(text)) {\n        const trimmed = rtrim(text, '#');\n        if (this.options.pedantic) {\n          text = trimmed.trim();\n        } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim();\n        }\n      }\n\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[1].length,\n        text,\n        tokens: this.lexer.inline(text),\n      };\n    }\n  }\n\n  hr(src: string): Tokens.Hr | undefined {\n    const cap = this.rules.block.hr.exec(src);\n    if (cap) {\n      return {\n        type: 'hr',\n        raw: rtrim(cap[0], '\\n'),\n      };\n    }\n  }\n\n  blockquote(src: string): Tokens.Blockquote | undefined {\n    const cap = this.rules.block.blockquote.exec(src);\n    if (cap) {\n      let lines = rtrim(cap[0], '\\n').split('\\n');\n      let raw = '';\n      let text = '';\n      const tokens: Token[] = [];\n\n      while (lines.length > 0) {\n        let inBlockquote = false;\n        const currentLines = [];\n\n        let i;\n        for (i = 0; i < lines.length; i++) {\n          // get lines up to a continuation\n          if (this.rules.other.blockquoteStart.test(lines[i])) {\n            currentLines.push(lines[i]);\n            inBlockquote = true;\n          } else if (!inBlockquote) {\n            currentLines.push(lines[i]);\n          } else {\n            break;\n          }\n        }\n        lines = lines.slice(i);\n\n        const currentRaw = currentLines.join('\\n');\n        const currentText = currentRaw\n          // precede setext continuation with 4 spaces so it isn't a setext\n          .replace(this.rules.other.blockquoteSetextReplace, '\\n    $1')\n          .replace(this.rules.other.blockquoteSetextReplace2, '');\n        raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n        text = text ? `${text}\\n${currentText}` : currentText;\n\n        // parse blockquote lines as top level tokens\n        // merge paragraphs if this is a continuation\n        const top = this.lexer.state.top;\n        this.lexer.state.top = true;\n        this.lexer.blockTokens(currentText, tokens, true);\n        this.lexer.state.top = top;\n\n        // if there is no continuation then we are done\n        if (lines.length === 0) {\n          break;\n        }\n\n        const lastToken = tokens.at(-1);\n\n        if (lastToken?.type === 'code') {\n          // blockquote continuation cannot be preceded by a code block\n          break;\n        } else if (lastToken?.type === 'blockquote') {\n          // include continuation in nested blockquote\n          const oldToken = lastToken as Tokens.Blockquote;\n          const newText = oldToken.raw + '\\n' + lines.join('\\n');\n          const newToken = this.blockquote(newText)!;\n          tokens[tokens.length - 1] = newToken;\n\n          raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n          text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n          break;\n        } else if (lastToken?.type === 'list') {\n          // include continuation in nested list\n          const oldToken = lastToken as Tokens.List;\n          const newText = oldToken.raw + '\\n' + lines.join('\\n');\n          const newToken = this.list(newText)!;\n          tokens[tokens.length - 1] = newToken;\n\n          raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n          text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n          lines = newText.substring(tokens.at(-1)!.raw.length).split('\\n');\n          continue;\n        }\n      }\n\n      return {\n        type: 'blockquote',\n        raw,\n        tokens,\n        text,\n      };\n    }\n  }\n\n  list(src: string): Tokens.List | undefined {\n    let cap = this.rules.block.list.exec(src);\n    if (cap) {\n      let bull = cap[1].trim();\n      const isordered = bull.length > 1;\n\n      const list: Tokens.List = {\n        type: 'list',\n        raw: '',\n        ordered: isordered,\n        start: isordered ? +bull.slice(0, -1) : '',\n        loose: false,\n        items: [],\n      };\n\n      bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\n      if (this.options.pedantic) {\n        bull = isordered ? bull : '[*+-]';\n      }\n\n      // Get next list item\n      const itemRegex = this.rules.other.listItemRegex(bull);\n      let endsWithBlankLine = false;\n      // Check if current bullet point can start a new List Item\n      while (src) {\n        let endEarly = false;\n        let raw = '';\n        let itemContents = '';\n        if (!(cap = itemRegex.exec(src))) {\n          break;\n        }\n\n        if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n          break;\n        }\n\n        raw = cap[0];\n        src = src.substring(raw.length);\n\n        let line = cap[2].split('\\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t: string) => ' '.repeat(3 * t.length));\n        let nextLine = src.split('\\n', 1)[0];\n        let blankLine = !line.trim();\n\n        let indent = 0;\n        if (this.options.pedantic) {\n          indent = 2;\n          itemContents = line.trimStart();\n        } else if (blankLine) {\n          indent = cap[1].length + 1;\n        } else {\n          indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n          itemContents = line.slice(indent);\n          indent += cap[1].length;\n        }\n\n        if (blankLine && this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line\n          raw += nextLine + '\\n';\n          src = src.substring(nextLine.length + 1);\n          endEarly = true;\n        }\n\n        if (!endEarly) {\n          const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n          const hrRegex = this.rules.other.hrRegex(indent);\n          const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n          const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n          const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n\n          // Check if following lines should be included in List Item\n          while (src) {\n            const rawLine = src.split('\\n', 1)[0];\n            let nextLineWithoutTabs;\n            nextLine = rawLine;\n\n            // Re-align to follow commonmark nesting rules\n            if (this.options.pedantic) {\n              nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');\n              nextLineWithoutTabs = nextLine;\n            } else {\n              nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');\n            }\n\n            // End list item if found code fences\n            if (fencesBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new heading\n            if (headingBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of html block\n            if (htmlBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new bullet\n            if (nextBulletRegex.test(nextLine)) {\n              break;\n            }\n\n            // Horizontal rule found\n            if (hrRegex.test(nextLine)) {\n              break;\n            }\n\n            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) { // Dedent if possible\n              itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n            } else {\n              // not enough indentation\n              if (blankLine) {\n                break;\n              }\n\n              // paragraph continuation unless last line was a different block level element\n              if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) { // indented code block\n                break;\n              }\n              if (fencesBeginRegex.test(line)) {\n                break;\n              }\n              if (headingBeginRegex.test(line)) {\n                break;\n              }\n              if (hrRegex.test(line)) {\n                break;\n              }\n\n              itemContents += '\\n' + nextLine;\n            }\n\n            if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n              blankLine = true;\n            }\n\n            raw += rawLine + '\\n';\n            src = src.substring(rawLine.length + 1);\n            line = nextLineWithoutTabs.slice(indent);\n          }\n        }\n\n        if (!list.loose) {\n          // If the previous item ended with a blank line, the list is loose\n          if (endsWithBlankLine) {\n            list.loose = true;\n          } else if (this.rules.other.doubleBlankLine.test(raw)) {\n            endsWithBlankLine = true;\n          }\n        }\n\n        let istask: RegExpExecArray | null = null;\n        let ischecked: boolean | undefined;\n        // Check for task list items\n        if (this.options.gfm) {\n          istask = this.rules.other.listIsTask.exec(itemContents);\n          if (istask) {\n            ischecked = istask[0] !== '[ ] ';\n            itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');\n          }\n        }\n\n        list.items.push({\n          type: 'list_item',\n          raw,\n          task: !!istask,\n          checked: ischecked,\n          loose: false,\n          text: itemContents,\n          tokens: [],\n        });\n\n        list.raw += raw;\n      }\n\n      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n      const lastItem = list.items.at(-1);\n      if (lastItem) {\n        lastItem.raw = lastItem.raw.trimEnd();\n        lastItem.text = lastItem.text.trimEnd();\n      } else {\n        // not a list since there were no items\n        return;\n      }\n      list.raw = list.raw.trimEnd();\n\n      // Item child tokens handled here at end because we needed to have the final item to trim it first\n      for (let i = 0; i < list.items.length; i++) {\n        this.lexer.state.top = false;\n        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n        if (!list.loose) {\n          // Check if list should be loose\n          const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));\n\n          list.loose = hasMultipleLineBreaks;\n        }\n      }\n\n      // Set all items to loose if list is loose\n      if (list.loose) {\n        for (let i = 0; i < list.items.length; i++) {\n          list.items[i].loose = true;\n        }\n      }\n\n      return list;\n    }\n  }\n\n  html(src: string): Tokens.HTML | undefined {\n    const cap = this.rules.block.html.exec(src);\n    if (cap) {\n      const token: Tokens.HTML = {\n        type: 'html',\n        block: true,\n        raw: cap[0],\n        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n        text: cap[0],\n      };\n      return token;\n    }\n  }\n\n  def(src: string): Tokens.Def | undefined {\n    const cap = this.rules.block.def.exec(src);\n    if (cap) {\n      const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');\n      const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n      return {\n        type: 'def',\n        tag,\n        raw: cap[0],\n        href,\n        title,\n      };\n    }\n  }\n\n  table(src: string): Tokens.Table | undefined {\n    const cap = this.rules.block.table.exec(src);\n    if (!cap) {\n      return;\n    }\n\n    if (!this.rules.other.tableDelimiter.test(cap[2])) {\n      // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n      return;\n    }\n\n    const headers = splitCells(cap[1]);\n    const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');\n    const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\\n') : [];\n\n    const item: Tokens.Table = {\n      type: 'table',\n      raw: cap[0],\n      header: [],\n      align: [],\n      rows: [],\n    };\n\n    if (headers.length !== aligns.length) {\n      // header and align columns must be equal, rows can be different.\n      return;\n    }\n\n    for (const align of aligns) {\n      if (this.rules.other.tableAlignRight.test(align)) {\n        item.align.push('right');\n      } else if (this.rules.other.tableAlignCenter.test(align)) {\n        item.align.push('center');\n      } else if (this.rules.other.tableAlignLeft.test(align)) {\n        item.align.push('left');\n      } else {\n        item.align.push(null);\n      }\n    }\n\n    for (let i = 0; i < headers.length; i++) {\n      item.header.push({\n        text: headers[i],\n        tokens: this.lexer.inline(headers[i]),\n        header: true,\n        align: item.align[i],\n      });\n    }\n\n    for (const row of rows) {\n      item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n        return {\n          text: cell,\n          tokens: this.lexer.inline(cell),\n          header: false,\n          align: item.align[i],\n        };\n      }));\n    }\n\n    return item;\n  }\n\n  lheading(src: string): Tokens.Heading | undefined {\n    const cap = this.rules.block.lheading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[2].charAt(0) === '=' ? 1 : 2,\n        text: cap[1],\n        tokens: this.lexer.inline(cap[1]),\n      };\n    }\n  }\n\n  paragraph(src: string): Tokens.Paragraph | undefined {\n    const cap = this.rules.block.paragraph.exec(src);\n    if (cap) {\n      const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n        ? cap[1].slice(0, -1)\n        : cap[1];\n      return {\n        type: 'paragraph',\n        raw: cap[0],\n        text,\n        tokens: this.lexer.inline(text),\n      };\n    }\n  }\n\n  text(src: string): Tokens.Text | undefined {\n    const cap = this.rules.block.text.exec(src);\n    if (cap) {\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        tokens: this.lexer.inline(cap[0]),\n      };\n    }\n  }\n\n  escape(src: string): Tokens.Escape | undefined {\n    const cap = this.rules.inline.escape.exec(src);\n    if (cap) {\n      return {\n        type: 'escape',\n        raw: cap[0],\n        text: cap[1],\n      };\n    }\n  }\n\n  tag(src: string): Tokens.Tag | undefined {\n    const cap = this.rules.inline.tag.exec(src);\n    if (cap) {\n      if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n        this.lexer.state.inLink = true;\n      } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n        this.lexer.state.inLink = false;\n      }\n      if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n        this.lexer.state.inRawBlock = true;\n      } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n        this.lexer.state.inRawBlock = false;\n      }\n\n      return {\n        type: 'html',\n        raw: cap[0],\n        inLink: this.lexer.state.inLink,\n        inRawBlock: this.lexer.state.inRawBlock,\n        block: false,\n        text: cap[0],\n      };\n    }\n  }\n\n  link(src: string): Tokens.Link | Tokens.Image | undefined {\n    const cap = this.rules.inline.link.exec(src);\n    if (cap) {\n      const trimmedUrl = cap[2].trim();\n      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n        // commonmark requires matching angle brackets\n        if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n          return;\n        }\n\n        // ending angle bracket cannot be escaped\n        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n          return;\n        }\n      } else {\n        // find closing parenthesis\n        const lastParenIndex = findClosingBracket(cap[2], '()');\n        if (lastParenIndex === -2) {\n          // more open parens than closed\n          return;\n        }\n\n        if (lastParenIndex > -1) {\n          const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          const linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n      }\n      let href = cap[2];\n      let title = '';\n      if (this.options.pedantic) {\n        // split pedantic href and title\n        const link = this.rules.other.pedanticHrefTitle.exec(href);\n\n        if (link) {\n          href = link[1];\n          title = link[3];\n        }\n      } else {\n        title = cap[3] ? cap[3].slice(1, -1) : '';\n      }\n\n      href = href.trim();\n      if (this.rules.other.startAngleBracket.test(href)) {\n        if (this.options.pedantic && !(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n          // pedantic allows starting angle bracket without ending angle bracket\n          href = href.slice(1);\n        } else {\n          href = href.slice(1, -1);\n        }\n      }\n      return outputLink(cap, {\n        href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n        title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n      }, cap[0], this.lexer, this.rules);\n    }\n  }\n\n  reflink(src: string, links: Links): Tokens.Link | Tokens.Image | Tokens.Text | undefined {\n    let cap;\n    if ((cap = this.rules.inline.reflink.exec(src))\n      || (cap = this.rules.inline.nolink.exec(src))) {\n      const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');\n      const link = links[linkString.toLowerCase()];\n      if (!link) {\n        const text = cap[0].charAt(0);\n        return {\n          type: 'text',\n          raw: text,\n          text,\n        };\n      }\n      return outputLink(cap, link, cap[0], this.lexer, this.rules);\n    }\n  }\n\n  emStrong(src: string, maskedSrc: string, prevChar = ''): Tokens.Em | Tokens.Strong | undefined {\n    let match = this.rules.inline.emStrongLDelim.exec(src);\n    if (!match) return;\n\n    // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n    if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;\n\n    const nextChar = match[1] || match[2] || '';\n\n    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n      // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n      const lLength = [...match[0]].length - 1;\n      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\n      const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n      endReg.lastIndex = 0;\n\n      // Clip maskedSrc to same section of string as src (move to lexer?)\n      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n        if (!rDelim) continue; // skip single * in __abc*abc__\n\n        rLength = [...rDelim].length;\n\n        if (match[3] || match[4]) { // found another Left Delim\n          delimTotal += rLength;\n          continue;\n        } else if (match[5] || match[6]) { // either Left or Right Delim\n          if (lLength % 3 && !((lLength + rLength) % 3)) {\n            midDelimTotal += rLength;\n            continue; // CommonMark Emphasis Rules 9-10\n          }\n        }\n\n        delimTotal -= rLength;\n\n        if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n\n        // Remove extra characters. *a*** -> *a*\n        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n        // char length can be >1 for unicode characters;\n        const lastCharLength = [...match[0]][0].length;\n        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n\n        // Create `em` if smallest delimiter has odd char count. *a***\n        if (Math.min(lLength, rLength) % 2) {\n          const text = raw.slice(1, -1);\n          return {\n            type: 'em',\n            raw,\n            text,\n            tokens: this.lexer.inlineTokens(text),\n          };\n        }\n\n        // Create 'strong' if smallest delimiter has even char count. **a***\n        const text = raw.slice(2, -2);\n        return {\n          type: 'strong',\n          raw,\n          text,\n          tokens: this.lexer.inlineTokens(text),\n        };\n      }\n    }\n  }\n\n  codespan(src: string): Tokens.Codespan | undefined {\n    const cap = this.rules.inline.code.exec(src);\n    if (cap) {\n      let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');\n      const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n      const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n        text = text.substring(1, text.length - 1);\n      }\n      return {\n        type: 'codespan',\n        raw: cap[0],\n        text,\n      };\n    }\n  }\n\n  br(src: string): Tokens.Br | undefined {\n    const cap = this.rules.inline.br.exec(src);\n    if (cap) {\n      return {\n        type: 'br',\n        raw: cap[0],\n      };\n    }\n  }\n\n  del(src: string): Tokens.Del | undefined {\n    const cap = this.rules.inline.del.exec(src);\n    if (cap) {\n      return {\n        type: 'del',\n        raw: cap[0],\n        text: cap[2],\n        tokens: this.lexer.inlineTokens(cap[2]),\n      };\n    }\n  }\n\n  autolink(src: string): Tokens.Link | undefined {\n    const cap = this.rules.inline.autolink.exec(src);\n    if (cap) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = cap[1];\n        href = 'mailto:' + text;\n      } else {\n        text = cap[1];\n        href = text;\n      }\n\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text,\n          },\n        ],\n      };\n    }\n  }\n\n  url(src: string): Tokens.Link | undefined {\n    let cap;\n    if (cap = this.rules.inline.url.exec(src)) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = cap[0];\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        let prevCapZero;\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n        } while (prevCapZero !== cap[0]);\n        text = cap[0];\n        if (cap[1] === 'www.') {\n          href = 'http://' + cap[0];\n        } else {\n          href = cap[0];\n        }\n      }\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text,\n          },\n        ],\n      };\n    }\n  }\n\n  inlineText(src: string): Tokens.Text | undefined {\n    const cap = this.rules.inline.text.exec(src);\n    if (cap) {\n      const escaped = this.lexer.state.inRawBlock;\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        escaped,\n      };\n    }\n  }\n}\n", "import { _Tokenizer } from './Tokenizer.ts';\nimport { _defaults } from './defaults.ts';\nimport { other, block, inline } from './rules.ts';\nimport type { Token, TokensList, Tokens } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Block Lexer\n */\nexport class _Lexer<ParserOutput = string, RendererOutput = string> {\n  tokens: TokensList;\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  state: {\n    inLink: boolean;\n    inRawBlock: boolean;\n    top: boolean;\n  };\n\n  private tokenizer: _Tokenizer<ParserOutput, RendererOutput>;\n  private inlineQueue: { src: string, tokens: Token[] }[];\n\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    // TokenList cannot be created in one go\n    this.tokens = [] as unknown as TokensList;\n    this.tokens.links = Object.create(null);\n    this.options = options || _defaults;\n    this.options.tokenizer = this.options.tokenizer || new _Tokenizer<ParserOutput, RendererOutput>();\n    this.tokenizer = this.options.tokenizer;\n    this.tokenizer.options = this.options;\n    this.tokenizer.lexer = this;\n    this.inlineQueue = [];\n    this.state = {\n      inLink: false,\n      inRawBlock: false,\n      top: true,\n    };\n\n    const rules = {\n      other,\n      block: block.normal,\n      inline: inline.normal,\n    };\n\n    if (this.options.pedantic) {\n      rules.block = block.pedantic;\n      rules.inline = inline.pedantic;\n    } else if (this.options.gfm) {\n      rules.block = block.gfm;\n      if (this.options.breaks) {\n        rules.inline = inline.breaks;\n      } else {\n        rules.inline = inline.gfm;\n      }\n    }\n    this.tokenizer.rules = rules;\n  }\n\n  /**\n   * Expose Rules\n   */\n  static get rules() {\n    return {\n      block,\n      inline,\n    };\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex<ParserOutput = string, RendererOutput = string>(src: string, options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const lexer = new _Lexer<ParserOutput, RendererOutput>(options);\n    return lexer.lex(src);\n  }\n\n  /**\n   * Static Lex Inline Method\n   */\n  static lexInline<ParserOutput = string, RendererOutput = string>(src: string, options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const lexer = new _Lexer<ParserOutput, RendererOutput>(options);\n    return lexer.inlineTokens(src);\n  }\n\n  /**\n   * Preprocessing\n   */\n  lex(src: string) {\n    src = src.replace(other.carriageReturn, '\\n');\n\n    this.blockTokens(src, this.tokens);\n\n    for (let i = 0; i < this.inlineQueue.length; i++) {\n      const next = this.inlineQueue[i];\n      this.inlineTokens(next.src, next.tokens);\n    }\n    this.inlineQueue = [];\n\n    return this.tokens;\n  }\n\n  /**\n   * Lexing\n   */\n  blockTokens(src: string, tokens?: Token[], lastParagraphClipped?: boolean): Token[];\n  blockTokens(src: string, tokens?: TokensList, lastParagraphClipped?: boolean): TokensList;\n  blockTokens(src: string, tokens: Token[] = [], lastParagraphClipped = false) {\n    if (this.options.pedantic) {\n      src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');\n    }\n\n    while (src) {\n      let token: Tokens.Generic | undefined;\n\n      if (this.options.extensions?.block?.some((extTokenizer) => {\n        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          return true;\n        }\n        return false;\n      })) {\n        continue;\n      }\n\n      // newline\n      if (token = this.tokenizer.space(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (token.raw.length === 1 && lastToken !== undefined) {\n          // if there's a single \\n as a spacer, it's terminating the last line,\n          // so move it there so that we don't get unnecessary paragraph tags\n          lastToken.raw += '\\n';\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.code(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // fences\n      if (token = this.tokenizer.fences(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // heading\n      if (token = this.tokenizer.heading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // hr\n      if (token = this.tokenizer.hr(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // blockquote\n      if (token = this.tokenizer.blockquote(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // list\n      if (token = this.tokenizer.list(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // html\n      if (token = this.tokenizer.html(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // def\n      if (token = this.tokenizer.def(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.raw;\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else if (!this.tokens.links[token.tag]) {\n          this.tokens.links[token.tag] = {\n            href: token.href,\n            title: token.title,\n          };\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (token = this.tokenizer.table(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // lheading\n      if (token = this.tokenizer.lheading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // top-level paragraph\n      // prevent paragraph consuming extensions by clipping 'src' to extension start\n      let cutSrc = src;\n      if (this.options.extensions?.startBlock) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startBlock.forEach((getStartIndex) => {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) {\n            startIndex = Math.min(startIndex, tempStart);\n          }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n        const lastToken = tokens.at(-1);\n        if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        lastParagraphClipped = cutSrc.length !== src.length;\n        src = src.substring(token.raw.length);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.text(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'text') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    this.state.top = true;\n    return tokens;\n  }\n\n  inline(src: string, tokens: Token[] = []) {\n    this.inlineQueue.push({ src, tokens });\n    return tokens;\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  inlineTokens(src: string, tokens: Token[] = []): Token[] {\n    // String with links masked to avoid interference with em and strong\n    let maskedSrc = src;\n    let match: RegExpExecArray | null = null;\n\n    // Mask out reflinks\n    if (this.tokens.links) {\n      const links = Object.keys(this.tokens.links);\n      if (links.length > 0) {\n        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n            maskedSrc = maskedSrc.slice(0, match.index)\n              + '[' + 'a'.repeat(match[0].length - 2) + ']'\n              + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n          }\n        }\n      }\n    }\n\n    // Mask out escaped characters\n    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n    }\n\n    // Mask out other blocks\n    let offset;\n    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n      offset = match[2] ? match[2].length : 0;\n      maskedSrc = maskedSrc.slice(0, match.index + offset) + '[' + 'a'.repeat(match[0].length - offset - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n    }\n\n    // Mask out blocks from extensions\n    maskedSrc = this.options.hooks?.emStrongMask?.call({ lexer: this }, maskedSrc) ?? maskedSrc;\n\n    let keepPrevChar = false;\n    let prevChar = '';\n    while (src) {\n      if (!keepPrevChar) {\n        prevChar = '';\n      }\n      keepPrevChar = false;\n\n      let token: Tokens.Generic | undefined;\n\n      // extensions\n      if (this.options.extensions?.inline?.some((extTokenizer) => {\n        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          return true;\n        }\n        return false;\n      })) {\n        continue;\n      }\n\n      // escape\n      if (token = this.tokenizer.escape(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // tag\n      if (token = this.tokenizer.tag(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // link\n      if (token = this.tokenizer.link(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // reflink, nolink\n      if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (token.type === 'text' && lastToken?.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // em & strong\n      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.codespan(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // br\n      if (token = this.tokenizer.br(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // del (gfm)\n      if (token = this.tokenizer.del(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // autolink\n      if (token = this.tokenizer.autolink(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      // prevent inlineText consuming extensions by clipping 'src' to extension start\n      let cutSrc = src;\n      if (this.options.extensions?.startInline) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startInline.forEach((getStartIndex) => {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) {\n            startIndex = Math.min(startIndex, tempStart);\n          }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (token = this.tokenizer.inlineText(cutSrc)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n          prevChar = token.raw.slice(-1);\n        }\n        keepPrevChar = true;\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n}\n", "import { _defaults } from './defaults.ts';\nimport {\n  cleanUrl,\n  escape,\n} from './helpers.ts';\nimport { other } from './rules.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\nimport type { Tokens } from './Tokens.ts';\nimport type { _Parser } from './Parser.ts';\n\n/**\n * Renderer\n */\nexport class _Renderer<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  parser!: _Parser<ParserOutput, RendererOutput>; // set by the parser\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n  }\n\n  space(token: Tokens.Space): RendererOutput {\n    return '' as RendererOutput;\n  }\n\n  code({ text, lang, escaped }: Tokens.Code): RendererOutput {\n    const langString = (lang || '').match(other.notSpaceStart)?.[0];\n\n    const code = text.replace(other.endingNewline, '') + '\\n';\n\n    if (!langString) {\n      return '<pre><code>'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>\\n' as RendererOutput;\n    }\n\n    return '<pre><code class=\"language-'\n      + escape(langString)\n      + '\">'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>\\n' as RendererOutput;\n  }\n\n  blockquote({ tokens }: Tokens.Blockquote): RendererOutput {\n    const body = this.parser.parse(tokens);\n    return `<blockquote>\\n${body}</blockquote>\\n` as RendererOutput;\n  }\n\n  html({ text }: Tokens.HTML | Tokens.Tag): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  def(token: Tokens.Def): RendererOutput {\n    return '' as RendererOutput;\n  }\n\n  heading({ tokens, depth }: Tokens.Heading): RendererOutput {\n    return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n` as RendererOutput;\n  }\n\n  hr(token: Tokens.Hr): RendererOutput {\n    return '<hr>\\n' as RendererOutput;\n  }\n\n  list(token: Tokens.List): RendererOutput {\n    const ordered = token.ordered;\n    const start = token.start;\n\n    let body = '';\n    for (let j = 0; j < token.items.length; j++) {\n      const item = token.items[j];\n      body += this.listitem(item);\n    }\n\n    const type = ordered ? 'ol' : 'ul';\n    const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n    return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n' as RendererOutput;\n  }\n\n  listitem(item: Tokens.ListItem): RendererOutput {\n    let itemBody = '';\n    if (item.task) {\n      const checkbox = this.checkbox({ checked: !!item.checked });\n      if (item.loose) {\n        if (item.tokens[0]?.type === 'paragraph') {\n          item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n            item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);\n            item.tokens[0].tokens[0].escaped = true;\n          }\n        } else {\n          item.tokens.unshift({\n            type: 'text',\n            raw: checkbox + ' ',\n            text: checkbox + ' ',\n            escaped: true,\n          });\n        }\n      } else {\n        itemBody += checkbox + ' ';\n      }\n    }\n\n    itemBody += this.parser.parse(item.tokens, !!item.loose);\n\n    return `<li>${itemBody}</li>\\n` as RendererOutput;\n  }\n\n  checkbox({ checked }: Tokens.Checkbox): RendererOutput {\n    return '<input '\n      + (checked ? 'checked=\"\" ' : '')\n      + 'disabled=\"\" type=\"checkbox\">' as RendererOutput;\n  }\n\n  paragraph({ tokens }: Tokens.Paragraph): RendererOutput {\n    return `<p>${this.parser.parseInline(tokens)}</p>\\n` as RendererOutput;\n  }\n\n  table(token: Tokens.Table): RendererOutput {\n    let header = '';\n\n    // header\n    let cell = '';\n    for (let j = 0; j < token.header.length; j++) {\n      cell += this.tablecell(token.header[j]);\n    }\n    header += this.tablerow({ text: cell as ParserOutput });\n\n    let body = '';\n    for (let j = 0; j < token.rows.length; j++) {\n      const row = token.rows[j];\n\n      cell = '';\n      for (let k = 0; k < row.length; k++) {\n        cell += this.tablecell(row[k]);\n      }\n\n      body += this.tablerow({ text: cell as ParserOutput });\n    }\n    if (body) body = `<tbody>${body}</tbody>`;\n\n    return '<table>\\n'\n      + '<thead>\\n'\n      + header\n      + '</thead>\\n'\n      + body\n      + '</table>\\n' as RendererOutput;\n  }\n\n  tablerow({ text }: Tokens.TableRow<ParserOutput>): RendererOutput {\n    return `<tr>\\n${text}</tr>\\n` as RendererOutput;\n  }\n\n  tablecell(token: Tokens.TableCell): RendererOutput {\n    const content = this.parser.parseInline(token.tokens);\n    const type = token.header ? 'th' : 'td';\n    const tag = token.align\n      ? `<${type} align=\"${token.align}\">`\n      : `<${type}>`;\n    return tag + content + `</${type}>\\n` as RendererOutput;\n  }\n\n  /**\n   * span level renderer\n   */\n  strong({ tokens }: Tokens.Strong): RendererOutput {\n    return `<strong>${this.parser.parseInline(tokens)}</strong>` as RendererOutput;\n  }\n\n  em({ tokens }: Tokens.Em): RendererOutput {\n    return `<em>${this.parser.parseInline(tokens)}</em>` as RendererOutput;\n  }\n\n  codespan({ text }: Tokens.Codespan): RendererOutput {\n    return `<code>${escape(text, true)}</code>` as RendererOutput;\n  }\n\n  br(token: Tokens.Br): RendererOutput {\n    return '<br>' as RendererOutput;\n  }\n\n  del({ tokens }: Tokens.Del): RendererOutput {\n    return `<del>${this.parser.parseInline(tokens)}</del>` as RendererOutput;\n  }\n\n  link({ href, title, tokens }: Tokens.Link): RendererOutput {\n    const text = this.parser.parseInline(tokens) as string;\n    const cleanHref = cleanUrl(href);\n    if (cleanHref === null) {\n      return text as RendererOutput;\n    }\n    href = cleanHref;\n    let out = '<a href=\"' + href + '\"';\n    if (title) {\n      out += ' title=\"' + (escape(title)) + '\"';\n    }\n    out += '>' + text + '</a>';\n    return out as RendererOutput;\n  }\n\n  image({ href, title, text, tokens }: Tokens.Image): RendererOutput {\n    if (tokens) {\n      text = this.parser.parseInline(tokens, this.parser.textRenderer) as string;\n    }\n    const cleanHref = cleanUrl(href);\n    if (cleanHref === null) {\n      return escape(text) as RendererOutput;\n    }\n    href = cleanHref;\n\n    let out = `<img src=\"${href}\" alt=\"${text}\"`;\n    if (title) {\n      out += ` title=\"${escape(title)}\"`;\n    }\n    out += '>';\n    return out as RendererOutput;\n  }\n\n  text(token: Tokens.Text | Tokens.Escape): RendererOutput {\n    return 'tokens' in token && token.tokens\n      ? this.parser.parseInline(token.tokens) as unknown as RendererOutput\n      : ('escaped' in token && token.escaped ? token.text as RendererOutput : escape(token.text) as RendererOutput);\n  }\n}\n", "import type { Tokens } from './Tokens.ts';\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nexport class _TextRenderer<RendererOutput = string> {\n  // no need for block level renderers\n  strong({ text }: Tokens.Strong): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  em({ text }: Tokens.Em): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  codespan({ text }: Tokens.Codespan): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  del({ text }: Tokens.Del): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  html({ text }: Tokens.HTML | Tokens.Tag): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  text({ text }: Tokens.Text | Tokens.Escape | Tokens.Tag): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  link({ text }: Tokens.Link): RendererOutput {\n    return '' + text as RendererOutput;\n  }\n\n  image({ text }: Tokens.Image): RendererOutput {\n    return '' + text as RendererOutput;\n  }\n\n  br(): RendererOutput {\n    return '' as RendererOutput;\n  }\n}\n", "import { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _defaults } from './defaults.ts';\nimport type { MarkedToken, Token, Tokens } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Parsing & Compiling\n */\nexport class _Parser<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  renderer: _Renderer<ParserOutput, RendererOutput>;\n  textRenderer: _TextRenderer<RendererOutput>;\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n    this.options.renderer = this.options.renderer || new _Renderer<ParserOutput, RendererOutput>();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.renderer.parser = this;\n    this.textRenderer = new _TextRenderer<RendererOutput>();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse<ParserOutput = string, RendererOutput = string>(tokens: Token[], options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const parser = new _Parser<ParserOutput, RendererOutput>(options);\n    return parser.parse(tokens);\n  }\n\n  /**\n   * Static Parse Inline Method\n   */\n  static parseInline<ParserOutput = string, RendererOutput = string>(tokens: Token[], options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const parser = new _Parser<ParserOutput, RendererOutput>(options);\n    return parser.parseInline(tokens);\n  }\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens: Token[], top = true): ParserOutput {\n    let out = '';\n\n    for (let i = 0; i < tokens.length; i++) {\n      const anyToken = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions?.renderers?.[anyToken.type]) {\n        const genericToken = anyToken as Tokens.Generic;\n        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'def', 'paragraph', 'text'].includes(genericToken.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      const token = anyToken as MarkedToken;\n\n      switch (token.type) {\n        case 'space': {\n          out += this.renderer.space(token);\n          continue;\n        }\n        case 'hr': {\n          out += this.renderer.hr(token);\n          continue;\n        }\n        case 'heading': {\n          out += this.renderer.heading(token);\n          continue;\n        }\n        case 'code': {\n          out += this.renderer.code(token);\n          continue;\n        }\n        case 'table': {\n          out += this.renderer.table(token);\n          continue;\n        }\n        case 'blockquote': {\n          out += this.renderer.blockquote(token);\n          continue;\n        }\n        case 'list': {\n          out += this.renderer.list(token);\n          continue;\n        }\n        case 'html': {\n          out += this.renderer.html(token);\n          continue;\n        }\n        case 'def': {\n          out += this.renderer.def(token);\n          continue;\n        }\n        case 'paragraph': {\n          out += this.renderer.paragraph(token);\n          continue;\n        }\n        case 'text': {\n          let textToken = token;\n          let body = this.renderer.text(textToken) as string;\n          while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n            textToken = tokens[++i] as Tokens.Text;\n            body += ('\\n' + this.renderer.text(textToken));\n          }\n          if (top) {\n            out += this.renderer.paragraph({\n              type: 'paragraph',\n              raw: body,\n              text: body,\n              tokens: [{ type: 'text', raw: body, text: body, escaped: true }],\n            });\n          } else {\n            out += body;\n          }\n          continue;\n        }\n\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return '' as ParserOutput;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n\n    return out as ParserOutput;\n  }\n\n  /**\n   * Parse Inline Tokens\n   */\n  parseInline(tokens: Token[], renderer: _Renderer<ParserOutput, RendererOutput> | _TextRenderer<RendererOutput> = this.renderer): ParserOutput {\n    let out = '';\n\n    for (let i = 0; i < tokens.length; i++) {\n      const anyToken = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions?.renderers?.[anyToken.type]) {\n        const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      const token = anyToken as MarkedToken;\n\n      switch (token.type) {\n        case 'escape': {\n          out += renderer.text(token);\n          break;\n        }\n        case 'html': {\n          out += renderer.html(token);\n          break;\n        }\n        case 'link': {\n          out += renderer.link(token);\n          break;\n        }\n        case 'image': {\n          out += renderer.image(token);\n          break;\n        }\n        case 'strong': {\n          out += renderer.strong(token);\n          break;\n        }\n        case 'em': {\n          out += renderer.em(token);\n          break;\n        }\n        case 'codespan': {\n          out += renderer.codespan(token);\n          break;\n        }\n        case 'br': {\n          out += renderer.br(token);\n          break;\n        }\n        case 'del': {\n          out += renderer.del(token);\n          break;\n        }\n        case 'text': {\n          out += renderer.text(token);\n          break;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return '' as ParserOutput;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n    return out as ParserOutput;\n  }\n}\n", "import { _defaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, TokensList } from './Tokens.ts';\n\nexport class _Hooks<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  block?: boolean;\n\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n  }\n\n  static passThroughHooks = new Set([\n    'preprocess',\n    'postprocess',\n    'processAllTokens',\n    'emStrongMask',\n  ]);\n\n  static passThroughHooksRespectAsync = new Set([\n    'preprocess',\n    'postprocess',\n    'processAllTokens',\n  ]);\n\n  /**\n   * Process markdown before marked\n   */\n  preprocess(markdown: string) {\n    return markdown;\n  }\n\n  /**\n   * Process HTML after marked is finished\n   */\n  postprocess(html: ParserOutput) {\n    return html;\n  }\n\n  /**\n   * Process all tokens before walk tokens\n   */\n  processAllTokens(tokens: Token[] | TokensList) {\n    return tokens;\n  }\n\n  /**\n   * Mask contents that should not be interpreted as em/strong delimiters\n   */\n  emStrongMask(src: string) {\n    return src;\n  }\n\n  /**\n   * Provide function to tokenize markdown\n   */\n  provideLexer() {\n    return this.block ? _Lexer.lex : _Lexer.lexInline;\n  }\n\n  /**\n   * Provide function to parse tokens\n   */\n  provideParser() {\n    return this.block ? _Parser.parse<ParserOutput, RendererOutput> : _Parser.parseInline<ParserOutput, RendererOutput>;\n  }\n}\n", "import { _getDefaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { escape } from './helpers.ts';\nimport type { MarkedExtension, MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, Tokens, TokensList } from './Tokens.ts';\n\nexport type MaybePromise = void | Promise<void>;\n\ntype UnknownFunction = (...args: unknown[]) => unknown;\ntype GenericRendererFunction = (...args: unknown[]) => string | false;\n\nexport class Marked<ParserOutput = string, RendererOutput = string> {\n  defaults = _getDefaults<ParserOutput, RendererOutput>();\n  options = this.setOptions;\n\n  parse = this.parseMarkdown(true);\n  parseInline = this.parseMarkdown(false);\n\n  Parser = _Parser<ParserOutput, RendererOutput>;\n  Renderer = _Renderer<ParserOutput, RendererOutput>;\n  TextRenderer = _TextRenderer<RendererOutput>;\n  Lexer = _Lexer;\n  Tokenizer = _Tokenizer<ParserOutput, RendererOutput>;\n  Hooks = _Hooks<ParserOutput, RendererOutput>;\n\n  constructor(...args: MarkedExtension<ParserOutput, RendererOutput>[]) {\n    this.use(...args);\n  }\n\n  /**\n   * Run callback for every token\n   */\n  walkTokens(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n    let values: MaybePromise[] = [];\n    for (const token of tokens) {\n      values = values.concat(callback.call(this, token));\n      switch (token.type) {\n        case 'table': {\n          const tableToken = token as Tokens.Table;\n          for (const cell of tableToken.header) {\n            values = values.concat(this.walkTokens(cell.tokens, callback));\n          }\n          for (const row of tableToken.rows) {\n            for (const cell of row) {\n              values = values.concat(this.walkTokens(cell.tokens, callback));\n            }\n          }\n          break;\n        }\n        case 'list': {\n          const listToken = token as Tokens.List;\n          values = values.concat(this.walkTokens(listToken.items, callback));\n          break;\n        }\n        default: {\n          const genericToken = token as Tokens.Generic;\n          if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n              const tokens = genericToken[childTokens].flat(Infinity) as Token[] | TokensList;\n              values = values.concat(this.walkTokens(tokens, callback));\n            });\n          } else if (genericToken.tokens) {\n            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n          }\n        }\n      }\n    }\n    return values;\n  }\n\n  use(...args: MarkedExtension<ParserOutput, RendererOutput>[]) {\n    const extensions: MarkedOptions<ParserOutput, RendererOutput>['extensions'] = this.defaults.extensions || { renderers: {}, childTokens: {} };\n\n    args.forEach((pack) => {\n      // copy options to new object\n      const opts = { ...pack } as MarkedOptions<ParserOutput, RendererOutput>;\n\n      // set async to true if it was set to true before\n      opts.async = this.defaults.async || opts.async || false;\n\n      // ==-- Parse \"addon\" extensions --== //\n      if (pack.extensions) {\n        pack.extensions.forEach((ext) => {\n          if (!ext.name) {\n            throw new Error('extension name required');\n          }\n          if ('renderer' in ext) { // Renderer extensions\n            const prevRenderer = extensions.renderers[ext.name];\n            if (prevRenderer) {\n              // Replace extension with func to run new extension but fall back if false\n              extensions.renderers[ext.name] = function(...args) {\n                let ret = ext.renderer.apply(this, args);\n                if (ret === false) {\n                  ret = prevRenderer.apply(this, args);\n                }\n                return ret;\n              };\n            } else {\n              extensions.renderers[ext.name] = ext.renderer;\n            }\n          }\n          if ('tokenizer' in ext) { // Tokenizer Extensions\n            if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n              throw new Error(\"extension level must be 'block' or 'inline'\");\n            }\n            const extLevel = extensions[ext.level];\n            if (extLevel) {\n              extLevel.unshift(ext.tokenizer);\n            } else {\n              extensions[ext.level] = [ext.tokenizer];\n            }\n            if (ext.start) { // Function to check for start of token\n              if (ext.level === 'block') {\n                if (extensions.startBlock) {\n                  extensions.startBlock.push(ext.start);\n                } else {\n                  extensions.startBlock = [ext.start];\n                }\n              } else if (ext.level === 'inline') {\n                if (extensions.startInline) {\n                  extensions.startInline.push(ext.start);\n                } else {\n                  extensions.startInline = [ext.start];\n                }\n              }\n            }\n          }\n          if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n            extensions.childTokens[ext.name] = ext.childTokens;\n          }\n        });\n        opts.extensions = extensions;\n      }\n\n      // ==-- Parse \"overwrite\" extensions --== //\n      if (pack.renderer) {\n        const renderer = this.defaults.renderer || new _Renderer<ParserOutput, RendererOutput>(this.defaults);\n        for (const prop in pack.renderer) {\n          if (!(prop in renderer)) {\n            throw new Error(`renderer '${prop}' does not exist`);\n          }\n          if (['options', 'parser'].includes(prop)) {\n            // ignore options property\n            continue;\n          }\n          const rendererProp = prop as Exclude<keyof _Renderer<ParserOutput, RendererOutput>, 'options' | 'parser'>;\n          const rendererFunc = pack.renderer[rendererProp] as GenericRendererFunction;\n          const prevRenderer = renderer[rendererProp] as GenericRendererFunction;\n          // Replace renderer with func to run extension, but fall back if false\n          renderer[rendererProp] = (...args: unknown[]) => {\n            let ret = rendererFunc.apply(renderer, args);\n            if (ret === false) {\n              ret = prevRenderer.apply(renderer, args);\n            }\n            return (ret || '') as RendererOutput;\n          };\n        }\n        opts.renderer = renderer;\n      }\n      if (pack.tokenizer) {\n        const tokenizer = this.defaults.tokenizer || new _Tokenizer<ParserOutput, RendererOutput>(this.defaults);\n        for (const prop in pack.tokenizer) {\n          if (!(prop in tokenizer)) {\n            throw new Error(`tokenizer '${prop}' does not exist`);\n          }\n          if (['options', 'rules', 'lexer'].includes(prop)) {\n            // ignore options, rules, and lexer properties\n            continue;\n          }\n          const tokenizerProp = prop as Exclude<keyof _Tokenizer<ParserOutput, RendererOutput>, 'options' | 'rules' | 'lexer'>;\n          const tokenizerFunc = pack.tokenizer[tokenizerProp] as UnknownFunction;\n          const prevTokenizer = tokenizer[tokenizerProp] as UnknownFunction;\n          // Replace tokenizer with func to run extension, but fall back if false\n          // @ts-expect-error cannot type tokenizer function dynamically\n          tokenizer[tokenizerProp] = (...args: unknown[]) => {\n            let ret = tokenizerFunc.apply(tokenizer, args);\n            if (ret === false) {\n              ret = prevTokenizer.apply(tokenizer, args);\n            }\n            return ret;\n          };\n        }\n        opts.tokenizer = tokenizer;\n      }\n\n      // ==-- Parse Hooks extensions --== //\n      if (pack.hooks) {\n        const hooks = this.defaults.hooks || new _Hooks<ParserOutput, RendererOutput>();\n        for (const prop in pack.hooks) {\n          if (!(prop in hooks)) {\n            throw new Error(`hook '${prop}' does not exist`);\n          }\n          if (['options', 'block'].includes(prop)) {\n            // ignore options and block properties\n            continue;\n          }\n          const hooksProp = prop as Exclude<keyof _Hooks<ParserOutput, RendererOutput>, 'options' | 'block'>;\n          const hooksFunc = pack.hooks[hooksProp] as UnknownFunction;\n          const prevHook = hooks[hooksProp] as UnknownFunction;\n          if (_Hooks.passThroughHooks.has(prop)) {\n            // @ts-expect-error cannot type hook function dynamically\n            hooks[hooksProp] = (arg: unknown) => {\n              if (this.defaults.async && _Hooks.passThroughHooksRespectAsync.has(prop)) {\n                return (async() => {\n                  const ret = await hooksFunc.call(hooks, arg);\n                  return prevHook.call(hooks, ret);\n                })();\n              }\n\n              const ret = hooksFunc.call(hooks, arg);\n              return prevHook.call(hooks, ret);\n            };\n          } else {\n            // @ts-expect-error cannot type hook function dynamically\n            hooks[hooksProp] = (...args: unknown[]) => {\n              if (this.defaults.async) {\n                return (async() => {\n                  let ret = await hooksFunc.apply(hooks, args);\n                  if (ret === false) {\n                    ret = await prevHook.apply(hooks, args);\n                  }\n                  return ret;\n                })();\n              }\n\n              let ret = hooksFunc.apply(hooks, args);\n              if (ret === false) {\n                ret = prevHook.apply(hooks, args);\n              }\n              return ret;\n            };\n          }\n        }\n        opts.hooks = hooks;\n      }\n\n      // ==-- Parse WalkTokens extensions --== //\n      if (pack.walkTokens) {\n        const walkTokens = this.defaults.walkTokens;\n        const packWalktokens = pack.walkTokens;\n        opts.walkTokens = function(token) {\n          let values: MaybePromise[] = [];\n          values.push(packWalktokens.call(this, token));\n          if (walkTokens) {\n            values = values.concat(walkTokens.call(this, token));\n          }\n          return values;\n        };\n      }\n\n      this.defaults = { ...this.defaults, ...opts };\n    });\n\n    return this;\n  }\n\n  setOptions(opt: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.defaults = { ...this.defaults, ...opt };\n    return this;\n  }\n\n  lexer(src: string, options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    return _Lexer.lex(src, options ?? this.defaults);\n  }\n\n  parser(tokens: Token[], options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    return _Parser.parse<ParserOutput, RendererOutput>(tokens, options ?? this.defaults);\n  }\n\n  private parseMarkdown(blockType: boolean) {\n    type overloadedParse = {\n      (src: string, options: MarkedOptions<ParserOutput, RendererOutput> & { async: true }): Promise<ParserOutput>;\n      (src: string, options: MarkedOptions<ParserOutput, RendererOutput> & { async: false }): ParserOutput;\n      (src: string, options?: MarkedOptions<ParserOutput, RendererOutput> | null): ParserOutput | Promise<ParserOutput>;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const parse: overloadedParse = (src: string, options?: MarkedOptions<ParserOutput, RendererOutput> | null): any => {\n      const origOpt = { ...options };\n      const opt = { ...this.defaults, ...origOpt };\n\n      const throwError = this.onError(!!opt.silent, !!opt.async);\n\n      // throw error if an extension set async to true but parse was called with async: false\n      if (this.defaults.async === true && origOpt.async === false) {\n        return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n      }\n\n      // throw error in case of non string input\n      if (typeof src === 'undefined' || src === null) {\n        return throwError(new Error('marked(): input parameter is undefined or null'));\n      }\n      if (typeof src !== 'string') {\n        return throwError(new Error('marked(): input parameter is of type '\n          + Object.prototype.toString.call(src) + ', string expected'));\n      }\n\n      if (opt.hooks) {\n        opt.hooks.options = opt;\n        opt.hooks.block = blockType;\n      }\n\n      if (opt.async) {\n        return (async() => {\n          const processedSrc = opt.hooks ? await opt.hooks.preprocess(src) : src;\n          const lexer = opt.hooks ? await opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n          const tokens = await lexer(processedSrc, opt);\n          const processedTokens = opt.hooks ? await opt.hooks.processAllTokens(tokens) : tokens;\n          if (opt.walkTokens) {\n            await Promise.all(this.walkTokens(processedTokens, opt.walkTokens));\n          }\n          const parser = opt.hooks ? await opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n          const html = await parser(processedTokens, opt);\n          return opt.hooks ? await opt.hooks.postprocess(html) : html;\n        })().catch(throwError);\n      }\n\n      try {\n        if (opt.hooks) {\n          src = opt.hooks.preprocess(src) as string;\n        }\n        const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n        let tokens = lexer(src, opt);\n        if (opt.hooks) {\n          tokens = opt.hooks.processAllTokens(tokens);\n        }\n        if (opt.walkTokens) {\n          this.walkTokens(tokens, opt.walkTokens);\n        }\n        const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n        let html = parser(tokens, opt);\n        if (opt.hooks) {\n          html = opt.hooks.postprocess(html);\n        }\n        return html;\n      } catch(e) {\n        return throwError(e as Error);\n      }\n    };\n\n    return parse;\n  }\n\n  private onError(silent: boolean, async: boolean) {\n    return (e: Error): string | Promise<string> => {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (silent) {\n        const msg = '<p>An error occurred:</p><pre>'\n          + escape(e.message + '', true)\n          + '</pre>';\n        if (async) {\n          return Promise.resolve(msg);\n        }\n        return msg;\n      }\n\n      if (async) {\n        return Promise.reject(e);\n      }\n      throw e;\n    };\n  }\n}\n", "import { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { Marked } from './Instance.ts';\nimport {\n  _getDefaults,\n  changeDefaults,\n  _defaults,\n} from './defaults.ts';\nimport type { MarkedExtension, MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, TokensList } from './Tokens.ts';\nimport type { MaybePromise } from './Instance.ts';\n\nconst markedInstance = new Marked();\n\n/**\n * Compiles markdown to HTML asynchronously.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options, having async: true\n * @return Promise of string of compiled HTML\n */\nexport function marked(src: string, options: MarkedOptions & { async: true }): Promise<string>;\n\n/**\n * Compiles markdown to HTML.\n *\n * @param src String of markdown source to be compiled\n * @param options Optional hash of options\n * @return String of compiled HTML. Will be a Promise of string if async is set to true by any extensions.\n */\nexport function marked(src: string, options: MarkedOptions & { async: false }): string;\nexport function marked(src: string, options: MarkedOptions & { async: true }): Promise<string>;\nexport function marked(src: string, options?: MarkedOptions | null): string | Promise<string>;\nexport function marked(src: string, opt?: MarkedOptions | null): string | Promise<string> {\n  return markedInstance.parse(src, opt);\n}\n\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\nmarked.setOptions = function(options: MarkedOptions) {\n  markedInstance.setOptions(options);\n  marked.defaults = markedInstance.defaults;\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\n\nmarked.defaults = _defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function(...args: MarkedExtension[]) {\n  markedInstance.use(...args);\n  marked.defaults = markedInstance.defaults;\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n  return markedInstance.walkTokens(tokens, callback);\n};\n\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\n\nexport const options = marked.options;\nexport const setOptions = marked.setOptions;\nexport const use = marked.use;\nexport const walkTokens = marked.walkTokens;\nexport const parseInline = marked.parseInline;\nexport const parse = marked;\nexport const parser = _Parser.parse;\nexport const lexer = _Lexer.lex;\nexport { _defaults as defaults, _getDefaults as getDefaults } from './defaults.ts';\nexport { _Lexer as Lexer } from './Lexer.ts';\nexport { _Parser as Parser } from './Parser.ts';\nexport { _Tokenizer as Tokenizer } from './Tokenizer.ts';\nexport { _Renderer as Renderer } from './Renderer.ts';\nexport { _TextRenderer as TextRenderer } from './TextRenderer.ts';\nexport { _Hooks as Hooks } from './Hooks.ts';\nexport { Marked } from './Instance.ts';\nexport type * from './MarkedOptions.ts';\nexport type * from './Tokens.ts';\n", "/**\n * @license\n * Copyright (c) 2000 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport DOMPurify from 'dompurify';\nimport { marked } from 'marked';\n\n/**\n * Synchronizes the attributes of a target element with those of a source element.\n */\nfunction synchronizeAttributes(targetElement, sourceElement) {\n  // Remove attributes from target that are not in source\n  for (const { name } of targetElement.attributes) {\n    if (!sourceElement.hasAttribute(name)) {\n      targetElement.removeAttribute(name);\n    }\n  }\n\n  // Add/update attributes from source to target\n  for (const { name, value } of sourceElement.attributes) {\n    targetElement.setAttribute(name, value);\n  }\n}\n\n/**\n * Synchronizes the child nodes of a target node with those of a source node.\n * It handles the addition, removal, and updating of child nodes.\n */\nfunction synchronizeNodes(targetNode, sourceNode) {\n  const sourceChildren = Array.from(sourceNode.childNodes);\n  const targetChildren = Array.from(targetNode.childNodes);\n  const maxChildren = Math.max(sourceChildren.length, targetChildren.length);\n\n  for (let i = 0; i < maxChildren; i++) {\n    const sourceChild = sourceChildren[i];\n    const targetChild = targetChildren[i];\n\n    // 1. If source child exists but target child doesn't, append source child clone\n    if (sourceChild && !targetChild) {\n      targetNode.appendChild(sourceChild.cloneNode(true));\n      continue;\n    }\n\n    // 2. If target child exists but source child doesn't, remove target child\n    if (!sourceChild && targetChild) {\n      targetNode.removeChild(targetChild);\n      continue;\n    }\n\n    // 3. If both exist, compare them\n    if (sourceChild && targetChild) {\n      // 3a. Different node types or tag names: replace target with source clone\n      if (sourceChild.nodeType !== targetChild.nodeType || sourceChild.nodeName !== targetChild.nodeName) {\n        targetNode.replaceChild(sourceChild.cloneNode(true), targetChild);\n        continue;\n      }\n\n      // 3b. Same node type\n      if (sourceChild.nodeType === Node.ELEMENT_NODE) {\n        // Synchronize attributes\n        synchronizeAttributes(targetChild, sourceChild);\n\n        // Recursively synchronize children\n        synchronizeNodes(targetChild, sourceChild);\n      } else if (sourceChild.nodeType === Node.TEXT_NODE) {\n        // Update text content if different\n        if (targetChild.nodeValue !== sourceChild.nodeValue) {\n          targetChild.nodeValue = sourceChild.nodeValue;\n        }\n      }\n      // Other node types (like comments) are ignored for synchronization\n    }\n  }\n}\n\n/**\n * Updates the content of a target element with the given Markdown parsed as HTML.\n */\nexport function renderMarkdownToElement(element, markdown) {\n  const template = document.createElement('template');\n  template.innerHTML = DOMPurify.sanitize(marked.parse(markdown || ''), {\n    CUSTOM_ELEMENT_HANDLING: {\n      tagNameCheck: (_tagName) => true,\n    },\n  });\n  synchronizeNodes(element, template.content);\n}\n"],
  "mappings": "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CA,OACA,QACA,MACA,YACA,UACA,UACA,KACA,WACA,OACA,YACA,KACA,MACA,MACA,QACA,KACA,QACA,UACA,WACA,UACA,UACA,QACA,SACA,UACA,UACA,QACA,UACA,UACA,SACA,OACA,WACA,OACA,SACA,SACA,MACA,YACA,YACA,SACA,MACA,SACA,QACA,MACA,SACA,MACA,KACA,MACA,OACA,SACA,KAAK,CACG;AAEH,IAAM+E,QAAM/E,OAAO,CACxB,OACA,KACA,YACA,eACA,gBACA,gBACA,iBACA,oBACA,UACA,YACA,QACA,QACA,WACA,gBACA,eACA,UACA,QACA,KACA,SACA,YACA,SACA,SACA,aACA,QACA,kBACA,UACA,QACA,YACA,SACA,QACA,QACA,WACA,WACA,YACA,kBACA,QACA,QACA,SACA,UACA,UACA,QACA,YACA,SACA,QACA,SACA,QACA,OAAO,CACC;AAEH,IAAMgF,aAAahF,OAAO,CAC/B,WACA,iBACA,uBACA,eACA,oBACA,qBACA,qBACA,kBACA,gBACA,WACA,WACA,WACA,WACA,WACA,kBACA,WACA,WACA,eACA,gBACA,YACA,gBACA,sBACA,eACA,UACA,cAAc,CACN;AAMH,IAAMiF,gBAAgBjF,OAAO,CAClC,WACA,iBACA,UACA,WACA,aACA,oBACA,kBACA,iBACA,iBACA,iBACA,SACA,aACA,QACA,gBACA,aACA,WACA,iBACA,UACA,OACA,cACA,WACA,KAAK,CACG;AAEH,IAAMkF,WAASlF,OAAO,CAC3B,QACA,YACA,UACA,WACA,SACA,UACA,MACA,cACA,iBACA,MACA,MACA,SACA,WACA,YACA,SACA,QACA,MACA,UACA,SACA,UACA,QACA,QACA,WACA,UACA,OACA,SACA,OACA,UACA,cACA,aAAa,CACL;AAIH,IAAMmF,mBAAmBnF,OAAO,CACrC,WACA,eACA,cACA,YACA,aACA,WACA,WACA,UACA,UACA,SACA,aACA,cACA,kBACA,eACA,MAAM,CACE;AAEH,IAAMoF,OAAOpF,OAAO,CAAC,OAAO,CAAU;AC1RtC,IAAM8E,OAAO9E,OAAO,CACzB,UACA,UACA,SACA,OACA,kBACA,gBACA,wBACA,YACA,cACA,WACA,UACA,WACA,eACA,eACA,WACA,QACA,SACA,SACA,SACA,QACA,WACA,YACA,gBACA,UACA,eACA,YACA,YACA,WACA,OACA,YACA,2BACA,yBACA,YACA,aACA,WACA,gBACA,eACA,QACA,OACA,WACA,UACA,UACA,QACA,QACA,YACA,MACA,SACA,aACA,aACA,SACA,QACA,SACA,QACA,QACA,WACA,QACA,OACA,OACA,aACA,SACA,UACA,OACA,aACA,YACA,SACA,QACA,SACA,WACA,cACA,UACA,QACA,WACA,QACA,WACA,eACA,eACA,WACA,iBACA,uBACA,UACA,WACA,WACA,cACA,YACA,OACA,YACA,OACA,YACA,QACA,QACA,WACA,cACA,SACA,YACA,SACA,QACA,SACA,QACA,QACA,WACA,SACA,OACA,UACA,QACA,SACA,WACA,YACA,SACA,aACA,QACA,UACA,UACA,SACA,SACA,QACA,SACA,MAAM,CACE;AAEH,IAAM+E,MAAM/E,OAAO,CACxB,iBACA,cACA,YACA,sBACA,aACA,UACA,iBACA,iBACA,WACA,iBACA,kBACA,SACA,QACA,MACA,SACA,QACA,iBACA,aACA,aACA,SACA,uBACA,+BACA,iBACA,mBACA,MACA,MACA,KACA,MACA,MACA,mBACA,aACA,WACA,WACA,OACA,YACA,aACA,OACA,YACA,QACA,gBACA,aACA,UACA,eACA,eACA,iBACA,eACA,aACA,oBACA,gBACA,cACA,gBACA,eACA,MACA,MACA,MACA,MACA,cACA,YACA,iBACA,qBACA,UACA,QACA,MACA,mBACA,MACA,OACA,aACA,KACA,MACA,MACA,MACA,MACA,WACA,aACA,cACA,YACA,QACA,gBACA,kBACA,gBACA,oBACA,kBACA,SACA,cACA,cACA,gBACA,gBACA,eACA,eACA,oBACA,aACA,OACA,QACA,aACA,SACA,UACA,QACA,OACA,QACA,cACA,UACA,YACA,WACA,SACA,UACA,eACA,UACA,YACA,eACA,QACA,cACA,uBACA,oBACA,gBACA,UACA,iBACA,uBACA,kBACA,KACA,MACA,MACA,UACA,QACA,QACA,eACA,aACA,WACA,UACA,UACA,SACA,QACA,mBACA,SACA,oBACA,oBACA,gBACA,eACA,gBACA,eACA,cACA,gBACA,oBACA,qBACA,kBACA,mBACA,qBACA,kBACA,UACA,gBACA,SACA,gBACA,kBACA,YACA,eACA,WACA,WACA,aACA,oBACA,eACA,mBACA,kBACA,cACA,QACA,MACA,MACA,WACA,UACA,WACA,cACA,WACA,cACA,iBACA,iBACA,SACA,gBACA,QACA,gBACA,oBACA,oBACA,KACA,MACA,MACA,SACA,KACA,MACA,MACA,KACA,YAAY,CACJ;AAEH,IAAMkF,SAASlF,OAAO,CAC3B,UACA,eACA,SACA,YACA,SACA,gBACA,eACA,cACA,cACA,SACA,OACA,WACA,gBACA,YACA,SACA,SACA,UACA,QACA,MACA,WACA,UACA,iBACA,UACA,UACA,kBACA,aACA,YACA,eACA,WACA,WACA,iBACA,YACA,YACA,QACA,YACA,YACA,cACA,WACA,UACA,UACA,eACA,iBACA,wBACA,aACA,aACA,cACA,YACA,kBACA,kBACA,aACA,WACA,SACA,OAAO,CACR;AAEM,IAAMqF,MAAMrF,OAAO,CACxB,cACA,UACA,eACA,aACA,aAAa,CACL;ACpXH,IAAMsF,gBAAgBrF,KAAK,2BAA2B;AACtD,IAAMsF,WAAWtF,KAAK,uBAAuB;AAC7C,IAAMuF,cAAcvF,KAAK,eAAe;AACxC,IAAMwF,YAAYxF,KAAK,8BAA8B;AACrD,IAAMyF,YAAYzF,KAAK,gBAAgB;AACvC,IAAM0F,iBAAiB1F;EAC5B;;;AAEK,IAAM2F,oBAAoB3F,KAAK,uBAAuB;AACtD,IAAM4F,kBAAkB5F;EAC7B;;;AAEK,IAAM6F,eAAe7F,KAAK,SAAS;AACnC,IAAM8F,iBAAiB9F,KAAK,0BAA0B;;;;;;;;;;;;;;ACmB7D,IAAM+F,YAAY;EAChBnC,SAAS;EACToC,WAAW;EACXb,MAAM;EACNc,cAAc;EACdC,iBAAiB;;EACjBC,YAAY;;EACZC,wBAAwB;EACxBC,SAAS;EACTC,UAAU;EACVC,cAAc;EACdC,kBAAkB;EAClBC,UAAU;;;AAGZ,IAAMC,YAAY,SAAZA,aAAY;AAChB,SAAO,OAAOC,WAAW,cAAc,OAAOA;AAChD;AAUA,IAAMC,4BAA4B,SAA5BA,2BACJC,cACAC,mBAAoC;AAEpC,MACE,OAAOD,iBAAiB,YACxB,OAAOA,aAAaE,iBAAiB,YACrC;AACA,WAAO;EACT;AAKA,MAAIC,SAAS;AACb,QAAMC,YAAY;AAClB,MAAIH,qBAAqBA,kBAAkBI,aAAaD,SAAS,GAAG;AAClED,aAASF,kBAAkBK,aAAaF,SAAS;EACnD;AAEA,QAAMG,aAAa,eAAeJ,SAAS,MAAMA,SAAS;AAE1D,MAAI;AACF,WAAOH,aAAaE,aAAaK,YAAY;MAC3CC,WAAWxC,OAAI;AACb,eAAOA;;MAETyC,gBAAgBC,WAAS;AACvB,eAAOA;MACT;IACD,CAAA;WACMC,IAAG;AAIVC,YAAQC,KACN,yBAAyBN,aAAa,wBAAwB;AAEhE,WAAO;EACT;AACF;AAEA,IAAMO,kBAAkB,SAAlBA,mBAAkB;AACtB,SAAO;IACLC,yBAAyB,CAAA;IACzBC,uBAAuB,CAAA;IACvBC,wBAAwB,CAAA;IACxBC,0BAA0B,CAAA;IAC1BC,wBAAwB,CAAA;IACxBC,yBAAyB,CAAA;IACzBC,uBAAuB,CAAA;IACvBC,qBAAqB,CAAA;IACrBC,wBAAwB,CAAA;;AAE5B;AAEA,SAASC,kBAAgD;AAAA,MAAhC1B,UAAqBlG,UAAAC,SAAAD,KAAAA,UAAA6H,CAAAA,MAAAA,SAAA7H,UAAAiG,CAAAA,IAAAA,UAAS;AACrD,QAAM6B,YAAwBC,UAAqBH,gBAAgBG,IAAI;AAEvED,YAAUE,UAAUC;AAEpBH,YAAUI,UAAU,CAAA;AAEpB,MACE,CAAChC,WACD,CAACA,QAAOL,YACRK,QAAOL,SAASsC,aAAa7C,UAAUO,YACvC,CAACK,QAAOkC,SACR;AAGAN,cAAUO,cAAc;AAExB,WAAOP;EACT;AAEA,MAAI;IAAEjC,UAAAA;EAAU,IAAGK;AAEnB,QAAMoC,mBAAmBzC;AACzB,QAAM0C,gBACJD,iBAAiBC;AACnB,QAAM;IACJC;IACAC;IACAC,MAAAA;IACAN;IACAO;IACAC,eAAe1C,QAAO0C,gBAAiB1C,QAAe2C;IACtDC;IACAC;IACA3C;EACD,IAAGF;AAEJ,QAAM8C,mBAAmBZ,QAAQ1H;AAEjC,QAAMuI,YAAYlF,aAAaiF,kBAAkB,WAAW;AAC5D,QAAME,SAASnF,aAAaiF,kBAAkB,QAAQ;AACtD,QAAMG,iBAAiBpF,aAAaiF,kBAAkB,aAAa;AACnE,QAAMI,gBAAgBrF,aAAaiF,kBAAkB,YAAY;AACjE,QAAMK,gBAAgBtF,aAAaiF,kBAAkB,YAAY;AAQjE,MAAI,OAAOP,wBAAwB,YAAY;AAC7C,UAAMa,WAAWzD,UAAS0D,cAAc,UAAU;AAClD,QAAID,SAASE,WAAWF,SAASE,QAAQC,eAAe;AACtD5D,MAAAA,YAAWyD,SAASE,QAAQC;IAC9B;EACF;AAEA,MAAIC;AACJ,MAAIC,YAAY;AAEhB,QAAM;IACJC;IACAC;IACAC;IACAC;EAAoB,IAClBlE;AACJ,QAAM;IAAEmE;EAAY,IAAG1B;AAEvB,MAAI2B,QAAQ/C,gBAAe;AAK3BY,YAAUO,cACR,OAAOrJ,YAAY,cACnB,OAAOqK,kBAAkB,cACzBO,kBACAA,eAAeM,uBAAuBrC;AAExC,QAAM;IACJjD,eAAAA;IACAC,UAAAA;IACAC,aAAAA;IACAC,WAAAA;IACAC,WAAAA;IACAE,mBAAAA;IACAC,iBAAAA;IACAE,gBAAAA;EACD,IAAG8E;AAEJ,MAAI;IAAElF,gBAAAA;EAAgB,IAAGkF;AAQzB,MAAIC,eAAe;AACnB,QAAMC,uBAAuBvH,SAAS,CAAA,GAAI,CACxC,GAAGwH,QACH,GAAGA,OACH,GAAGA,YACH,GAAGA,UACH,GAAGA,IAAS,CACb;AAGD,MAAIC,eAAe;AACnB,QAAMC,uBAAuB1H,SAAS,CAAA,GAAI,CACxC,GAAG2H,MACH,GAAGA,KACH,GAAGA,QACH,GAAGA,GAAS,CACb;AAQD,MAAIC,0BAA0BrL,OAAOE,KACnCC,OAAO,MAAM;IACXmL,cAAc;MACZC,UAAU;MACVC,cAAc;MACdC,YAAY;MACZlH,OAAO;;IAETmH,oBAAoB;MAClBH,UAAU;MACVC,cAAc;MACdC,YAAY;MACZlH,OAAO;;IAEToH,gCAAgC;MAC9BJ,UAAU;MACVC,cAAc;MACdC,YAAY;MACZlH,OAAO;IACR;EACF,CAAA,CAAC;AAIJ,MAAIqH,cAAc;AAGlB,MAAIC,cAAc;AAGlB,QAAMC,yBAAyB9L,OAAOE,KACpCC,OAAO,MAAM;IACX4L,UAAU;MACRR,UAAU;MACVC,cAAc;MACdC,YAAY;MACZlH,OAAO;;IAETyH,gBAAgB;MACdT,UAAU;MACVC,cAAc;MACdC,YAAY;MACZlH,OAAO;IACR;EACF,CAAA,CAAC;AAIJ,MAAI0H,kBAAkB;AAGtB,MAAIC,kBAAkB;AAGtB,MAAIC,0BAA0B;AAI9B,MAAIC,2BAA2B;AAK/B,MAAIC,qBAAqB;AAKzB,MAAIC,eAAe;AAGnB,MAAIC,iBAAiB;AAGrB,MAAIC,aAAa;AAIjB,MAAIC,aAAa;AAMjB,MAAIC,aAAa;AAIjB,MAAIC,sBAAsB;AAI1B,MAAIC,sBAAsB;AAK1B,MAAIC,eAAe;AAenB,MAAIC,uBAAuB;AAC3B,QAAMC,8BAA8B;AAGpC,MAAIC,eAAe;AAInB,MAAIC,WAAW;AAGf,MAAIC,eAA0C,CAAA;AAG9C,MAAIC,kBAAkB;AACtB,QAAMC,0BAA0B3J,SAAS,CAAA,GAAI,CAC3C,kBACA,SACA,YACA,QACA,iBACA,QACA,UACA,QACA,MACA,MACA,MACA,MACA,SACA,WACA,YACA,YACA,aACA,UACA,SACA,OACA,YACA,SACA,SACA,SACA,KAAK,CACN;AAGD,MAAI4J,gBAAgB;AACpB,QAAMC,wBAAwB7J,SAAS,CAAA,GAAI,CACzC,SACA,SACA,OACA,UACA,SACA,OAAO,CACR;AAGD,MAAI8J,sBAAsB;AAC1B,QAAMC,8BAA8B/J,SAAS,CAAA,GAAI,CAC/C,OACA,SACA,OACA,MACA,SACA,QACA,WACA,eACA,QACA,WACA,SACA,SACA,SACA,OAAO,CACR;AAED,QAAMgK,mBAAmB;AACzB,QAAMC,gBAAgB;AACtB,QAAMC,iBAAiB;AAEvB,MAAIC,YAAYD;AAChB,MAAIE,iBAAiB;AAGrB,MAAIC,qBAAqB;AACzB,QAAMC,6BAA6BtK,SACjC,CAAA,GACA,CAACgK,kBAAkBC,eAAeC,cAAc,GAChDzL,cAAc;AAGhB,MAAI8L,iCAAiCvK,SAAS,CAAA,GAAI,CAChD,MACA,MACA,MACA,MACA,OAAO,CACR;AAED,MAAIwK,0BAA0BxK,SAAS,CAAA,GAAI,CAAC,gBAAgB,CAAC;AAM7D,QAAMyK,+BAA+BzK,SAAS,CAAA,GAAI,CAChD,SACA,SACA,QACA,KACA,QAAQ,CACT;AAGD,MAAI0K,oBAAmD;AACvD,QAAMC,+BAA+B,CAAC,yBAAyB,WAAW;AAC1E,QAAMC,4BAA4B;AAClC,MAAIzK,oBAA2D;AAG/D,MAAI0K,SAAwB;AAK5B,QAAMC,cAAc/H,UAAS0D,cAAc,MAAM;AAEjD,QAAMsE,oBAAoB,SAApBA,mBACJC,WAAkB;AAElB,WAAOA,qBAAqB1L,UAAU0L,qBAAqBC;;AAS7D,QAAMC,eAAe,SAAfA,gBAAyC;AAAA,QAAhBC,MAAAjO,UAAAC,SAAA,KAAAD,UAAA,CAAA,MAAA6H,SAAA7H,UAAA,CAAA,IAAc,CAAA;AAC3C,QAAI2N,UAAUA,WAAWM,KAAK;AAC5B;IACF;AAGA,QAAI,CAACA,OAAO,OAAOA,QAAQ,UAAU;AACnCA,YAAM,CAAA;IACR;AAGAA,UAAMzK,MAAMyK,GAAG;AAEfT;IAEEC,6BAA6B3L,QAAQmM,IAAIT,iBAAiB,MAAM,KAC5DE,4BACAO,IAAIT;AAGVvK,wBACEuK,sBAAsB,0BAClBjM,iBACAH;AAGNgJ,mBAAenI,qBAAqBgM,KAAK,cAAc,IACnDnL,SAAS,CAAA,GAAImL,IAAI7D,cAAcnH,iBAAiB,IAChDoH;AACJE,mBAAetI,qBAAqBgM,KAAK,cAAc,IACnDnL,SAAS,CAAA,GAAImL,IAAI1D,cAActH,iBAAiB,IAChDuH;AACJ2C,yBAAqBlL,qBAAqBgM,KAAK,oBAAoB,IAC/DnL,SAAS,CAAA,GAAImL,IAAId,oBAAoB5L,cAAc,IACnD6L;AACJR,0BAAsB3K,qBAAqBgM,KAAK,mBAAmB,IAC/DnL,SACEU,MAAMqJ,2BAA2B,GACjCoB,IAAIC,mBACJjL,iBAAiB,IAEnB4J;AACJH,oBAAgBzK,qBAAqBgM,KAAK,mBAAmB,IACzDnL,SACEU,MAAMmJ,qBAAqB,GAC3BsB,IAAIE,mBACJlL,iBAAiB,IAEnB0J;AACJH,sBAAkBvK,qBAAqBgM,KAAK,iBAAiB,IACzDnL,SAAS,CAAA,GAAImL,IAAIzB,iBAAiBvJ,iBAAiB,IACnDwJ;AACJxB,kBAAchJ,qBAAqBgM,KAAK,aAAa,IACjDnL,SAAS,CAAA,GAAImL,IAAIhD,aAAahI,iBAAiB,IAC/CO,MAAM,CAAA,CAAE;AACZ0H,kBAAcjJ,qBAAqBgM,KAAK,aAAa,IACjDnL,SAAS,CAAA,GAAImL,IAAI/C,aAAajI,iBAAiB,IAC/CO,MAAM,CAAA,CAAE;AACZ+I,mBAAetK,qBAAqBgM,KAAK,cAAc,IACnDA,IAAI1B,eACJ;AACJjB,sBAAkB2C,IAAI3C,oBAAoB;AAC1CC,sBAAkB0C,IAAI1C,oBAAoB;AAC1CC,8BAA0ByC,IAAIzC,2BAA2B;AACzDC,+BAA2BwC,IAAIxC,6BAA6B;AAC5DC,yBAAqBuC,IAAIvC,sBAAsB;AAC/CC,mBAAesC,IAAItC,iBAAiB;AACpCC,qBAAiBqC,IAAIrC,kBAAkB;AACvCG,iBAAakC,IAAIlC,cAAc;AAC/BC,0BAAsBiC,IAAIjC,uBAAuB;AACjDC,0BAAsBgC,IAAIhC,uBAAuB;AACjDH,iBAAamC,IAAInC,cAAc;AAC/BI,mBAAe+B,IAAI/B,iBAAiB;AACpCC,2BAAuB8B,IAAI9B,wBAAwB;AACnDE,mBAAe4B,IAAI5B,iBAAiB;AACpCC,eAAW2B,IAAI3B,YAAY;AAC3BrH,uBAAiBgJ,IAAIG,sBAAsBjE;AAC3C8C,gBAAYgB,IAAIhB,aAAaD;AAC7BK,qCACEY,IAAIZ,kCAAkCA;AACxCC,8BACEW,IAAIX,2BAA2BA;AAEjC5C,8BAA0BuD,IAAIvD,2BAA2B,CAAA;AACzD,QACEuD,IAAIvD,2BACJmD,kBAAkBI,IAAIvD,wBAAwBC,YAAY,GAC1D;AACAD,8BAAwBC,eACtBsD,IAAIvD,wBAAwBC;IAChC;AAEA,QACEsD,IAAIvD,2BACJmD,kBAAkBI,IAAIvD,wBAAwBK,kBAAkB,GAChE;AACAL,8BAAwBK,qBACtBkD,IAAIvD,wBAAwBK;IAChC;AAEA,QACEkD,IAAIvD,2BACJ,OAAOuD,IAAIvD,wBAAwBM,mCACjC,WACF;AACAN,8BAAwBM,iCACtBiD,IAAIvD,wBAAwBM;IAChC;AAEA,QAAIU,oBAAoB;AACtBH,wBAAkB;IACpB;AAEA,QAAIS,qBAAqB;AACvBD,mBAAa;IACf;AAGA,QAAIQ,cAAc;AAChBnC,qBAAetH,SAAS,CAAA,GAAIwH,IAAS;AACrCC,qBAAe,CAAA;AACf,UAAIgC,aAAanI,SAAS,MAAM;AAC9BtB,iBAASsH,cAAcE,MAAS;AAChCxH,iBAASyH,cAAcE,IAAU;MACnC;AAEA,UAAI8B,aAAalI,QAAQ,MAAM;AAC7BvB,iBAASsH,cAAcE,KAAQ;AAC/BxH,iBAASyH,cAAcE,GAAS;AAChC3H,iBAASyH,cAAcE,GAAS;MAClC;AAEA,UAAI8B,aAAajI,eAAe,MAAM;AACpCxB,iBAASsH,cAAcE,UAAe;AACtCxH,iBAASyH,cAAcE,GAAS;AAChC3H,iBAASyH,cAAcE,GAAS;MAClC;AAEA,UAAI8B,aAAa/H,WAAW,MAAM;AAChC1B,iBAASsH,cAAcE,QAAW;AAClCxH,iBAASyH,cAAcE,MAAY;AACnC3H,iBAASyH,cAAcE,GAAS;MAClC;IACF;AAGA,QAAIwD,IAAII,UAAU;AAChB,UAAI,OAAOJ,IAAII,aAAa,YAAY;AACtClD,+BAAuBC,WAAW6C,IAAII;MACxC,OAAO;AACL,YAAIjE,iBAAiBC,sBAAsB;AACzCD,yBAAe5G,MAAM4G,YAAY;QACnC;AAEAtH,iBAASsH,cAAc6D,IAAII,UAAUpL,iBAAiB;MACxD;IACF;AAEA,QAAIgL,IAAIK,UAAU;AAChB,UAAI,OAAOL,IAAIK,aAAa,YAAY;AACtCnD,+BAAuBE,iBAAiB4C,IAAIK;MAC9C,OAAO;AACL,YAAI/D,iBAAiBC,sBAAsB;AACzCD,yBAAe/G,MAAM+G,YAAY;QACnC;AAEAzH,iBAASyH,cAAc0D,IAAIK,UAAUrL,iBAAiB;MACxD;IACF;AAEA,QAAIgL,IAAIC,mBAAmB;AACzBpL,eAAS8J,qBAAqBqB,IAAIC,mBAAmBjL,iBAAiB;IACxE;AAEA,QAAIgL,IAAIzB,iBAAiB;AACvB,UAAIA,oBAAoBC,yBAAyB;AAC/CD,0BAAkBhJ,MAAMgJ,eAAe;MACzC;AAEA1J,eAAS0J,iBAAiByB,IAAIzB,iBAAiBvJ,iBAAiB;IAClE;AAGA,QAAIoJ,cAAc;AAChBjC,mBAAa,OAAO,IAAI;IAC1B;AAGA,QAAIwB,gBAAgB;AAClB9I,eAASsH,cAAc,CAAC,QAAQ,QAAQ,MAAM,CAAC;IACjD;AAGA,QAAIA,aAAamE,OAAO;AACtBzL,eAASsH,cAAc,CAAC,OAAO,CAAC;AAChC,aAAOa,YAAYuD;IACrB;AAEA,QAAIP,IAAIQ,sBAAsB;AAC5B,UAAI,OAAOR,IAAIQ,qBAAqB7H,eAAe,YAAY;AAC7D,cAAMtE,gBACJ,6EAA6E;MAEjF;AAEA,UAAI,OAAO2L,IAAIQ,qBAAqB5H,oBAAoB,YAAY;AAClE,cAAMvE,gBACJ,kFAAkF;MAEtF;AAGAoH,2BAAqBuE,IAAIQ;AAGzB9E,kBAAYD,mBAAmB9C,WAAW,EAAE;IAC9C,OAAO;AAEL,UAAI8C,uBAAuB7B,QAAW;AACpC6B,6BAAqBvD,0BACnBC,cACAmC,aAAa;MAEjB;AAGA,UAAImB,uBAAuB,QAAQ,OAAOC,cAAc,UAAU;AAChEA,oBAAYD,mBAAmB9C,WAAW,EAAE;MAC9C;IACF;AAIA,QAAItH,QAAQ;AACVA,aAAO2O,GAAG;IACZ;AAEAN,aAASM;;AAMX,QAAMS,eAAe5L,SAAS,CAAA,GAAI,CAChC,GAAGwH,OACH,GAAGA,YACH,GAAGA,aAAkB,CACtB;AACD,QAAMqE,kBAAkB7L,SAAS,CAAA,GAAI,CACnC,GAAGwH,UACH,GAAGA,gBAAqB,CACzB;AAQD,QAAMsE,uBAAuB,SAAvBA,sBAAiCzL,SAAgB;AACrD,QAAI0L,SAASxF,cAAclG,OAAO;AAIlC,QAAI,CAAC0L,UAAU,CAACA,OAAOC,SAAS;AAC9BD,eAAS;QACPE,cAAc9B;QACd6B,SAAS;;IAEb;AAEA,UAAMA,UAAU1N,kBAAkB+B,QAAQ2L,OAAO;AACjD,UAAME,gBAAgB5N,kBAAkByN,OAAOC,OAAO;AAEtD,QAAI,CAAC3B,mBAAmBhK,QAAQ4L,YAAY,GAAG;AAC7C,aAAO;IACT;AAEA,QAAI5L,QAAQ4L,iBAAiBhC,eAAe;AAI1C,UAAI8B,OAAOE,iBAAiB/B,gBAAgB;AAC1C,eAAO8B,YAAY;MACrB;AAKA,UAAID,OAAOE,iBAAiBjC,kBAAkB;AAC5C,eACEgC,YAAY,UACXE,kBAAkB,oBACjB3B,+BAA+B2B,aAAa;MAElD;AAIA,aAAOC,QAAQP,aAAaI,OAAO,CAAC;IACtC;AAEA,QAAI3L,QAAQ4L,iBAAiBjC,kBAAkB;AAI7C,UAAI+B,OAAOE,iBAAiB/B,gBAAgB;AAC1C,eAAO8B,YAAY;MACrB;AAIA,UAAID,OAAOE,iBAAiBhC,eAAe;AACzC,eAAO+B,YAAY,UAAUxB,wBAAwB0B,aAAa;MACpE;AAIA,aAAOC,QAAQN,gBAAgBG,OAAO,CAAC;IACzC;AAEA,QAAI3L,QAAQ4L,iBAAiB/B,gBAAgB;AAI3C,UACE6B,OAAOE,iBAAiBhC,iBACxB,CAACO,wBAAwB0B,aAAa,GACtC;AACA,eAAO;MACT;AAEA,UACEH,OAAOE,iBAAiBjC,oBACxB,CAACO,+BAA+B2B,aAAa,GAC7C;AACA,eAAO;MACT;AAIA,aACE,CAACL,gBAAgBG,OAAO,MACvBvB,6BAA6BuB,OAAO,KAAK,CAACJ,aAAaI,OAAO;IAEnE;AAGA,QACEtB,sBAAsB,2BACtBL,mBAAmBhK,QAAQ4L,YAAY,GACvC;AACA,aAAO;IACT;AAMA,WAAO;;AAQT,QAAMG,eAAe,SAAfA,cAAyBC,MAAU;AACvCnO,cAAU8G,UAAUI,SAAS;MAAE/E,SAASgM;IAAM,CAAA;AAE9C,QAAI;AAEF9F,oBAAc8F,IAAI,EAAEC,YAAYD,IAAI;aAC7BpI,IAAG;AACVmC,aAAOiG,IAAI;IACb;;AASF,QAAME,mBAAmB,SAAnBA,kBAA6BC,MAAcnM,SAAgB;AAC/D,QAAI;AACFnC,gBAAU8G,UAAUI,SAAS;QAC3B3C,WAAWpC,QAAQoM,iBAAiBD,IAAI;QACxCE,MAAMrM;MACP,CAAA;aACM4D,IAAG;AACV/F,gBAAU8G,UAAUI,SAAS;QAC3B3C,WAAW;QACXiK,MAAMrM;MACP,CAAA;IACH;AAEAA,YAAQsM,gBAAgBH,IAAI;AAG5B,QAAIA,SAAS,MAAM;AACjB,UAAIvD,cAAcC,qBAAqB;AACrC,YAAI;AACFkD,uBAAa/L,OAAO;QACtB,SAAS4D,IAAG;QAAA;MACd,OAAO;AACL,YAAI;AACF5D,kBAAQuM,aAAaJ,MAAM,EAAE;QAC/B,SAASvI,IAAG;QAAA;MACd;IACF;;AASF,QAAM4I,gBAAgB,SAAhBA,eAA0BC,OAAa;AAE3C,QAAIC,MAAM;AACV,QAAIC,oBAAoB;AAExB,QAAIhE,YAAY;AACd8D,cAAQ,sBAAsBA;IAChC,OAAO;AAEL,YAAMG,UAAUtO,YAAYmO,OAAO,aAAa;AAChDE,0BAAoBC,WAAWA,QAAQ,CAAC;IAC1C;AAEA,QACEvC,sBAAsB,2BACtBP,cAAcD,gBACd;AAEA4C,cACE,mEACAA,QACA;IACJ;AAEA,UAAMI,eAAetG,qBACjBA,mBAAmB9C,WAAWgJ,KAAK,IACnCA;AAKJ,QAAI3C,cAAcD,gBAAgB;AAChC,UAAI;AACF6C,cAAM,IAAI9G,UAAS,EAAGkH,gBAAgBD,cAAcxC,iBAAiB;MACvE,SAASzG,IAAG;MAAA;IACd;AAGA,QAAI,CAAC8I,OAAO,CAACA,IAAIK,iBAAiB;AAChCL,YAAMjG,eAAeuG,eAAelD,WAAW,YAAY,IAAI;AAC/D,UAAI;AACF4C,YAAIK,gBAAgBE,YAAYlD,iBAC5BvD,YACAqG;eACGjJ,IAAG;MACV;IAEJ;AAEA,UAAMsJ,OAAOR,IAAIQ,QAAQR,IAAIK;AAE7B,QAAIN,SAASE,mBAAmB;AAC9BO,WAAKC,aACHzK,UAAS0K,eAAeT,iBAAiB,GACzCO,KAAKG,WAAW,CAAC,KAAK,IAAI;IAE9B;AAGA,QAAIvD,cAAcD,gBAAgB;AAChC,aAAOjD,qBAAqB0G,KAC1BZ,KACAjE,iBAAiB,SAAS,MAAM,EAChC,CAAC;IACL;AAEA,WAAOA,iBAAiBiE,IAAIK,kBAAkBG;;AAShD,QAAMK,sBAAsB,SAAtBA,qBAAgC3I,MAAU;AAC9C,WAAO8B,mBAAmB4G;MACxB1I,KAAK0B,iBAAiB1B;MACtBA;;MAEAY,WAAWgI,eACThI,WAAWiI,eACXjI,WAAWkI,YACXlI,WAAWmI,8BACXnI,WAAWoI;MACb;IAAI;;AAUR,QAAMC,eAAe,SAAfA,cAAyB7N,SAAgB;AAC7C,WACEA,mBAAmB2F,oBAClB,OAAO3F,QAAQ8N,aAAa,YAC3B,OAAO9N,QAAQ+N,gBAAgB,YAC/B,OAAO/N,QAAQiM,gBAAgB,cAC/B,EAAEjM,QAAQgO,sBAAsBvI,iBAChC,OAAOzF,QAAQsM,oBAAoB,cACnC,OAAOtM,QAAQuM,iBAAiB,cAChC,OAAOvM,QAAQ4L,iBAAiB,YAChC,OAAO5L,QAAQmN,iBAAiB,cAChC,OAAOnN,QAAQiO,kBAAkB;;AAUvC,QAAMC,UAAU,SAAVA,SAAoBzN,OAAc;AACtC,WAAO,OAAO8E,UAAS,cAAc9E,iBAAiB8E;;AAGxD,WAAS4I,cACPrH,QACAsH,aACAC,MAAsB;AAEtBhR,iBAAayJ,QAAQwH,UAAW;AAC9BA,WAAKhB,KAAK3I,WAAWyJ,aAAaC,MAAM7D,MAAM;IAChD,CAAC;EACH;AAWA,QAAM+D,oBAAoB,SAApBA,mBAA8BH,aAAgB;AAClD,QAAI/H,UAAU;AAGd8H,kBAAcrH,MAAM1C,wBAAwBgK,aAAa,IAAI;AAG7D,QAAIP,aAAaO,WAAW,GAAG;AAC7BrC,mBAAaqC,WAAW;AACxB,aAAO;IACT;AAGA,UAAMzC,UAAU7L,kBAAkBsO,YAAYN,QAAQ;AAGtDK,kBAAcrH,MAAMvC,qBAAqB6J,aAAa;MACpDzC;MACA6C,aAAavH;IACd,CAAA;AAGD,QACEuB,gBACA4F,YAAYH,cAAa,KACzB,CAACC,QAAQE,YAAYK,iBAAiB,KACtCzP,WAAW,YAAYoP,YAAYnB,SAAS,KAC5CjO,WAAW,YAAYoP,YAAYL,WAAW,GAC9C;AACAhC,mBAAaqC,WAAW;AACxB,aAAO;IACT;AAGA,QAAIA,YAAYpJ,aAAa7C,UAAUK,wBAAwB;AAC7DuJ,mBAAaqC,WAAW;AACxB,aAAO;IACT;AAGA,QACE5F,gBACA4F,YAAYpJ,aAAa7C,UAAUM,WACnCzD,WAAW,WAAWoP,YAAYC,IAAI,GACtC;AACAtC,mBAAaqC,WAAW;AACxB,aAAO;IACT;AAGA,QACE,EACEpG,uBAAuBC,oBAAoB2C,YAC3C5C,uBAAuBC,SAAS0D,OAAO,OAExC,CAAC1E,aAAa0E,OAAO,KAAK7D,YAAY6D,OAAO,IAC9C;AAEA,UAAI,CAAC7D,YAAY6D,OAAO,KAAK+C,sBAAsB/C,OAAO,GAAG;AAC3D,YACEpE,wBAAwBC,wBAAwBvI,UAChDD,WAAWuI,wBAAwBC,cAAcmE,OAAO,GACxD;AACA,iBAAO;QACT;AAEA,YACEpE,wBAAwBC,wBAAwBoD,YAChDrD,wBAAwBC,aAAamE,OAAO,GAC5C;AACA,iBAAO;QACT;MACF;AAGA,UAAIzC,gBAAgB,CAACG,gBAAgBsC,OAAO,GAAG;AAC7C,cAAMgD,aAAazI,cAAckI,WAAW,KAAKA,YAAYO;AAC7D,cAAMtB,aAAapH,cAAcmI,WAAW,KAAKA,YAAYf;AAE7D,YAAIA,cAAcsB,YAAY;AAC5B,gBAAMC,aAAavB,WAAWvQ;AAE9B,mBAAS+R,IAAID,aAAa,GAAGC,KAAK,GAAG,EAAEA,GAAG;AACxC,kBAAMC,aAAahJ,UAAUuH,WAAWwB,CAAC,GAAG,IAAI;AAChDC,uBAAWC,kBAAkBX,YAAYW,kBAAkB,KAAK;AAChEJ,uBAAWxB,aAAa2B,YAAY9I,eAAeoI,WAAW,CAAC;UACjE;QACF;MACF;AAEArC,mBAAaqC,WAAW;AACxB,aAAO;IACT;AAGA,QAAIA,uBAAuBnJ,WAAW,CAACwG,qBAAqB2C,WAAW,GAAG;AACxErC,mBAAaqC,WAAW;AACxB,aAAO;IACT;AAGA,SACGzC,YAAY,cACXA,YAAY,aACZA,YAAY,eACd3M,WAAW,+BAA+BoP,YAAYnB,SAAS,GAC/D;AACAlB,mBAAaqC,WAAW;AACxB,aAAO;IACT;AAGA,QAAI7F,sBAAsB6F,YAAYpJ,aAAa7C,UAAUZ,MAAM;AAEjE8E,gBAAU+H,YAAYL;AAEtB1Q,mBAAa,CAACoE,gBAAeC,WAAUC,YAAW,GAAIqN,UAAgB;AACpE3I,kBAAU7H,cAAc6H,SAAS2I,MAAM,GAAG;MAC5C,CAAC;AAED,UAAIZ,YAAYL,gBAAgB1H,SAAS;AACvCxI,kBAAU8G,UAAUI,SAAS;UAAE/E,SAASoO,YAAYtI,UAAS;QAAE,CAAE;AACjEsI,oBAAYL,cAAc1H;MAC5B;IACF;AAGA8H,kBAAcrH,MAAM7C,uBAAuBmK,aAAa,IAAI;AAE5D,WAAO;;AAYT,QAAMa,oBAAoB,SAApBA,mBACJC,OACAC,QACA1O,OAAa;AAGb,QACEsI,iBACCoG,WAAW,QAAQA,WAAW,YAC9B1O,SAASiC,aAAYjC,SAASgK,cAC/B;AACA,aAAO;IACT;AAMA,QACErC,mBACA,CAACL,YAAYoH,MAAM,KACnBnQ,WAAW4C,YAAWuN,MAAM,EAC5B;aAEShH,mBAAmBnJ,WAAW6C,YAAWsN,MAAM,EAAG;aAI3DnH,uBAAuBE,0BAA0B0C,YACjD5C,uBAAuBE,eAAeiH,QAAQD,KAAK,EACnD;aAGS,CAAC9H,aAAa+H,MAAM,KAAKpH,YAAYoH,MAAM,GAAG;AACvD;;;;QAIGT,sBAAsBQ,KAAK,MACxB3H,wBAAwBC,wBAAwBvI,UAChDD,WAAWuI,wBAAwBC,cAAc0H,KAAK,KACrD3H,wBAAwBC,wBAAwBoD,YAC/CrD,wBAAwBC,aAAa0H,KAAK,OAC5C3H,wBAAwBK,8BAA8B3I,UACtDD,WAAWuI,wBAAwBK,oBAAoBuH,MAAM,KAC5D5H,wBAAwBK,8BAA8BgD,YACrDrD,wBAAwBK,mBAAmBuH,QAAQD,KAAK;;QAG7DC,WAAW,QACV5H,wBAAwBM,mCACtBN,wBAAwBC,wBAAwBvI,UAChDD,WAAWuI,wBAAwBC,cAAc/G,KAAK,KACrD8G,wBAAwBC,wBAAwBoD,YAC/CrD,wBAAwBC,aAAa/G,KAAK;OAChD;WAGK;AACL,eAAO;MACT;IAEF,WAAWgJ,oBAAoB0F,MAAM,EAAG;aAKtCnQ,WAAW8C,kBAAgBtD,cAAciC,OAAOuB,kBAAiB,EAAE,CAAC,EACpE;cAKCmN,WAAW,SAASA,WAAW,gBAAgBA,WAAW,WAC3DD,UAAU,YACVxQ,cAAc+B,OAAO,OAAO,MAAM,KAClC8I,cAAc2F,KAAK,EACnB;aAMA7G,2BACA,CAACrJ,WAAW+C,oBAAmBvD,cAAciC,OAAOuB,kBAAiB,EAAE,CAAC,EACxE;aAGSvB,OAAO;AAChB,aAAO;IACT,MAAO;AAKP,WAAO;;AAWT,QAAMiO,wBAAwB,SAAxBA,uBAAkC/C,SAAe;AACrD,WAAOA,YAAY,oBAAoBrN,YAAYqN,SAASzJ,eAAc;;AAa5E,QAAMkN,sBAAsB,SAAtBA,qBAAgChB,aAAoB;AAExDD,kBAAcrH,MAAM3C,0BAA0BiK,aAAa,IAAI;AAE/D,UAAM;MAAEJ;IAAY,IAAGI;AAGvB,QAAI,CAACJ,cAAcH,aAAaO,WAAW,GAAG;AAC5C;IACF;AAEA,UAAMiB,YAAY;MAChBC,UAAU;MACVC,WAAW;MACXC,UAAU;MACVC,mBAAmBrI;MACnBsI,eAAehL;;AAEjB,QAAI3E,KAAIiO,WAAWlR;AAGnB,WAAOiD,MAAK;AACV,YAAM4P,OAAO3B,WAAWjO,EAAC;AACzB,YAAM;QAAEoM;QAAMP;QAAcnL,OAAO8O;MAAS,IAAKI;AACjD,YAAMR,SAASrP,kBAAkBqM,IAAI;AAErC,YAAMyD,YAAYL;AAClB,UAAI9O,QAAQ0L,SAAS,UAAUyD,YAAYhR,WAAWgR,SAAS;AAG/DP,gBAAUC,WAAWH;AACrBE,gBAAUE,YAAY9O;AACtB4O,gBAAUG,WAAW;AACrBH,gBAAUK,gBAAgBhL;AAC1ByJ,oBAAcrH,MAAMxC,uBAAuB8J,aAAaiB,SAAS;AACjE5O,cAAQ4O,UAAUE;AAKlB,UAAIvG,yBAAyBmG,WAAW,QAAQA,WAAW,SAAS;AAElEjD,yBAAiBC,MAAMiC,WAAW;AAGlC3N,gBAAQwI,8BAA8BxI;MACxC;AAGA,UACE+H,gBACAxJ,WAAW,0CAA0CyB,KAAK,GAC1D;AACAyL,yBAAiBC,MAAMiC,WAAW;AAClC;MACF;AAGA,UAAIe,WAAW,mBAAmB7Q,YAAYmC,OAAO,MAAM,GAAG;AAC5DyL,yBAAiBC,MAAMiC,WAAW;AAClC;MACF;AAGA,UAAIiB,UAAUK,eAAe;AAC3B;MACF;AAGA,UAAI,CAACL,UAAUG,UAAU;AACvBtD,yBAAiBC,MAAMiC,WAAW;AAClC;MACF;AAGA,UAAI,CAAC9F,4BAA4BtJ,WAAW,QAAQyB,KAAK,GAAG;AAC1DyL,yBAAiBC,MAAMiC,WAAW;AAClC;MACF;AAGA,UAAI7F,oBAAoB;AACtBlL,qBAAa,CAACoE,gBAAeC,WAAUC,YAAW,GAAIqN,UAAgB;AACpEvO,kBAAQjC,cAAciC,OAAOuO,MAAM,GAAG;QACxC,CAAC;MACH;AAGA,YAAME,QAAQpP,kBAAkBsO,YAAYN,QAAQ;AACpD,UAAI,CAACmB,kBAAkBC,OAAOC,QAAQ1O,KAAK,GAAG;AAC5CyL,yBAAiBC,MAAMiC,WAAW;AAClC;MACF;AAGA,UACE7H,sBACA,OAAOtD,iBAAiB,YACxB,OAAOA,aAAa4M,qBAAqB,YACzC;AACA,YAAIjE,aAAc;aAEX;AACL,kBAAQ3I,aAAa4M,iBAAiBX,OAAOC,MAAM,GAAC;YAClD,KAAK,eAAe;AAClB1O,sBAAQ8F,mBAAmB9C,WAAWhD,KAAK;AAC3C;YACF;YAEA,KAAK,oBAAoB;AACvBA,sBAAQ8F,mBAAmB7C,gBAAgBjD,KAAK;AAChD;YACF;UAKF;QACF;MACF;AAGA,UAAIA,UAAUmP,WAAW;AACvB,YAAI;AACF,cAAIhE,cAAc;AAChBwC,wBAAY0B,eAAelE,cAAcO,MAAM1L,KAAK;UACtD,OAAO;AAEL2N,wBAAY7B,aAAaJ,MAAM1L,KAAK;UACtC;AAEA,cAAIoN,aAAaO,WAAW,GAAG;AAC7BrC,yBAAaqC,WAAW;UAC1B,OAAO;AACLzQ,qBAASgH,UAAUI,OAAO;UAC5B;iBACOnB,IAAG;AACVsI,2BAAiBC,MAAMiC,WAAW;QACpC;MACF;IACF;AAGAD,kBAAcrH,MAAM9C,yBAAyBoK,aAAa,IAAI;;AAQhE,QAAM2B,qBAAqB,SAArBA,oBAA+BC,UAA0B;AAC7D,QAAIC,aAAa;AACjB,UAAMC,iBAAiB3C,oBAAoByC,QAAQ;AAGnD7B,kBAAcrH,MAAMzC,yBAAyB2L,UAAU,IAAI;AAE3D,WAAQC,aAAaC,eAAeC,SAAQ,GAAK;AAE/ChC,oBAAcrH,MAAMtC,wBAAwByL,YAAY,IAAI;AAG5D1B,wBAAkB0B,UAAU;AAG5Bb,0BAAoBa,UAAU;AAG9B,UAAIA,WAAW5J,mBAAmBhB,kBAAkB;AAClD0K,QAAAA,oBAAmBE,WAAW5J,OAAO;MACvC;IACF;AAGA8H,kBAAcrH,MAAM5C,wBAAwB8L,UAAU,IAAI;;AAI5DrL,YAAUyL,WAAW,SAAU3D,OAAe;AAAA,QAAR3B,MAAGjO,UAAAC,SAAA,KAAAD,UAAA,CAAA,MAAA6H,SAAA7H,UAAA,CAAA,IAAG,CAAA;AAC1C,QAAIqQ,OAAO;AACX,QAAImD,eAAe;AACnB,QAAIjC,cAAc;AAClB,QAAIkC,aAAa;AAIjBvG,qBAAiB,CAAC0C;AAClB,QAAI1C,gBAAgB;AAClB0C,cAAQ;IACV;AAGA,QAAI,OAAOA,UAAU,YAAY,CAACyB,QAAQzB,KAAK,GAAG;AAChD,UAAI,OAAOA,MAAMpO,aAAa,YAAY;AACxCoO,gBAAQA,MAAMpO,SAAQ;AACtB,YAAI,OAAOoO,UAAU,UAAU;AAC7B,gBAAMtN,gBAAgB,iCAAiC;QACzD;MACF,OAAO;AACL,cAAMA,gBAAgB,4BAA4B;MACpD;IACF;AAGA,QAAI,CAACwF,UAAUO,aAAa;AAC1B,aAAOuH;IACT;AAGA,QAAI,CAAC/D,YAAY;AACfmC,mBAAaC,GAAG;IAClB;AAGAnG,cAAUI,UAAU,CAAA;AAGpB,QAAI,OAAO0H,UAAU,UAAU;AAC7BtD,iBAAW;IACb;AAEA,QAAIA,UAAU;AAEZ,UAAKsD,MAAeqB,UAAU;AAC5B,cAAMnC,UAAU7L,kBAAmB2M,MAAeqB,QAAQ;AAC1D,YAAI,CAAC7G,aAAa0E,OAAO,KAAK7D,YAAY6D,OAAO,GAAG;AAClD,gBAAMxM,gBACJ,yDAAyD;QAE7D;MACF;IACF,WAAWsN,iBAAiBlH,OAAM;AAGhC2H,aAAOV,cAAc,SAAS;AAC9B6D,qBAAenD,KAAK5G,cAAcO,WAAW4F,OAAO,IAAI;AACxD,UACE4D,aAAarL,aAAa7C,UAAUnC,WACpCqQ,aAAavC,aAAa,QAC1B;AAEAZ,eAAOmD;MACT,WAAWA,aAAavC,aAAa,QAAQ;AAC3CZ,eAAOmD;MACT,OAAO;AAELnD,aAAKqD,YAAYF,YAAY;MAC/B;IACF,OAAO;AAEL,UACE,CAACzH,cACD,CAACL,sBACD,CAACE;MAEDgE,MAAM9N,QAAQ,GAAG,MAAM,IACvB;AACA,eAAO4H,sBAAsBuC,sBACzBvC,mBAAmB9C,WAAWgJ,KAAK,IACnCA;MACN;AAGAS,aAAOV,cAAcC,KAAK;AAG1B,UAAI,CAACS,MAAM;AACT,eAAOtE,aAAa,OAAOE,sBAAsBtC,YAAY;MAC/D;IACF;AAGA,QAAI0G,QAAQvE,YAAY;AACtBoD,mBAAamB,KAAKsD,UAAU;IAC9B;AAGA,UAAMC,eAAelD,oBAAoBpE,WAAWsD,QAAQS,IAAI;AAGhE,WAAQkB,cAAcqC,aAAaN,SAAQ,GAAK;AAE9C5B,wBAAkBH,WAAW;AAG7BgB,0BAAoBhB,WAAW;AAG/B,UAAIA,YAAY/H,mBAAmBhB,kBAAkB;AACnD0K,2BAAmB3B,YAAY/H,OAAO;MACxC;IACF;AAGA,QAAI8C,UAAU;AACZ,aAAOsD;IACT;AAGA,QAAI7D,YAAY;AACd,UAAIC,qBAAqB;AACvByH,qBAAa3J,uBAAuB2G,KAAKJ,KAAK5G,aAAa;AAE3D,eAAO4G,KAAKsD,YAAY;AAEtBF,qBAAWC,YAAYrD,KAAKsD,UAAU;QACxC;MACF,OAAO;AACLF,qBAAapD;MACf;AAEA,UAAI9F,aAAasJ,cAActJ,aAAauJ,gBAAgB;AAQ1DL,qBAAazJ,WAAWyG,KAAKnI,kBAAkBmL,YAAY,IAAI;MACjE;AAEA,aAAOA;IACT;AAEA,QAAIM,iBAAiBnI,iBAAiByE,KAAK2D,YAAY3D,KAAKD;AAG5D,QACExE,kBACAxB,aAAa,UAAU,KACvBiG,KAAK5G,iBACL4G,KAAK5G,cAAcwK,WACnB5D,KAAK5G,cAAcwK,QAAQ3E,QAC3BnN,WAAWgI,cAA0BkG,KAAK5G,cAAcwK,QAAQ3E,IAAI,GACpE;AACAyE,uBACE,eAAe1D,KAAK5G,cAAcwK,QAAQ3E,OAAO,QAAQyE;IAC7D;AAGA,QAAIrI,oBAAoB;AACtBlL,mBAAa,CAACoE,gBAAeC,WAAUC,YAAW,GAAIqN,UAAgB;AACpE4B,yBAAiBpS,cAAcoS,gBAAgB5B,MAAM,GAAG;MAC1D,CAAC;IACH;AAEA,WAAOzI,sBAAsBuC,sBACzBvC,mBAAmB9C,WAAWmN,cAAc,IAC5CA;;AAGNjM,YAAUoM,YAAY,WAAkB;AAAA,QAARjG,MAAGjO,UAAAC,SAAA,KAAAD,UAAA,CAAA,MAAA6H,SAAA7H,UAAA,CAAA,IAAG,CAAA;AACpCgO,iBAAaC,GAAG;AAChBpC,iBAAa;;AAGf/D,YAAUqM,cAAc,WAAA;AACtBxG,aAAS;AACT9B,iBAAa;;AAGf/D,YAAUsM,mBAAmB,SAAUC,KAAKvB,MAAMlP,OAAK;AAErD,QAAI,CAAC+J,QAAQ;AACXK,mBAAa,CAAA,CAAE;IACjB;AAEA,UAAMqE,QAAQpP,kBAAkBoR,GAAG;AACnC,UAAM/B,SAASrP,kBAAkB6P,IAAI;AACrC,WAAOV,kBAAkBC,OAAOC,QAAQ1O,KAAK;;AAG/CkE,YAAUwM,UAAU,SAClBC,YACAC,cAA0B;AAE1B,QAAI,OAAOA,iBAAiB,YAAY;AACtC;IACF;AAEAxT,cAAUiJ,MAAMsK,UAAU,GAAGC,YAAY;;AAG3C1M,YAAU2M,aAAa,SACrBF,YACAC,cAA0B;AAE1B,QAAIA,iBAAiB3M,QAAW;AAC9B,YAAMvE,QAAQ1C,iBAAiBqJ,MAAMsK,UAAU,GAAGC,YAAY;AAE9D,aAAOlR,UAAU,KACbuE,SACA3G,YAAY+I,MAAMsK,UAAU,GAAGjR,OAAO,CAAC,EAAE,CAAC;IAChD;AAEA,WAAOxC,SAASmJ,MAAMsK,UAAU,CAAC;;AAGnCzM,YAAU4M,cAAc,SAAUH,YAA0B;AAC1DtK,UAAMsK,UAAU,IAAI,CAAA;;AAGtBzM,YAAU6M,iBAAiB,WAAA;AACzB1K,YAAQ/C,gBAAe;;AAGzB,SAAOY;AACT;AAEA,IAAA,SAAeF,gBAAe;;;AClrDvB,SAASgN,IAA4G;AAC1H,SAAO,EACL,OAAO,OACP,QAAQ,OACR,YAAY,MACZ,KAAK,MACL,OAAO,MACP,UAAU,OACV,UAAU,MACV,QAAQ,OACR,WAAW,MACX,YAAY,KACd;AACF;AAEO,IAAIC,IAAqCD,EAAa;AAEtD,SAASE,EAA+DC,IAA0D;AACvIF,MAAYE;AACd;ACxBA,IAAMC,IAAW,EAAE,MAAM,MAAM,KAAK;AAEpC,SAASC,EAAKC,IAAwBC,IAAM,IAAI;AAC9C,MAAIC,IAAS,OAAOF,MAAU,WAAWA,KAAQA,GAAM,QACjDG,IAAM,EACV,SAAS,CAACC,GAAuBC,MAAyB;AACxD,QAAIC,IAAY,OAAOD,KAAQ,WAAWA,IAAMA,EAAI;AACpD,WAAAC,IAAYA,EAAU,QAAQC,EAAM,OAAO,IAAI,GAC/CL,IAASA,EAAO,QAAQE,GAAME,CAAS,GAChCH;EACT,GACA,UAAU,MACD,IAAI,OAAOD,GAAQD,CAAG,EAEjC;AACA,SAAOE;AACT;AAEA,IAAMK,MAAsB,MAAM;AAClC,MAAI;AAEF,WAAO,CAAC,CAAC,IAAI,OAAO,cAAc;EACpC,QAAQ;AAGN,WAAO;EACT;AACA,GAAG;AATH,IAWaD,IAAQ,EACnB,kBAAkB,0BAClB,mBAAmB,eACnB,wBAAwB,iBACxB,gBAAgB,QAChB,YAAY,MACZ,mBAAmB,MACnB,iBAAiB,MACjB,cAAc,QACd,mBAAmB,OACnB,eAAe,OACf,qBAAqB,QACrB,WAAW,YACX,iBAAiB,qBACjB,iBAAiB,YACjB,yBAAyB,kCACzB,0BAA0B,oBAC1B,iBAAiB,QACjB,oBAAoB,2BACpB,YAAY,eACZ,iBAAiB,gBACjB,SAAS,UACT,cAAc,YACd,gBAAgB,QAChB,iBAAiB,cACjB,mBAAmB,aACnB,iBAAiB,aACjB,kBAAkB,cAClB,gBAAgB,aAChB,WAAW,SACX,SAAS,WACT,mBAAmB,kCACnB,iBAAiB,oCACjB,mBAAmB,MACnB,iBAAiB,MACjB,mBAAmB,iCACnB,qBAAqB,iBACrB,YAAY,WACZ,eAAe,YACf,oBAAoB,qDACpB,uBAAuB,sDACvB,cAAc,8CACd,OAAO,gBACP,eAAe,QACf,UAAU,OACV,WAAW,OACX,WAAW,SACX,gBAAgB,YAChB,WAAW,UACX,eAAe,QACf,eAAe,OACf,eAAgBE,CAAAA,OAAiB,IAAI,OAAO,WAAWA,EAAI,8BAA+B,GAC1F,iBAAkBC,CAAAA,OAAmB,IAAI,OAAO,QAAQ,KAAK,IAAI,GAAGA,KAAS,CAAC,CAAC,oDAAqD,GACpI,SAAUA,CAAAA,OAAmB,IAAI,OAAO,QAAQ,KAAK,IAAI,GAAGA,KAAS,CAAC,CAAC,oDAAoD,GAC3H,kBAAmBA,CAAAA,OAAmB,IAAI,OAAO,QAAQ,KAAK,IAAI,GAAGA,KAAS,CAAC,CAAC,iBAAiB,GACjG,mBAAoBA,CAAAA,OAAmB,IAAI,OAAO,QAAQ,KAAK,IAAI,GAAGA,KAAS,CAAC,CAAC,IAAI,GACrF,gBAAiBA,CAAAA,OAAmB,IAAI,OAAO,QAAQ,KAAK,IAAI,GAAGA,KAAS,CAAC,CAAC,sBAAsB,GAAG,EACzG;AApEA,IA0EMC,KAAU;AA1EhB,IA2EMC,KAAY;AA3ElB,IA4EMC,KAAS;AA5Ef,IA6EMC,IAAK;AA7EX,IA8EMC,KAAU;AA9EhB,IA+EMC,IAAS;AA/Ef,IAgFMC,KAAe;AAhFrB,IAiFMC,KAAWnB,EAAKkB,EAAY,EAC/B,QAAQ,SAASD,CAAM,EACvB,QAAQ,cAAc,mBAAmB,EACzC,QAAQ,WAAW,uBAAuB,EAC1C,QAAQ,eAAe,SAAS,EAChC,QAAQ,YAAY,cAAc,EAClC,QAAQ,SAAS,mBAAmB,EACpC,QAAQ,YAAY,EAAE,EACtB,SAAS;AAzFZ,IA0FMG,KAAcpB,EAAKkB,EAAY,EAClC,QAAQ,SAASD,CAAM,EACvB,QAAQ,cAAc,mBAAmB,EACzC,QAAQ,WAAW,uBAAuB,EAC1C,QAAQ,eAAe,SAAS,EAChC,QAAQ,YAAY,cAAc,EAClC,QAAQ,SAAS,mBAAmB,EACpC,QAAQ,UAAU,mCAAmC,EACrD,SAAS;AAlGZ,IAmGMI,IAAa;AAnGnB,IAoGMC,KAAY;AApGlB,IAqGMC,IAAc;AArGpB,IAsGMC,KAAMxB,EAAK,6GAA6G,EAC3H,QAAQ,SAASuB,CAAW,EAC5B,QAAQ,SAAS,8DAA8D,EAC/E,SAAS;AAzGZ,IA2GME,KAAOzB,EAAK,sCAAsC,EACrD,QAAQ,SAASiB,CAAM,EACvB,SAAS;AA7GZ,IA+GMS,IAAO;AA/Gb,IAqHMC,IAAW;AArHjB,IAsHMC,KAAO5B,EACX,6dASK,GAAG,EACP,QAAQ,WAAW2B,CAAQ,EAC3B,QAAQ,OAAOD,CAAI,EACnB,QAAQ,aAAa,0EAA0E,EAC/F,SAAS;AApIZ,IAsIMG,KAAY7B,EAAKqB,CAAU,EAC9B,QAAQ,MAAMN,CAAE,EAChB,QAAQ,WAAW,uBAAuB,EAC1C,QAAQ,aAAa,EAAE,EACvB,QAAQ,UAAU,EAAE,EACpB,QAAQ,cAAc,SAAS,EAC/B,QAAQ,UAAU,gDAAgD,EAClE,QAAQ,QAAQ,wBAAwB,EACxC,QAAQ,QAAQ,6DAA6D,EAC7E,QAAQ,OAAOW,CAAI,EACnB,SAAS;AAhJZ,IAkJMI,KAAa9B,EAAK,yCAAyC,EAC9D,QAAQ,aAAa6B,EAAS,EAC9B,SAAS;AApJZ,IA0JME,IAAc,EAClB,YAAAD,IACA,MAAMjB,IACN,KAAAW,IACA,QAAAV,IACA,SAAAE,IACA,IAAAD,GACA,MAAAa,IACA,UAAAT,IACA,MAAAM,IACA,SAAAb,IACA,WAAAiB,IACA,OAAO9B,GACP,MAAMuB,GACR;AAxKA,IAgLMU,KAAWhC,EACf,6JAEsF,EACrF,QAAQ,MAAMe,CAAE,EAChB,QAAQ,WAAW,uBAAuB,EAC1C,QAAQ,cAAc,SAAS,EAC/B,QAAQ,QAAQ,wBAAyB,EACzC,QAAQ,UAAU,gDAAgD,EAClE,QAAQ,QAAQ,wBAAwB,EACxC,QAAQ,QAAQ,6DAA6D,EAC7E,QAAQ,OAAOW,CAAI,EACnB,SAAS;AA5LZ,IA8LMO,KAAsC,EAC1C,GAAGF,GACH,UAAUX,IACV,OAAOY,IACP,WAAWhC,EAAKqB,CAAU,EACvB,QAAQ,MAAMN,CAAE,EAChB,QAAQ,WAAW,uBAAuB,EAC1C,QAAQ,aAAa,EAAE,EACvB,QAAQ,SAASiB,EAAQ,EACzB,QAAQ,cAAc,SAAS,EAC/B,QAAQ,UAAU,gDAAgD,EAClE,QAAQ,QAAQ,wBAAwB,EACxC,QAAQ,QAAQ,6DAA6D,EAC7E,QAAQ,OAAON,CAAI,EACnB,SAAS,EACd;AA7MA,IAmNMQ,KAA2C,EAC/C,GAAGH,GACH,MAAM/B,EACJ,wIAEwE,EACvE,QAAQ,WAAW2B,CAAQ,EAC3B,QAAQ,QAAQ,mKAGkB,EAClC,SAAS,GACZ,KAAK,qEACL,SAAS,0BACT,QAAQ5B,GACR,UAAU,oCACV,WAAWC,EAAKqB,CAAU,EACvB,QAAQ,MAAMN,CAAE,EAChB,QAAQ,WAAW;EAAiB,EACpC,QAAQ,YAAYI,EAAQ,EAC5B,QAAQ,UAAU,EAAE,EACpB,QAAQ,cAAc,SAAS,EAC/B,QAAQ,WAAW,EAAE,EACrB,QAAQ,SAAS,EAAE,EACnB,QAAQ,SAAS,EAAE,EACnB,QAAQ,QAAQ,EAAE,EAClB,SAAS,EACd;AA9OA,IAoPMgB,KAAS;AApPf,IAqPMC,KAAa;AArPnB,IAsPMC,KAAK;AAtPX,IAuPMC,KAAa;AAvPnB,IA0PMC,IAAe;AA1PrB,IA2PMC,IAAsB;AA3P5B,IA4PMC,KAAyB;AA5P/B,IA6PMC,KAAc1C,EAAK,yBAAyB,GAAG,EAClD,QAAQ,eAAewC,CAAmB,EAAE,SAAS;AA9PxD,IAiQMG,KAA0B;AAjQhC,IAkQMC,KAAiC;AAlQvC,IAmQMC,KAAoC;AAnQ1C,IAsQMC,KAAY9C,EAAK,0BAA0B,GAAG,EACjD,QAAQ,QAAQ,mGAAmG,EACnH,QAAQ,YAAYS,KAAqB,aAAa,WAAW,EACjE,QAAQ,QAAQ,yBAAyB,EACzC,QAAQ,QAAQ,gBAAgB,EAChC,SAAS;AA3QZ,IA6QMsC,KAAqB;AA7Q3B,IA+QMC,KAAiBhD,EAAK+C,IAAoB,GAAG,EAChD,QAAQ,UAAUR,CAAY,EAC9B,SAAS;AAjRZ,IAmRMU,KAAoBjD,EAAK+C,IAAoB,GAAG,EACnD,QAAQ,UAAUJ,EAAuB,EACzC,SAAS;AArRZ,IAuRMO,KACJ;AAxRF,IAiSMC,KAAoBnD,EAAKkD,IAAuB,IAAI,EACvD,QAAQ,kBAAkBT,EAAsB,EAChD,QAAQ,eAAeD,CAAmB,EAC1C,QAAQ,UAAUD,CAAY,EAC9B,SAAS;AArSZ,IAuSMa,KAAuBpD,EAAKkD,IAAuB,IAAI,EAC1D,QAAQ,kBAAkBL,EAAiC,EAC3D,QAAQ,eAAeD,EAA8B,EACrD,QAAQ,UAAUD,EAAuB,EACzC,SAAS;AA3SZ,IA8SMU,KAAoBrD,EACxB,oNAMiC,IAAI,EACpC,QAAQ,kBAAkByC,EAAsB,EAChD,QAAQ,eAAeD,CAAmB,EAC1C,QAAQ,UAAUD,CAAY,EAC9B,SAAS;AAzTZ,IA2TMe,KAAiBtD,EAAK,aAAa,IAAI,EAC1C,QAAQ,UAAUuC,CAAY,EAC9B,SAAS;AA7TZ,IA+TMgB,KAAWvD,EAAK,qCAAqC,EACxD,QAAQ,UAAU,8BAA8B,EAChD,QAAQ,SAAS,8IAA8I,EAC/J,SAAS;AAlUZ,IAoUMwD,KAAiBxD,EAAK2B,CAAQ,EAAE,QAAQ,aAAa,KAAK,EAAE,SAAS;AApU3E,IAqUM8B,KAAMzD,EACV,0JAKsC,EACrC,QAAQ,WAAWwD,EAAc,EACjC,QAAQ,aAAa,6EAA6E,EAClG,SAAS;AA9UZ,IAgVME,IAAe;AAhVrB,IAkVMC,KAAO3D,EAAK,mEAAmE,EAClF,QAAQ,SAAS0D,CAAY,EAC7B,QAAQ,QAAQ,yCAAyC,EACzD,QAAQ,SAAS,6DAA6D,EAC9E,SAAS;AAtVZ,IAwVME,KAAU5D,EAAK,yBAAyB,EAC3C,QAAQ,SAAS0D,CAAY,EAC7B,QAAQ,OAAOnC,CAAW,EAC1B,SAAS;AA3VZ,IA6VMsC,KAAS7D,EAAK,uBAAuB,EACxC,QAAQ,OAAOuB,CAAW,EAC1B,SAAS;AA/VZ,IAiWMuC,KAAgB9D,EAAK,yBAAyB,GAAG,EACpD,QAAQ,WAAW4D,EAAO,EAC1B,QAAQ,UAAUC,EAAM,EACxB,SAAS;AApWZ,IAsWME,KAA2B;AAtWjC,IA4WMC,IAAe,EACnB,YAAYjE,GACZ,gBAAAuD,IACA,UAAAC,IACA,WAAAT,IACA,IAAAT,IACA,MAAMD,IACN,KAAKrC,GACL,gBAAAiD,IACA,mBAAAG,IACA,mBAAAE,IACA,QAAAlB,IACA,MAAAwB,IACA,QAAAE,IACA,aAAAnB,IACA,SAAAkB,IACA,eAAAE,IACA,KAAAL,IACA,MAAMnB,IACN,KAAKvC,EACP;AAhYA,IAwYMkE,KAA6C,EACjD,GAAGD,GACH,MAAMhE,EAAK,yBAAyB,EACjC,QAAQ,SAAS0D,CAAY,EAC7B,SAAS,GACZ,SAAS1D,EAAK,+BAA+B,EAC1C,QAAQ,SAAS0D,CAAY,EAC7B,SAAS,EACd;AAhZA,IAsZMQ,IAAwC,EAC5C,GAAGF,GACH,mBAAmBZ,IACnB,gBAAgBH,IAChB,KAAKjD,EAAK,gEAAgE,EACvE,QAAQ,YAAY+D,EAAwB,EAC5C,QAAQ,SAAS,2EAA2E,EAC5F,SAAS,GACZ,YAAY,8EACZ,KAAK,2EACL,MAAM/D,EAAK,qNAAqN,EAC7N,QAAQ,YAAY+D,EAAwB,EAC5C,SAAS,EACd;AAnaA,IAyaMI,KAA2C,EAC/C,GAAGD,GACH,IAAIlE,EAAKqC,EAAE,EAAE,QAAQ,QAAQ,GAAG,EAAE,SAAS,GAC3C,MAAMrC,EAAKkE,EAAU,IAAI,EACtB,QAAQ,QAAQ,eAAe,EAC/B,QAAQ,WAAW,GAAG,EACtB,SAAS,EACd;AAhbA,IAsbaE,IAAQ,EACnB,QAAQrC,GACR,KAAKE,IACL,UAAUC,GACZ;AA1bA,IA4bamC,IAAS,EACpB,QAAQL,GACR,KAAKE,GACL,QAAQC,IACR,UAAUF,GACZ;AC9cA,IAAMK,KAAkD,EACtD,KAAK,SACL,KAAK,QACL,KAAK,QACL,KAAK,UACL,KAAK,QACP;AANA,IAOMC,KAAwBC,CAAAA,OAAeF,GAAmBE,EAAE;AAE3D,SAASrC,EAAOP,IAAc6C,GAAkB;AACrD,MAAIA,GAAAA;AACF,QAAIjE,EAAM,WAAW,KAAKoB,EAAI,EAC5B,QAAOA,GAAK,QAAQpB,EAAM,eAAe+D,EAAoB;EAAA,WAG3D/D,EAAM,mBAAmB,KAAKoB,EAAI,EACpC,QAAOA,GAAK,QAAQpB,EAAM,uBAAuB+D,EAAoB;AAIzE,SAAO3C;AACT;AAgBO,SAAS8C,EAASC,IAAc;AACrC,MAAI;AACFA,IAAAA,KAAO,UAAUA,EAAI,EAAE,QAAQnE,EAAM,eAAe,GAAG;EACzD,QAAQ;AACN,WAAO;EACT;AACA,SAAOmE;AACT;AAEO,SAASC,EAAWC,IAAkBC,GAAgB;AAG3D,MAAMC,IAAMF,GAAS,QAAQrE,EAAM,UAAU,CAACwE,GAAOC,GAAQC,MAAQ;AACjE,QAAIC,IAAU,OACVC,IAAOH;AACX,WAAO,EAAEG,KAAQ,KAAKF,EAAIE,CAAI,MAAM,OAAMD,KAAU,CAACA;AACrD,WAAIA,IAGK,MAGA;EAEX,CAAC,GACDE,IAAQN,EAAI,MAAMvE,EAAM,SAAS,GAC/B8E,IAAI;AAUR,MAPKD,EAAM,CAAC,EAAE,KAAK,KACjBA,EAAM,MAAM,GAEVA,EAAM,SAAS,KAAK,CAACA,EAAM,GAAG,EAAE,GAAG,KAAK,KAC1CA,EAAM,IAAI,GAGRP,EACF,KAAIO,EAAM,SAASP,EACjBO,GAAM,OAAOP,CAAK;MAElB,QAAOO,EAAM,SAASP,IAAOO,GAAM,KAAK,EAAE;AAI9C,SAAOC,IAAID,EAAM,QAAQC,IAEvBD,GAAMC,CAAC,IAAID,EAAMC,CAAC,EAAE,KAAK,EAAE,QAAQ9E,EAAM,WAAW,GAAG;AAEzD,SAAO6E;AACT;AAUO,SAASE,EAAML,IAAaM,GAAWC,GAAkB;AAC9D,MAAMC,IAAIR,GAAI;AACd,MAAIQ,MAAM,EACR,QAAO;AAIT,MAAIC,IAAU;AAGd,SAAOA,IAAUD,KAAG;AAClB,QAAME,IAAWV,GAAI,OAAOQ,IAAIC,IAAU,CAAC;AAC3C,QAAIC,MAAaJ,KAAK,CAACC,EACrBE;aACSC,MAAaJ,KAAKC,EAC3BE;QAEA;EAEJ;AAEA,SAAOT,GAAI,MAAM,GAAGQ,IAAIC,CAAO;AACjC;AAEO,SAASE,GAAmBX,IAAaY,GAAW;AACzD,MAAIZ,GAAI,QAAQY,EAAE,CAAC,CAAC,MAAM,GACxB,QAAO;AAGT,MAAIC,IAAQ;AACZ,WAAST,IAAI,GAAGA,IAAIJ,GAAI,QAAQI,IAC9B,KAAIJ,GAAII,CAAC,MAAM,KACbA;WACSJ,GAAII,CAAC,MAAMQ,EAAE,CAAC,EACvBC;WACSb,GAAII,CAAC,MAAMQ,EAAE,CAAC,MACvBC,KACIA,IAAQ,GACV,QAAOT;AAIb,SAAIS,IAAQ,IACH,KAGF;AACT;ACzIA,SAASC,GAAWC,IAAetC,GAA2CuC,GAAaC,GAAeC,GAA0C;AAClJ,MAAMzB,IAAOhB,EAAK,MACZ0C,IAAQ1C,EAAK,SAAS,MACtB2C,IAAOL,GAAI,CAAC,EAAE,QAAQG,EAAM,MAAM,mBAAmB,IAAI;AAE/DD,IAAM,MAAM,SAAS;AACrB,MAAMI,IAAoC,EACxC,MAAMN,GAAI,CAAC,EAAE,OAAO,CAAC,MAAM,MAAM,UAAU,QAC3C,KAAAC,GACA,MAAAvB,GACA,OAAA0B,GACA,MAAAC,GACA,QAAQH,EAAM,aAAaG,CAAI,EACjC;AACA,SAAAH,EAAM,MAAM,SAAS,OACdI;AACT;AAEA,SAASC,GAAuBN,IAAaI,GAAcF,GAAc;AACvE,MAAMK,IAAoBP,GAAI,MAAME,EAAM,MAAM,sBAAsB;AAEtE,MAAIK,MAAsB,KACxB,QAAOH;AAGT,MAAMI,IAAeD,EAAkB,CAAC;AAExC,SAAOH,EACJ,MAAM;CAAI,EACV,IAAIK,OAAQ;AACX,QAAMC,IAAoBD,EAAK,MAAMP,EAAM,MAAM,cAAc;AAC/D,QAAIQ,MAAsB,KACxB,QAAOD;AAGT,QAAM,CAACE,CAAY,IAAID;AAEvB,WAAIC,EAAa,UAAUH,EAAa,SAC/BC,EAAK,MAAMD,EAAa,MAAM,IAGhCC;EACT,CAAC,EACA,KAAK;CAAI;AACd;AAKO,IAAMG,IAAN,MAAiE;EACtE;EACA;EACA;EAEA,YAAYC,GAAuD;AACjE,SAAK,UAAUA,KAAWnH;EAC5B;EAEA,MAAMoH,GAAuC;AAC3C,QAAMf,IAAM,KAAK,MAAM,MAAM,QAAQ,KAAKe,CAAG;AAC7C,QAAIf,KAAOA,EAAI,CAAC,EAAE,SAAS,EACzB,QAAO,EACL,MAAM,SACN,KAAKA,EAAI,CAAC,EACZ;EAEJ;EAEA,KAAKe,GAAsC;AACzC,QAAMf,IAAM,KAAK,MAAM,MAAM,KAAK,KAAKe,CAAG;AAC1C,QAAIf,GAAK;AACP,UAAMK,IAAOL,EAAI,CAAC,EAAE,QAAQ,KAAK,MAAM,MAAM,kBAAkB,EAAE;AACjE,aAAO,EACL,MAAM,QACN,KAAKA,EAAI,CAAC,GACV,gBAAgB,YAChB,MAAO,KAAK,QAAQ,WAEhBK,IADAf,EAAMe,GAAM;CAAI,EAEtB;IACF;EACF;EAEA,OAAOU,GAAsC;AAC3C,QAAMf,IAAM,KAAK,MAAM,MAAM,OAAO,KAAKe,CAAG;AAC5C,QAAIf,GAAK;AACP,UAAMC,IAAMD,EAAI,CAAC,GACXK,IAAOE,GAAuBN,GAAKD,EAAI,CAAC,KAAK,IAAI,KAAK,KAAK;AAEjE,aAAO,EACL,MAAM,QACN,KAAAC,GACA,MAAMD,EAAI,CAAC,IAAIA,EAAI,CAAC,EAAE,KAAK,EAAE,QAAQ,KAAK,MAAM,OAAO,gBAAgB,IAAI,IAAIA,EAAI,CAAC,GACpF,MAAAK,EACF;IACF;EACF;EAEA,QAAQU,GAAyC;AAC/C,QAAMf,IAAM,KAAK,MAAM,MAAM,QAAQ,KAAKe,CAAG;AAC7C,QAAIf,GAAK;AACP,UAAIK,IAAOL,EAAI,CAAC,EAAE,KAAK;AAGvB,UAAI,KAAK,MAAM,MAAM,WAAW,KAAKK,CAAI,GAAG;AAC1C,YAAMW,IAAU1B,EAAMe,GAAM,GAAG;AAAA,SAC3B,KAAK,QAAQ,YAEN,CAACW,KAAW,KAAK,MAAM,MAAM,gBAAgB,KAAKA,CAAO,OAElEX,IAAOW,EAAQ,KAAK;MAExB;AAEA,aAAO,EACL,MAAM,WACN,KAAKhB,EAAI,CAAC,GACV,OAAOA,EAAI,CAAC,EAAE,QACd,MAAAK,GACA,QAAQ,KAAK,MAAM,OAAOA,CAAI,EAChC;IACF;EACF;EAEA,GAAGU,GAAoC;AACrC,QAAMf,IAAM,KAAK,MAAM,MAAM,GAAG,KAAKe,CAAG;AACxC,QAAIf,EACF,QAAO,EACL,MAAM,MACN,KAAKV,EAAMU,EAAI,CAAC,GAAG;CAAI,EACzB;EAEJ;EAEA,WAAWe,GAA4C;AACrD,QAAMf,IAAM,KAAK,MAAM,MAAM,WAAW,KAAKe,CAAG;AAChD,QAAIf,GAAK;AACP,UAAIiB,IAAQ3B,EAAMU,EAAI,CAAC,GAAG;CAAI,EAAE,MAAM;CAAI,GACtCC,IAAM,IACNI,IAAO,IACLa,IAAkB,CAAC;AAEzB,aAAOD,EAAM,SAAS,KAAG;AACvB,YAAIE,IAAe,OACbC,IAAe,CAAC,GAElB/B;AACJ,aAAKA,IAAI,GAAGA,IAAI4B,EAAM,QAAQ5B,IAE5B,KAAI,KAAK,MAAM,MAAM,gBAAgB,KAAK4B,EAAM5B,CAAC,CAAC,EAChD+B,GAAa,KAAKH,EAAM5B,CAAC,CAAC,GAC1B8B,IAAe;iBACN,CAACA,EACVC,GAAa,KAAKH,EAAM5B,CAAC,CAAC;YAE1B;AAGJ4B,YAAQA,EAAM,MAAM5B,CAAC;AAErB,YAAMgC,IAAaD,EAAa,KAAK;CAAI,GACnCE,IAAcD,EAEjB,QAAQ,KAAK,MAAM,MAAM,yBAAyB;OAAU,EAC5D,QAAQ,KAAK,MAAM,MAAM,0BAA0B,EAAE;AACxDpB,YAAMA,IAAM,GAAGA,CAAG;EAAKoB,CAAU,KAAKA,GACtChB,IAAOA,IAAO,GAAGA,CAAI;EAAKiB,CAAW,KAAKA;AAI1C,YAAMC,IAAM,KAAK,MAAM,MAAM;AAM7B,YALA,KAAK,MAAM,MAAM,MAAM,MACvB,KAAK,MAAM,YAAYD,GAAaJ,GAAQ,IAAI,GAChD,KAAK,MAAM,MAAM,MAAMK,GAGnBN,EAAM,WAAW,EACnB;AAGF,YAAMO,IAAYN,EAAO,GAAG,EAAE;AAE9B,YAAIM,GAAW,SAAS,OAEtB;AACK,YAAIA,GAAW,SAAS,cAAc;AAE3C,cAAMC,IAAWD,GACXE,IAAUD,EAAS,MAAM;IAAOR,EAAM,KAAK;CAAI,GAC/CU,IAAW,KAAK,WAAWD,CAAO;AACxCR,YAAOA,EAAO,SAAS,CAAC,IAAIS,GAE5B1B,IAAMA,EAAI,UAAU,GAAGA,EAAI,SAASwB,EAAS,IAAI,MAAM,IAAIE,EAAS,KACpEtB,IAAOA,EAAK,UAAU,GAAGA,EAAK,SAASoB,EAAS,KAAK,MAAM,IAAIE,EAAS;AACxE;QACF,WAAWH,GAAW,SAAS,QAAQ;AAErC,cAAMC,IAAWD,GACXE,IAAUD,EAAS,MAAM;IAAOR,EAAM,KAAK;CAAI,GAC/CU,IAAW,KAAK,KAAKD,CAAO;AAClCR,YAAOA,EAAO,SAAS,CAAC,IAAIS,GAE5B1B,IAAMA,EAAI,UAAU,GAAGA,EAAI,SAASuB,EAAU,IAAI,MAAM,IAAIG,EAAS,KACrEtB,IAAOA,EAAK,UAAU,GAAGA,EAAK,SAASoB,EAAS,IAAI,MAAM,IAAIE,EAAS,KACvEV,IAAQS,EAAQ,UAAUR,EAAO,GAAG,EAAE,EAAG,IAAI,MAAM,EAAE,MAAM;CAAI;AAC/D;QACF;MACF;AAEA,aAAO,EACL,MAAM,cACN,KAAAjB,GACA,QAAAiB,GACA,MAAAb,EACF;IACF;EACF;EAEA,KAAKU,GAAsC;AACzC,QAAIf,IAAM,KAAK,MAAM,MAAM,KAAK,KAAKe,CAAG;AACxC,QAAIf,GAAK;AACP,UAAIvF,IAAOuF,EAAI,CAAC,EAAE,KAAK,GACjB4B,IAAYnH,EAAK,SAAS,GAE1Be,IAAoB,EACxB,MAAM,QACN,KAAK,IACL,SAASoG,GACT,OAAOA,IAAY,CAACnH,EAAK,MAAM,GAAG,EAAE,IAAI,IACxC,OAAO,OACP,OAAO,CAAC,EACV;AAEAA,UAAOmH,IAAY,aAAanH,EAAK,MAAM,EAAE,CAAC,KAAK,KAAKA,CAAI,IAExD,KAAK,QAAQ,aACfA,IAAOmH,IAAYnH,IAAO;AAI5B,UAAMoH,IAAY,KAAK,MAAM,MAAM,cAAcpH,CAAI,GACjDqH,IAAoB;AAExB,aAAOf,KAAK;AACV,YAAIgB,IAAW,OACX9B,IAAM,IACN+B,IAAe;AAKnB,YAJI,EAAEhC,IAAM6B,EAAU,KAAKd,CAAG,MAI1B,KAAK,MAAM,MAAM,GAAG,KAAKA,CAAG,EAC9B;AAGFd,YAAMD,EAAI,CAAC,GACXe,IAAMA,EAAI,UAAUd,EAAI,MAAM;AAE9B,YAAIgC,IAAOjC,EAAI,CAAC,EAAE,MAAM;GAAM,CAAC,EAAE,CAAC,EAAE,QAAQ,KAAK,MAAM,MAAM,iBAAkBkC,OAAc,IAAI,OAAO,IAAIA,EAAE,MAAM,CAAC,GACjHC,IAAWpB,EAAI,MAAM;GAAM,CAAC,EAAE,CAAC,GAC/BqB,IAAY,CAACH,EAAK,KAAK,GAEvBvH,IAAS;AAmBb,YAlBI,KAAK,QAAQ,YACfA,IAAS,GACTsH,IAAeC,EAAK,UAAU,KACrBG,IACT1H,IAASsF,EAAI,CAAC,EAAE,SAAS,KAEzBtF,IAASsF,EAAI,CAAC,EAAE,OAAO,KAAK,MAAM,MAAM,YAAY,GACpDtF,IAASA,IAAS,IAAI,IAAIA,GAC1BsH,IAAeC,EAAK,MAAMvH,CAAM,GAChCA,KAAUsF,EAAI,CAAC,EAAE,SAGfoC,KAAa,KAAK,MAAM,MAAM,UAAU,KAAKD,CAAQ,MACvDlC,KAAOkC,IAAW;GAClBpB,IAAMA,EAAI,UAAUoB,EAAS,SAAS,CAAC,GACvCJ,IAAW,OAGT,CAACA,GAAU;AACb,cAAMM,IAAkB,KAAK,MAAM,MAAM,gBAAgB3H,CAAM,GACzD4H,KAAU,KAAK,MAAM,MAAM,QAAQ5H,CAAM,GACzC6H,KAAmB,KAAK,MAAM,MAAM,iBAAiB7H,CAAM,GAC3D8H,KAAoB,KAAK,MAAM,MAAM,kBAAkB9H,CAAM,GAC7D+H,KAAiB,KAAK,MAAM,MAAM,eAAe/H,CAAM;AAG7D,iBAAOqG,KAAK;AACV,gBAAM2B,IAAU3B,EAAI,MAAM;GAAM,CAAC,EAAE,CAAC,GAChC4B;AAgCJ,gBA/BAR,IAAWO,GAGP,KAAK,QAAQ,YACfP,IAAWA,EAAS,QAAQ,KAAK,MAAM,MAAM,oBAAoB,IAAI,GACrEQ,IAAsBR,KAEtBQ,IAAsBR,EAAS,QAAQ,KAAK,MAAM,MAAM,eAAe,MAAM,GAI3EI,GAAiB,KAAKJ,CAAQ,KAK9BK,GAAkB,KAAKL,CAAQ,KAK/BM,GAAe,KAAKN,CAAQ,KAK5BE,EAAgB,KAAKF,CAAQ,KAK7BG,GAAQ,KAAKH,CAAQ,EACvB;AAGF,gBAAIQ,EAAoB,OAAO,KAAK,MAAM,MAAM,YAAY,KAAKjI,KAAU,CAACyH,EAAS,KAAK,EACxFH,MAAgB;IAAOW,EAAoB,MAAMjI,CAAM;iBAClD;AAgBL,kBAdI0H,KAKAH,EAAK,QAAQ,KAAK,MAAM,MAAM,eAAe,MAAM,EAAE,OAAO,KAAK,MAAM,MAAM,YAAY,KAAK,KAG9FM,GAAiB,KAAKN,CAAI,KAG1BO,GAAkB,KAAKP,CAAI,KAG3BK,GAAQ,KAAKL,CAAI,EACnB;AAGFD,mBAAgB;IAAOG;YACzB;AAEI,aAACC,KAAa,CAACD,EAAS,KAAK,MAC/BC,IAAY,OAGdnC,KAAOyC,IAAU;GACjB3B,IAAMA,EAAI,UAAU2B,EAAQ,SAAS,CAAC,GACtCT,IAAOU,EAAoB,MAAMjI,CAAM;UACzC;QACF;AAEKc,UAAK,UAEJsG,IACFtG,EAAK,QAAQ,OACJ,KAAK,MAAM,MAAM,gBAAgB,KAAKyE,CAAG,MAClD6B,IAAoB;AAIxB,YAAIc,IAAiC,MACjCC;AAEA,aAAK,QAAQ,QACfD,IAAS,KAAK,MAAM,MAAM,WAAW,KAAKZ,CAAY,GAClDY,MACFC,IAAYD,EAAO,CAAC,MAAM,QAC1BZ,IAAeA,EAAa,QAAQ,KAAK,MAAM,MAAM,iBAAiB,EAAE,KAI5ExG,EAAK,MAAM,KAAK,EACd,MAAM,aACN,KAAAyE,GACA,MAAM,CAAC,CAAC2C,GACR,SAASC,GACT,OAAO,OACP,MAAMb,GACN,QAAQ,CAAC,EACX,CAAC,GAEDxG,EAAK,OAAOyE;MACd;AAGA,UAAM6C,IAAWtH,EAAK,MAAM,GAAG,EAAE;AACjC,UAAIsH,EACFA,GAAS,MAAMA,EAAS,IAAI,QAAQ,GACpCA,EAAS,OAAOA,EAAS,KAAK,QAAQ;UAGtC;AAEFtH,QAAK,MAAMA,EAAK,IAAI,QAAQ;AAG5B,eAAS6D,IAAI,GAAGA,IAAI7D,EAAK,MAAM,QAAQ6D,IAIrC,KAHA,KAAK,MAAM,MAAM,MAAM,OACvB7D,EAAK,MAAM6D,CAAC,EAAE,SAAS,KAAK,MAAM,YAAY7D,EAAK,MAAM6D,CAAC,EAAE,MAAM,CAAC,CAAC,GAEhE,CAAC7D,EAAK,OAAO;AAEf,YAAMuH,IAAUvH,EAAK,MAAM6D,CAAC,EAAE,OAAO,OAAO6C,OAAKA,EAAE,SAAS,OAAO,GAC7Dc,IAAwBD,EAAQ,SAAS,KAAKA,EAAQ,KAAKb,OAAK,KAAK,MAAM,MAAM,QAAQ,KAAKA,EAAE,GAAG,CAAC;AAE1G1G,UAAK,QAAQwH;MACf;AAIF,UAAIxH,EAAK,MACP,UAAS6D,IAAI,GAAGA,IAAI7D,EAAK,MAAM,QAAQ6D,IACrC7D,GAAK,MAAM6D,CAAC,EAAE,QAAQ;AAI1B,aAAO7D;IACT;EACF;EAEA,KAAKuF,GAAsC;AACzC,QAAMf,IAAM,KAAK,MAAM,MAAM,KAAK,KAAKe,CAAG;AAC1C,QAAIf,EAQF,QAP2B,EACzB,MAAM,QACN,OAAO,MACP,KAAKA,EAAI,CAAC,GACV,KAAKA,EAAI,CAAC,MAAM,SAASA,EAAI,CAAC,MAAM,YAAYA,EAAI,CAAC,MAAM,SAC3D,MAAMA,EAAI,CAAC,EACb;EAGJ;EAEA,IAAIe,GAAqC;AACvC,QAAMf,IAAM,KAAK,MAAM,MAAM,IAAI,KAAKe,CAAG;AACzC,QAAIf,GAAK;AACP,UAAMxC,IAAMwC,EAAI,CAAC,EAAE,YAAY,EAAE,QAAQ,KAAK,MAAM,MAAM,qBAAqB,GAAG,GAC5EtB,IAAOsB,EAAI,CAAC,IAAIA,EAAI,CAAC,EAAE,QAAQ,KAAK,MAAM,MAAM,cAAc,IAAI,EAAE,QAAQ,KAAK,MAAM,OAAO,gBAAgB,IAAI,IAAI,IACtHI,IAAQJ,EAAI,CAAC,IAAIA,EAAI,CAAC,EAAE,UAAU,GAAGA,EAAI,CAAC,EAAE,SAAS,CAAC,EAAE,QAAQ,KAAK,MAAM,OAAO,gBAAgB,IAAI,IAAIA,EAAI,CAAC;AACrH,aAAO,EACL,MAAM,OACN,KAAAxC,GACA,KAAKwC,EAAI,CAAC,GACV,MAAAtB,GACA,OAAA0B,EACF;IACF;EACF;EAEA,MAAMW,GAAuC;AAC3C,QAAMf,IAAM,KAAK,MAAM,MAAM,MAAM,KAAKe,CAAG;AAK3C,QAJI,CAACf,KAID,CAAC,KAAK,MAAM,MAAM,eAAe,KAAKA,EAAI,CAAC,CAAC,EAE9C;AAGF,QAAMiD,IAAUtE,EAAWqB,EAAI,CAAC,CAAC,GAC3BkD,IAASlD,EAAI,CAAC,EAAE,QAAQ,KAAK,MAAM,MAAM,iBAAiB,EAAE,EAAE,MAAM,GAAG,GACvEmD,IAAOnD,EAAI,CAAC,GAAG,KAAK,IAAIA,EAAI,CAAC,EAAE,QAAQ,KAAK,MAAM,MAAM,mBAAmB,EAAE,EAAE,MAAM;CAAI,IAAI,CAAC,GAE9FoD,IAAqB,EACzB,MAAM,SACN,KAAKpD,EAAI,CAAC,GACV,QAAQ,CAAC,GACT,OAAO,CAAC,GACR,MAAM,CAAC,EACT;AAEA,QAAIiD,EAAQ,WAAWC,EAAO,QAK9B;AAAA,eAAWG,KAASH,EACd,MAAK,MAAM,MAAM,gBAAgB,KAAKG,CAAK,IAC7CD,EAAK,MAAM,KAAK,OAAO,IACd,KAAK,MAAM,MAAM,iBAAiB,KAAKC,CAAK,IACrDD,EAAK,MAAM,KAAK,QAAQ,IACf,KAAK,MAAM,MAAM,eAAe,KAAKC,CAAK,IACnDD,EAAK,MAAM,KAAK,MAAM,IAEtBA,EAAK,MAAM,KAAK,IAAI;AAIxB,eAAS/D,IAAI,GAAGA,IAAI4D,EAAQ,QAAQ5D,IAClC+D,GAAK,OAAO,KAAK,EACf,MAAMH,EAAQ5D,CAAC,GACf,QAAQ,KAAK,MAAM,OAAO4D,EAAQ5D,CAAC,CAAC,GACpC,QAAQ,MACR,OAAO+D,EAAK,MAAM/D,CAAC,EACrB,CAAC;AAGH,eAAWP,KAAOqE,EAChBC,GAAK,KAAK,KAAKzE,EAAWG,GAAKsE,EAAK,OAAO,MAAM,EAAE,IAAI,CAACE,GAAMjE,OACrD,EACL,MAAMiE,GACN,QAAQ,KAAK,MAAM,OAAOA,CAAI,GAC9B,QAAQ,OACR,OAAOF,EAAK,MAAM/D,CAAC,EACrB,EACD,CAAC;AAGJ,aAAO+D;IAAAA;EACT;EAEA,SAASrC,GAAyC;AAChD,QAAMf,IAAM,KAAK,MAAM,MAAM,SAAS,KAAKe,CAAG;AAC9C,QAAIf,EACF,QAAO,EACL,MAAM,WACN,KAAKA,EAAI,CAAC,GACV,OAAOA,EAAI,CAAC,EAAE,OAAO,CAAC,MAAM,MAAM,IAAI,GACtC,MAAMA,EAAI,CAAC,GACX,QAAQ,KAAK,MAAM,OAAOA,EAAI,CAAC,CAAC,EAClC;EAEJ;EAEA,UAAUe,GAA2C;AACnD,QAAMf,IAAM,KAAK,MAAM,MAAM,UAAU,KAAKe,CAAG;AAC/C,QAAIf,GAAK;AACP,UAAMK,IAAOL,EAAI,CAAC,EAAE,OAAOA,EAAI,CAAC,EAAE,SAAS,CAAC,MAAM;IAC9CA,EAAI,CAAC,EAAE,MAAM,GAAG,EAAE,IAClBA,EAAI,CAAC;AACT,aAAO,EACL,MAAM,aACN,KAAKA,EAAI,CAAC,GACV,MAAAK,GACA,QAAQ,KAAK,MAAM,OAAOA,CAAI,EAChC;IACF;EACF;EAEA,KAAKU,GAAsC;AACzC,QAAMf,IAAM,KAAK,MAAM,MAAM,KAAK,KAAKe,CAAG;AAC1C,QAAIf,EACF,QAAO,EACL,MAAM,QACN,KAAKA,EAAI,CAAC,GACV,MAAMA,EAAI,CAAC,GACX,QAAQ,KAAK,MAAM,OAAOA,EAAI,CAAC,CAAC,EAClC;EAEJ;EAEA,OAAOe,GAAwC;AAC7C,QAAMf,IAAM,KAAK,MAAM,OAAO,OAAO,KAAKe,CAAG;AAC7C,QAAIf,EACF,QAAO,EACL,MAAM,UACN,KAAKA,EAAI,CAAC,GACV,MAAMA,EAAI,CAAC,EACb;EAEJ;EAEA,IAAIe,GAAqC;AACvC,QAAMf,IAAM,KAAK,MAAM,OAAO,IAAI,KAAKe,CAAG;AAC1C,QAAIf,EACF,QAAI,CAAC,KAAK,MAAM,MAAM,UAAU,KAAK,MAAM,MAAM,UAAU,KAAKA,EAAI,CAAC,CAAC,IACpE,KAAK,MAAM,MAAM,SAAS,OACjB,KAAK,MAAM,MAAM,UAAU,KAAK,MAAM,MAAM,QAAQ,KAAKA,EAAI,CAAC,CAAC,MACxE,KAAK,MAAM,MAAM,SAAS,QAExB,CAAC,KAAK,MAAM,MAAM,cAAc,KAAK,MAAM,MAAM,kBAAkB,KAAKA,EAAI,CAAC,CAAC,IAChF,KAAK,MAAM,MAAM,aAAa,OACrB,KAAK,MAAM,MAAM,cAAc,KAAK,MAAM,MAAM,gBAAgB,KAAKA,EAAI,CAAC,CAAC,MACpF,KAAK,MAAM,MAAM,aAAa,QAGzB,EACL,MAAM,QACN,KAAKA,EAAI,CAAC,GACV,QAAQ,KAAK,MAAM,MAAM,QACzB,YAAY,KAAK,MAAM,MAAM,YAC7B,OAAO,OACP,MAAMA,EAAI,CAAC,EACb;EAEJ;EAEA,KAAKe,GAAqD;AACxD,QAAMf,IAAM,KAAK,MAAM,OAAO,KAAK,KAAKe,CAAG;AAC3C,QAAIf,GAAK;AACP,UAAMuD,IAAavD,EAAI,CAAC,EAAE,KAAK;AAC/B,UAAI,CAAC,KAAK,QAAQ,YAAY,KAAK,MAAM,MAAM,kBAAkB,KAAKuD,CAAU,GAAG;AAEjF,YAAI,CAAE,KAAK,MAAM,MAAM,gBAAgB,KAAKA,CAAU,EACpD;AAIF,YAAMC,IAAalE,EAAMiE,EAAW,MAAM,GAAG,EAAE,GAAG,IAAI;AACtD,aAAKA,EAAW,SAASC,EAAW,UAAU,MAAM,EAClD;MAEJ,OAAO;AAEL,YAAMC,IAAiB7D,GAAmBI,EAAI,CAAC,GAAG,IAAI;AACtD,YAAIyD,MAAmB,GAErB;AAGF,YAAIA,IAAiB,IAAI;AAEvB,cAAMC,KADQ1D,EAAI,CAAC,EAAE,QAAQ,GAAG,MAAM,IAAI,IAAI,KACtBA,EAAI,CAAC,EAAE,SAASyD;AACxCzD,YAAI,CAAC,IAAIA,EAAI,CAAC,EAAE,UAAU,GAAGyD,CAAc,GAC3CzD,EAAI,CAAC,IAAIA,EAAI,CAAC,EAAE,UAAU,GAAG0D,CAAO,EAAE,KAAK,GAC3C1D,EAAI,CAAC,IAAI;QACX;MACF;AACA,UAAItB,IAAOsB,EAAI,CAAC,GACZI,IAAQ;AACZ,UAAI,KAAK,QAAQ,UAAU;AAEzB,YAAM1C,IAAO,KAAK,MAAM,MAAM,kBAAkB,KAAKgB,CAAI;AAErDhB,cACFgB,IAAOhB,EAAK,CAAC,GACb0C,IAAQ1C,EAAK,CAAC;MAElB,MACE0C,KAAQJ,EAAI,CAAC,IAAIA,EAAI,CAAC,EAAE,MAAM,GAAG,EAAE,IAAI;AAGzC,aAAAtB,IAAOA,EAAK,KAAK,GACb,KAAK,MAAM,MAAM,kBAAkB,KAAKA,CAAI,MAC1C,KAAK,QAAQ,YAAY,CAAE,KAAK,MAAM,MAAM,gBAAgB,KAAK6E,CAAU,IAE7E7E,IAAOA,EAAK,MAAM,CAAC,IAEnBA,IAAOA,EAAK,MAAM,GAAG,EAAE,IAGpBqB,GAAWC,GAAK,EACrB,MAAMtB,KAAOA,EAAK,QAAQ,KAAK,MAAM,OAAO,gBAAgB,IAAI,GAChE,OAAO0B,KAAQA,EAAM,QAAQ,KAAK,MAAM,OAAO,gBAAgB,IAAI,EACrE,GAAGJ,EAAI,CAAC,GAAG,KAAK,OAAO,KAAK,KAAK;IACnC;EACF;EAEA,QAAQe,GAAa4C,GAAoE;AACvF,QAAI3D;AACJ,SAAKA,IAAM,KAAK,MAAM,OAAO,QAAQ,KAAKe,CAAG,OACvCf,IAAM,KAAK,MAAM,OAAO,OAAO,KAAKe,CAAG,IAAI;AAC/C,UAAM6C,KAAc5D,EAAI,CAAC,KAAKA,EAAI,CAAC,GAAG,QAAQ,KAAK,MAAM,MAAM,qBAAqB,GAAG,GACjFtC,IAAOiG,EAAMC,EAAW,YAAY,CAAC;AAC3C,UAAI,CAAClG,GAAM;AACT,YAAM2C,IAAOL,EAAI,CAAC,EAAE,OAAO,CAAC;AAC5B,eAAO,EACL,MAAM,QACN,KAAKK,GACL,MAAAA,EACF;MACF;AACA,aAAON,GAAWC,GAAKtC,GAAMsC,EAAI,CAAC,GAAG,KAAK,OAAO,KAAK,KAAK;IAC7D;EACF;EAEA,SAASe,GAAa8C,GAAmBC,IAAW,IAA2C;AAC7F,QAAI/E,IAAQ,KAAK,MAAM,OAAO,eAAe,KAAKgC,CAAG;AAIrD,QAHI,CAAChC,KAGDA,EAAM,CAAC,KAAK+E,EAAS,MAAM,KAAK,MAAM,MAAM,mBAAmB,EAAG;AAItE,QAAI,EAFa/E,EAAM,CAAC,KAAKA,EAAM,CAAC,KAAK,OAExB,CAAC+E,KAAY,KAAK,MAAM,OAAO,YAAY,KAAKA,CAAQ,GAAG;AAE1E,UAAMC,IAAU,CAAC,GAAGhF,EAAM,CAAC,CAAC,EAAE,SAAS,GACnCiF,GAAQC,GAASC,IAAaH,GAASI,IAAgB,GAErDC,IAASrF,EAAM,CAAC,EAAE,CAAC,MAAM,MAAM,KAAK,MAAM,OAAO,oBAAoB,KAAK,MAAM,OAAO;AAM7F,WALAqF,EAAO,YAAY,GAGnBP,IAAYA,EAAU,MAAM,KAAK9C,EAAI,SAASgD,CAAO,IAE7ChF,IAAQqF,EAAO,KAAKP,CAAS,MAAM,QAAM;AAG/C,YAFAG,IAASjF,EAAM,CAAC,KAAKA,EAAM,CAAC,KAAKA,EAAM,CAAC,KAAKA,EAAM,CAAC,KAAKA,EAAM,CAAC,KAAKA,EAAM,CAAC,GAExE,CAACiF,EAAQ;AAIb,YAFAC,IAAU,CAAC,GAAGD,CAAM,EAAE,QAElBjF,EAAM,CAAC,KAAKA,EAAM,CAAC,GAAG;AACxBmF,eAAcD;AACd;QACF,YAAWlF,EAAM,CAAC,KAAKA,EAAM,CAAC,MACxBgF,IAAU,KAAK,GAAGA,IAAUE,KAAW,IAAI;AAC7CE,eAAiBF;AACjB;QACF;AAKF,YAFAC,KAAcD,GAEVC,IAAa,EAAG;AAGpBD,YAAU,KAAK,IAAIA,GAASA,IAAUC,IAAaC,CAAa;AAEhE,YAAME,IAAiB,CAAC,GAAGtF,EAAM,CAAC,CAAC,EAAE,CAAC,EAAE,QAClCkB,IAAMc,EAAI,MAAM,GAAGgD,IAAUhF,EAAM,QAAQsF,IAAiBJ,CAAO;AAGzE,YAAI,KAAK,IAAIF,GAASE,CAAO,IAAI,GAAG;AAClC,cAAM5D,IAAOJ,EAAI,MAAM,GAAG,EAAE;AAC5B,iBAAO,EACL,MAAM,MACN,KAAAA,GACA,MAAAI,GACA,QAAQ,KAAK,MAAM,aAAaA,CAAI,EACtC;QACF;AAGA,YAAMA,IAAOJ,EAAI,MAAM,GAAG,EAAE;AAC5B,eAAO,EACL,MAAM,UACN,KAAAA,GACA,MAAAI,GACA,QAAQ,KAAK,MAAM,aAAaA,CAAI,EACtC;MACF;IACF;EACF;EAEA,SAASU,GAA0C;AACjD,QAAMf,IAAM,KAAK,MAAM,OAAO,KAAK,KAAKe,CAAG;AAC3C,QAAIf,GAAK;AACP,UAAIK,IAAOL,EAAI,CAAC,EAAE,QAAQ,KAAK,MAAM,MAAM,mBAAmB,GAAG,GAC3DsE,IAAmB,KAAK,MAAM,MAAM,aAAa,KAAKjE,CAAI,GAC1DkE,IAA0B,KAAK,MAAM,MAAM,kBAAkB,KAAKlE,CAAI,KAAK,KAAK,MAAM,MAAM,gBAAgB,KAAKA,CAAI;AAC3H,aAAIiE,KAAoBC,MACtBlE,IAAOA,EAAK,UAAU,GAAGA,EAAK,SAAS,CAAC,IAEnC,EACL,MAAM,YACN,KAAKL,EAAI,CAAC,GACV,MAAAK,EACF;IACF;EACF;EAEA,GAAGU,GAAoC;AACrC,QAAMf,IAAM,KAAK,MAAM,OAAO,GAAG,KAAKe,CAAG;AACzC,QAAIf,EACF,QAAO,EACL,MAAM,MACN,KAAKA,EAAI,CAAC,EACZ;EAEJ;EAEA,IAAIe,GAAqC;AACvC,QAAMf,IAAM,KAAK,MAAM,OAAO,IAAI,KAAKe,CAAG;AAC1C,QAAIf,EACF,QAAO,EACL,MAAM,OACN,KAAKA,EAAI,CAAC,GACV,MAAMA,EAAI,CAAC,GACX,QAAQ,KAAK,MAAM,aAAaA,EAAI,CAAC,CAAC,EACxC;EAEJ;EAEA,SAASe,GAAsC;AAC7C,QAAMf,IAAM,KAAK,MAAM,OAAO,SAAS,KAAKe,CAAG;AAC/C,QAAIf,GAAK;AACP,UAAIK,GAAM3B;AACV,aAAIsB,EAAI,CAAC,MAAM,OACbK,IAAOL,EAAI,CAAC,GACZtB,IAAO,YAAY2B,MAEnBA,IAAOL,EAAI,CAAC,GACZtB,IAAO2B,IAGF,EACL,MAAM,QACN,KAAKL,EAAI,CAAC,GACV,MAAAK,GACA,MAAA3B,GACA,QAAQ,CACN,EACE,MAAM,QACN,KAAK2B,GACL,MAAAA,EACF,CACF,EACF;IACF;EACF;EAEA,IAAIU,GAAsC;AACxC,QAAIf;AACJ,QAAIA,IAAM,KAAK,MAAM,OAAO,IAAI,KAAKe,CAAG,GAAG;AACzC,UAAIV,GAAM3B;AACV,UAAIsB,EAAI,CAAC,MAAM,IACbK,KAAOL,EAAI,CAAC,GACZtB,IAAO,YAAY2B;WACd;AAEL,YAAImE;AACJ;AACEA,cAAcxE,EAAI,CAAC,GACnBA,EAAI,CAAC,IAAI,KAAK,MAAM,OAAO,WAAW,KAAKA,EAAI,CAAC,CAAC,IAAI,CAAC,KAAK;eACpDwE,MAAgBxE,EAAI,CAAC;AAC9BK,YAAOL,EAAI,CAAC,GACRA,EAAI,CAAC,MAAM,SACbtB,IAAO,YAAYsB,EAAI,CAAC,IAExBtB,IAAOsB,EAAI,CAAC;MAEhB;AACA,aAAO,EACL,MAAM,QACN,KAAKA,EAAI,CAAC,GACV,MAAAK,GACA,MAAA3B,GACA,QAAQ,CACN,EACE,MAAM,QACN,KAAK2B,GACL,MAAAA,EACF,CACF,EACF;IACF;EACF;EAEA,WAAWU,GAAsC;AAC/C,QAAMf,IAAM,KAAK,MAAM,OAAO,KAAK,KAAKe,CAAG;AAC3C,QAAIf,GAAK;AACP,UAAMd,IAAU,KAAK,MAAM,MAAM;AACjC,aAAO,EACL,MAAM,QACN,KAAKc,EAAI,CAAC,GACV,MAAMA,EAAI,CAAC,GACX,SAAAd,EACF;IACF;EACF;AACF;ACn2BO,IAAMuF,IAAN,MAAMC,EAAuD;EAClE;EACA;EACA;EAMQ;EACA;EAER,YAAY5D,GAAuD;AAEjE,SAAK,SAAS,CAAC,GACf,KAAK,OAAO,QAAQ,uBAAO,OAAO,IAAI,GACtC,KAAK,UAAUA,KAAWnH,GAC1B,KAAK,QAAQ,YAAY,KAAK,QAAQ,aAAa,IAAIkH,KACvD,KAAK,YAAY,KAAK,QAAQ,WAC9B,KAAK,UAAU,UAAU,KAAK,SAC9B,KAAK,UAAU,QAAQ,MACvB,KAAK,cAAc,CAAC,GACpB,KAAK,QAAQ,EACX,QAAQ,OACR,YAAY,OACZ,KAAK,KACP;AAEA,QAAMV,IAAQ,EACZ,OAAA5F,GACA,OAAO4D,EAAM,QACb,QAAQC,EAAO,OACjB;AAEI,SAAK,QAAQ,YACf+B,EAAM,QAAQhC,EAAM,UACpBgC,EAAM,SAAS/B,EAAO,YACb,KAAK,QAAQ,QACtB+B,EAAM,QAAQhC,EAAM,KAChB,KAAK,QAAQ,SACfgC,EAAM,SAAS/B,EAAO,SAEtB+B,EAAM,SAAS/B,EAAO,MAG1B,KAAK,UAAU,QAAQ+B;EACzB;EAKA,WAAW,QAAQ;AACjB,WAAO,EACL,OAAAhC,GACA,QAAAC,EACF;EACF;EAKA,OAAO,IAAoD2C,GAAaD,GAAuD;AAE7H,WADc,IAAI4D,EAAqC5D,CAAO,EACjD,IAAIC,CAAG;EACtB;EAKA,OAAO,UAA0DA,GAAaD,GAAuD;AAEnI,WADc,IAAI4D,EAAqC5D,CAAO,EACjD,aAAaC,CAAG;EAC/B;EAKA,IAAIA,GAAa;AACfA,QAAMA,EAAI,QAAQxG,EAAM,gBAAgB;CAAI,GAE5C,KAAK,YAAYwG,GAAK,KAAK,MAAM;AAEjC,aAAS1B,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA,KAAK;AAChD,UAAMsF,IAAO,KAAK,YAAYtF,CAAC;AAC/B,WAAK,aAAasF,EAAK,KAAKA,EAAK,MAAM;IACzC;AACA,WAAA,KAAK,cAAc,CAAC,GAEb,KAAK;EACd;EAOA,YAAY5D,GAAaG,IAAkB,CAAC,GAAG0D,IAAuB,OAAO;AAK3E,SAJI,KAAK,QAAQ,aACf7D,IAAMA,EAAI,QAAQxG,EAAM,eAAe,MAAM,EAAE,QAAQA,EAAM,WAAW,EAAE,IAGrEwG,KAAK;AACV,UAAIT;AAEJ,UAAI,KAAK,QAAQ,YAAY,OAAO,KAAMuE,QACpCvE,IAAQuE,EAAa,KAAK,EAAE,OAAO,KAAK,GAAG9D,GAAKG,CAAM,MACxDH,IAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK,GACV,QAEF,KACR,EACC;AAIF,UAAIA,IAAQ,KAAK,UAAU,MAAMS,CAAG,GAAG;AACrCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM;AACpC,YAAMkB,IAAYN,EAAO,GAAG,EAAE;AAC1BZ,UAAM,IAAI,WAAW,KAAKkB,MAAc,SAG1CA,EAAU,OAAO;IAEjBN,EAAO,KAAKZ,CAAK;AAEnB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,KAAKS,CAAG,GAAG;AACpCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM;AACpC,YAAMkB,IAAYN,EAAO,GAAG,EAAE;AAE1BM,WAAW,SAAS,eAAeA,GAAW,SAAS,UACzDA,EAAU,QAAQA,EAAU,IAAI,SAAS;CAAI,IAAI,KAAK;KAAQlB,EAAM,KACpEkB,EAAU,QAAQ;IAAOlB,EAAM,MAC/B,KAAK,YAAY,GAAG,EAAE,EAAG,MAAMkB,EAAU,QAEzCN,EAAO,KAAKZ,CAAK;AAEnB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,OAAOS,CAAG,GAAG;AACtCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,QAAQS,CAAG,GAAG;AACvCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,GAAGS,CAAG,GAAG;AAClCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,WAAWS,CAAG,GAAG;AAC1CA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,KAAKS,CAAG,GAAG;AACpCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,KAAKS,CAAG,GAAG;AACpCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,IAAIS,CAAG,GAAG;AACnCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM;AACpC,YAAMkB,IAAYN,EAAO,GAAG,EAAE;AAC1BM,WAAW,SAAS,eAAeA,GAAW,SAAS,UACzDA,EAAU,QAAQA,EAAU,IAAI,SAAS;CAAI,IAAI,KAAK;KAAQlB,EAAM,KACpEkB,EAAU,QAAQ;IAAOlB,EAAM,KAC/B,KAAK,YAAY,GAAG,EAAE,EAAG,MAAMkB,EAAU,QAC/B,KAAK,OAAO,MAAMlB,EAAM,GAAG,MACrC,KAAK,OAAO,MAAMA,EAAM,GAAG,IAAI,EAC7B,MAAMA,EAAM,MACZ,OAAOA,EAAM,MACf,GACAY,EAAO,KAAKZ,CAAK;AAEnB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,MAAMS,CAAG,GAAG;AACrCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,SAASS,CAAG,GAAG;AACxCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAIA,UAAIwE,IAAS/D;AACb,UAAI,KAAK,QAAQ,YAAY,YAAY;AACvC,YAAIgE,IAAa,IAAA,GACXC,IAAUjE,EAAI,MAAM,CAAC,GACvBkE;AACJ,aAAK,QAAQ,WAAW,WAAW,QAASC,OAAkB;AAC5DD,cAAYC,EAAc,KAAK,EAAE,OAAO,KAAK,GAAGF,CAAO,GACnD,OAAOC,KAAc,YAAYA,KAAa,MAChDF,IAAa,KAAK,IAAIA,GAAYE,CAAS;QAE/C,CAAC,GACGF,IAAa,IAAA,KAAYA,KAAc,MACzCD,IAAS/D,EAAI,UAAU,GAAGgE,IAAa,CAAC;MAE5C;AACA,UAAI,KAAK,MAAM,QAAQzE,IAAQ,KAAK,UAAU,UAAUwE,CAAM,IAAI;AAChE,YAAMtD,IAAYN,EAAO,GAAG,EAAE;AAC1B0D,aAAwBpD,GAAW,SAAS,eAC9CA,EAAU,QAAQA,EAAU,IAAI,SAAS;CAAI,IAAI,KAAK;KAAQlB,EAAM,KACpEkB,EAAU,QAAQ;IAAOlB,EAAM,MAC/B,KAAK,YAAY,IAAI,GACrB,KAAK,YAAY,GAAG,EAAE,EAAG,MAAMkB,EAAU,QAEzCN,EAAO,KAAKZ,CAAK,GAEnBsE,IAAuBE,EAAO,WAAW/D,EAAI,QAC7CA,IAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM;AACpC;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,KAAKS,CAAG,GAAG;AACpCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM;AACpC,YAAMkB,IAAYN,EAAO,GAAG,EAAE;AAC1BM,WAAW,SAAS,UACtBA,EAAU,QAAQA,EAAU,IAAI,SAAS;CAAI,IAAI,KAAK;KAAQlB,EAAM,KACpEkB,EAAU,QAAQ;IAAOlB,EAAM,MAC/B,KAAK,YAAY,IAAI,GACrB,KAAK,YAAY,GAAG,EAAE,EAAG,MAAMkB,EAAU,QAEzCN,EAAO,KAAKZ,CAAK;AAEnB;MACF;AAEA,UAAIS,GAAK;AACP,YAAMoE,IAAS,4BAA4BpE,EAAI,WAAW,CAAC;AAC3D,YAAI,KAAK,QAAQ,QAAQ;AACvB,kBAAQ,MAAMoE,CAAM;AACpB;QACF,MACE,OAAM,IAAI,MAAMA,CAAM;MAE1B;IACF;AAEA,WAAA,KAAK,MAAM,MAAM,MACVjE;EACT;EAEA,OAAOH,GAAaG,IAAkB,CAAC,GAAG;AACxC,WAAA,KAAK,YAAY,KAAK,EAAE,KAAAH,GAAK,QAAAG,EAAO,CAAC,GAC9BA;EACT;EAKA,aAAaH,GAAaG,IAAkB,CAAC,GAAY;AAEvD,QAAI2C,IAAY9C,GACZhC,IAAgC;AAGpC,QAAI,KAAK,OAAO,OAAO;AACrB,UAAM4E,IAAQ,OAAO,KAAK,KAAK,OAAO,KAAK;AAC3C,UAAIA,EAAM,SAAS,EACjB,SAAQ5E,IAAQ,KAAK,UAAU,MAAM,OAAO,cAAc,KAAK8E,CAAS,MAAM,OACxEF,GAAM,SAAS5E,EAAM,CAAC,EAAE,MAAMA,EAAM,CAAC,EAAE,YAAY,GAAG,IAAI,GAAG,EAAE,CAAC,MAClE8E,IAAYA,EAAU,MAAM,GAAG9E,EAAM,KAAK,IACtC,MAAM,IAAI,OAAOA,EAAM,CAAC,EAAE,SAAS,CAAC,IAAI,MACxC8E,EAAU,MAAM,KAAK,UAAU,MAAM,OAAO,cAAc,SAAS;IAI/E;AAGA,YAAQ9E,IAAQ,KAAK,UAAU,MAAM,OAAO,eAAe,KAAK8E,CAAS,MAAM,OAC7EA,KAAYA,EAAU,MAAM,GAAG9E,EAAM,KAAK,IAAI,OAAO8E,EAAU,MAAM,KAAK,UAAU,MAAM,OAAO,eAAe,SAAS;AAI3H,QAAI7E;AACJ,YAAQD,IAAQ,KAAK,UAAU,MAAM,OAAO,UAAU,KAAK8E,CAAS,MAAM,OACxE7E,KAASD,EAAM,CAAC,IAAIA,EAAM,CAAC,EAAE,SAAS,GACtC8E,IAAYA,EAAU,MAAM,GAAG9E,EAAM,QAAQC,CAAM,IAAI,MAAM,IAAI,OAAOD,EAAM,CAAC,EAAE,SAASC,IAAS,CAAC,IAAI,MAAM6E,EAAU,MAAM,KAAK,UAAU,MAAM,OAAO,UAAU,SAAS;AAI/KA,QAAY,KAAK,QAAQ,OAAO,cAAc,KAAK,EAAE,OAAO,KAAK,GAAGA,CAAS,KAAKA;AAElF,QAAIuB,IAAe,OACftB,IAAW;AACf,WAAO/C,KAAK;AACLqE,YACHtB,IAAW,KAEbsB,IAAe;AAEf,UAAI9E;AAGJ,UAAI,KAAK,QAAQ,YAAY,QAAQ,KAAMuE,QACrCvE,IAAQuE,EAAa,KAAK,EAAE,OAAO,KAAK,GAAG9D,GAAKG,CAAM,MACxDH,IAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK,GACV,QAEF,KACR,EACC;AAIF,UAAIA,IAAQ,KAAK,UAAU,OAAOS,CAAG,GAAG;AACtCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,IAAIS,CAAG,GAAG;AACnCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,KAAKS,CAAG,GAAG;AACpCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,QAAQS,GAAK,KAAK,OAAO,KAAK,GAAG;AAC1DA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM;AACpC,YAAMkB,IAAYN,EAAO,GAAG,EAAE;AAC1BZ,UAAM,SAAS,UAAUkB,GAAW,SAAS,UAC/CA,EAAU,OAAOlB,EAAM,KACvBkB,EAAU,QAAQlB,EAAM,QAExBY,EAAO,KAAKZ,CAAK;AAEnB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,SAASS,GAAK8C,GAAWC,CAAQ,GAAG;AAC7D/C,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,SAASS,CAAG,GAAG;AACxCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,GAAGS,CAAG,GAAG;AAClCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,IAAIS,CAAG,GAAG;AACnCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAIA,IAAQ,KAAK,UAAU,SAASS,CAAG,GAAG;AACxCA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAGA,UAAI,CAAC,KAAK,MAAM,WAAWA,IAAQ,KAAK,UAAU,IAAIS,CAAG,IAAI;AAC3DA,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GACpCY,EAAO,KAAKZ,CAAK;AACjB;MACF;AAIA,UAAIwE,IAAS/D;AACb,UAAI,KAAK,QAAQ,YAAY,aAAa;AACxC,YAAIgE,IAAa,IAAA,GACXC,IAAUjE,EAAI,MAAM,CAAC,GACvBkE;AACJ,aAAK,QAAQ,WAAW,YAAY,QAASC,OAAkB;AAC7DD,cAAYC,EAAc,KAAK,EAAE,OAAO,KAAK,GAAGF,CAAO,GACnD,OAAOC,KAAc,YAAYA,KAAa,MAChDF,IAAa,KAAK,IAAIA,GAAYE,CAAS;QAE/C,CAAC,GACGF,IAAa,IAAA,KAAYA,KAAc,MACzCD,IAAS/D,EAAI,UAAU,GAAGgE,IAAa,CAAC;MAE5C;AACA,UAAIzE,IAAQ,KAAK,UAAU,WAAWwE,CAAM,GAAG;AAC7C/D,YAAMA,EAAI,UAAUT,EAAM,IAAI,MAAM,GAChCA,EAAM,IAAI,MAAM,EAAE,MAAM,QAC1BwD,IAAWxD,EAAM,IAAI,MAAM,EAAE,IAE/B8E,IAAe;AACf,YAAM5D,IAAYN,EAAO,GAAG,EAAE;AAC1BM,WAAW,SAAS,UACtBA,EAAU,OAAOlB,EAAM,KACvBkB,EAAU,QAAQlB,EAAM,QAExBY,EAAO,KAAKZ,CAAK;AAEnB;MACF;AAEA,UAAIS,GAAK;AACP,YAAMoE,IAAS,4BAA4BpE,EAAI,WAAW,CAAC;AAC3D,YAAI,KAAK,QAAQ,QAAQ;AACvB,kBAAQ,MAAMoE,CAAM;AACpB;QACF,MACE,OAAM,IAAI,MAAMA,CAAM;MAE1B;IACF;AAEA,WAAOjE;EACT;AACF;AC9cO,IAAMmE,IAAN,MAAgE;EACrE;EACA;EACA,YAAYvE,GAAuD;AACjE,SAAK,UAAUA,KAAWnH;EAC5B;EAEA,MAAM2G,GAAqC;AACzC,WAAO;EACT;EAEA,KAAK,EAAE,MAAAD,GAAM,MAAAiF,GAAM,SAAApG,EAAQ,GAAgC;AACzD,QAAMqG,KAAcD,KAAQ,IAAI,MAAM/K,EAAM,aAAa,IAAI,CAAC,GAExDiL,IAAOnF,EAAK,QAAQ9F,EAAM,eAAe,EAAE,IAAI;;AAErD,WAAKgL,IAME,gCACHrJ,EAAOqJ,CAAU,IACjB,QACCrG,IAAUsG,IAAOtJ,EAAOsJ,GAAM,IAAI,KACnC;IATK,iBACFtG,IAAUsG,IAAOtJ,EAAOsJ,GAAM,IAAI,KACnC;;EAQR;EAEA,WAAW,EAAE,QAAAtE,EAAO,GAAsC;AAExD,WAAO;EADM,KAAK,OAAO,MAAMA,CAAM,CACT;;EAC9B;EAEA,KAAK,EAAE,MAAAb,EAAK,GAA6C;AACvD,WAAOA;EACT;EAEA,IAAIC,GAAmC;AACrC,WAAO;EACT;EAEA,QAAQ,EAAE,QAAAY,GAAQ,OAAAuE,EAAM,GAAmC;AACzD,WAAO,KAAKA,CAAK,IAAI,KAAK,OAAO,YAAYvE,CAAM,CAAC,MAAMuE,CAAK;;EACjE;EAEA,GAAGnF,GAAkC;AACnC,WAAO;;EACT;EAEA,KAAKA,GAAoC;AACvC,QAAMoF,IAAUpF,EAAM,SAChBqF,IAAQrF,EAAM,OAEhBsF,IAAO;AACX,aAASC,IAAI,GAAGA,IAAIvF,EAAM,MAAM,QAAQuF,KAAK;AAC3C,UAAMzC,IAAO9C,EAAM,MAAMuF,CAAC;AAC1BD,WAAQ,KAAK,SAASxC,CAAI;IAC5B;AAEA,QAAM0C,IAAOJ,IAAU,OAAO,MACxBK,IAAaL,KAAWC,MAAU,IAAM,aAAaA,IAAQ,MAAO;AAC1E,WAAO,MAAMG,IAAOC,IAAY;IAAQH,IAAO,OAAOE,IAAO;;EAC/D;EAEA,SAAS1C,GAAuC;AAC9C,QAAI4C,IAAW;AACf,QAAI5C,EAAK,MAAM;AACb,UAAM6C,IAAW,KAAK,SAAS,EAAE,SAAS,CAAC,CAAC7C,EAAK,QAAQ,CAAC;AACtDA,QAAK,QACHA,EAAK,OAAO,CAAC,GAAG,SAAS,eAC3BA,EAAK,OAAO,CAAC,EAAE,OAAO6C,IAAW,MAAM7C,EAAK,OAAO,CAAC,EAAE,MAClDA,EAAK,OAAO,CAAC,EAAE,UAAUA,EAAK,OAAO,CAAC,EAAE,OAAO,SAAS,KAAKA,EAAK,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,SAAS,WACjGA,EAAK,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,OAAO6C,IAAW,MAAM/J,EAAOkH,EAAK,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,IAAI,GACrFA,EAAK,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,UAAU,SAGrCA,EAAK,OAAO,QAAQ,EAClB,MAAM,QACN,KAAK6C,IAAW,KAChB,MAAMA,IAAW,KACjB,SAAS,KACX,CAAC,IAGHD,KAAYC,IAAW;IAE3B;AAEA,WAAAD,KAAY,KAAK,OAAO,MAAM5C,EAAK,QAAQ,CAAC,CAACA,EAAK,KAAK,GAEhD,OAAO4C,CAAQ;;EACxB;EAEA,SAAS,EAAE,SAAAE,EAAQ,GAAoC;AACrD,WAAO,aACFA,IAAU,gBAAgB,MAC3B;EACN;EAEA,UAAU,EAAE,QAAAhF,EAAO,GAAqC;AACtD,WAAO,MAAM,KAAK,OAAO,YAAYA,CAAM,CAAC;;EAC9C;EAEA,MAAMZ,GAAqC;AACzC,QAAI6F,IAAS,IAGT7C,IAAO;AACX,aAASuC,IAAI,GAAGA,IAAIvF,EAAM,OAAO,QAAQuF,IACvCvC,MAAQ,KAAK,UAAUhD,EAAM,OAAOuF,CAAC,CAAC;AAExCM,SAAU,KAAK,SAAS,EAAE,MAAM7C,EAAqB,CAAC;AAEtD,QAAIsC,IAAO;AACX,aAASC,IAAI,GAAGA,IAAIvF,EAAM,KAAK,QAAQuF,KAAK;AAC1C,UAAM/G,IAAMwB,EAAM,KAAKuF,CAAC;AAExBvC,UAAO;AACP,eAAS8C,IAAI,GAAGA,IAAItH,EAAI,QAAQsH,IAC9B9C,MAAQ,KAAK,UAAUxE,EAAIsH,CAAC,CAAC;AAG/BR,WAAQ,KAAK,SAAS,EAAE,MAAMtC,EAAqB,CAAC;IACtD;AACA,WAAIsC,MAAMA,IAAO,UAAUA,CAAI,aAExB;;IAEHO,IACA;IACAP,IACA;;EACN;EAEA,SAAS,EAAE,MAAAvF,EAAK,GAAkD;AAChE,WAAO;EAASA,CAAI;;EACtB;EAEA,UAAUC,GAAyC;AACjD,QAAM+F,IAAU,KAAK,OAAO,YAAY/F,EAAM,MAAM,GAC9CwF,IAAOxF,EAAM,SAAS,OAAO;AAInC,YAHYA,EAAM,QACd,IAAIwF,CAAI,WAAWxF,EAAM,KAAK,OAC9B,IAAIwF,CAAI,OACCO,IAAU,KAAKP,CAAI;;EAClC;EAKA,OAAO,EAAE,QAAA5E,EAAO,GAAkC;AAChD,WAAO,WAAW,KAAK,OAAO,YAAYA,CAAM,CAAC;EACnD;EAEA,GAAG,EAAE,QAAAA,EAAO,GAA8B;AACxC,WAAO,OAAO,KAAK,OAAO,YAAYA,CAAM,CAAC;EAC/C;EAEA,SAAS,EAAE,MAAAb,EAAK,GAAoC;AAClD,WAAO,SAASnE,EAAOmE,GAAM,IAAI,CAAC;EACpC;EAEA,GAAGC,GAAkC;AACnC,WAAO;EACT;EAEA,IAAI,EAAE,QAAAY,EAAO,GAA+B;AAC1C,WAAO,QAAQ,KAAK,OAAO,YAAYA,CAAM,CAAC;EAChD;EAEA,KAAK,EAAE,MAAAxC,GAAM,OAAA0B,GAAO,QAAAc,EAAO,GAAgC;AACzD,QAAMb,IAAO,KAAK,OAAO,YAAYa,CAAM,GACrCoF,IAAY7H,EAASC,CAAI;AAC/B,QAAI4H,MAAc,KAChB,QAAOjG;AAET3B,QAAO4H;AACP,QAAIC,IAAM,cAAc7H,IAAO;AAC/B,WAAI0B,MACFmG,KAAO,aAAcrK,EAAOkE,CAAK,IAAK,MAExCmG,KAAO,MAAMlG,IAAO,QACbkG;EACT;EAEA,MAAM,EAAE,MAAA7H,GAAM,OAAA0B,GAAO,MAAAC,GAAM,QAAAa,EAAO,GAAiC;AAC7DA,UACFb,IAAO,KAAK,OAAO,YAAYa,GAAQ,KAAK,OAAO,YAAY;AAEjE,QAAMoF,IAAY7H,EAASC,CAAI;AAC/B,QAAI4H,MAAc,KAChB,QAAOpK,EAAOmE,CAAI;AAEpB3B,QAAO4H;AAEP,QAAIC,IAAM,aAAa7H,CAAI,UAAU2B,CAAI;AACzC,WAAID,MACFmG,KAAO,WAAWrK,EAAOkE,CAAK,CAAC,MAEjCmG,KAAO,KACAA;EACT;EAEA,KAAKjG,GAAoD;AACvD,WAAO,YAAYA,KAASA,EAAM,SAC9B,KAAK,OAAO,YAAYA,EAAM,MAAM,IACnC,aAAaA,KAASA,EAAM,UAAUA,EAAM,OAAyBpE,EAAOoE,EAAM,IAAI;EAC7F;AACF;ACxNO,IAAMkG,IAAN,MAA6C;EAElD,OAAO,EAAE,MAAAnG,EAAK,GAAkC;AAC9C,WAAOA;EACT;EAEA,GAAG,EAAE,MAAAA,EAAK,GAA8B;AACtC,WAAOA;EACT;EAEA,SAAS,EAAE,MAAAA,EAAK,GAAoC;AAClD,WAAOA;EACT;EAEA,IAAI,EAAE,MAAAA,EAAK,GAA+B;AACxC,WAAOA;EACT;EAEA,KAAK,EAAE,MAAAA,EAAK,GAA6C;AACvD,WAAOA;EACT;EAEA,KAAK,EAAE,MAAAA,EAAK,GAA6D;AACvE,WAAOA;EACT;EAEA,KAAK,EAAE,MAAAA,EAAK,GAAgC;AAC1C,WAAO,KAAKA;EACd;EAEA,MAAM,EAAE,MAAAA,EAAK,GAAiC;AAC5C,WAAO,KAAKA;EACd;EAEA,KAAqB;AACnB,WAAO;EACT;AACF;AClCO,IAAMoG,IAAN,MAAMC,GAAwD;EACnE;EACA;EACA;EACA,YAAY5F,GAAuD;AACjE,SAAK,UAAUA,KAAWnH,GAC1B,KAAK,QAAQ,WAAW,KAAK,QAAQ,YAAY,IAAI0L,KACrD,KAAK,WAAW,KAAK,QAAQ,UAC7B,KAAK,SAAS,UAAU,KAAK,SAC7B,KAAK,SAAS,SAAS,MACvB,KAAK,eAAe,IAAImB;EAC1B;EAKA,OAAO,MAAsDtF,GAAiBJ,GAAuD;AAEnI,WADe,IAAI4F,GAAsC5F,CAAO,EAClD,MAAMI,CAAM;EAC5B;EAKA,OAAO,YAA4DA,GAAiBJ,GAAuD;AAEzI,WADe,IAAI4F,GAAsC5F,CAAO,EAClD,YAAYI,CAAM;EAClC;EAKA,MAAMA,GAAiBK,IAAM,MAAoB;AAC/C,QAAIgF,IAAM;AAEV,aAASlH,IAAI,GAAGA,IAAI6B,EAAO,QAAQ7B,KAAK;AACtC,UAAMsH,IAAWzF,EAAO7B,CAAC;AAGzB,UAAI,KAAK,QAAQ,YAAY,YAAYsH,EAAS,IAAI,GAAG;AACvD,YAAMC,IAAeD,GACfE,IAAM,KAAK,QAAQ,WAAW,UAAUD,EAAa,IAAI,EAAE,KAAK,EAAE,QAAQ,KAAK,GAAGA,CAAY;AACpG,YAAIC,MAAQ,SAAS,CAAC,CAAC,SAAS,MAAM,WAAW,QAAQ,SAAS,cAAc,QAAQ,QAAQ,OAAO,aAAa,MAAM,EAAE,SAASD,EAAa,IAAI,GAAG;AACvJL,eAAOM,KAAO;AACd;QACF;MACF;AAEA,UAAMvG,IAAQqG;AAEd,cAAQrG,EAAM,MAAM;QAClB,KAAK,SAAS;AACZiG,eAAO,KAAK,SAAS,MAAMjG,CAAK;AAChC;QACF;QACA,KAAK,MAAM;AACTiG,eAAO,KAAK,SAAS,GAAGjG,CAAK;AAC7B;QACF;QACA,KAAK,WAAW;AACdiG,eAAO,KAAK,SAAS,QAAQjG,CAAK;AAClC;QACF;QACA,KAAK,QAAQ;AACXiG,eAAO,KAAK,SAAS,KAAKjG,CAAK;AAC/B;QACF;QACA,KAAK,SAAS;AACZiG,eAAO,KAAK,SAAS,MAAMjG,CAAK;AAChC;QACF;QACA,KAAK,cAAc;AACjBiG,eAAO,KAAK,SAAS,WAAWjG,CAAK;AACrC;QACF;QACA,KAAK,QAAQ;AACXiG,eAAO,KAAK,SAAS,KAAKjG,CAAK;AAC/B;QACF;QACA,KAAK,QAAQ;AACXiG,eAAO,KAAK,SAAS,KAAKjG,CAAK;AAC/B;QACF;QACA,KAAK,OAAO;AACViG,eAAO,KAAK,SAAS,IAAIjG,CAAK;AAC9B;QACF;QACA,KAAK,aAAa;AAChBiG,eAAO,KAAK,SAAS,UAAUjG,CAAK;AACpC;QACF;QACA,KAAK,QAAQ;AACX,cAAIwG,IAAYxG,GACZsF,IAAO,KAAK,SAAS,KAAKkB,CAAS;AACvC,iBAAOzH,IAAI,IAAI6B,EAAO,UAAUA,EAAO7B,IAAI,CAAC,EAAE,SAAS,SACrDyH,KAAY5F,EAAO,EAAE7B,CAAC,GACtBuG,KAAS;IAAO,KAAK,SAAS,KAAKkB,CAAS;AAE1CvF,cACFgF,KAAO,KAAK,SAAS,UAAU,EAC7B,MAAM,aACN,KAAKX,GACL,MAAMA,GACN,QAAQ,CAAC,EAAE,MAAM,QAAQ,KAAKA,GAAM,MAAMA,GAAM,SAAS,KAAK,CAAC,EACjE,CAAC,IAEDW,KAAOX;AAET;QACF;QAEA,SAAS;AACP,cAAMT,IAAS,iBAAiB7E,EAAM,OAAO;AAC7C,cAAI,KAAK,QAAQ,OACf,QAAA,QAAQ,MAAM6E,CAAM,GACb;AAEP,gBAAM,IAAI,MAAMA,CAAM;QAE1B;MACF;IACF;AAEA,WAAOoB;EACT;EAKA,YAAYrF,GAAiB6F,IAAoF,KAAK,UAAwB;AAC5I,QAAIR,IAAM;AAEV,aAASlH,IAAI,GAAGA,IAAI6B,EAAO,QAAQ7B,KAAK;AACtC,UAAMsH,IAAWzF,EAAO7B,CAAC;AAGzB,UAAI,KAAK,QAAQ,YAAY,YAAYsH,EAAS,IAAI,GAAG;AACvD,YAAME,IAAM,KAAK,QAAQ,WAAW,UAAUF,EAAS,IAAI,EAAE,KAAK,EAAE,QAAQ,KAAK,GAAGA,CAAQ;AAC5F,YAAIE,MAAQ,SAAS,CAAC,CAAC,UAAU,QAAQ,QAAQ,SAAS,UAAU,MAAM,YAAY,MAAM,OAAO,MAAM,EAAE,SAASF,EAAS,IAAI,GAAG;AAClIJ,eAAOM,KAAO;AACd;QACF;MACF;AAEA,UAAMvG,IAAQqG;AAEd,cAAQrG,EAAM,MAAM;QAClB,KAAK,UAAU;AACbiG,eAAOQ,EAAS,KAAKzG,CAAK;AAC1B;QACF;QACA,KAAK,QAAQ;AACXiG,eAAOQ,EAAS,KAAKzG,CAAK;AAC1B;QACF;QACA,KAAK,QAAQ;AACXiG,eAAOQ,EAAS,KAAKzG,CAAK;AAC1B;QACF;QACA,KAAK,SAAS;AACZiG,eAAOQ,EAAS,MAAMzG,CAAK;AAC3B;QACF;QACA,KAAK,UAAU;AACbiG,eAAOQ,EAAS,OAAOzG,CAAK;AAC5B;QACF;QACA,KAAK,MAAM;AACTiG,eAAOQ,EAAS,GAAGzG,CAAK;AACxB;QACF;QACA,KAAK,YAAY;AACfiG,eAAOQ,EAAS,SAASzG,CAAK;AAC9B;QACF;QACA,KAAK,MAAM;AACTiG,eAAOQ,EAAS,GAAGzG,CAAK;AACxB;QACF;QACA,KAAK,OAAO;AACViG,eAAOQ,EAAS,IAAIzG,CAAK;AACzB;QACF;QACA,KAAK,QAAQ;AACXiG,eAAOQ,EAAS,KAAKzG,CAAK;AAC1B;QACF;QACA,SAAS;AACP,cAAM6E,IAAS,iBAAiB7E,EAAM,OAAO;AAC7C,cAAI,KAAK,QAAQ,OACf,QAAA,QAAQ,MAAM6E,CAAM,GACb;AAEP,gBAAM,IAAI,MAAMA,CAAM;QAE1B;MACF;IACF;AACA,WAAOoB;EACT;AACF;AC3MO,IAAMS,IAAN,MAA6D;EAClE;EACA;EAEA,YAAYlG,GAAuD;AACjE,SAAK,UAAUA,KAAWnH;EAC5B;EAEA,OAAO,mBAAmB,oBAAI,IAAI,CAChC,cACA,eACA,oBACA,cACF,CAAC;EAED,OAAO,+BAA+B,oBAAI,IAAI,CAC5C,cACA,eACA,kBACF,CAAC;EAKD,WAAWsN,GAAkB;AAC3B,WAAOA;EACT;EAKA,YAAYtL,GAAoB;AAC9B,WAAOA;EACT;EAKA,iBAAiBuF,GAA8B;AAC7C,WAAOA;EACT;EAKA,aAAaH,GAAa;AACxB,WAAOA;EACT;EAKA,eAAe;AACb,WAAO,KAAK,QAAQ0D,EAAO,MAAMA,EAAO;EAC1C;EAKA,gBAAgB;AACd,WAAO,KAAK,QAAQgC,EAAQ,QAAsCA,EAAQ;EAC5E;AACF;ACpDO,IAAMS,IAAN,MAA6D;EAClE,WAAWxN,EAA2C;EACtD,UAAU,KAAK;EAEf,QAAQ,KAAK,cAAc,IAAI;EAC/B,cAAc,KAAK,cAAc,KAAK;EAEtC,SAAS+M;EACT,WAAWpB;EACX,eAAemB;EACf,QAAQ/B;EACR,YAAY5D;EACZ,QAAQmG;EAER,eAAeG,GAAuD;AACpE,SAAK,IAAI,GAAGA,CAAI;EAClB;EAKA,WAAWjG,GAA8BkG,GAA2D;AAClG,QAAIC,IAAyB,CAAC;AAC9B,aAAW/G,KAASY,EAElB,SADAmG,IAASA,EAAO,OAAOD,EAAS,KAAK,MAAM9G,CAAK,CAAC,GACzCA,EAAM,MAAM;MAClB,KAAK,SAAS;AACZ,YAAMgH,IAAahH;AACnB,iBAAWgD,KAAQgE,EAAW,OAC5BD,KAASA,EAAO,OAAO,KAAK,WAAW/D,EAAK,QAAQ8D,CAAQ,CAAC;AAE/D,iBAAWtI,KAAOwI,EAAW,KAC3B,UAAWhE,KAAQxE,EACjBuI,KAASA,EAAO,OAAO,KAAK,WAAW/D,EAAK,QAAQ8D,CAAQ,CAAC;AAGjE;MACF;MACA,KAAK,QAAQ;AACX,YAAMG,IAAYjH;AAClB+G,YAASA,EAAO,OAAO,KAAK,WAAWE,EAAU,OAAOH,CAAQ,CAAC;AACjE;MACF;MACA,SAAS;AACP,YAAMR,IAAetG;AACjB,aAAK,SAAS,YAAY,cAAcsG,EAAa,IAAI,IAC3D,KAAK,SAAS,WAAW,YAAYA,EAAa,IAAI,EAAE,QAASY,OAAgB;AAC/E,cAAMtG,IAAS0F,EAAaY,CAAW,EAAE,KAAK,IAAA,CAAQ;AACtDH,cAASA,EAAO,OAAO,KAAK,WAAWnG,GAAQkG,CAAQ,CAAC;QAC1D,CAAC,IACQR,EAAa,WACtBS,IAASA,EAAO,OAAO,KAAK,WAAWT,EAAa,QAAQQ,CAAQ,CAAC;MAEzE;IACF;AAEF,WAAOC;EACT;EAEA,OAAOF,GAAuD;AAC5D,QAAMM,IAAwE,KAAK,SAAS,cAAc,EAAE,WAAW,CAAC,GAAG,aAAa,CAAC,EAAE;AAE3I,WAAAN,EAAK,QAASO,OAAS;AAErB,UAAMC,IAAO,EAAE,GAAGD,EAAK;AA4DvB,UAzDAC,EAAK,QAAQ,KAAK,SAAS,SAASA,EAAK,SAAS,OAG9CD,EAAK,eACPA,EAAK,WAAW,QAASE,OAAQ;AAC/B,YAAI,CAACA,EAAI,KACP,OAAM,IAAI,MAAM,yBAAyB;AAE3C,YAAI,cAAcA,GAAK;AACrB,cAAMC,IAAeJ,EAAW,UAAUG,EAAI,IAAI;AAC9CC,cAEFJ,EAAW,UAAUG,EAAI,IAAI,IAAI,YAAYT,GAAM;AACjD,gBAAIN,IAAMe,EAAI,SAAS,MAAM,MAAMT,CAAI;AACvC,mBAAIN,MAAQ,UACVA,IAAMgB,EAAa,MAAM,MAAMV,CAAI,IAE9BN;UACT,IAEAY,EAAW,UAAUG,EAAI,IAAI,IAAIA,EAAI;QAEzC;AACA,YAAI,eAAeA,GAAK;AACtB,cAAI,CAACA,EAAI,SAAUA,EAAI,UAAU,WAAWA,EAAI,UAAU,SACxD,OAAM,IAAI,MAAM,6CAA6C;AAE/D,cAAME,IAAWL,EAAWG,EAAI,KAAK;AACjCE,cACFA,EAAS,QAAQF,EAAI,SAAS,IAE9BH,EAAWG,EAAI,KAAK,IAAI,CAACA,EAAI,SAAS,GAEpCA,EAAI,UACFA,EAAI,UAAU,UACZH,EAAW,aACbA,EAAW,WAAW,KAAKG,EAAI,KAAK,IAEpCH,EAAW,aAAa,CAACG,EAAI,KAAK,IAE3BA,EAAI,UAAU,aACnBH,EAAW,cACbA,EAAW,YAAY,KAAKG,EAAI,KAAK,IAErCH,EAAW,cAAc,CAACG,EAAI,KAAK;QAI3C;AACI,yBAAiBA,KAAOA,EAAI,gBAC9BH,EAAW,YAAYG,EAAI,IAAI,IAAIA,EAAI;MAE3C,CAAC,GACDD,EAAK,aAAaF,IAIhBC,EAAK,UAAU;AACjB,YAAMX,IAAW,KAAK,SAAS,YAAY,IAAI1B,EAAwC,KAAK,QAAQ;AACpG,iBAAW0C,KAAQL,EAAK,UAAU;AAChC,cAAI,EAAEK,KAAQhB,GACZ,OAAM,IAAI,MAAM,aAAagB,CAAI,kBAAkB;AAErD,cAAI,CAAC,WAAW,QAAQ,EAAE,SAASA,CAAI,EAErC;AAEF,cAAMC,IAAeD,GACfE,IAAeP,EAAK,SAASM,CAAY,GACzCH,IAAed,EAASiB,CAAY;AAE1CjB,YAASiB,CAAY,IAAI,IAAIb,MAAoB;AAC/C,gBAAIN,IAAMoB,EAAa,MAAMlB,GAAUI,CAAI;AAC3C,mBAAIN,MAAQ,UACVA,IAAMgB,EAAa,MAAMd,GAAUI,CAAI,IAEjCN,KAAO;UACjB;QACF;AACAc,UAAK,WAAWZ;MAClB;AACA,UAAIW,EAAK,WAAW;AAClB,YAAMQ,IAAY,KAAK,SAAS,aAAa,IAAIrH,EAAyC,KAAK,QAAQ;AACvG,iBAAWkH,KAAQL,EAAK,WAAW;AACjC,cAAI,EAAEK,KAAQG,GACZ,OAAM,IAAI,MAAM,cAAcH,CAAI,kBAAkB;AAEtD,cAAI,CAAC,WAAW,SAAS,OAAO,EAAE,SAASA,CAAI,EAE7C;AAEF,cAAMI,IAAgBJ,GAChBK,IAAgBV,EAAK,UAAUS,CAAa,GAC5CE,IAAgBH,EAAUC,CAAa;AAG7CD,YAAUC,CAAa,IAAI,IAAIhB,MAAoB;AACjD,gBAAIN,IAAMuB,EAAc,MAAMF,GAAWf,CAAI;AAC7C,mBAAIN,MAAQ,UACVA,IAAMwB,EAAc,MAAMH,GAAWf,CAAI,IAEpCN;UACT;QACF;AACAc,UAAK,YAAYO;MACnB;AAGA,UAAIR,EAAK,OAAO;AACd,YAAMY,IAAQ,KAAK,SAAS,SAAS,IAAItB;AACzC,iBAAWe,KAAQL,EAAK,OAAO;AAC7B,cAAI,EAAEK,KAAQO,GACZ,OAAM,IAAI,MAAM,SAASP,CAAI,kBAAkB;AAEjD,cAAI,CAAC,WAAW,OAAO,EAAE,SAASA,CAAI,EAEpC;AAEF,cAAMQ,IAAYR,GACZS,IAAYd,EAAK,MAAMa,CAAS,GAChCE,IAAWH,EAAMC,CAAS;AAC5BvB,YAAO,iBAAiB,IAAIe,CAAI,IAElCO,EAAMC,CAAS,IAAKG,OAAiB;AACnC,gBAAI,KAAK,SAAS,SAAS1B,EAAO,6BAA6B,IAAIe,CAAI,EACrE,SAAQ,YAAW;AACjB,kBAAMlB,IAAM,MAAM2B,EAAU,KAAKF,GAAOI,CAAG;AAC3C,qBAAOD,EAAS,KAAKH,GAAOzB,CAAG;YACjC,GAAG;AAGL,gBAAMA,IAAM2B,EAAU,KAAKF,GAAOI,CAAG;AACrC,mBAAOD,EAAS,KAAKH,GAAOzB,CAAG;UACjC,IAGAyB,EAAMC,CAAS,IAAI,IAAIpB,MAAoB;AACzC,gBAAI,KAAK,SAAS,MAChB,SAAQ,YAAW;AACjB,kBAAIN,IAAM,MAAM2B,EAAU,MAAMF,GAAOnB,CAAI;AAC3C,qBAAIN,MAAQ,UACVA,IAAM,MAAM4B,EAAS,MAAMH,GAAOnB,CAAI,IAEjCN;YACT,GAAG;AAGL,gBAAIA,IAAM2B,EAAU,MAAMF,GAAOnB,CAAI;AACrC,mBAAIN,MAAQ,UACVA,IAAM4B,EAAS,MAAMH,GAAOnB,CAAI,IAE3BN;UACT;QAEJ;AACAc,UAAK,QAAQW;MACf;AAGA,UAAIZ,EAAK,YAAY;AACnB,YAAMiB,IAAa,KAAK,SAAS,YAC3BC,IAAiBlB,EAAK;AAC5BC,UAAK,aAAa,SAASrH,GAAO;AAChC,cAAI+G,IAAyB,CAAC;AAC9B,iBAAAA,EAAO,KAAKuB,EAAe,KAAK,MAAMtI,CAAK,CAAC,GACxCqI,MACFtB,IAASA,EAAO,OAAOsB,EAAW,KAAK,MAAMrI,CAAK,CAAC,IAE9C+G;QACT;MACF;AAEA,WAAK,WAAW,EAAE,GAAG,KAAK,UAAU,GAAGM,EAAK;IAC9C,CAAC,GAEM;EACT;EAEA,WAAW1N,GAAkD;AAC3D,WAAA,KAAK,WAAW,EAAE,GAAG,KAAK,UAAU,GAAGA,EAAI,GACpC;EACT;EAEA,MAAM8G,GAAaD,GAAuD;AACxE,WAAO2D,EAAO,IAAI1D,GAAKD,KAAW,KAAK,QAAQ;EACjD;EAEA,OAAOI,GAAiBJ,GAAuD;AAC7E,WAAO2F,EAAQ,MAAoCvF,GAAQJ,KAAW,KAAK,QAAQ;EACrF;EAEQ,cAAc+H,GAAoB;AAuExC,WA/D+B,CAAC9H,GAAaD,MAAsE;AACjH,UAAMgI,IAAU,EAAE,GAAGhI,EAAQ,GACvB7G,IAAM,EAAE,GAAG,KAAK,UAAU,GAAG6O,EAAQ,GAErCC,IAAa,KAAK,QAAQ,CAAC,CAAC9O,EAAI,QAAQ,CAAC,CAACA,EAAI,KAAK;AAGzD,UAAI,KAAK,SAAS,UAAU,QAAQ6O,EAAQ,UAAU,MACpD,QAAOC,EAAW,IAAI,MAAM,oIAAoI,CAAC;AAInK,UAAI,OAAOhI,IAAQ,OAAeA,MAAQ,KACxC,QAAOgI,EAAW,IAAI,MAAM,gDAAgD,CAAC;AAE/E,UAAI,OAAOhI,KAAQ,SACjB,QAAOgI,EAAW,IAAI,MAAM,0CACxB,OAAO,UAAU,SAAS,KAAKhI,CAAG,IAAI,mBAAmB,CAAC;AAQhE,UALI9G,EAAI,UACNA,EAAI,MAAM,UAAUA,GACpBA,EAAI,MAAM,QAAQ4O,IAGhB5O,EAAI,MACN,SAAQ,YAAW;AACjB,YAAM+O,IAAe/O,EAAI,QAAQ,MAAMA,EAAI,MAAM,WAAW8G,CAAG,IAAIA,GAE7DG,IAAS,OADDjH,EAAI,QAAQ,MAAMA,EAAI,MAAM,aAAa,IAAK4O,IAAYpE,EAAO,MAAMA,EAAO,WACjEuE,GAAc/O,CAAG,GACtCgP,IAAkBhP,EAAI,QAAQ,MAAMA,EAAI,MAAM,iBAAiBiH,CAAM,IAAIA;AAC3EjH,UAAI,cACN,MAAM,QAAQ,IAAI,KAAK,WAAWgP,GAAiBhP,EAAI,UAAU,CAAC;AAGpE,YAAM0B,IAAO,OADE1B,EAAI,QAAQ,MAAMA,EAAI,MAAM,cAAc,IAAK4O,IAAYpC,EAAQ,QAAQA,EAAQ,aACxEwC,GAAiBhP,CAAG;AAC9C,eAAOA,EAAI,QAAQ,MAAMA,EAAI,MAAM,YAAY0B,CAAI,IAAIA;MACzD,GAAG,EAAE,MAAMoN,CAAU;AAGvB,UAAI;AACE9O,UAAI,UACN8G,IAAM9G,EAAI,MAAM,WAAW8G,CAAG;AAGhC,YAAIG,KADUjH,EAAI,QAAQA,EAAI,MAAM,aAAa,IAAK4O,IAAYpE,EAAO,MAAMA,EAAO,WACnE1D,GAAK9G,CAAG;AACvBA,UAAI,UACNiH,IAASjH,EAAI,MAAM,iBAAiBiH,CAAM,IAExCjH,EAAI,cACN,KAAK,WAAWiH,GAAQjH,EAAI,UAAU;AAGxC,YAAI0B,KADW1B,EAAI,QAAQA,EAAI,MAAM,cAAc,IAAK4O,IAAYpC,EAAQ,QAAQA,EAAQ,aAC1EvF,GAAQjH,CAAG;AAC7B,eAAIA,EAAI,UACN0B,IAAO1B,EAAI,MAAM,YAAY0B,CAAI,IAE5BA;MACT,SAAQuN,GAAG;AACT,eAAOH,EAAWG,CAAU;MAC9B;IACF;EAGF;EAEQ,QAAQC,GAAiBC,GAAgB;AAC/C,WAAQF,OAAuC;AAG7C,UAFAA,EAAE,WAAW;4DAETC,GAAQ;AACV,YAAME,IAAM,mCACRnN,EAAOgN,EAAE,UAAU,IAAI,IAAI,IAC3B;AACJ,eAAIE,IACK,QAAQ,QAAQC,CAAG,IAErBA;MACT;AAEA,UAAID,EACF,QAAO,QAAQ,OAAOF,CAAC;AAEzB,YAAMA;IACR;EACF;AACF;AChWA,IAAMI,IAAiB,IAAIpC;AAqBpB,SAASqC,EAAOxI,IAAa9G,GAAsD;AACxF,SAAOqP,EAAe,MAAMvI,IAAK9G,CAAG;AACtC;AAOAsP,EAAO,UACPA,EAAO,aAAa,SAASzI,IAAwB;AACnD,SAAAwI,EAAe,WAAWxI,EAAO,GACjCyI,EAAO,WAAWD,EAAe,UACjC1P,EAAe2P,EAAO,QAAQ,GACvBA;AACT;AAKAA,EAAO,cAAc7P;AAErB6P,EAAO,WAAW5P;AAMlB4P,EAAO,MAAM,YAAYpC,IAAyB;AAChD,SAAAmC,EAAe,IAAI,GAAGnC,EAAI,GAC1BoC,EAAO,WAAWD,EAAe,UACjC1P,EAAe2P,EAAO,QAAQ,GACvBA;AACT;AAMAA,EAAO,aAAa,SAASrI,IAA8BkG,GAA2D;AACpH,SAAOkC,EAAe,WAAWpI,IAAQkG,CAAQ;AACnD;AASAmC,EAAO,cAAcD,EAAe;AAKpCC,EAAO,SAAS9C;AAChB8C,EAAO,SAAS9C,EAAQ;AACxB8C,EAAO,WAAWlE;AAClBkE,EAAO,eAAe/C;AACtB+C,EAAO,QAAQ9E;AACf8E,EAAO,QAAQ9E,EAAO;AACtB8E,EAAO,YAAY1I;AACnB0I,EAAO,QAAQvC;AACfuC,EAAO,QAAQA;AAER,IAAMzI,KAAUyI,EAAO;AAAvB,IACMC,KAAaD,EAAO;AAD1B,IAEME,KAAMF,EAAO;AAFnB,IAGMZ,KAAaY,EAAO;AAH1B,IAIMG,KAAcH,EAAO;AAJ3B,IAMMI,KAASC,EAAQ;AANvB,IAOMC,KAAQC,EAAO;;;AClG5B,SAAS,sBAAsB,eAAe,eAAe;AAE3D,aAAW,EAAE,KAAK,KAAK,cAAc,YAAY;AAC/C,QAAI,CAAC,cAAc,aAAa,IAAI,GAAG;AACrC,oBAAc,gBAAgB,IAAI;AAAA,IACpC;AAAA,EACF;AAGA,aAAW,EAAE,MAAM,MAAM,KAAK,cAAc,YAAY;AACtD,kBAAc,aAAa,MAAM,KAAK;AAAA,EACxC;AACF;AAMA,SAAS,iBAAiB,YAAY,YAAY;AAChD,QAAM,iBAAiB,MAAM,KAAK,WAAW,UAAU;AACvD,QAAM,iBAAiB,MAAM,KAAK,WAAW,UAAU;AACvD,QAAM,cAAc,KAAK,IAAI,eAAe,QAAQ,eAAe,MAAM;AAEzE,WAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AACpC,UAAM,cAAc,eAAe,CAAC;AACpC,UAAM,cAAc,eAAe,CAAC;AAGpC,QAAI,eAAe,CAAC,aAAa;AAC/B,iBAAW,YAAY,YAAY,UAAU,IAAI,CAAC;AAClD;AAAA,IACF;AAGA,QAAI,CAAC,eAAe,aAAa;AAC/B,iBAAW,YAAY,WAAW;AAClC;AAAA,IACF;AAGA,QAAI,eAAe,aAAa;AAE9B,UAAI,YAAY,aAAa,YAAY,YAAY,YAAY,aAAa,YAAY,UAAU;AAClG,mBAAW,aAAa,YAAY,UAAU,IAAI,GAAG,WAAW;AAChE;AAAA,MACF;AAGA,UAAI,YAAY,aAAa,KAAK,cAAc;AAE9C,8BAAsB,aAAa,WAAW;AAG9C,yBAAiB,aAAa,WAAW;AAAA,MAC3C,WAAW,YAAY,aAAa,KAAK,WAAW;AAElD,YAAI,YAAY,cAAc,YAAY,WAAW;AACnD,sBAAY,YAAY,YAAY;AAAA,QACtC;AAAA,MACF;AAAA,IAEF;AAAA,EACF;AACF;AAKO,SAAS,wBAAwB,SAAS,UAAU;AACzD,QAAM,WAAW,SAAS,cAAc,UAAU;AAClD,WAAS,YAAY,OAAU,SAAS,EAAO,MAAM,YAAY,EAAE,GAAG;AAAA,IACpE,yBAAyB;AAAA,MACvB,cAAc,CAAC,aAAa;AAAA,IAC9B;AAAA,EACF,CAAC;AACD,mBAAiB,SAAS,SAAS,OAAO;AAC5C;",
  "names": ["entries", "setPrototypeOf", "isFrozen", "getPrototypeOf", "getOwnPropertyDescriptor", "Object", "freeze", "seal", "create", "apply", "construct", "Reflect", "x", "func", "thisArg", "_len", "arguments", "length", "args", "Array", "_key", "Func", "_len2", "_key2", "arrayForEach", "unapply", "prototype", "forEach", "arrayLastIndexOf", "lastIndexOf", "arrayPop", "pop", "arrayPush", "push", "arraySplice", "splice", "stringToLowerCase", "String", "toLowerCase", "stringToString", "toString", "stringMatch", "match", "stringReplace", "replace", "stringIndexOf", "indexOf", "stringTrim", "trim", "objectHasOwnProperty", "hasOwnProperty", "regExpTest", "RegExp", "test", "typeErrorCreate", "unconstruct", "TypeError", "lastIndex", "_len3", "_key3", "_len4", "_key4", "addToSet", "set", "array", "transformCaseFunc", "l", "element", "lcElement", "cleanArray", "index", "isPropertyExist", "clone", "object", "newObject", "property", "value", "isArray", "constructor", "lookupGetter", "prop", "desc", "get", "fallbackValue", "html", "svg", "svgFilters", "svgDisallowed", "mathMl", "mathMlDisallowed", "text", "xml", "MUSTACHE_EXPR", "ERB_EXPR", "TMPLIT_EXPR", "DATA_ATTR", "ARIA_ATTR", "IS_ALLOWED_URI", "IS_SCRIPT_OR_DATA", "ATTR_WHITESPACE", "DOCTYPE_NAME", "CUSTOM_ELEMENT", "NODE_TYPE", "attribute", "cdataSection", "entityReference", "entityNode", "progressingInstruction", "comment", "document", "documentType", "documentFragment", "notation", "getGlobal", "window", "_createTrustedTypesPolicy", "trustedTypes", "purifyHostElement", "createPolicy", "suffix", "ATTR_NAME", "hasAttribute", "getAttribute", "policyName", "createHTML", "createScriptURL", "scriptUrl", "_", "console", "warn", "_createHooksMap", "afterSanitizeAttributes", "afterSanitizeElements", "afterSanitizeShadowDOM", "beforeSanitizeAttributes", "beforeSanitizeElements", "beforeSanitizeShadowDOM", "uponSanitizeAttribute", "uponSanitizeElement", "uponSanitizeShadowNode", "createDOMPurify", "undefined", "DOMPurify", "root", "version", "VERSION", "removed", "nodeType", "Element", "isSupported", "originalDocument", "currentScript", "DocumentFragment", "HTMLTemplateElement", "Node", "NodeFilter", "NamedNodeMap", "MozNamedAttrMap", "HTMLFormElement", "DOMParser", "ElementPrototype", "cloneNode", "remove", "getNextSibling", "getChildNodes", "getParentNode", "template", "createElement", "content", "ownerDocument", "trustedTypesPolicy", "emptyHTML", "implementation", "createNodeIterator", "createDocumentFragment", "getElementsByTagName", "importNode", "hooks", "createHTMLDocument", "EXPRESSIONS", "ALLOWED_TAGS", "DEFAULT_ALLOWED_TAGS", "TAGS", "ALLOWED_ATTR", "DEFAULT_ALLOWED_ATTR", "ATTRS", "CUSTOM_ELEMENT_HANDLING", "tagNameCheck", "writable", "configurable", "enumerable", "attributeNameCheck", "allowCustomizedBuiltInElements", "FORBID_TAGS", "FORBID_ATTR", "EXTRA_ELEMENT_HANDLING", "tagCheck", "attributeCheck", "ALLOW_ARIA_ATTR", "ALLOW_DATA_ATTR", "ALLOW_UNKNOWN_PROTOCOLS", "ALLOW_SELF_CLOSE_IN_ATTR", "SAFE_FOR_TEMPLATES", "SAFE_FOR_XML", "WHOLE_DOCUMENT", "SET_CONFIG", "FORCE_BODY", "RETURN_DOM", "RETURN_DOM_FRAGMENT", "RETURN_TRUSTED_TYPE", "SANITIZE_DOM", "SANITIZE_NAMED_PROPS", "SANITIZE_NAMED_PROPS_PREFIX", "KEEP_CONTENT", "IN_PLACE", "USE_PROFILES", "FORBID_CONTENTS", "DEFAULT_FORBID_CONTENTS", "DATA_URI_TAGS", "DEFAULT_DATA_URI_TAGS", "URI_SAFE_ATTRIBUTES", "DEFAULT_URI_SAFE_ATTRIBUTES", "MATHML_NAMESPACE", "SVG_NAMESPACE", "HTML_NAMESPACE", "NAMESPACE", "IS_EMPTY_INPUT", "ALLOWED_NAMESPACES", "DEFAULT_ALLOWED_NAMESPACES", "MATHML_TEXT_INTEGRATION_POINTS", "HTML_INTEGRATION_POINTS", "COMMON_SVG_AND_HTML_ELEMENTS", "PARSER_MEDIA_TYPE", "SUPPORTED_PARSER_MEDIA_TYPES", "DEFAULT_PARSER_MEDIA_TYPE", "CONFIG", "formElement", "isRegexOrFunction", "testValue", "Function", "_parseConfig", "cfg", "ADD_URI_SAFE_ATTR", "ADD_DATA_URI_TAGS", "ALLOWED_URI_REGEXP", "ADD_TAGS", "ADD_ATTR", "table", "tbody", "TRUSTED_TYPES_POLICY", "ALL_SVG_TAGS", "ALL_MATHML_TAGS", "_checkValidNamespace", "parent", "tagName", "namespaceURI", "parentTagName", "Boolean", "_forceRemove", "node", "removeChild", "_removeAttribute", "name", "getAttributeNode", "from", "removeAttribute", "setAttribute", "_initDocument", "dirty", "doc", "leadingWhitespace", "matches", "dirtyPayload", "parseFromString", "documentElement", "createDocument", "innerHTML", "body", "insertBefore", "createTextNode", "childNodes", "call", "_createNodeIterator", "SHOW_ELEMENT", "SHOW_COMMENT", "SHOW_TEXT", "SHOW_PROCESSING_INSTRUCTION", "SHOW_CDATA_SECTION", "_isClobbered", "nodeName", "textContent", "attributes", "hasChildNodes", "_isNode", "_executeHooks", "currentNode", "data", "hook", "_sanitizeElements", "allowedTags", "firstElementChild", "_isBasicCustomElement", "parentNode", "childCount", "i", "childClone", "__removalCount", "expr", "_isValidAttribute", "lcTag", "lcName", "_sanitizeAttributes", "hookEvent", "attrName", "attrValue", "keepAttr", "allowedAttributes", "forceKeepAttr", "attr", "initValue", "getAttributeType", "setAttributeNS", "_sanitizeShadowDOM", "fragment", "shadowNode", "shadowIterator", "nextNode", "sanitize", "importedNode", "returnNode", "appendChild", "firstChild", "nodeIterator", "shadowroot", "shadowrootmode", "serializedHTML", "outerHTML", "doctype", "setConfig", "clearConfig", "isValidAttribute", "tag", "addHook", "entryPoint", "hookFunction", "removeHook", "removeHooks", "removeAllHooks", "_getDefaults", "_defaults", "changeDefaults", "newDefaults", "noopTest", "edit", "regex", "opt", "source", "obj", "name", "val", "valSource", "other", "supportsLookbehind", "bull", "indent", "newline", "blockCode", "fences", "hr", "heading", "bullet", "lheadingCore", "lheading", "lheadingGfm", "_paragraph", "blockText", "_blockLabel", "def", "list", "_tag", "_comment", "html", "paragraph", "blockquote", "blockNormal", "gfmTable", "blockGfm", "blockPedantic", "escape", "inlineCode", "br", "inlineText", "_punctuation", "_punctuationOrSpace", "_notPunctuationOrSpace", "punctuation", "_punctuationGfmStrongEm", "_punctuationOrSpaceGfmStrongEm", "_notPunctuationOrSpaceGfmStrongEm", "blockSkip", "emStrongLDelimCore", "emStrongLDelim", "emStrongLDelimGfm", "emStrongRDelimAstCore", "emStrongRDelimAst", "emStrongRDelimAstGfm", "emStrongRDelimUnd", "anyPunctuation", "autolink", "_inlineComment", "tag", "_inlineLabel", "link", "reflink", "nolink", "reflinkSearch", "_caseInsensitiveProtocol", "inlineNormal", "inlinePedantic", "inlineGfm", "inlineBreaks", "block", "inline", "escapeReplacements", "getEscapeReplacement", "ch", "encode", "cleanUrl", "href", "splitCells", "tableRow", "count", "row", "match", "offset", "str", "escaped", "curr", "cells", "i", "rtrim", "c", "invert", "l", "suffLen", "currChar", "findClosingBracket", "b", "level", "outputLink", "cap", "raw", "lexer", "rules", "title", "text", "token", "indentCodeCompensation", "matchIndentToCode", "indentToCode", "node", "matchIndentInNode", "indentInNode", "_Tokenizer", "options", "src", "trimmed", "lines", "tokens", "inBlockquote", "currentLines", "currentRaw", "currentText", "top", "lastToken", "oldToken", "newText", "newToken", "isordered", "itemRegex", "endsWithBlankLine", "endEarly", "itemContents", "line", "t", "nextLine", "blankLine", "nextBulletRegex", "hrRegex", "fencesBeginRegex", "headingBeginRegex", "htmlBeginRegex", "rawLine", "nextLineWithoutTabs", "istask", "ischecked", "lastItem", "spacers", "hasMultipleLineBreaks", "headers", "aligns", "rows", "item", "align", "cell", "trimmedUrl", "rtrimSlash", "lastParenIndex", "linkLen", "links", "linkString", "maskedSrc", "prevChar", "lLength", "rDelim", "rLength", "delimTotal", "midDelimTotal", "endReg", "lastCharLength", "hasNonSpaceChars", "hasSpaceCharsOnBothEnds", "prevCapZero", "_Lexer", "__Lexer", "next", "lastParagraphClipped", "extTokenizer", "cutSrc", "startIndex", "tempSrc", "tempStart", "getStartIndex", "errMsg", "keepPrevChar", "_Renderer", "lang", "langString", "code", "depth", "ordered", "start", "body", "j", "type", "startAttr", "itemBody", "checkbox", "checked", "header", "k", "content", "cleanHref", "out", "_TextRenderer", "_Parser", "__Parser", "anyToken", "genericToken", "ret", "textToken", "renderer", "_Hooks", "markdown", "Marked", "args", "callback", "values", "tableToken", "listToken", "childTokens", "extensions", "pack", "opts", "ext", "prevRenderer", "extLevel", "prop", "rendererProp", "rendererFunc", "tokenizer", "tokenizerProp", "tokenizerFunc", "prevTokenizer", "hooks", "hooksProp", "hooksFunc", "prevHook", "arg", "walkTokens", "packWalktokens", "blockType", "origOpt", "throwError", "processedSrc", "processedTokens", "e", "silent", "async", "msg", "markedInstance", "marked", "setOptions", "use", "parseInline", "parser", "_Parser", "lexer", "_Lexer"]
}
