import {
  OverflowController
} from "./chunk-NSMHBY24.js";
import {
  Virtualizer
} from "./chunk-DIP5G4YG.js";
import {
  isChrome,
  isSafari
} from "./chunk-T3UXCKHJ.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import "./chunk-OWHE56FA.js";
import "./chunk-ULNR4UH6.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";
import "./chunk-MWWP2LZ3.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/virtual-list/src/styles/vaadin-virtual-list-base-styles.js
var virtualListStyles = css`
  :host {
    /* Don't let these properties inherit */
    --vaadin-virtual-list-padding-block: 0px;
    --vaadin-virtual-list-padding-inline: 0px;
    --vaadin-virtual-list-overflow-indicator-top-opacity: 0;
    --vaadin-virtual-list-overflow-indicator-bottom-opacity: 0;
    display: block;
    height: 400px;
    overflow: auto;
    flex: 1;
    align-self: stretch;
    box-sizing: border-box;
    padding: 0;
    --_indicator-height: var(--vaadin-virtual-list-overflow-indicator-height, 1px);
  }

  :host([hidden]) {
    display: none !important;
  }

  :host(:not([grid])) #items > ::slotted(*) {
    inset-inline: var(--vaadin-virtual-list-padding-inline);
  }

  #items {
    position: relative;
  }

  :host::before,
  :host::after {
    content: '';
    display: block;
    opacity: 0;
    position: sticky;
    inset: 0;
    z-index: 9999;
    pointer-events: none;
    box-sizing: border-box;
    height: var(--_indicator-height);
    background: var(--vaadin-border-color-secondary);
  }

  :host::before {
    margin-bottom: calc(var(--vaadin-virtual-list-padding-block) - var(--_indicator-height));
  }

  :host::after {
    margin-top: calc(var(--vaadin-virtual-list-padding-block) - var(--_indicator-height));
  }

  :host([overflow~='top'])::before {
    opacity: var(--vaadin-virtual-list-overflow-indicator-top-opacity);
  }

  :host([overflow~='bottom'])::after {
    opacity: var(--vaadin-virtual-list-overflow-indicator-bottom-opacity);
  }

  :host([theme~='overflow-indicator-top'][overflow~='top']),
  :host([theme~='overflow-indicators'][overflow~='top']) {
    --vaadin-virtual-list-overflow-indicator-top-opacity: 1;
  }

  :host([theme~='overflow-indicators'][overflow~='bottom']),
  :host([theme~='overflow-indicator-bottom'][overflow~='bottom']) {
    --vaadin-virtual-list-overflow-indicator-bottom-opacity: 1;
  }
`;

// node_modules/@vaadin/virtual-list/src/vaadin-virtual-list-mixin.js
var VirtualListMixin = (superClass) => class VirtualListMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * An array containing items determining how many instances to render.
       * @type {Array<!VirtualListItem> | undefined}
       */
      items: { type: Array, sync: true },
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The render target element representing one item at a time.
       * - `virtualList` The reference to the `<vaadin-virtual-list>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       * @type {VirtualListRenderer | undefined}
       */
      renderer: { type: Function, sync: true },
      /**
       * A function that generates accessible names for virtual list items.
       * The function gets the item as an argument and the
       * return value should be a string representing that item. The
       * result gets applied to the corresponding virtual list child element
       * as an `aria-label` attribute.
       */
      itemAccessibleNameGenerator: {
        type: Function,
        sync: true
      },
      /** @private */
      __virtualizer: Object
    };
  }
  static get observers() {
    return ["__itemsOrRendererChanged(items, renderer, __virtualizer, itemAccessibleNameGenerator)"];
  }
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @return {number}
   */
  get firstVisibleIndex() {
    return this.__virtualizer.firstVisibleIndex;
  }
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @return {number}
   */
  get lastVisibleIndex() {
    return this.__virtualizer.lastVisibleIndex;
  }
  constructor() {
    super();
    this.__onDocumentDragStart = this.__onDocumentDragStart.bind(this);
  }
  /** @protected */
  ready() {
    super.ready();
    this.__virtualizer = new Virtualizer({
      createElements: this.__createElements,
      updateElement: this.__updateElement.bind(this),
      elementsContainer: this,
      scrollTarget: this,
      scrollContainer: this.shadowRoot.querySelector("#items"),
      reorderElements: true
    });
    this.__overflowController = new OverflowController(this);
    this.addController(this.__overflowController);
    this.__updateAria();
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.addEventListener("dragstart", this.__onDocumentDragStart, { capture: true });
    this.__virtualizer.hostConnected();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("dragstart", this.__onDocumentDragStart, { capture: true });
  }
  /**
   * Scroll to a specific index in the virtual list.
   *
   * @param {number} index Index to scroll to
   */
  scrollToIndex(index) {
    this.__virtualizer.scrollToIndex(index);
  }
  /** @private */
  __createElements(count) {
    return [...Array(count)].map(() => document.createElement("div"));
  }
  /** @private */
  __updateAria() {
    this.role = "list";
  }
  /** @private */
  __updateElement(el, index) {
    const item = this.items[index];
    el.ariaSetSize = String(this.items.length);
    el.ariaPosInSet = String(index + 1);
    el.ariaLabel = this.itemAccessibleNameGenerator ? this.itemAccessibleNameGenerator(item) : null;
    this.__updateElementRole(el);
    if (el.__renderer !== this.renderer) {
      el.__renderer = this.renderer;
      this.__clearRenderTargetContent(el);
    }
    if (this.renderer) {
      this.renderer(el, this, { item, index });
    }
  }
  /** @private */
  __updateElementRole(el) {
    el.role = "listitem";
  }
  /**
   * Clears the content of a render target.
   * @private
   */
  __clearRenderTargetContent(element) {
    element.innerHTML = "";
    delete element._$litPart$;
  }
  /** @private */
  __itemsOrRendererChanged(items, renderer, virtualizer) {
    const hasRenderedItems = this.childElementCount > 0;
    if ((renderer || hasRenderedItems) && virtualizer) {
      virtualizer.size = (items || []).length;
      virtualizer.update();
    }
  }
  /**
   * Webkit-based browsers have issues with generating drag images
   * for elements that have children with massive heights. Chromium
   * browsers crash, while Safari experiences significant performance
   * issues. To mitigate these issues, we hide the items container
   * when drag starts to remove it from the drag image.
   *
   * Virtual lists with fewer rows also have issues on Chromium and Safari
   * where the drag image is not properly clipped and may include
   * content outside the virtual list. Temporary inline styles are applied
   * to mitigate this issue.
   *
   * Related issues:
   * - https://github.com/vaadin/web-components/issues/7985
   * - https://issues.chromium.org/issues/383356871
   * - https://github.com/vaadin/web-components/issues/8386
   *
   * @private
   */
  __onDocumentDragStart(e) {
    if (e.target.contains(this)) {
      const elements = [e.target, this.$.items];
      const originalInlineStyles = elements.map((element) => element.style.cssText);
      if (this.scrollHeight > 2e4) {
        this.$.items.style.display = "none";
      }
      if (isChrome) {
        e.target.style.willChange = "transform";
      }
      if (isSafari) {
        this.$.items.style.maxHeight = "100%";
      }
      requestAnimationFrame(() => {
        elements.forEach((element, index) => {
          element.style.cssText = originalInlineStyles[index];
        });
      });
    }
  }
  /**
   * Requests an update for the content of the rows.
   * While performing the update, it invokes the renderer passed in the `renderer` property for each visible row.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this.__virtualizer) {
      this.__virtualizer.update();
    }
  }
};

// node_modules/@vaadin/virtual-list/src/vaadin-virtual-list.js
var VirtualList = class extends VirtualListMixin(ThemableMixin(ElementMixin(PolylitMixin(LitElement)))) {
  static get is() {
    return "vaadin-virtual-list";
  }
  static get styles() {
    return virtualListStyles;
  }
  /** @protected */
  render() {
    return html`
      <div id="items">
        <slot></slot>
      </div>
    `;
  }
};
defineCustomElement(VirtualList);
export {
  VirtualList
};
//# sourceMappingURL=@vaadin_virtual-list_src_vaadin-virtual-list__js.js.map
