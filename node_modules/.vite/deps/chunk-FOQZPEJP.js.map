{
  "version": 3,
  "sources": ["../../@vaadin/overlay/src/vaadin-overlay-position-mixin.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2017 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { getAncestorRootNodes } from '@vaadin/component-base/src/dom-utils.js';\nimport { observeMove, setOverlayStateAttribute } from './vaadin-overlay-utils.js';\n\nconst PROP_NAMES_VERTICAL = {\n  start: 'top',\n  end: 'bottom',\n};\n\nconst PROP_NAMES_HORIZONTAL = {\n  start: 'left',\n  end: 'right',\n};\n\nconst targetResizeObserver = new ResizeObserver((entries) => {\n  setTimeout(() => {\n    entries.forEach((entry) => {\n      if (entry.target.__overlay) {\n        entry.target.__overlay._updatePosition();\n      }\n    });\n  });\n});\n\n/**\n * @polymerMixin\n */\nexport const PositionMixin = (superClass) =>\n  class PositionMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * The element next to which this overlay should be aligned.\n         * The position of the overlay relative to the positionTarget can be adjusted\n         * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`\n         * and `noVerticalOverlap`.\n         */\n        positionTarget: {\n          type: Object,\n          value: null,\n          sync: true,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether to align the overlay's\n         * left or right side to the target element by default.\n         * Possible values are `start` and `end`.\n         * RTL is taken into account when interpreting the value.\n         * The overlay is automatically flipped to the opposite side when it doesn't fit into\n         * the default side defined by this property.\n         *\n         * @attr {start|end} horizontal-align\n         */\n        horizontalAlign: {\n          type: String,\n          value: 'start',\n          sync: true,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether to align the overlay's\n         * top or bottom side to the target element by default.\n         * Possible values are `top` and `bottom`.\n         * The overlay is automatically flipped to the opposite side when it doesn't fit into\n         * the default side defined by this property.\n         *\n         * @attr {top|bottom} vertical-align\n         */\n        verticalAlign: {\n          type: String,\n          value: 'top',\n          sync: true,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether the overlay should overlap\n         * the target element in the x-axis, or be positioned right next to it.\n         *\n         * @attr {boolean} no-horizontal-overlap\n         */\n        noHorizontalOverlap: {\n          type: Boolean,\n          value: false,\n          sync: true,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether the overlay should overlap\n         * the target element in the y-axis, or be positioned right above/below it.\n         *\n         * @attr {boolean} no-vertical-overlap\n         */\n        noVerticalOverlap: {\n          type: Boolean,\n          value: false,\n          sync: true,\n        },\n\n        /**\n         * If the overlay content has no intrinsic height, this property can be used to set\n         * the minimum vertical space (in pixels) required by the overlay. Setting a value to\n         * the property effectively disables the content measurement in favor of using this\n         * fixed value for determining the open direction.\n         *\n         * @attr {number} required-vertical-space\n         */\n        requiredVerticalSpace: {\n          type: Number,\n          value: 0,\n          sync: true,\n        },\n      };\n    }\n\n    constructor() {\n      super();\n\n      this.__onScroll = this.__onScroll.bind(this);\n      this._updatePosition = this._updatePosition.bind(this);\n    }\n\n    /** @protected */\n    connectedCallback() {\n      super.connectedCallback();\n\n      if (this.opened) {\n        this.__addUpdatePositionEventListeners();\n      }\n    }\n\n    /** @protected */\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.__removeUpdatePositionEventListeners();\n    }\n\n    /** @protected */\n    updated(props) {\n      super.updated(props);\n\n      if (props.has('positionTarget')) {\n        const oldTarget = props.get('positionTarget');\n\n        // 1. When position target is removed, always reset position settings\n        // 2. When position target is set, reset if overlay was opened before\n        if ((!this.positionTarget && oldTarget) || (this.positionTarget && !oldTarget && !!this.__margins)) {\n          this.__resetPosition();\n        }\n      }\n\n      if (props.has('opened') || props.has('positionTarget')) {\n        this.__updatePositionSettings(this.opened, this.positionTarget);\n      }\n\n      const positionProps = [\n        'horizontalAlign',\n        'verticalAlign',\n        'noHorizontalOverlap',\n        'noVerticalOverlap',\n        'requiredVerticalSpace',\n      ];\n      if (positionProps.some((prop) => props.has(prop))) {\n        this._updatePosition();\n      }\n    }\n\n    /** @private */\n    __addUpdatePositionEventListeners() {\n      window.visualViewport.addEventListener('resize', this._updatePosition);\n      window.visualViewport.addEventListener('scroll', this.__onScroll, true);\n\n      this.__positionTargetAncestorRootNodes = getAncestorRootNodes(this.positionTarget);\n      this.__positionTargetAncestorRootNodes.forEach((node) => {\n        node.addEventListener('scroll', this.__onScroll, true);\n      });\n\n      if (this.positionTarget) {\n        this.__observePositionTargetMove = observeMove(this.positionTarget, () => {\n          this._updatePosition();\n        });\n      }\n    }\n\n    /** @private */\n    __removeUpdatePositionEventListeners() {\n      window.visualViewport.removeEventListener('resize', this._updatePosition);\n      window.visualViewport.removeEventListener('scroll', this.__onScroll, true);\n\n      if (this.__positionTargetAncestorRootNodes) {\n        this.__positionTargetAncestorRootNodes.forEach((node) => {\n          node.removeEventListener('scroll', this.__onScroll, true);\n        });\n        this.__positionTargetAncestorRootNodes = null;\n      }\n\n      if (this.__observePositionTargetMove) {\n        this.__observePositionTargetMove();\n        this.__observePositionTargetMove = null;\n      }\n    }\n\n    /** @private */\n    __updatePositionSettings(opened, positionTarget) {\n      this.__removeUpdatePositionEventListeners();\n\n      if (positionTarget) {\n        positionTarget.__overlay = null;\n        targetResizeObserver.unobserve(positionTarget);\n\n        if (opened) {\n          this.__addUpdatePositionEventListeners();\n          positionTarget.__overlay = this;\n          targetResizeObserver.observe(positionTarget);\n        }\n      }\n\n      if (opened) {\n        const computedStyle = getComputedStyle(this);\n        if (!this.__margins) {\n          this.__margins = {};\n          ['top', 'bottom', 'left', 'right'].forEach((propName) => {\n            this.__margins[propName] = parseInt(computedStyle[propName], 10);\n          });\n        }\n\n        this._updatePosition();\n        // Schedule another position update (to cover virtual keyboard opening for example)\n        requestAnimationFrame(() => this._updatePosition());\n      }\n    }\n\n    /** @private */\n    __onScroll(e) {\n      // If the scroll event occurred inside the overlay, ignore it.\n      if (e.target instanceof Node && this._deepContains(e.target)) {\n        return;\n      }\n\n      this._updatePosition();\n    }\n\n    /** @private */\n    __resetPosition() {\n      this.__margins = null;\n\n      Object.assign(this.style, {\n        justifyContent: '',\n        alignItems: '',\n        top: '',\n        bottom: '',\n        left: '',\n        right: '',\n      });\n\n      setOverlayStateAttribute(this, 'bottom-aligned', false);\n      setOverlayStateAttribute(this, 'top-aligned', false);\n      setOverlayStateAttribute(this, 'end-aligned', false);\n      setOverlayStateAttribute(this, 'start-aligned', false);\n    }\n\n    _updatePosition() {\n      if (!this.positionTarget || !this.opened || !this.__margins) {\n        return;\n      }\n\n      const targetRect = this.positionTarget.getBoundingClientRect();\n\n      if (targetRect.width === 0 && targetRect.height === 0 && this.opened) {\n        this.opened = false;\n        return;\n      }\n\n      // Detect the desired alignment and update the layout accordingly\n      const shouldAlignStartVertically = this.__shouldAlignStartVertically(targetRect);\n      this.style.justifyContent = shouldAlignStartVertically ? 'flex-start' : 'flex-end';\n\n      const isRTL = this.__isRTL;\n      const shouldAlignStartHorizontally = this.__shouldAlignStartHorizontally(targetRect, isRTL);\n      const flexStart = (!isRTL && shouldAlignStartHorizontally) || (isRTL && !shouldAlignStartHorizontally);\n      this.style.alignItems = flexStart ? 'flex-start' : 'flex-end';\n\n      // Get the overlay rect after possible overlay alignment changes\n      const overlayRect = this.getBoundingClientRect();\n\n      // Obtain vertical positioning properties\n      const verticalProps = this.__calculatePositionInOneDimension(\n        targetRect,\n        overlayRect,\n        this.noVerticalOverlap,\n        PROP_NAMES_VERTICAL,\n        this,\n        shouldAlignStartVertically,\n      );\n\n      // Obtain horizontal positioning properties\n      const horizontalProps = this.__calculatePositionInOneDimension(\n        targetRect,\n        overlayRect,\n        this.noHorizontalOverlap,\n        PROP_NAMES_HORIZONTAL,\n        this,\n        shouldAlignStartHorizontally,\n      );\n\n      // Apply the positioning properties to the overlay\n      Object.assign(this.style, verticalProps, horizontalProps);\n\n      setOverlayStateAttribute(this, 'bottom-aligned', !shouldAlignStartVertically);\n      setOverlayStateAttribute(this, 'top-aligned', shouldAlignStartVertically);\n\n      setOverlayStateAttribute(this, 'end-aligned', !flexStart);\n      setOverlayStateAttribute(this, 'start-aligned', flexStart);\n    }\n\n    __shouldAlignStartHorizontally(targetRect, rtl) {\n      // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n      // smaller than its current space before the fit-calculations.\n      const contentWidth = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);\n      this.__oldContentWidth = this.$.overlay.offsetWidth;\n\n      const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n      const defaultAlignLeft = (!rtl && this.horizontalAlign === 'start') || (rtl && this.horizontalAlign === 'end');\n\n      return this.__shouldAlignStart(\n        targetRect,\n        contentWidth,\n        viewportWidth,\n        this.__margins,\n        defaultAlignLeft,\n        this.noHorizontalOverlap,\n        PROP_NAMES_HORIZONTAL,\n      );\n    }\n\n    __shouldAlignStartVertically(targetRect) {\n      // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n      // smaller than its current space before the fit-calculations.\n      const contentHeight =\n        this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);\n      this.__oldContentHeight = this.$.overlay.offsetHeight;\n\n      const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n      const defaultAlignTop = this.verticalAlign === 'top';\n\n      return this.__shouldAlignStart(\n        targetRect,\n        contentHeight,\n        viewportHeight,\n        this.__margins,\n        defaultAlignTop,\n        this.noVerticalOverlap,\n        PROP_NAMES_VERTICAL,\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/max-params\n    __shouldAlignStart(targetRect, contentSize, viewportSize, margins, defaultAlignStart, noOverlap, propNames) {\n      const spaceForStartAlignment =\n        viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];\n      const spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];\n\n      const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;\n      const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;\n\n      const shouldGoToDefaultSide =\n        spaceForDefaultAlignment > spaceForOtherAlignment || spaceForDefaultAlignment > contentSize;\n\n      return defaultAlignStart === shouldGoToDefaultSide;\n    }\n\n    /**\n     * Returns an adjusted value after resizing the browser window,\n     * to avoid wrong calculations when e.g. previously set `bottom`\n     * CSS property value is larger than the updated viewport height.\n     * See https://github.com/vaadin/web-components/issues/4604\n     */\n    __adjustBottomProperty(cssPropNameToSet, propNames, currentValue) {\n      let adjustedProp;\n\n      if (cssPropNameToSet === propNames.end) {\n        // Adjust horizontally\n        if (propNames.end === PROP_NAMES_VERTICAL.end) {\n          const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n\n          if (currentValue > viewportHeight && this.__oldViewportHeight) {\n            const heightDiff = this.__oldViewportHeight - viewportHeight;\n            adjustedProp = currentValue - heightDiff;\n          }\n\n          this.__oldViewportHeight = viewportHeight;\n        }\n\n        // Adjust vertically\n        if (propNames.end === PROP_NAMES_HORIZONTAL.end) {\n          const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n\n          if (currentValue > viewportWidth && this.__oldViewportWidth) {\n            const widthDiff = this.__oldViewportWidth - viewportWidth;\n            adjustedProp = currentValue - widthDiff;\n          }\n\n          this.__oldViewportWidth = viewportWidth;\n        }\n      }\n\n      return adjustedProp;\n    }\n\n    /**\n     * Returns an object with CSS position properties to set,\n     * e.g. { top: \"100px\" }\n     */\n    // eslint-disable-next-line @typescript-eslint/max-params\n    __calculatePositionInOneDimension(targetRect, overlayRect, noOverlap, propNames, overlay, shouldAlignStart) {\n      const cssPropNameToSet = shouldAlignStart ? propNames.start : propNames.end;\n      const cssPropNameToClear = shouldAlignStart ? propNames.end : propNames.start;\n\n      const currentValue = parseFloat(overlay.style[cssPropNameToSet] || getComputedStyle(overlay)[cssPropNameToSet]);\n      const adjustedValue = this.__adjustBottomProperty(cssPropNameToSet, propNames, currentValue);\n\n      const diff =\n        overlayRect[shouldAlignStart ? propNames.start : propNames.end] -\n        targetRect[noOverlap === shouldAlignStart ? propNames.end : propNames.start];\n\n      const valueToSet = adjustedValue\n        ? `${adjustedValue}px`\n        : `${currentValue + diff * (shouldAlignStart ? -1 : 1)}px`;\n\n      return {\n        [cssPropNameToSet]: valueToSet,\n        [cssPropNameToClear]: '',\n      };\n    }\n  };\n"],
  "mappings": "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",
  "names": []
}
