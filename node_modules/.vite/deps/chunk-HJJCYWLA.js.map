{
  "version": 3,
  "sources": ["../../@vaadin/a11y-base/src/keyboard-direction-mixin.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2022 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { isElementFocused, isElementHidden } from './focus-utils.js';\nimport { KeyboardMixin } from './keyboard-mixin.js';\n\n/**\n * A mixin for navigating items with keyboard.\n *\n * @polymerMixin\n * @mixes KeyboardMixin\n */\nexport const KeyboardDirectionMixin = (superclass) =>\n  class KeyboardDirectionMixinClass extends KeyboardMixin(superclass) {\n    /**\n     * @return {Element | null}\n     * @protected\n     */\n    get focused() {\n      return (this._getItems() || []).find(isElementFocused);\n    }\n\n    /**\n     * @return {boolean}\n     * @protected\n     */\n    get _vertical() {\n      return true;\n    }\n\n    /**\n     * @return {boolean}\n     * @protected\n     */\n    get _tabNavigation() {\n      return false;\n    }\n\n    /**\n     * @param {FocusOptions=} options\n     * @protected\n     * @override\n     */\n    focus(options) {\n      const idx = this._getFocusableIndex();\n      if (idx >= 0) {\n        this._focus(idx, options);\n      }\n    }\n\n    /**\n     * Get the index of a first focusable item, if any.\n     *\n     * @return {Element[]}\n     * @protected\n     */\n    _getFocusableIndex() {\n      const items = this._getItems();\n      return Array.isArray(items) ? this._getAvailableIndex(items, 0, null, (item) => !isElementHidden(item)) : -1;\n    }\n\n    /**\n     * Get the list of items participating in keyboard navigation.\n     * By default, it treats all the light DOM children as items.\n     * Override this method to provide custom list of elements.\n     *\n     * @return {Element[]}\n     * @protected\n     */\n    _getItems() {\n      return Array.from(this.children);\n    }\n\n    /**\n     * Override an event listener from `KeyboardMixin`.\n     *\n     * @param {!KeyboardEvent} event\n     * @protected\n     * @override\n     */\n    _onKeyDown(event) {\n      super._onKeyDown(event);\n\n      if (event.metaKey || event.ctrlKey) {\n        return;\n      }\n\n      const { key, shiftKey } = event;\n      const items = this._getItems() || [];\n      const currentIdx = items.indexOf(this.focused);\n\n      let idx;\n      let increment;\n\n      const isRTL = !this._vertical && this.getAttribute('dir') === 'rtl';\n      const dirIncrement = isRTL ? -1 : 1;\n\n      if (this.__isPrevKeyPressed(key, shiftKey)) {\n        increment = -dirIncrement;\n        idx = currentIdx - dirIncrement;\n      } else if (this.__isNextKeyPressed(key, shiftKey)) {\n        increment = dirIncrement;\n        idx = currentIdx + dirIncrement;\n      } else if (key === 'Home') {\n        increment = 1;\n        idx = 0;\n      } else if (key === 'End') {\n        increment = -1;\n        idx = items.length - 1;\n      }\n\n      idx = this._getAvailableIndex(items, idx, increment, (item) => !isElementHidden(item));\n\n      if (\n        this._tabNavigation &&\n        key === 'Tab' &&\n        ((idx > currentIdx && event.shiftKey) || (idx < currentIdx && !event.shiftKey) || idx === currentIdx)\n      ) {\n        // Prevent \"roving tabindex\" logic and let the normal Tab behavior if\n        // - currently on the first focusable item and Shift + Tab is pressed,\n        // - currently on the last focusable item and Tab is pressed,\n        // - currently on the only focusable item and Tab is pressed\n        return;\n      }\n\n      if (idx >= 0) {\n        event.preventDefault();\n        this._focus(idx, { focusVisible: true }, true);\n      }\n    }\n\n    /**\n     * @param {string} key\n     * @param {boolean} shiftKey\n     * @return {boolean}\n     * @private\n     */\n    __isPrevKeyPressed(key, shiftKey) {\n      if (this._vertical) {\n        return key === 'ArrowUp';\n      }\n\n      return key === 'ArrowLeft' || (this._tabNavigation && key === 'Tab' && shiftKey);\n    }\n\n    /**\n     * @param {string} key\n     * @param {boolean} shiftKey\n     * @return {boolean}\n     * @private\n     */\n    __isNextKeyPressed(key, shiftKey) {\n      if (this._vertical) {\n        return key === 'ArrowDown';\n      }\n\n      return key === 'ArrowRight' || (this._tabNavigation && key === 'Tab' && !shiftKey);\n    }\n\n    /**\n     * Focus the item at given index. Override this method to add custom logic.\n     *\n     * @param {number} index\n     * @param {FocusOptions=} options\n     * @param {boolean} navigating\n     * @protected\n     */\n    _focus(index, options, navigating = false) {\n      const items = this._getItems();\n\n      this._focusItem(items[index], options, navigating);\n    }\n\n    /**\n     * Focus the given item. Override this method to add custom logic.\n     *\n     * @param {Element} item\n     * @param {FocusOptions=} options\n     * @param {boolean} navigating\n     * @protected\n     */\n    _focusItem(item, options) {\n      if (item) {\n        item.focus(options);\n      }\n    }\n\n    /**\n     * Returns index of the next item that satisfies the given condition,\n     * based on the index of the current item and a numeric increment.\n     *\n     * @param {Element[]} items - array of items to iterate over\n     * @param {number} index - index of the current item\n     * @param {number} increment - numeric increment, can be either 1 or -1\n     * @param {Function} condition - function used to check the item\n     * @return {number}\n     * @protected\n     */\n    _getAvailableIndex(items, index, increment, condition) {\n      const totalItems = items.length;\n      let idx = index;\n      for (let i = 0; typeof idx === 'number' && i < totalItems; i += 1, idx += increment || 1) {\n        if (idx < 0) {\n          idx = totalItems - 1;\n        } else if (idx >= totalItems) {\n          idx = 0;\n        }\n\n        const item = items[idx];\n\n        if (this._isItemFocusable(item) && this.__isMatchingItem(item, condition)) {\n          return idx;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Returns true if the item matches condition.\n     *\n     * @param {Element} item - item to check\n     * @param {Function} condition - function used to check the item\n     * @return {number}\n     * @private\n     */\n    __isMatchingItem(item, condition) {\n      return typeof condition === 'function' ? condition(item) : true;\n    }\n\n    /**\n     * Returns whether the item is focusable. By default,\n     * returns true if the item is not disabled.\n     *\n     * @param {Element} item\n     * @return {boolean}\n     * @protected\n     */\n    _isItemFocusable(item) {\n      return !item.hasAttribute('disabled');\n    }\n  };\n"],
  "mappings": "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",
  "names": []
}
