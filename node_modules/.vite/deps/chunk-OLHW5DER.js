import {
  InputFieldMixin
} from "./chunk-MNTMWC4G.js";
import {
  inputFieldShared
} from "./chunk-F6FMTQFS.js";
import {
  ifDefined
} from "./chunk-OSWHV746.js";
import {
  ResizeMixin
} from "./chunk-J36B4EVN.js";
import {
  LabelledInputController
} from "./chunk-C63QNJWN.js";
import {
  TooltipController
} from "./chunk-XFKQJ73Z.js";
import {
  SlotController
} from "./chunk-X5EEA4XV.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/text-area/src/styles/vaadin-text-area-base-styles.js
var textAreaStyles = css`
  [part='input-field'] {
    overflow: auto;
    scroll-padding: var(
      --vaadin-input-field-padding,
      var(--vaadin-padding-block-container) var(--vaadin-padding-inline-container)
    );
  }

  ::slotted(textarea) {
    resize: none;
    white-space: pre-wrap;
  }

  [part='input-field'] ::slotted(:not(textarea)),
  [part~='clear-button'] {
    align-self: flex-start;
    position: sticky;
    top: 0;
  }

  [part~='clear-button'] {
    top: min(0px, (24px - 1lh) / -2);
  }

  /* Workaround https://bugzilla.mozilla.org/show_bug.cgi?id=1739079 */
  :host([disabled]) ::slotted(textarea) {
    user-select: none;
  }
`;

// node_modules/@vaadin/field-base/src/text-area-controller.js
var TextAreaController = class extends SlotController {
  constructor(host, callback) {
    super(host, "textarea", "textarea", {
      initializer: (node, host2) => {
        const value = host2.getAttribute("value");
        if (value) {
          node.value = value;
        }
        const name = host2.getAttribute("name");
        if (name) {
          node.setAttribute("name", name);
        }
        node.id = this.defaultId;
        if (typeof callback === "function") {
          callback(node);
        }
      },
      useUniqueId: true
    });
  }
};

// node_modules/@vaadin/text-area/src/vaadin-text-area-mixin.js
var TextAreaMixin = (superClass) => class TextAreaMixinClass extends ResizeMixin(InputFieldMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Maximum number of characters (in Unicode code points) that the user can enter.
       */
      maxlength: {
        type: Number
      },
      /**
       * Minimum number of characters (in Unicode code points) that the user can enter.
       */
      minlength: {
        type: Number
      },
      /**
       * A regular expression that the value is checked against.
       * The pattern must match the entire value, not just some subset.
       */
      pattern: {
        type: String
      },
      /**
       * Minimum number of rows to show. Default is two rows.
       *
       * When using a custom slotted textarea, the minimum number of rows are not applied for backwards compatibility.
       *
       * @attr {number} min-rows
       */
      minRows: {
        type: Number,
        value: 2,
        observer: "__minRowsChanged"
      },
      /**
       * Maximum number of rows to expand to before the text area starts scrolling. This effectively sets a max-height
       * on the `input-field` part. By default, it is not set, and the text area grows with the content without
       * constraints.
       * @attr {number} max-rows
       */
      maxRows: {
        type: Number
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "maxlength", "minlength", "pattern"];
  }
  static get constraints() {
    return [...super.constraints, "maxlength", "minlength", "pattern"];
  }
  static get observers() {
    return ["__updateMinHeight(minRows, inputElement)", "__updateMaxHeight(maxRows, inputElement, _inputField)"];
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this._updateHeight();
    this.__scrollPositionUpdated();
  }
  /** @protected */
  _onScroll() {
    this.__scrollPositionUpdated();
  }
  /** @protected */
  ready() {
    super.ready();
    this.__textAreaController = new TextAreaController(this, (input) => {
      this._setInputElement(input);
      this._setFocusElement(input);
      this.stateTarget = input;
      this.ariaTarget = input;
    });
    this.addController(this.__textAreaController);
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._inputField = this.shadowRoot.querySelector("[part=input-field]");
    this._inputField.addEventListener("wheel", (e) => {
      const scrollTopBefore = this._inputField.scrollTop;
      this._inputField.scrollTop += e.deltaY;
      if (scrollTopBefore !== this._inputField.scrollTop) {
        e.preventDefault();
        this.__scrollPositionUpdated();
      }
    });
    this._updateHeight();
    this.__scrollPositionUpdated();
  }
  /** @private */
  __scrollPositionUpdated() {
    this._inputField.style.setProperty("--_text-area-vertical-scroll-position", "0px");
    this._inputField.style.setProperty("--_text-area-vertical-scroll-position", `${this._inputField.scrollTop}px`);
  }
  /**
   * @param {unknown} newVal
   * @param {unknown} oldVal
   * @protected
   * @override
   */
  _valueChanged(newVal, oldVal) {
    super._valueChanged(newVal, oldVal);
    this._updateHeight();
  }
  /** @private */
  _updateHeight() {
    const input = this.inputElement;
    const inputField = this._inputField;
    if (!input || !inputField) {
      return;
    }
    const scrollTop = inputField.scrollTop;
    const valueLength = this.value ? this.value.length : 0;
    if (this._oldValueLength >= valueLength) {
      const inputFieldHeight = getComputedStyle(inputField).height;
      const inputWidth = getComputedStyle(input).width;
      inputField.style.height = inputFieldHeight;
      input.style.maxWidth = inputWidth;
      input.style.alignSelf = "flex-start";
      input.style.height = "auto";
    }
    this._oldValueLength = valueLength;
    const inputHeight = input.scrollHeight;
    if (inputHeight > input.clientHeight) {
      input.style.height = `${inputHeight}px`;
    }
    input.style.removeProperty("max-width");
    input.style.removeProperty("align-self");
    inputField.style.removeProperty("height");
    inputField.scrollTop = scrollTop;
    this.__updateMaxHeight(this.maxRows);
  }
  /** @private */
  __updateMinHeight(minRows) {
    if (!this.inputElement) {
      return;
    }
    if (this.inputElement === this.__textAreaController.defaultNode) {
      this.inputElement.rows = Math.max(minRows, 1);
    }
  }
  /** @private */
  __updateMaxHeight(maxRows) {
    if (!this._inputField || !this.inputElement) {
      return;
    }
    if (maxRows) {
      const inputStyle = getComputedStyle(this.inputElement);
      const inputFieldStyle = getComputedStyle(this._inputField);
      const lineHeight = parseFloat(inputStyle.lineHeight);
      const contentHeight = lineHeight * maxRows;
      const marginsAndPaddings = parseFloat(inputStyle.paddingTop) + parseFloat(inputStyle.paddingBottom) + parseFloat(inputStyle.marginTop) + parseFloat(inputStyle.marginBottom) + parseFloat(inputFieldStyle.borderTopWidth) + parseFloat(inputFieldStyle.borderBottomWidth) + parseFloat(inputFieldStyle.paddingTop) + parseFloat(inputFieldStyle.paddingBottom);
      const maxHeight = Math.ceil(contentHeight + marginsAndPaddings);
      this._inputField.style.setProperty("max-height", `${maxHeight}px`);
    } else {
      this._inputField.style.removeProperty("max-height");
    }
  }
  /**
   * @private
   */
  __minRowsChanged(minRows) {
    if (minRows < 1) {
      console.warn("<vaadin-text-area> minRows must be at least 1.");
    }
  }
  /**
   * Scrolls the textarea to the start if it has a vertical scrollbar.
   */
  scrollToStart() {
    this._inputField.scrollTop = 0;
  }
  /**
   * Scrolls the textarea to the end if it has a vertical scrollbar.
   */
  scrollToEnd() {
    this._inputField.scrollTop = this._inputField.scrollHeight;
  }
  /**
   * Returns true if the current textarea value satisfies all constraints (if any).
   * @return {boolean}
   * @override
   */
  checkValidity() {
    if (!super.checkValidity()) {
      return false;
    }
    if (!this.pattern || !this.inputElement.value) {
      return true;
    }
    try {
      const match = this.inputElement.value.match(this.pattern);
      return match ? match[0] === match.input : false;
    } catch (_) {
      return true;
    }
  }
};

// node_modules/@vaadin/text-area/src/vaadin-text-area.js
var TextArea = class extends TextAreaMixin(ThemableMixin(ElementMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-text-area";
  }
  static get styles() {
    return [inputFieldShared, textAreaStyles];
  }
  /** @protected */
  render() {
    return html`
      <div class="vaadin-text-area-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" @click="${this.focus}"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          .readonly="${this.readonly}"
          .disabled="${this.disabled}"
          .invalid="${this.invalid}"
          theme="${ifDefined(this._theme)}"
          @scroll="${this._onScroll}"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="textarea"></slot>
          <slot name="suffix" slot="suffix"></slot>
          <div id="clearButton" part="field-button clear-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>

        <slot name="tooltip"></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
};
defineCustomElement(TextArea);

export {
  TextArea
};
//# sourceMappingURL=chunk-OLHW5DER.js.map
