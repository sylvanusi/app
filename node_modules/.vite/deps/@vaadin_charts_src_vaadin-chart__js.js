import "./chunk-ETQJ5U4W.js";
import {
  ResizeMixin
} from "./chunk-J36B4EVN.js";
import {
  SlotObserver
} from "./chunk-VNVGWFKZ.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import "./chunk-OWHE56FA.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  addGlobalThemeStyles
} from "./chunk-ULNR4UH6.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import "./chunk-TMRBPE5K.js";
import "./chunk-56IVV4NW.js";
import {
  PolylitMixin,
  get
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css,
  unsafeCSS
} from "./chunk-5IHOHWXL.js";
import "./chunk-MWWP2LZ3.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/charts/src/helpers.js
function inflateFunctions(config) {
  if (Array.isArray(config)) {
    config.forEach(inflateFunctions);
    return;
  }
  if (
    // Check if param is a primitive/null/undefined value
    !(config instanceof Object) || // Check if param is a plain object (not a HC object)
    config.constructor !== Object
  ) {
    return;
  }
  Object.entries(config).forEach(([attr, targetProperty]) => {
    if (attr.startsWith("_fn_") && (typeof targetProperty === "string" || targetProperty instanceof String)) {
      try {
        config[attr.substr(4)] = eval(`(${targetProperty})`);
      } catch (_) {
        config[attr.substr(4)] = eval(`(function(){${targetProperty}})`);
      }
      delete config[attr];
    } else if (targetProperty instanceof Object) {
      inflateFunctions(targetProperty);
    }
  });
}
function deepMerge(target, source) {
  const isObject27 = (item) => item && typeof item === "object" && !Array.isArray(item);
  if (isObject27(source) && isObject27(target)) {
    Object.keys(source).forEach((key) => {
      if (isObject27(source[key])) {
        if (!target[key]) {
          Object.assign(target, { [key]: {} });
        }
        deepMerge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    });
  }
  return target;
}
function prepareExport(chart) {
  if (!chart.tempBodyStyle) {
    let effectiveCss = "";
    if (chart.shadowRoot.adoptedStyleSheets) {
      chart.shadowRoot.adoptedStyleSheets.forEach((sheet) => {
        effectiveCss += `${[...sheet.cssRules].map((rule) => rule.cssText).join("\n")}
`;
      });
    }
    effectiveCss = effectiveCss.replace(/:host\(.+?\)/gu, (match) => {
      const selector = match.substr(6, match.length - 7);
      return chart.matches(selector) ? "" : match;
    });
    effectiveCss = `${effectiveCss}body {    -moz-transform: scale(0.9, 0.9);    zoom: 0.9;    zoom: 90%;}`;
    chart.tempBodyStyle = document.createElement("style");
    chart.tempBodyStyle.textContent = effectiveCss;
    document.body.appendChild(chart.tempBodyStyle);
    if (chart.options.chart.styledMode) {
      document.body.setAttribute("styled-mode", "");
    }
  }
}
function cleanupExport(chart) {
  if (chart.tempBodyStyle) {
    document.body.removeChild(chart.tempBodyStyle);
    delete chart.tempBodyStyle;
    if (chart.options.chart.styledMode) {
      document.body.removeAttribute("styled-mode");
    }
  }
}

// node_modules/@vaadin/charts/src/vaadin-chart-series-mixin.js
var ChartSeriesMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      /**
       * An array of data used by the series.
       * Format depends on the chart type and can be:
       *   - An array of numerical values `[y0, y1, y2, y3,...]`
       *   - An array of arrays with 2 values (`x`, `y`) `[ [x0, y0], [x1, y1], [x2, y2], ... ]`
       *   - An array of objects, each one describing one point `[ {x: x0, y: y0, name: 'Point0', color: '#FF0000'}, {...}, ...]`
       *
       *  See more in [API Site](https://api.highcharts.com/highcharts/series)
       *
       * @type {ChartSeriesValues}
       */
      values: {
        type: Array,
        value: () => [],
        sync: true
      },
      /**
       * Value-axis minimum-value.
       * Sets the value to a series bound by 'unit' property.
       * Otherwise sets the value to the first series.
       * Undefined by default (determined from data).
       * @attr {number} value-min
       */
      valueMin: {
        type: Number,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Value-axis maximum-value.
       * See the 'valueMin'
       * @attr {number} value-max
       */
      valueMax: {
        type: Number,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * A string with the type of the series.
       * Defaults to `'line'` in case no type is set for the chart.
       * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type on `<vaadin-chart>`.
       */
      type: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * The name of the series as shown in the legend, tooltip etc.
       * @type {string}
       */
      title: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Shows/hides data-point markers for line-like series.
       * Acceptable input are:
       *  - `shown`: markers are always visible
       *  - `hidden`: markers are always hidden
       *  - `auto`: markers are visible for widespread data and hidden, when data is dense *(default)*
       * @type {ChartSeriesMarkers | undefined}
       */
      markers: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Used to connect the series to an axis; if multiple series have the same `unit`, they will share axis.
       * Displayed as a title for the axis.
       * If no unit is defined, then series will be connected to the first axis.
       */
      unit: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Used to group series in a different stacks.
       * "stacking" property should be specified either for each series or in plotOptions.
       * It is recommended to place series in a single stack, when they belong to the same yAxis.
       * @type {number | string}
       */
      stack: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * The height of the neck, the lower part of the funnel.
       * A number defines pixel width, a percentage string defines a percentage of the plot area height. Defaults to 30%.
       * Note that this property only applies for "funnel" charts.
       * @attr {number | string} neck-position
       * @type {number | string}
       */
      neckPosition: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * The width of the neck, the lower part of the funnel.
       * A number defines pixel width, a percentage string defines a percentage of the plot area width. Defaults to 30%.
       * Note that this property only applies for "funnel" charts.
       * @attr {number | string} neck-width
       * @type {number | string}
       */
      neckWidth: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Object with the configured options defined and used to create a series.
       * @type {!ChartSeriesOptions}
       * @readonly
       */
      options: {
        type: Object,
        sync: true
      },
      /**
       * Represents additional JSON configuration.
       * @type {SeriesOptionsType | undefined}
       */
      additionalOptions: {
        type: Object,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * @type {!Series | undefined}
       * @protected
       */
      _series: {
        type: Object,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "__additionalOptionsObserver(additionalOptions, _series)",
      "__markersObserver(markers, _series)",
      "__neckPositionObserver(neckPosition, _series)",
      "__neckWidthObserver(neckWidth, _series)",
      "__stackObserver(stack, _series)",
      "__titleObserver(title, _series)",
      "__typeObserver(type, _series)",
      "__unitObserver(unit, valueMin, valueMax, _series)",
      "__valueMinObserver(valueMin, _series)",
      "__valueMaxObserver(valueMax, _series)",
      "__valuesObserver(values, _series)"
    ];
  }
  get options() {
    const options2 = deepMerge({}, this.additionalOptions);
    if (this.type) {
      options2.type = this.type;
    }
    if (this.title) {
      options2.name = this.title;
    }
    if (this.values) {
      options2.data = this.values;
    }
    if (this.markers) {
      if (!this.__isMarkersValid()) {
        this.markers = "auto";
      }
      options2.marker = this.__markersConfiguration;
    }
    if (this.unit) {
      options2.yAxis = this.unit;
    }
    if (this.stack) {
      options2.stack = this.stack;
    }
    if (isFinite(this.valueMin)) {
      options2.yAxisValueMin = this.valueMin;
    }
    if (isFinite(this.valueMax)) {
      options2.yAxisValueMax = this.valueMax;
    }
    if (this.neckWidth) {
      options2.neckWidth = this.neckWidth;
    }
    if (this.neckPosition) {
      options2.neckHeight = this.neckPosition;
    }
    return options2;
  }
  /** @private */
  get __markersConfiguration() {
    const config2 = {};
    switch (this.markers) {
      case "shown":
        config2.enabled = true;
        break;
      case "hidden":
        config2.enabled = false;
        break;
      case "auto":
      default:
        config2.enabled = null;
        break;
    }
    return config2;
  }
  /**
   * Method to attach a series object of type `Highcharts.Series`.
   * @param {!Series} series Object of type `Highcharts.Series`
   */
  setSeries(series) {
    this._series = series;
  }
  /** @private */
  __valuesObserver(values, series) {
    if (series) {
      series.setData(values);
    }
  }
  /** @private */
  __additionalOptionsObserver(additionalOptions, series) {
    if (series && additionalOptions) {
      series.update(additionalOptions);
    }
  }
  /** @private */
  __updateAxis(series, value, key) {
    if (!isFinite(value)) {
      this.__showWarn(`value-${key}`, "Numbers or null");
      return;
    }
    if (series && series.yAxis) {
      series.yAxis.update({ [key]: value });
    }
  }
  /** @private */
  __valueMinObserver(valueMin, series) {
    if (valueMin === void 0 || series == null) {
      return;
    }
    this.__updateAxis(series, valueMin, "min");
  }
  /** @private */
  __valueMaxObserver(valueMax, series) {
    if (valueMax === void 0 || series == null) {
      return;
    }
    this.__updateAxis(series, valueMax, "max");
  }
  /** @private */
  __typeObserver(type, series) {
    if (type && series) {
      series.update({ type });
    }
  }
  /** @private */
  __titleObserver(title, series) {
    if (title === void 0 || series == null) {
      return;
    }
    series.update({ name: title });
  }
  /** @private */
  __stackObserver(stack, series) {
    if (stack === void 0 || series == null) {
      return;
    }
    series.update({ stack });
  }
  /** @private */
  __neckPositionObserver(neckPosition, series) {
    if (neckPosition === void 0 || series == null) {
      return;
    }
    series.update({ neckHeight: neckPosition });
  }
  /** @private */
  __neckWidthObserver(neckWidth, series) {
    if (neckWidth === void 0 || series == null) {
      return;
    }
    series.update({ neckWidth });
  }
  /** @private */
  __unitObserver(unit, valueMin, valueMax, series) {
    if (series && unit !== this.__oldUnit) {
      const Chart3 = customElements.get("vaadin-chart");
      this.__oldUnit = unit;
      const parent = this.parentNode instanceof Chart3 && this.parentNode;
      if (parent && parent instanceof Chart3) {
        if (unit && !parent.__getAxis(unit)) {
          const title = { title: { text: unit } };
          parent.__addAxis({ id: unit, axisGenerated: true, ...title });
        }
        series.update({ yAxis: unit || 0 });
        if (valueMin !== void 0) {
          this.__updateAxis(series, valueMin, "min");
        }
        if (valueMax !== void 0) {
          this.__updateAxis(series, valueMax, "max");
        }
        parent.__removeAxisIfEmpty();
      }
    }
  }
  /** @private */
  __isMarkersValid() {
    if (["shown", "hidden", "auto"].indexOf(this.markers) === -1) {
      this.__showWarn("markers", '"shown", "hidden" or "auto"');
      return false;
    }
    return true;
  }
  /** @private */
  __markersObserver(markers, series) {
    if (markers === void 0 || series == null) {
      return;
    }
    if (!this.__isMarkersValid()) {
      this.markers = "auto";
      return;
    }
    series.update({
      marker: this.__markersConfiguration
    });
  }
  /** @private */
  __showWarn(propertyName, acceptedValues) {
    console.warn(`<vaadin-chart-series> Acceptable values for "${propertyName}" are ${acceptedValues}`);
  }
};

// node_modules/@vaadin/charts/src/vaadin-chart-series.js
var ChartSeries = class extends ChartSeriesMixin(PolylitMixin(LitElement)) {
  static get is() {
    return "vaadin-chart-series";
  }
};
defineCustomElement(ChartSeries);

// node_modules/@vaadin/charts/src/styles/vaadin-chart-base-styles.js
var tooltipStyles = (scope) => css`
  ${unsafeCSS(scope)} .highcharts-tooltip {
    cursor: default;
    pointer-events: none;
    white-space: nowrap;
    transition: stroke 150ms;
    filter: drop-shadow(var(--vaadin-charts-tooltip-shadow, 0 4px 8px rgba(0, 0, 0, 0.2))) !important;
  }

  ${unsafeCSS(scope)} .highcharts-tooltip text,
  ${unsafeCSS(scope)} .highcharts-tooltip foreignObject span {
    fill: var(--highcharts-neutral-color-80, var(--vaadin-charts-data-label, var(--vaadin-text-color)));
  }

  ${unsafeCSS(scope)} .highcharts-tooltip .highcharts-tracker {
    fill: none;
    stroke: none;
  }

  ${unsafeCSS(scope)} .highcharts-tooltip .highcharts-header {
    font-size: 0.85em;
    color: var(--highcharts-neutral-color-60, var(--vaadin-text-color-secondary));
  }

  ${unsafeCSS(scope)} .highcharts-tooltip-box {
    stroke-width: 0;
    fill: var(--highcharts-background-color, var(--vaadin-charts-tooltip-background, var(--vaadin-background-color)));
  }

  ${unsafeCSS(scope)} .highcharts-tooltip-box .highcharts-label-box {
    fill: var(--highcharts-background-color, var(--vaadin-charts-tooltip-background, var(--vaadin-background-color)));
  }

  ${unsafeCSS(scope)} div.highcharts-tooltip {
    filter: none;
    font-size: 0.8em;
  }
`;
addGlobalThemeStyles(
  "vaadin-charts-tooltip",
  css`
    .highcharts-tooltip-container .highcharts-root {
      overflow: visible;
      font-size: var(--vaadin-charts-font-size, 0.75rem);
      line-height: normal;
    }
  `,
  tooltipStyles(".highcharts-tooltip-container")
);
var chartStyles = css`
  :host {
    display: block;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  :host,
  :root {
    font-size: var(--vaadin-charts-font-size, 0.75rem);
    line-height: normal;

    /* Needs to be a color, not a background image */
    --_bg: var(--vaadin-charts-background, var(--vaadin-background-color));

    --_color-0: var(--highcharts-color-0, var(--vaadin-charts-color-0, var(--vaadin-user-color-0)));
    --_color-1: var(--highcharts-color-1, var(--vaadin-charts-color-1, var(--vaadin-user-color-1)));
    --_color-2: var(--highcharts-color-2, var(--vaadin-charts-color-2, var(--vaadin-user-color-2)));
    --_color-3: var(--highcharts-color-3, var(--vaadin-charts-color-3, var(--vaadin-user-color-3)));
    --_color-4: var(--highcharts-color-4, var(--vaadin-charts-color-4, var(--vaadin-user-color-4)));
    --_color-5: var(--highcharts-color-5, var(--vaadin-charts-color-5, var(--vaadin-user-color-5)));
    --_color-6: var(--highcharts-color-6, var(--vaadin-charts-color-6, var(--vaadin-user-color-6)));
    --_color-7: var(--highcharts-color-7, var(--vaadin-charts-color-7, var(--vaadin-user-color-7)));
    --_color-8: var(--highcharts-color-8, var(--vaadin-charts-color-8, var(--vaadin-user-color-8)));
    --_color-9: var(--highcharts-color-9, var(--vaadin-charts-color-9, var(--vaadin-user-color-9)));

    --_color-0-label: oklch(from var(--_color-0) clamp(0, (0.62 - l) * 1000, 1) 0 0);
    --_color-1-label: oklch(from var(--_color-1) clamp(0, (0.62 - l) * 1000, 1) 0 0);
    --_color-2-label: oklch(from var(--_color-2) clamp(0, (0.62 - l) * 1000, 1) 0 0);
    --_color-3-label: oklch(from var(--_color-3) clamp(0, (0.62 - l) * 1000, 1) 0 0);
    --_color-4-label: oklch(from var(--_color-4) clamp(0, (0.62 - l) * 1000, 1) 0 0);
    --_color-5-label: oklch(from var(--_color-5) clamp(0, (0.62 - l) * 1000, 1) 0 0);
    --_color-6-label: oklch(from var(--_color-6) clamp(0, (0.62 - l) * 1000, 1) 0 0);
    --_color-7-label: oklch(from var(--_color-7) clamp(0, (0.62 - l) * 1000, 1) 0 0);
    --_color-8-label: oklch(from var(--_color-8) clamp(0, (0.62 - l) * 1000, 1) 0 0);
    --_color-9-label: oklch(from var(--_color-9) clamp(0, (0.62 - l) * 1000, 1) 0 0);

    --_color-positive: light-dark(#19b156, #1ccc62);
    --_color-negative: light-dark(#dc0611, #f7353f);

    --_label: var(--vaadin-charts-label, var(--vaadin-text-color));
    --_secondary-label: var(--vaadin-charts-secondary-label, var(--vaadin-text-color-secondary));
    --_disabled-label: var(--vaadin-charts-disabled-label, var(--vaadin-text-color-disabled));
    --_point-border: var(--vaadin-charts-point-border, var(--_bg));
    --_axis-line: var(--vaadin-charts-axis-line, var(--vaadin-border-color-secondary));
    --_axis-title: var(--vaadin-charts-axis-title, var(--_secondary-label));
    --_axis-label: var(--vaadin-charts-axis-label, var(--_secondary-label));
    --_grid-line: var(--vaadin-charts-grid-line, var(--vaadin-border-color-secondary));
    --_minor-grid-line: var(
      --vaadin-charts-minor-grid-line,
      color-mix(in srgb, var(--vaadin-border-color-secondary) 60%, transparent)
    );
    --_data-label: var(--vaadin-charts-data-label, var(--_label));
  }

  /* Safari 17 doesn't support relative colors from light-dark() */
  @supports not (color: oklch(from light-dark(red, red) l c h)) {
    :host {
      /* Safari 17 wants degrees instead of raw numbers */
      --_hue-scale: 180deg;
    }
  }

  :host([hidden]) {
    display: none !important;
  }

  .highcharts-container {
    position: relative;
    overflow: hidden;
    width: 100%;
    height: 100%;
    text-align: left;
    line-height: normal;
    z-index: 0; /* highcharts/highcharts#1072 */
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    user-select: none;
    touch-action: manipulation;
    outline: none;
  }

  :where([styled-mode]) .highcharts-no-touch-action {
    touch-action: none;
  }

  :where([styled-mode]) .highcharts-root {
    display: block;
  }

  :where([styled-mode]) .highcharts-root text {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-strong {
    font-weight: bold;
  }

  :where([styled-mode]) .highcharts-emphasized {
    font-style: italic;
  }

  :where([styled-mode]) .highcharts-anchor {
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-background {
    fill: var(--highcharts-background-color, var(--_bg));
  }

  :where([styled-mode]) .highcharts-plot-border,
  :where([styled-mode]) .highcharts-plot-background {
    fill: none;
  }

  :where([styled-mode]) .highcharts-label-box {
    fill: none;
  }

  :where([styled-mode]) .highcharts-label text {
    fill: var(--highcharts-neutral-color-80, var(--_data-label));
  }

  :where([styled-mode]) .highcharts-button-box {
    fill: inherit;
    rx: var(--vaadin-charts-button-border-radius, var(--vaadin-radius-m));
    ry: var(--vaadin-charts-button-border-radius, var(--vaadin-radius-m));
  }

  :where([styled-mode]) .highcharts-tracker-line {
    stroke-linejoin: round;
    stroke: rgba(192, 192, 192, 0.0001);
    stroke-width: 22;
    fill: none;
  }

  :where([styled-mode]) .highcharts-tracker-area {
    fill: rgba(192, 192, 192, 0.0001);
    stroke-width: 0;
  }

  /* Titles */
  :where([styled-mode]) .highcharts-title {
    fill: var(--highcharts-neutral-color-80, var(--vaadin-charts-title-label, var(--_label)));
    font-size: 1.6em;
    font-weight: bold;
  }

  :where([styled-mode]) .highcharts-subtitle {
    fill: var(--highcharts-neutral-color-60, var(--_secondary-label));
    font-size: 1em;
  }

  /* Axes */
  :where([styled-mode]) .highcharts-axis-line {
    fill: none;
    stroke: var(--highcharts-neutral-color-80, var(--_axis-line));
  }

  :where([styled-mode]) .highcharts-yaxis .highcharts-axis-line {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-axis-title {
    fill: var(--highcharts-neutral-color-60, var(--_axis-title));
    font-size: 1em;
  }

  :where([styled-mode]) .highcharts-axis-labels {
    fill: var(--highcharts-neutral-color-80, var(--_axis-label));
    cursor: default;
  }

  :where([styled-mode]) .highcharts-grid-line {
    fill: none;
    stroke: var(--highcharts-neutral-color-10, var(--_grid-line));
  }

  :where([styled-mode]) .highcharts-xaxis-grid .highcharts-grid-line {
    stroke-width: var(--vaadin-charts-xaxis-line-width, 0);
  }

  :where([styled-mode]) .highcharts-tick {
    stroke: var(--highcharts-neutral-color-80, var(--_grid-line));
  }

  :where([styled-mode]) .highcharts-yaxis .highcharts-tick {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-minor-grid-line {
    stroke: var(--highcharts-neutral-color-5, var(--_minor-grid-line));
  }

  :where([styled-mode]) .highcharts-crosshair-thin {
    stroke-width: 1px;
    stroke: var(--highcharts-neutral-color-20, var(--_grid-line));
  }

  :where([styled-mode]) .highcharts-crosshair-category {
    stroke: var(--highcharts-highlight-color-20, var(--_color-0));
    stroke-opacity: 0.25;
  }

  /* Credits */
  :where([styled-mode]) .highcharts-credits {
    cursor: pointer;
    fill: var(--highcharts-neutral-color-40, var(--_disabled-label));
    font-size: 0.7em;
    transition:
      fill 250ms,
      font-size 250ms;
  }

  :where([styled-mode]) .highcharts-credits:hover {
    fill: var(--highcharts-neutral-color-100, black);
    font-size: 0.8em;
  }

  /* Tooltip */
  ${unsafeCSS(tooltipStyles(":where([styled-mode])"))};

  :where([styled-mode]) .highcharts-selection-marker {
    fill: var(--highcharts-highlight-color-80, var(--_color-0));
    fill-opacity: 0.25;
  }

  :where([styled-mode]) .highcharts-graph {
    fill: none;
    stroke-width: var(--vaadin-chart-graph-stroke-width, 2);
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  :where([styled-mode]) .highcharts-empty-series {
    stroke-width: 1px;
    fill: none;
    stroke: var(--highcharts-neutral-color-20, var(--_color-0));
  }

  :where([styled-mode]) .highcharts-state-hover .highcharts-graph {
    stroke-width: calc(var(--vaadin-chart-graph-stroke-width, 2) + 1);
  }

  :where([styled-mode]) .highcharts-point-inactive {
    opacity: 0.2;
    transition: opacity 50ms; /* quick in */
  }

  :where([styled-mode]) .highcharts-series-inactive {
    opacity: 0.2;
    transition: opacity 50ms; /* quick in */
  }

  :where([styled-mode]) .highcharts-state-hover path {
    transition: stroke-width 50ms; /* quick in */
  }

  :where([styled-mode]) .highcharts-state-normal path {
    transition: stroke-width 250ms; /* slow out */
  }

  /* Legend hover affects points and series */
  :where([styled-mode]) g.highcharts-series,
  :where([styled-mode]) .highcharts-point,
  :where([styled-mode]) .highcharts-markers,
  :where([styled-mode]) .highcharts-data-labels {
    transition: opacity 250ms;
  }

  :where([styled-mode]) .highcharts-legend-series-active g.highcharts-series:not(.highcharts-series-hover),
  :where([styled-mode])
    .highcharts-legend-point-active
    .highcharts-point:not(.highcharts-point-hover, .highcharts-point-select),
  :where([styled-mode]) .highcharts-legend-series-active .highcharts-markers:not(.highcharts-series-hover),
  :where([styled-mode]) .highcharts-legend-series-active .highcharts-data-labels:not(.highcharts-series-hover) {
    opacity: 0.2;
  }

  /* Series options */

  /* Default colors */
  :where([styled-mode]) .highcharts-color-0 {
    fill: var(--_color-0);
    stroke: var(--_color-0);
  }

  :where([styled-mode]) .highcharts-color-1 {
    fill: var(--_color-1);
    stroke: var(--_color-1);
  }

  :where([styled-mode]) .highcharts-color-2 {
    fill: var(--_color-2);
    stroke: var(--_color-2);
  }

  :where([styled-mode]) .highcharts-color-3 {
    fill: var(--_color-3);
    stroke: var(--_color-3);
  }

  :where([styled-mode]) .highcharts-color-4 {
    fill: var(--_color-4);
    stroke: var(--_color-4);
  }

  :where([styled-mode]) .highcharts-color-5 {
    fill: var(--_color-5);
    stroke: var(--_color-5);
  }

  :where([styled-mode]) .highcharts-color-6 {
    fill: var(--_color-6);
    stroke: var(--_color-6);
  }

  :where([styled-mode]) .highcharts-color-7 {
    fill: var(--_color-7);
    color: var(--_color-7-label);
  }

  :where([styled-mode]) .highcharts-color-8 {
    fill: var(--_color-8);
    stroke: var(--_color-8);
  }

  :where([styled-mode]) .highcharts-color-9 {
    fill: var(--_color-9);
    stroke: var(--_color-9);
  }

  :where([styled-mode])
    :where(.highcharts-treemap-series, .highcharts-organization-series, .highcharts-gantt-series)
    .highcharts-data-label-color-0 {
    color: var(--_color-0-label);
  }

  :where([styled-mode])
    :where(.highcharts-treemap-series, .highcharts-organization-series, .highcharts-gantt-series)
    .highcharts-data-label-color-1 {
    color: var(--_color-1-label);
  }

  :where([styled-mode])
    :where(.highcharts-treemap-series, .highcharts-organization-series, .highcharts-gantt-series)
    .highcharts-data-label-color-2 {
    color: var(--_color-2-label);
  }

  :where([styled-mode])
    :where(.highcharts-treemap-series, .highcharts-organization-series, .highcharts-gantt-series)
    .highcharts-data-label-color-3 {
    color: var(--_color-3-label);
  }

  :where([styled-mode])
    :where(.highcharts-treemap-series, .highcharts-organization-series, .highcharts-gantt-series)
    .highcharts-data-label-color-4 {
    color: var(--_color-4-label);
  }

  :where([styled-mode])
    :where(.highcharts-treemap-series, .highcharts-organization-series, .highcharts-gantt-series)
    .highcharts-data-label-color-5 {
    color: var(--_color-5-label);
  }

  :where([styled-mode])
    :where(.highcharts-treemap-series, .highcharts-organization-series, .highcharts-gantt-series)
    .highcharts-data-label-color-6 {
    color: var(--_color-6-label);
  }

  :where([styled-mode])
    :where(.highcharts-treemap-series, .highcharts-organization-series, .highcharts-gantt-series)
    .highcharts-data-label-color-7 {
    color: var(--_color-7-label);
  }

  :where([styled-mode])
    :where(.highcharts-treemap-series, .highcharts-organization-series, .highcharts-gantt-series)
    .highcharts-data-label-color-8 {
    color: var(--_color-8-label);
  }

  :where([styled-mode])
    :where(.highcharts-treemap-series, .highcharts-organization-series, .highcharts-gantt-series)
    .highcharts-data-label-color-9 {
    color: var(--_color-9-label);
  }

  :where([styled-mode]) [class*='highcharts-data-label-color-'] {
    fill: currentColor;
  }

  /* Various series-specific */
  :where([styled-mode]) .highcharts-area {
    fill-opacity: 0.75;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-markers {
    stroke-width: 1px;
    stroke: var(--highcharts-background-color, var(--_bg));
  }

  :where([styled-mode])
    .highcharts-a11y-markers-hidden
    .highcharts-point:not(.highcharts-point-hover, .highcharts-a11y-marker-visible),
  :where([styled-mode]) .highcharts-a11y-marker-hidden {
    opacity: 0;
  }

  :where([styled-mode]) .highcharts-point {
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-dense-data .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-data-label text,
  :where([styled-mode]) .highcharts-data-label span,
  :where([styled-mode]) text.highcharts-data-label {
    font-size: 0.9em;
  }

  :where([styled-mode]) .highcharts-data-label-box {
    fill: none;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-data-label text,
  :where([styled-mode]) text.highcharts-data-label {
    fill: var(--highcharts-neutral-color-80, var(--_data-label));
  }

  :where([styled-mode]) .highcharts-data-label-connector {
    fill: none;
  }

  :where([styled-mode]) .highcharts-data-label-hidden {
    pointer-events: none;
  }

  :where([styled-mode]) .highcharts-halo {
    fill-opacity: 0.25;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-series-label text {
    fill: inherit;
    font-weight: bold;
  }

  :where([styled-mode]) .highcharts-series:not(.highcharts-pie-series) .highcharts-point-select,
  :where([styled-mode]) .highcharts-markers .highcharts-point-select {
    fill: var(--highcharts-neutral-color-20, var(--_grid-line));
    stroke: var(--highcharts-neutral-color-100, var(--vaadin-charts-contrast, var(--_label)));
  }

  :where([styled-mode]) .highcharts-column-series path.highcharts-point,
  :where([styled-mode]) .highcharts-bar-series path.highcharts-point {
    /* path to prevent stroke on 3D columns and bars */
    stroke: var(--highcharts-background-color, var(--_point-border));
  }

  :where([styled-mode]) .highcharts-column-series .highcharts-point,
  :where([styled-mode]) .highcharts-bar-series .highcharts-point {
    transition: fill-opacity 250ms;
  }

  :where([styled-mode]) .highcharts-column-series .highcharts-point-hover,
  :where([styled-mode]) .highcharts-bar-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-pie-series .highcharts-point {
    stroke-linejoin: round;
    stroke: var(--highcharts-background-color, var(--_point-border));
  }

  :where([styled-mode]) .highcharts-pie-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-funnel-series .highcharts-point {
    stroke-linejoin: round;
    stroke: var(--highcharts-background-color, var(--_point-border));
  }

  :where([styled-mode]) .highcharts-funnel-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-funnel-series .highcharts-point-select {
    fill: inherit;
    stroke: inherit;
  }

  :where([styled-mode]) .highcharts-pyramid-series .highcharts-point {
    stroke-linejoin: round;
    stroke: var(--highcharts-background-color, var(--_point-border));
  }

  :where([styled-mode]) .highcharts-pyramid-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-pyramid-series .highcharts-point-select {
    fill: inherit;
    stroke: inherit;
  }

  :where([styled-mode]) .highcharts-solidgauge-series .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-point {
    stroke-width: 1px;
    stroke: var(--highcharts-background-color, var(--_point-border));
    transition:
      stroke 250ms,
      fill 250ms,
      fill-opacity 250ms;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-point-hover {
    stroke: var(--highcharts-neutral-color-40, var(--_point-border));
    transition:
      stroke 25ms,
      fill 25ms,
      fill-opacity 25ms;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-above-level {
    display: none;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-internal-node {
    fill: none;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-internal-node-interactive {
    fill-opacity: 0.15;
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-internal-node-interactive:hover {
    fill-opacity: 0.75;
  }

  :where([styled-mode]) .highcharts-vector-series .highcharts-point {
    fill: none;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-windbarb-series .highcharts-point {
    fill: none;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-lollipop-stem {
    stroke: var(--highcharts-neutral-color-100, var(--vaadin-charts-contrast, var(--_label)));
  }

  :where([styled-mode]) .highcharts-focus-border {
    fill: none;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-legend-item-hidden .highcharts-focus-border {
    fill: none !important;
  }

  /* Legend */
  :where([styled-mode]) .highcharts-legend-box {
    fill: none;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-legend-item > text,
  :where([styled-mode]) .highcharts-legend-item span {
    fill: var(--highcharts-neutral-color-80, var(--_data-label));
    font-size: 1em;
    cursor: pointer;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-legend-item:hover text {
    fill: var(--highcharts-neutral-color-100, var(--vaadin-charts-title-label, var(--_label)));
  }

  :where([styled-mode]) .highcharts-legend-item-hidden * {
    fill: var(--highcharts-neutral-color-60, var(--_disabled-label)) !important;
    stroke: var(--highcharts-neutral-color-60, var(--_disabled-label)) !important;
    transition: fill 250ms;
    text-decoration: line-through;
  }

  :where([styled-mode]) .highcharts-legend-nav-active {
    fill: var(--highcharts-highlight-color-100, var(--vaadin-charts-button-label, var(--_label)));
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-legend-nav-inactive {
    fill: var(--highcharts-neutral-color-20, var(--_disabled-label));
  }

  :where([styled-mode]) circle.highcharts-legend-nav-active,
  :where([styled-mode]) circle.highcharts-legend-nav-inactive {
    /* tracker */
    fill: rgba(192, 192, 192, 0.0001);
  }

  :where([styled-mode]) .highcharts-legend-title-box {
    fill: none;
    stroke-width: 0;
  }

  /* Bubble legend */
  :where([styled-mode]) .highcharts-bubble-legend-symbol {
    stroke-width: 2;
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-bubble-legend-connectors {
    stroke-width: 1;
  }

  :where([styled-mode]) .highcharts-bubble-legend-labels {
    fill: var(--highcharts-neutral-color-80, var(--_data-label));
    font-size: 0.95em;
  }

  /* Loading */
  :where([styled-mode]) .highcharts-loading {
    position: absolute;
    background-color: var(--highcharts-background-color, var(--_bg));
    opacity: 0.5;
    text-align: center;
    z-index: 10;
    transition: opacity 250ms;
  }

  :where([styled-mode]) .highcharts-loading-hidden {
    height: 0 !important;
    opacity: 0;
    overflow: hidden;
    transition:
      opacity 250ms,
      height 250ms step-end;
  }

  :where([styled-mode]) .highcharts-loading-inner {
    font-weight: bold;
    position: relative;
    top: 45%;
  }

  /* Plot bands and polar pane backgrounds */
  :where([styled-mode]) .highcharts-plot-band,
  :where([styled-mode]) .highcharts-pane {
    fill: var(--highcharts-neutral-color-100, var(--vaadin-charts-contrast, var(--_label)));
    fill-opacity: 0.05;
  }

  :where([styled-mode]) .highcharts-plot-line {
    fill: none;
    stroke: var(
      --highcharts-neutral-color-40,
      color-mix(in srgb, var(--vaadin-charts-contrast, var(--_label)) 60%, transparent)
    );
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-plot-line-label {
    font-size: 1em;
  }

  /* Highcharts More and modules */
  :where([styled-mode]) .highcharts-boxplot-box {
    fill: var(--highcharts-background-color, var(--_bg));
  }

  :where([styled-mode]) .highcharts-boxplot-median {
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-bubble-series .highcharts-point {
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-errorbar-series .highcharts-point {
    stroke: var(--highcharts-neutral-color-100, var(--vaadin-charts-contrast, var(--_label)));
  }

  :where([styled-mode]) .highcharts-gauge-series .highcharts-data-label-box {
    stroke: var(--highcharts-neutral-color-20, var(--_grid-line));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-gauge-series .highcharts-dial {
    fill: var(--highcharts-neutral-color-100, var(--vaadin-charts-contrast, var(--_label)));
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-organization-series .highcharts-null-point {
    fill: transparent;
  }

  :where([styled-mode]) .highcharts-polygon-series .highcharts-graph {
    fill: inherit;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-waterfall-series .highcharts-graph {
    stroke: var(
      --highcharts-neutral-color-80,
      color-mix(in srgb, var(--vaadin-charts-contrast, var(--_label)) 60%, transparent)
    );
    stroke-dasharray: 1, 3;
  }

  :where([styled-mode]) .highcharts-sankey-series .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-sankey-series .highcharts-link {
    transition:
      fill 250ms,
      fill-opacity 250ms;
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-sankey-series .highcharts-point-hover.highcharts-link {
    transition:
      fill 50ms,
      fill-opacity 50ms;
    fill-opacity: 1;
  }

  :where([styled-mode]) .highcharts-venn-series .highcharts-point {
    fill-opacity: 0.75;
    stroke: var(--highcharts-neutral-color-20, var(--_point-border));
    transition:
      stroke 250ms,
      fill-opacity 250ms;
  }

  :where([styled-mode]) .highcharts-venn-series .highcharts-point-hover {
    fill-opacity: 1;
    stroke: var(--highcharts-neutral-color-20, var(--_point-border));
  }

  :where([styled-mode]) .highcharts-timeline-series .highcharts-graph {
    stroke: var(--highcharts-neutral-color-20, var(--_point-border));
  }

  /* Highstock */
  :where([styled-mode]) .highcharts-navigator-mask-outside {
    fill-opacity: 0;
  }

  :where([styled-mode]) .highcharts-navigator-mask-inside {
    fill: var(--highcharts-highlight-color-60, var(--_color-0)); /* navigator.maskFill option */
    fill-opacity: 0.25;
    cursor: ew-resize;
  }

  :where([styled-mode]) .highcharts-navigator-outline {
    stroke: var(--highcharts-neutral-color-40, var(--_grid-line));
    fill: none;
  }

  :where([styled-mode]) .highcharts-navigator-handle {
    stroke: var(--highcharts-neutral-color-40, var(--_grid-line));
    fill: var(--highcharts-neutral-color-5, var(--_bg));
    cursor: ew-resize;
  }

  :where([styled-mode]) .highcharts-navigator-series {
    fill: var(--highcharts-highlight-color-80, var(--_color-1));
    stroke: var(--highcharts-highlight-color-80, var(--_color-1));
  }

  :where([styled-mode]) .highcharts-navigator-series .highcharts-graph {
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-navigator-series .highcharts-area {
    fill-opacity: 0.05;
  }

  :where([styled-mode]) .highcharts-navigator-xaxis .highcharts-axis-line {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-navigator-xaxis .highcharts-grid-line {
    stroke-width: 1px;
    stroke: var(--highcharts-neutral-color-10, var(--_grid-line));
  }

  :where([styled-mode]) .highcharts-navigator-xaxis.highcharts-axis-labels {
    fill: var(--highcharts-neutral-color-100, var(--_secondary-label));
    font-size: 0.95em;
    opacity: 0.6;
  }

  :where([styled-mode]) .highcharts-navigator-yaxis .highcharts-grid-line {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-scrollbar-thumb {
    fill: var(
      --highcharts-neutral-color-20,
      color-mix(in srgb, var(--vaadin-charts-contrast, var(--_label)) 20%, transparent)
    );
  }

  :where([styled-mode]) .highcharts-scrollbar-button {
    fill: var(--highcharts-neutral-color-10, var(--_bg));
    stroke: var(--highcharts-neutral-color-20);
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-scrollbar-arrow {
    fill: var(--highcharts-neutral-color-60, var(--_data-label));
  }

  :where([styled-mode]) .highcharts-scrollbar-rifles {
    stroke: none;
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-scrollbar-track {
    fill: color-mix(in srgb, var(--vaadin-charts-contrast, var(--_label)) 5%, transparent);
    stroke: var(--highcharts-neutral-color-20);
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-button {
    fill: var(--highcharts-neutral-color-3, var(--vaadin-charts-button-background, var(--vaadin-background-container)));
    stroke: var(--highcharts-neutral-color-20);
    cursor: default;
    stroke-width: 1px;
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-button text {
    fill: var(--highcharts-neutral-color-80, var(--vaadin-charts-button-label, var(--_label)));
    font-size: 1em;
  }

  :where([styled-mode]) .highcharts-button-hover {
    transition: fill 0ms;
    fill: var(
      --highcharts-neutral-color-10,
      var(--vaadin-charts-button-hover-background, var(--vaadin-background-container))
    );
    stroke: var(--highcharts-neutral-color-20);
  }

  :where([styled-mode]) .highcharts-button-hover text {
    fill: var(--highcharts-neutral-color-80, var(--vaadin-charts-button-label, var(--_label)));
  }

  :where([styled-mode]) .highcharts-button-pressed {
    font-weight: bold;
    fill: var(--highcharts-highlight-color-10, var(--vaadin-charts-button-active-background, var(--_label)));
    stroke: var(--highcharts-neutral-color-20);
  }

  :where([styled-mode]) .highcharts-button-pressed text {
    fill: var(--highcharts-neutral-color-80, var(--vaadin-charts-button-active-label, var(--_bg)));
    font-weight: bold;
  }

  :where([styled-mode]) .highcharts-button-disabled text {
    fill: var(
      --highcharts-neutral-color-80,
      var(--vaadin-charts-button-disabled-label, var(--vaadin-text-color-disabled))
    );
  }

  :where([styled-mode]) .highcharts-range-selector-buttons .highcharts-button {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-range-label rect {
    fill: none;
  }

  :where([styled-mode]) .highcharts-range-label text {
    fill: var(--highcharts-neutral-color-60, var(--_secondary-label));
  }

  :where([styled-mode]) .highcharts-range-input rect {
    fill: var(--vaadin-charts-range-input-background, var(--vaadin-background-container));
    rx: var(--vaadin-charts-button-border-radius, var(--vaadin-radius-m));
    ry: var(--vaadin-charts-button-border-radius, var(--vaadin-radius-m));
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-range-input:hover rect {
    fill: var(--vaadin-charts-range-input-background-hover, var(--vaadin-background-container));
  }

  :where([styled-mode]) .highcharts-range-input text {
    fill: var(--highcharts-neutral-color-80, var(--_data-label));
    font-size: 1em;
  }

  :where([styled-mode]) .highcharts-range-input {
    stroke-width: 1px;
    stroke: var(--highcharts-neutral-color-20);
  }

  :where([styled-mode]) input.highcharts-range-selector {
    position: absolute;
    border: 0;
    padding: 0;
    text-align: center;
    top: -9999em;
  }

  :where([styled-mode]) .highcharts-crosshair-label text {
    fill: var(--highcharts-background-color, var(--_bg));
    font-size: 0.9em;
  }

  :where([styled-mode]) .highcharts-crosshair-label .highcharts-label-box {
    fill: inherit;
  }

  :where([styled-mode]) .highcharts-candlestick-series .highcharts-point {
    stroke: var(--highcharts-neutral-color-100, var(--vaadin-charts-candlestick-line, var(--vaadin-border-color)));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-candlestick-series .highcharts-point-up {
    fill: var(--highcharts-background-color, var(--_color-positive));
  }

  :where([styled-mode]) .highcharts-renko-series .highcharts-point-down,
  :where([styled-mode]) .highcharts-hollowcandlestick-series .highcharts-point-down {
    fill: var(--highcharts-negative-color, var(--_color-negative));
    stroke: var(--highcharts-negative-color, var(--_color-negative));
  }

  :where([styled-mode]) .highcharts-renko-series .highcharts-point-up,
  :where([styled-mode]) .highcharts-hollowcandlestick-series .highcharts-point-down-bearish-up {
    fill: var(--highcharts-positive-color, var(--_color-positive));
    stroke: var(--highcharts-positive-color, var(--_color-positive));
  }

  :where([styled-mode]) .highcharts-hollowcandlestick-series .highcharts-point-up {
    fill: transparent;
    stroke: var(--highcharts-positive-color, var(--_color-positive));
  }

  :where([styled-mode]) .highcharts-ohlc-series .highcharts-point-hover {
    stroke-width: 3px;
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point .highcharts-label-box {
    stroke: var(--highcharts-neutral-color-40, var(--_grid-line));
    fill: var(--highcharts-background-color, var(--_bg));
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point-hover .highcharts-label-box {
    stroke: var(
      --highcharts-neutral-color-100,
      color-mix(in srgb, var(--vaadin-charts-contrast, var(--_label)) 60%, transparent)
    );
    fill: var(--highcharts-highlight-color-20, var(--_bg));
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point text {
    fill: var(--highcharts-neutral-color-100, var(--_data-label));
    font-size: 0.9em;
    font-weight: bold;
  }

  /* Highcharts Maps */
  :where([styled-mode]) .highcharts-map-series .highcharts-point {
    transition:
      fill 500ms,
      fill-opacity 500ms,
      stroke-width 250ms;
    stroke: var(--highcharts-neutral-color-20);
    stroke-width: inherit;
  }

  :where([styled-mode]) .highcharts-map-series .highcharts-point-hover {
    transition:
      fill 0ms,
      fill-opacity 0ms;
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-mapline-series .highcharts-point {
    fill: none;
  }

  :where([styled-mode]) .highcharts-heatmap-series .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-map-navigation {
    font-size: 1.3em;
    font-weight: bold;
    text-align: center;
  }

  :where([styled-mode]) .highcharts-map-navigation.highcharts-button {
    fill: var(--highcharts-background-color);
    stroke: var(--highcharts-neutral-color-10);
  }

  :where([styled-mode]) .highcharts-map-navigation.highcharts-button:hover {
    fill: var(--highcharts-neutral-color-10);
  }

  :where([styled-mode]) .highcharts-map-navigation.highcharts-button .highcharts-button-symbol {
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-mapview-inset-border {
    stroke: var(--highcharts-neutral-color-20);
    stroke-width: 1px;
    fill: none;
  }

  :where([styled-mode]) .highcharts-coloraxis {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-coloraxis-marker {
    fill: var(--highcharts-neutral-color-40);
  }

  :where([styled-mode]) .highcharts-null-point {
    fill: var(--highcharts-neutral-color-3, var(--vaadin-charts-button-background, var(--vaadin-background-container)));
  }

  /* 3d charts */
  :where([styled-mode]) .highcharts-3d-frame {
    fill: transparent;
  }

  /* Exporting module */
  :where([styled-mode]) .highcharts-contextbutton {
    /* Fill is needed to capture hover */
    fill: var(--highcharts-background-color, var(--_bg));
    stroke: none;
    stroke-linecap: round;
  }

  :where([styled-mode]) .highcharts-contextbutton:hover {
    fill: var(--highcharts-neutral-color-10, #e6e6e6);
    stroke: var(--highcharts-neutral-color-10, #e6e6e6);
  }

  :where([styled-mode]) .highcharts-button-symbol {
    stroke: var(--highcharts-neutral-color-60, var(--_secondary-label));
    stroke-width: 3px;
  }

  :where([styled-mode]) .highcharts-menu {
    border: none;
    background: var(--highcharts-background-color, var(--_bg));
    border-radius: 3px;
    padding: 0.5em;
    box-shadow: 3px 3px 10px #888;
  }

  :where([styled-mode]) .highcharts-menu-item {
    background: none;
    border-radius: 3px;
    color: var(--highcharts-neutral-color-80, var(--vaadin-charts-button-label, var(--_label)));
    cursor: pointer;
    font-size: 1em;
    list-style-type: none;
    padding: 0.5em;
    transition:
      background 250ms,
      color 250ms;
  }

  :where([styled-mode]) .highcharts-menu-item:hover {
    background: var(--highcharts-neutral-color-5, var(--_bg));
  }

  /* Breadcrumbs */
  :where([styled-mode]) .highcharts-breadcrumbs-button {
    fill: none;
    stroke-width: 0;
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-breadcrumbs-separator {
    fill: var(--highcharts-neutral-color-60, var(--_secondary-label));
  }

  /* Drilldown module */
  :where([styled-mode]) .highcharts-drilldown-point {
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-drilldown-data-label text,
  :where([styled-mode]) text.highcharts-drilldown-data-label,
  :where([styled-mode]) .highcharts-drilldown-axis-label {
    cursor: pointer;
    fill: var(--highcharts-highlight-color-100, var(--vaadin-charts-button-label, var(--_label)));
    font-weight: bold;
    text-decoration: underline;
  }

  /* No-data module */
  :where([styled-mode]) .highcharts-no-data text {
    font-weight: bold;
    font-size: 1em;
    fill: var(--highcharts-neutral-color-60, var(--_secondary-label));
  }

  /* Drag-panes module */
  :where([styled-mode]) .highcharts-axis-resizer {
    cursor: ns-resize;
    stroke: var(--highcharts-neutral-color-100, black);
    stroke-width: 2px;
  }

  /* Bullet type series */
  :where([styled-mode]) .highcharts-bullet-target {
    stroke-width: 0;
  }

  /* Lineargauge type series */
  :where([styled-mode]) .highcharts-lineargauge-target {
    stroke-width: 1px;
    stroke: var(
      --highcharts-neutral-color-80,
      color-mix(in srgb, var(--vaadin-charts-contrast, var(--_label)) 60%, transparent)
    );
  }

  :where([styled-mode]) .highcharts-lineargauge-target-line {
    stroke-width: 1px;
    stroke: var(
      --highcharts-neutral-color-80,
      color-mix(in srgb, var(--vaadin-charts-contrast, var(--_label)) 60%, transparent)
    );
  }

  /* Advanced annotations module */
  :where([styled-mode]) .highcharts-fibonacci-background-0,
  :where([styled-mode]) .highcharts-pitchfork-inner-background,
  :where([styled-mode]) .highcharts-measure-background {
    fill: var(--highcharts-annotation-color-0);
  }

  :where([styled-mode]) .highcharts-fibonacci-background-1 {
    fill: var(--highcharts-annotation-color-1);
  }

  :where([styled-mode]) .highcharts-fibonacci-background-2 {
    fill: var(--highcharts-annotation-color-2);
  }

  :where([styled-mode]) .highcharts-fibonacci-background-3,
  :where([styled-mode]) .highcharts-pitchfork-outer-background {
    fill: var(--highcharts-annotation-color-3);
  }

  :where([styled-mode]) .highcharts-fibonacci-background-4 {
    fill: var(--highcharts-annotation-color-4);
  }

  :where([styled-mode]) .highcharts-fibonacci-background-5 {
    fill: var(--highcharts-annotation-color-5);
  }

  :where([styled-mode]) .highcharts-fibonacci-line {
    stroke: var(--highcharts-neutral-color-40);
  }

  :where([styled-mode]) .highcharts-crooked-lines,
  :where([styled-mode]) .highcharts-tunnel-lines,
  :where([styled-mode]) .highcharts-infinity-lines,
  :where([styled-mode]) .highcharts-timecycles-lines,
  :where([styled-mode]) .highcharts-fibonacci-timezones-lines,
  :where([styled-mode]) .highcharts-pitchfork-lines,
  :where([styled-mode]) .highcharts-vertical-line,
  :where([styled-mode]) .highcharts-measure-crosshair-x,
  :where([styled-mode]) .highcharts-measure-crosshair-y {
    stroke: var(--highcharts-neutral-color-100);
    stroke-opacity: 0.75;
    fill: none;
  }

  :where([styled-mode]) .highcharts-measure-crosshair-x,
  :where([styled-mode]) .highcharts-measure-crosshair-y {
    stroke-dasharray: 1, 3;
  }

  :where([styled-mode]) .highcharts-tunnel-background {
    fill: var(--highcharts-color-0);
  }

  :where([styled-mode]) .highcharts-annotation-shapes {
    cursor: move;
  }

  :where([styled-mode]) .highcharts-basic-shape {
    fill: var(--highcharts-neutral-color-100);
    stroke: var(--highcharts-neutral-color-100);
    opacity: 0.74;
  }

  /* Annotations module */

  :where([styled-mode]) .highcharts-annotation-label-box {
    stroke-width: 1px;
    stroke: var(--highcharts-neutral-color-100, var(--vaadin-charts-contrast, var(--_label)));
    fill: var(--highcharts-neutral-color-100, var(--vaadin-charts-contrast, var(--_label)));
    fill-opacity: 0.75;
  }

  :where([styled-mode]) .highcharts-annotation-label text {
    fill: var(--highcharts-neutral-color-10, var(--_label));
    font-size: 1em;
  }

  /* A11y module */
  :where([styled-mode]) .highcharts-a11y-proxy-element {
    border-width: 0;
    background-color: transparent;
    cursor: pointer;
    outline: none;
    opacity: 0.001;
    z-index: 999;
    overflow: hidden;
    padding: 0;
    margin: 0;
    display: block;
    position: absolute;
  }

  :where([styled-mode]) .highcharts-a11y-proxy-group li {
    list-style: none;
  }

  :where([styled-mode]) .highcharts-visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    overflow: hidden;
    white-space: nowrap;
    clip: rect(1px, 1px, 1px, 1px);
    margin-top: -3px;
    opacity: 0.01;
  }

  :where([styled-mode]) .highcharts-a11y-invisible {
    visibility: hidden;
  }

  :where([styled-mode]) .highcharts-a11y-proxy-container,
  :where([styled-mode]) .highcharts-a11y-proxy-container-before,
  :where([styled-mode]) .highcharts-a11y-proxy-container-after {
    position: absolute;
    white-space: nowrap;
  }

  :where([styled-mode]) g.highcharts-series,
  :where([styled-mode]) .highcharts-markers,
  :where([styled-mode]) .highcharts-point {
    outline: none;
  }

  /* Gantt */
  :where([styled-mode]) .highcharts-treegrid-node-collapsed,
  :where([styled-mode]) .highcharts-treegrid-node-expanded {
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-point-connecting-path {
    fill: none;
  }

  :where([styled-mode]) .highcharts-grid-axis .highcharts-tick {
    stroke: var(--highcharts-neutral-color-20, var(--_grid-line));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-grid-axis .highcharts-axis-line {
    stroke: var(--highcharts-neutral-color-20, var(--_grid-line));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-gantt-series .highcharts-partfill-overlay {
    fill: hsla(0, 0%, 0%, 0.3);
    stroke: hsla(0, 0%, 0%, 0.3);
  }

  /* RTL styles */
  :host([dir='rtl']) :where([styled-mode]) .highcharts-container {
    text-align: right;
  }

  :host([dir='rtl']) :where([styled-mode]) input.highcharts-range-selector {
    left: auto;
    right: -9em;
  }

  :host([dir='rtl']) :where([styled-mode]) .highcharts-menu {
    box-shadow: -3px 3px 10px #888;
  }
`;

// node_modules/highcharts/es-modules/Core/Globals.js
var Globals;
(function(Globals2) {
  Globals2.SVG_NS = "http://www.w3.org/2000/svg", Globals2.product = "Highcharts", Globals2.version = "12.2.0", Globals2.win = typeof window !== "undefined" ? window : {}, // eslint-disable-line node/no-unsupported-features/es-builtins
  Globals2.doc = Globals2.win.document, Globals2.svg = !!Globals2.doc?.createElementNS?.(Globals2.SVG_NS, "svg")?.createSVGRect, Globals2.pageLang = Globals2.doc?.documentElement?.closest("[lang]")?.lang, Globals2.userAgent = Globals2.win.navigator?.userAgent || "", Globals2.isChrome = Globals2.win.chrome, Globals2.isFirefox = Globals2.userAgent.indexOf("Firefox") !== -1, Globals2.isMS = /(edge|msie|trident)/i.test(Globals2.userAgent) && !Globals2.win.opera, Globals2.isSafari = !Globals2.isChrome && Globals2.userAgent.indexOf("Safari") !== -1, Globals2.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(Globals2.userAgent), Globals2.isWebKit = Globals2.userAgent.indexOf("AppleWebKit") !== -1, Globals2.deg2rad = Math.PI * 2 / 360, Globals2.marginNames = [
    "plotTop",
    "marginRight",
    "marginBottom",
    "plotLeft"
  ], Globals2.noop = function() {
  }, Globals2.supportsPassiveEvents = (function() {
    let supportsPassive = false;
    if (!Globals2.isMS) {
      const opts = Object.defineProperty({}, "passive", {
        get: function() {
          supportsPassive = true;
        }
      });
      if (Globals2.win.addEventListener && Globals2.win.removeEventListener) {
        Globals2.win.addEventListener("testPassive", Globals2.noop, opts);
        Globals2.win.removeEventListener("testPassive", Globals2.noop, opts);
      }
    }
    return supportsPassive;
  })();
  Globals2.charts = [];
  Globals2.composed = [];
  Globals2.dateFormats = {};
  Globals2.seriesTypes = {};
  Globals2.symbolSizes = {};
  Globals2.chartCount = 0;
})(Globals || (Globals = {}));
var Globals_default = Globals;

// node_modules/highcharts/es-modules/Core/Utilities.js
var { charts, doc, win } = Globals_default;
function error(code, stop4, chart, params) {
  const severity = stop4 ? "Highcharts error" : "Highcharts warning";
  if (code === 32) {
    code = `${severity}: Deprecated member`;
  }
  const isCode = isNumber(code);
  let message = isCode ? `${severity} #${code}: www.highcharts.com/errors/${code}/` : code.toString();
  const defaultHandler = function() {
    if (stop4) {
      throw new Error(message);
    }
    if (win.console && error.messages.indexOf(message) === -1) {
      console.warn(message);
    }
  };
  if (typeof params !== "undefined") {
    let additionalMessages = "";
    if (isCode) {
      message += "?";
    }
    objectEach(params, function(value, key) {
      additionalMessages += `
 - ${key}: ${value}`;
      if (isCode) {
        message += encodeURI(key) + "=" + encodeURI(value);
      }
    });
    message += additionalMessages;
  }
  fireEvent(Globals_default, "displayError", { chart, code, message, params }, defaultHandler);
  error.messages.push(message);
}
(function(error13) {
  error13.messages = [];
})(error || (error = {}));
function merge(extendOrSource, ...sources) {
  let i, args = [extendOrSource, ...sources], ret = {};
  const doCopy = function(copy, original) {
    if (typeof copy !== "object") {
      copy = {};
    }
    objectEach(original, function(value, key) {
      if (key === "__proto__" || key === "constructor") {
        return;
      }
      if (isObject(value, true) && !isClass(value) && !isDOMElement(value)) {
        copy[key] = doCopy(copy[key] || {}, value);
      } else {
        copy[key] = original[key];
      }
    });
    return copy;
  };
  if (extendOrSource === true) {
    ret = args[1];
    args = Array.prototype.slice.call(args, 2);
  }
  const len = args.length;
  for (i = 0; i < len; i++) {
    ret = doCopy(ret, args[i]);
  }
  return ret;
}
function clamp(value, min4, max4) {
  return value > min4 ? value < max4 ? value : max4 : min4;
}
function crisp(value, lineWidth = 0, inverted) {
  const mod = lineWidth % 2 / 2, inverter = inverted ? -1 : 1;
  return (Math.round(value * inverter - mod) + mod) * inverter;
}
function diffObjects(newer, older, keepOlder, collectionsWithUpdate) {
  const ret = {};
  function diff(newer2, older2, ret2, depth) {
    const keeper = keepOlder ? older2 : newer2;
    objectEach(newer2, function(newerVal, key) {
      if (!depth && collectionsWithUpdate && collectionsWithUpdate.indexOf(key) > -1 && older2[key]) {
        newerVal = splat(newerVal);
        ret2[key] = [];
        for (let i = 0; i < Math.max(newerVal.length, older2[key].length); i++) {
          if (older2[key][i]) {
            if (newerVal[i] === void 0) {
              ret2[key][i] = older2[key][i];
            } else {
              ret2[key][i] = {};
              diff(newerVal[i], older2[key][i], ret2[key][i], depth + 1);
            }
          }
        }
      } else if (isObject(newerVal, true) && !newerVal.nodeType) {
        ret2[key] = isArray(newerVal) ? [] : {};
        diff(newerVal, older2[key] || {}, ret2[key], depth + 1);
        if (Object.keys(ret2[key]).length === 0 && // Except colorAxis which is a special case where the empty
        // object means it is enabled. Which is unfortunate and we
        // should try to find a better way.
        !(key === "colorAxis" && depth === 0)) {
          delete ret2[key];
        }
      } else if (newer2[key] !== older2[key] || // If the newer key is explicitly undefined, keep it (#10525)
      key in newer2 && !(key in older2)) {
        if (key !== "__proto__" && key !== "constructor") {
          ret2[key] = keeper[key];
        }
      }
    });
  }
  diff(newer, older, ret, 0);
  return ret;
}
function pInt(s, mag) {
  return parseInt(s, mag || 10);
}
function isString(s) {
  return typeof s === "string";
}
function isArray(obj) {
  const str = Object.prototype.toString.call(obj);
  return str === "[object Array]" || str === "[object Array Iterator]";
}
function isObject(obj, strict) {
  return !!obj && typeof obj === "object" && (!strict || !isArray(obj));
}
function isDOMElement(obj) {
  return isObject(obj) && typeof obj.nodeType === "number";
}
function isClass(obj) {
  const c = obj?.constructor;
  return !!(isObject(obj, true) && !isDOMElement(obj) && (c?.name && c.name !== "Object"));
}
function isNumber(n) {
  return typeof n === "number" && !isNaN(n) && n < Infinity && n > -Infinity;
}
function erase(arr, item) {
  let i = arr.length;
  while (i--) {
    if (arr[i] === item) {
      arr.splice(i, 1);
      break;
    }
  }
}
function insertItem(item, collection) {
  const indexOption = item.options.index, length = collection.length;
  let i;
  for (
    // Internal item (navigator) should always be pushed to the end
    i = item.options.isInternal ? length : 0;
    i < length + 1;
    i++
  ) {
    if (
      // No index option, reached the end of the collection,
      // equivalent to pushing
      !collection[i] || // Handle index option, the element to insert has lower index
      isNumber(indexOption) && indexOption < pick(collection[i].options.index, collection[i]._i) || // Insert the new item before other internal items
      // (navigator)
      collection[i].options.isInternal
    ) {
      collection.splice(i, 0, item);
      break;
    }
  }
  return i;
}
function pushUnique(array, item) {
  return array.indexOf(item) < 0 && !!array.push(item);
}
function defined(obj) {
  return typeof obj !== "undefined" && obj !== null;
}
function attr2(elem, keyOrAttribs, value) {
  const isGetter = isString(keyOrAttribs) && !defined(value);
  let ret;
  const attrSingle = (value2, key) => {
    if (defined(value2)) {
      elem.setAttribute(key, value2);
    } else if (isGetter) {
      ret = elem.getAttribute(key);
      if (!ret && key === "class") {
        ret = elem.getAttribute(key + "Name");
      }
    } else {
      elem.removeAttribute(key);
    }
  };
  if (isString(keyOrAttribs)) {
    attrSingle(value, keyOrAttribs);
  } else {
    objectEach(keyOrAttribs, attrSingle);
  }
  return ret;
}
function splat(obj) {
  return isArray(obj) ? obj : [obj];
}
function syncTimeout(fn, delay, context) {
  if (delay > 0) {
    return setTimeout(fn, delay, context);
  }
  fn.call(0, context);
  return -1;
}
function internalClearTimeout(id) {
  if (defined(id)) {
    clearTimeout(id);
  }
}
function extend(a, b) {
  let n;
  if (!a) {
    a = {};
  }
  for (n in b) {
    a[n] = b[n];
  }
  return a;
}
function pick() {
  const args = arguments;
  const length = args.length;
  for (let i = 0; i < length; i++) {
    const arg = args[i];
    if (typeof arg !== "undefined" && arg !== null) {
      return arg;
    }
  }
}
function css2(el, styles) {
  extend(el.style, styles);
}
function createElement(tag, attribs, styles, parent, nopad) {
  const el = doc.createElement(tag);
  if (attribs) {
    extend(el, attribs);
  }
  if (nopad) {
    css2(el, { padding: "0", border: "none", margin: "0" });
  }
  if (styles) {
    css2(el, styles);
  }
  if (parent) {
    parent.appendChild(el);
  }
  return el;
}
function extendClass(parent, members) {
  const obj = (function() {
  });
  obj.prototype = new parent();
  extend(obj.prototype, members);
  return obj;
}
function pad(number, length, padder) {
  return new Array((length || 2) + 1 - String(number).replace("-", "").length).join(padder || "0") + number;
}
function relativeLength(value, base, offset3) {
  return /%$/.test(value) ? base * parseFloat(value) / 100 + (offset3 || 0) : parseFloat(value);
}
function replaceNested(text, ...replacements) {
  let previous, replacement;
  do {
    previous = text;
    for (replacement of replacements) {
      text = text.replace(replacement[0], replacement[1]);
    }
  } while (text !== previous);
  return text;
}
function wrap(obj, method, func) {
  const proceed = obj[method];
  obj[method] = function() {
    const outerArgs = arguments, scope = this;
    return func.apply(this, [
      function() {
        return proceed.apply(scope, arguments.length ? arguments : outerArgs);
      }
    ].concat([].slice.call(arguments)));
  };
}
function getMagnitude(num) {
  return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
}
function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, hasTickAmount) {
  let i, retInterval = interval;
  magnitude = pick(magnitude, getMagnitude(interval));
  const normalized = interval / magnitude;
  if (!multiples) {
    multiples = hasTickAmount ? (
      // Finer grained ticks when the tick amount is hard set, including
      // when alignTicks is true on multiple axes (#4580).
      [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10]
    ) : (
      // Else, let ticks fall on rounder numbers
      [1, 2, 2.5, 5, 10]
    );
    if (allowDecimals === false) {
      if (magnitude === 1) {
        multiples = multiples.filter(function(num) {
          return num % 1 === 0;
        });
      } else if (magnitude <= 0.1) {
        multiples = [1 / magnitude];
      }
    }
  }
  for (i = 0; i < multiples.length; i++) {
    retInterval = multiples[i];
    if (hasTickAmount && retInterval * magnitude >= interval || !hasTickAmount && normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
      break;
    }
  }
  retInterval = correctFloat(retInterval * magnitude, -Math.round(Math.log(1e-3) / Math.LN10));
  return retInterval;
}
function stableSort(arr, sortFunction) {
  const length = arr.length;
  let sortValue, i;
  for (i = 0; i < length; i++) {
    arr[i].safeI = i;
  }
  arr.sort(function(a, b) {
    sortValue = sortFunction(a, b);
    return sortValue === 0 ? a.safeI - b.safeI : sortValue;
  });
  for (i = 0; i < length; i++) {
    delete arr[i].safeI;
  }
}
function arrayMin(data) {
  let i = data.length, min4 = data[0];
  while (i--) {
    if (data[i] < min4) {
      min4 = data[i];
    }
  }
  return min4;
}
function arrayMax(data) {
  let i = data.length, max4 = data[0];
  while (i--) {
    if (data[i] > max4) {
      max4 = data[i];
    }
  }
  return max4;
}
function destroyObjectProperties(obj, except, destructablesOnly) {
  objectEach(obj, function(val, n) {
    if (val !== except && val?.destroy) {
      val.destroy();
    }
    if (val?.destroy || !destructablesOnly) {
      delete obj[n];
    }
  });
}
function discardElement(element) {
  element?.parentElement?.removeChild(element);
}
function correctFloat(num, prec) {
  return num > 1e14 ? num : parseFloat(num.toPrecision(prec || 14));
}
var timeUnits = {
  millisecond: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 24 * 36e5,
  week: 7 * 24 * 36e5,
  month: 28 * 24 * 36e5,
  year: 364 * 24 * 36e5
};
Math.easeInOutSine = function(pos) {
  return -0.5 * (Math.cos(Math.PI * pos) - 1);
};
var getAlignFactor = (align = "") => ({
  center: 0.5,
  right: 1,
  middle: 0.5,
  bottom: 1
})[align] || 0;
function getClosestDistance(arrays, onError) {
  const allowNegative = !onError;
  let closest, loopLength, distance, i;
  arrays.forEach((xData) => {
    if (xData.length > 1) {
      loopLength = xData.length - 1;
      for (i = loopLength; i > 0; i--) {
        distance = xData[i] - xData[i - 1];
        if (distance < 0 && !allowNegative) {
          onError?.();
          onError = void 0;
        } else if (distance && (typeof closest === "undefined" || distance < closest)) {
          closest = distance;
        }
      }
    }
  });
  return closest;
}
function getNestedProperty(path, parent) {
  const pathElements = path.split(".");
  while (pathElements.length && defined(parent)) {
    const pathElement = pathElements.shift();
    if (typeof pathElement === "undefined" || pathElement === "__proto__") {
      return;
    }
    if (pathElement === "this") {
      let thisProp;
      if (isObject(parent)) {
        thisProp = parent["@this"];
      }
      return thisProp ?? parent;
    }
    const child = parent[pathElement.replace(/[\\'"]/g, "")];
    if (!defined(child) || typeof child === "function" || typeof child.nodeType === "number" || child === win) {
      return;
    }
    parent = child;
  }
  return parent;
}
function getStyle(el, prop, toInt) {
  let style;
  if (prop === "width") {
    let offsetWidth = Math.min(el.offsetWidth, el.scrollWidth);
    const boundingClientRectWidth = el.getBoundingClientRect?.().width;
    if (boundingClientRectWidth < offsetWidth && boundingClientRectWidth >= offsetWidth - 1) {
      offsetWidth = Math.floor(boundingClientRectWidth);
    }
    return Math.max(
      0,
      // #8377
      offsetWidth - (getStyle(el, "padding-left", true) || 0) - (getStyle(el, "padding-right", true) || 0)
    );
  }
  if (prop === "height") {
    return Math.max(
      0,
      // #8377
      Math.min(el.offsetHeight, el.scrollHeight) - (getStyle(el, "padding-top", true) || 0) - (getStyle(el, "padding-bottom", true) || 0)
    );
  }
  const css19 = win.getComputedStyle(el, void 0);
  if (css19) {
    style = css19.getPropertyValue(prop);
    if (pick(toInt, prop !== "opacity")) {
      style = pInt(style);
    }
  }
  return style;
}
var find = Array.prototype.find ? function(arr, callback) {
  return arr.find(callback);
} : (
  // Legacy implementation. PhantomJS, IE <= 11 etc. #7223.
  function(arr, callback) {
    let i;
    const length = arr.length;
    for (i = 0; i < length; i++) {
      if (callback(arr[i], i)) {
        return arr[i];
      }
    }
  }
);
function offset(el) {
  const docElem = doc.documentElement, box = el.parentElement || el.parentNode ? el.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 };
  return {
    top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
    left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),
    width: box.width,
    height: box.height
  };
}
function objectEach(obj, fn, ctx) {
  for (const key in obj) {
    if (Object.hasOwnProperty.call(obj, key)) {
      fn.call(ctx || obj[key], obj[key], key, obj);
    }
  }
}
function addEvent(el, type, fn, options2 = {}) {
  const owner = typeof el === "function" && el.prototype || el;
  if (!Object.hasOwnProperty.call(owner, "hcEvents")) {
    owner.hcEvents = {};
  }
  const events = owner.hcEvents;
  if (Globals_default.Point && // Without H a dependency loop occurs
  el instanceof Globals_default.Point && el.series && el.series.chart) {
    el.series.chart.runTrackerClick = true;
  }
  const addEventListener = el.addEventListener;
  if (addEventListener) {
    addEventListener.call(el, type, fn, Globals_default.supportsPassiveEvents ? {
      passive: options2.passive === void 0 ? type.indexOf("touch") !== -1 : options2.passive,
      capture: false
    } : false);
  }
  if (!events[type]) {
    events[type] = [];
  }
  const eventObject = {
    fn,
    order: typeof options2.order === "number" ? options2.order : Infinity
  };
  events[type].push(eventObject);
  events[type].sort((a, b) => a.order - b.order);
  return function() {
    removeEvent(el, type, fn);
  };
}
function removeEvent(el, type, fn) {
  function removeOneEvent(type2, fn2) {
    const removeEventListener = el.removeEventListener;
    if (removeEventListener) {
      removeEventListener.call(el, type2, fn2, false);
    }
  }
  function removeAllEvents(eventCollection) {
    let types, len;
    if (!el.nodeName) {
      return;
    }
    if (type) {
      types = {};
      types[type] = true;
    } else {
      types = eventCollection;
    }
    objectEach(types, function(_val, n) {
      if (eventCollection[n]) {
        len = eventCollection[n].length;
        while (len--) {
          removeOneEvent(n, eventCollection[n][len].fn);
        }
      }
    });
  }
  const owner = typeof el === "function" && el.prototype || el;
  if (Object.hasOwnProperty.call(owner, "hcEvents")) {
    const events = owner.hcEvents;
    if (type) {
      const typeEvents = events[type] || [];
      if (fn) {
        events[type] = typeEvents.filter(function(obj) {
          return fn !== obj.fn;
        });
        removeOneEvent(type, fn);
      } else {
        removeAllEvents(events);
        events[type] = [];
      }
    } else {
      removeAllEvents(events);
      delete owner.hcEvents;
    }
  }
}
function fireEvent(el, type, eventArguments, defaultFunction) {
  eventArguments = eventArguments || {};
  if (doc?.createEvent && (el.dispatchEvent || el.fireEvent && // Enable firing events on Highcharts instance.
  el !== Globals_default)) {
    const e = doc.createEvent("Events");
    e.initEvent(type, true, true);
    eventArguments = extend(e, eventArguments);
    if (el.dispatchEvent) {
      el.dispatchEvent(eventArguments);
    } else {
      el.fireEvent(type, eventArguments);
    }
  } else if (el.hcEvents) {
    if (!eventArguments.target) {
      extend(eventArguments, {
        // Attach a simple preventDefault function to skip
        // default handler if called. The built-in
        // defaultPrevented property is not overwritable (#5112)
        preventDefault: function() {
          eventArguments.defaultPrevented = true;
        },
        // Setting target to native events fails with clicking
        // the zoom-out button in Chrome.
        target: el,
        // If the type is not set, we're running a custom event
        // (#2297). If it is set, we're running a browser event.
        type
      });
    }
    const events = [];
    let object = el;
    let multilevel = false;
    while (object.hcEvents) {
      if (Object.hasOwnProperty.call(object, "hcEvents") && object.hcEvents[type]) {
        if (events.length) {
          multilevel = true;
        }
        events.unshift.apply(events, object.hcEvents[type]);
      }
      object = Object.getPrototypeOf(object);
    }
    if (multilevel) {
      events.sort((a, b) => a.order - b.order);
    }
    events.forEach((obj) => {
      if (obj.fn.call(el, eventArguments) === false) {
        eventArguments.preventDefault();
      }
    });
  }
  if (defaultFunction && !eventArguments.defaultPrevented) {
    defaultFunction.call(el, eventArguments);
  }
}
var serialMode;
var uniqueKey = (function() {
  const hash = Math.random().toString(36).substring(2, 9) + "-";
  let id = 0;
  return function() {
    return "highcharts-" + (serialMode ? "" : hash) + id++;
  };
})();
function useSerialIds(mode) {
  return serialMode = pick(mode, serialMode);
}
function isFunction(obj) {
  return typeof obj === "function";
}
function ucfirst(s) {
  return isString(s) ? s.substring(0, 1).toUpperCase() + s.substring(1) : String(s);
}
if (win.jQuery) {
  win.jQuery.fn.highcharts = function() {
    const args = [].slice.call(arguments);
    if (this[0]) {
      if (args[0]) {
        new Globals_default[
          // eslint-disable-line computed-property-spacing, no-new
          // Constructor defaults to Chart
          isString(args[0]) ? args.shift() : "Chart"
        ](this[0], args[0], args[1]);
        return this;
      }
      return charts[attr2(this[0], "data-highcharts-chart")];
    }
  };
}
var Utilities = {
  addEvent,
  arrayMax,
  arrayMin,
  attr: attr2,
  clamp,
  clearTimeout: internalClearTimeout,
  correctFloat,
  createElement,
  crisp,
  css: css2,
  defined,
  destroyObjectProperties,
  diffObjects,
  discardElement,
  erase,
  error,
  extend,
  extendClass,
  find,
  fireEvent,
  getAlignFactor,
  getClosestDistance,
  getMagnitude,
  getNestedProperty,
  getStyle,
  insertItem,
  isArray,
  isClass,
  isDOMElement,
  isFunction,
  isNumber,
  isObject,
  isString,
  merge,
  normalizeTickInterval,
  objectEach,
  offset,
  pad,
  pick,
  pInt,
  pushUnique,
  relativeLength,
  removeEvent,
  replaceNested,
  splat,
  stableSort,
  syncTimeout,
  timeUnits,
  ucfirst,
  uniqueKey,
  useSerialIds,
  wrap
};
var Utilities_default = Utilities;

// node_modules/highcharts/es-modules/Core/Chart/ChartDefaults.js
var ChartDefaults = {
  /**
   * Default `mapData` for all series, in terms of a GeoJSON or TopoJSON
   * object. If set to a string, it functions as an index into the
   * `Highcharts.maps` array.
   *
   * For picking out individual shapes and geometries to use for each series
   * of the map, see [series.mapData](#series.map.mapData).
   *
   * @sample    maps/demo/geojson
   *            Loading GeoJSON data
   * @sample    maps/chart/topojson
   *            Loading TopoJSON data
   *
   * @type      {string|Array<*>|Highcharts.GeoJSON|Highcharts.TopoJSON}
   * @since     5.0.0
   * @product   highmaps
   * @apioption chart.map
   */
  /**
   * Set lat/lon transformation definitions for the chart. If not defined,
   * these are extracted from the map data.
   *
   * @type      {*}
   * @since     5.0.0
   * @product   highmaps
   * @apioption chart.mapTransforms
   */
  /**
   * When using multiple axes, the ticks of two or more opposite axes
   * will automatically be aligned by adding ticks to the axis or axes
   * with the least ticks, as if `tickAmount` were specified.
   *
   * This can be prevented by setting `alignTicks` to false. If the grid
   * lines look messy, it's a good idea to hide them for the secondary
   * axis by setting `gridLineWidth` to 0.
   *
   * If `startOnTick` or `endOnTick` in the axis options are set to false,
   * then the `alignTicks ` will be disabled for the axis.
   *
   * Disabled for logarithmic axes.
   *
   * @sample {highcharts} highcharts/chart/alignticks-true/
   *         True by default
   * @sample {highcharts} highcharts/chart/alignticks-false/
   *         False
   * @sample {highstock} stock/chart/alignticks-true/
   *         True by default
   * @sample {highstock} stock/chart/alignticks-false/
   *         False
   *
   * @type      {boolean}
   * @default   true
   * @product   highcharts highstock gantt
   * @apioption chart.alignTicks
   */
  /**
   * When using multiple axes, align the thresholds. When this is true, other
   * ticks will also be aligned.
   *
   * Note that for line series and some other series types, the `threshold`
   * option is set to `null` by default. This will in turn cause their y-axis
   * to not have a threshold. In order to avoid that, set the series
   * `threshold` to 0 or another number.
   *
   * If `startOnTick` or `endOnTick` in the axis options are set to false, or
   * if the axis is logarithmic, the threshold will not be aligned.
   *
   * @sample {highcharts} highcharts/chart/alignthresholds/ Set to true
   *
   * @since 10.0.0
   * @product   highcharts highstock gantt
   * @apioption chart.alignThresholds
   */
  alignThresholds: false,
  /**
   * Set the overall animation for all chart updating. Animation can be
   * disabled throughout the chart by setting it to false here. It can
   * be overridden for each individual API method as a function parameter.
   * The only animation not affected by this option is the initial series
   * animation, see [plotOptions.series.animation](
   * #plotOptions.series.animation).
   *
   * The animation can either be set as a boolean or a configuration
   * object. If `true`, it will use the 'swing' jQuery easing and a
   * duration of 500 ms. If used as a configuration object, the following
   * properties are supported:
   *
   * - `defer`: The animation delay time in milliseconds.
   *
   * - `duration`: The duration of the animation in milliseconds.
   *
   * - `easing`: A string reference to an easing function set on the
   *   `Math` object. See
   *   [the easing demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).
   *
   * When zooming on a series with less than 100 points, the chart redraw
   * will be done with animation, but in case of more data points, it is
   * necessary to set this option to ensure animation on zoom.
   *
   * @sample {highcharts} highcharts/chart/animation-none/
   *         Updating with no animation
   * @sample {highcharts} highcharts/chart/animation-duration/
   *         With a longer duration
   * @sample {highcharts} highcharts/chart/animation-easing/
   *         With a jQuery UI easing
   * @sample {highmaps} maps/chart/animation-none/
   *         Updating with no animation
   * @sample {highmaps} maps/chart/animation-duration/
   *         With a longer duration
   *
   * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
   * @default   true
   * @apioption chart.animation
   */
  /**
   * A CSS class name to apply to the charts container `div`, allowing
   * unique CSS styling for each chart.
   *
   * @type      {string}
   * @apioption chart.className
   */
  /**
   * Event listeners for the chart.
   *
   * @apioption chart.events
   */
  /**
   * Fires when a series is added to the chart after load time, using the
   * `addSeries` method. One parameter, `event`, is passed to the
   * function, containing common event information. Through
   * `event.options` you can access the series options that were passed to
   * the `addSeries` method. Returning false prevents the series from
   * being added.
   *
   * @sample {highcharts} highcharts/chart/events-addseries/
   *         Alert on add series
   * @sample {highstock} stock/chart/events-addseries/
   *         Alert on add series
   *
   * @type      {Highcharts.ChartAddSeriesCallbackFunction}
   * @since     1.2.0
   * @context   Highcharts.Chart
   * @apioption chart.events.addSeries
   */
  /**
   * Fires when clicking on the plot background. One parameter, `event`,
   * is passed to the function, containing common event information.
   *
   * Information on the clicked spot can be found through `event.xAxis`
   * and `event.yAxis`, which are arrays containing the axes of each
   * dimension and each axis' value at the clicked spot. The primary axes
   * are `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
   * datetime axis is milliseconds since 1970-01-01 00:00:00.
   *
   * ```js
   * click: function(e) {
   *     console.log(
   *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', e.xAxis[0].value),
   *         e.yAxis[0].value
   *     )
   * }
   * ```
   *
   * @sample {highcharts} highcharts/chart/events-click/
   *         Alert coordinates on click
   * @sample {highcharts} highcharts/chart/events-container/
   *         Alternatively, attach event to container
   * @sample {highstock} stock/chart/events-click/
   *         Alert coordinates on click
   * @sample {highstock} highcharts/chart/events-container/
   *         Alternatively, attach event to container
   * @sample {highmaps} maps/chart/events-click/
   *         Record coordinates on click
   * @sample {highmaps} highcharts/chart/events-container/
   *         Alternatively, attach event to container
   *
   * @type      {Highcharts.ChartClickCallbackFunction}
   * @since     1.2.0
   * @context   Highcharts.Chart
   * @apioption chart.events.click
   */
  /**
   * Fires when the chart is finished loading. Since v4.2.2, it also waits
   * for images to be loaded, for example from point markers. One
   * parameter, `event`, is passed to the function, containing common
   * event information.
   *
   * There is also a second parameter to the chart constructor where a
   * callback function can be passed to be executed on chart.load.
   *
   * @sample {highcharts} highcharts/chart/events-load/
   *         Alert on chart load
   * @sample {highcharts} highcharts/chart/events-render/
   *         Load vs Redraw vs Render
   * @sample {highstock} stock/chart/events-load/
   *         Alert on chart load
   * @sample {highmaps} maps/chart/events-load/
   *         Add series on chart load
   *
   * @type      {Highcharts.ChartLoadCallbackFunction}
   * @context   Highcharts.Chart
   * @apioption chart.events.load
   */
  /**
   * Fires when the chart is redrawn, either after a call to
   * `chart.redraw()` or after an axis, series or point is modified with
   * the `redraw` option set to `true`. One parameter, `event`, is passed
   * to the function, containing common event information.
   *
   * @sample {highcharts} highcharts/chart/events-redraw/
   *         Alert on chart redraw
   * @sample {highcharts} highcharts/chart/events-render/
   *         Load vs Redraw vs Render
   * @sample {highstock} stock/chart/events-redraw/
   *         Alert on chart redraw when adding a series or moving the
   *         zoomed range
   * @sample {highmaps} maps/chart/events-redraw/
   *         Set subtitle on chart redraw
   *
   * @type      {Highcharts.ChartRedrawCallbackFunction}
   * @since     1.2.0
   * @context   Highcharts.Chart
   * @apioption chart.events.redraw
   */
  /**
   * Fires after initial load of the chart (directly after the `load`
   * event), and after each redraw (directly after the `redraw` event).
   *
   * @sample {highcharts} highcharts/chart/events-render/
   *         Load vs Redraw vs Render
   *
   * @type      {Highcharts.ChartRenderCallbackFunction}
   * @since     5.0.7
   * @context   Highcharts.Chart
   * @apioption chart.events.render
   */
  /**
   * Fires when an area of the chart has been selected. Selection is
   * enabled by setting the chart's zoomType. One parameter, `event`, is
   * passed to the function, containing common event information. The
   * default action for the selection event is to zoom the chart to the
   * selected area. It can be prevented by calling
   * `event.preventDefault()` or return false.
   *
   * Information on the selected area can be found through `event.xAxis`
   * and `event.yAxis`, which are arrays containing the axes of each
   * dimension and each axis' min and max values. The primary axes are
   * `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
   * datetime axis is milliseconds since 1970-01-01 00:00:00.
   *
   * ```js
   * selection: function(event) {
   *     // log the min and max of the primary, datetime x-axis
   *     console.log(
   *         Highcharts.dateFormat(
   *             '%Y-%m-%d %H:%M:%S',
   *             event.xAxis[0].min
   *         ),
   *         Highcharts.dateFormat(
   *             '%Y-%m-%d %H:%M:%S',
   *             event.xAxis[0].max
   *         )
   *     );
   *     // log the min and max of the y axis
   *     console.log(event.yAxis[0].min, event.yAxis[0].max);
   * }
   * ```
   *
   * @sample {highcharts} highcharts/chart/events-selection/
   *         Report on selection and reset
   * @sample {highcharts} highcharts/chart/events-selection-points/
   *         Select a range of points through a drag selection
   * @sample {highstock} stock/chart/events-selection/
   *         Report on selection and reset
   * @sample {highstock} highcharts/chart/events-selection-points/
   *         Select a range of points through a drag selection
   *         (Highcharts)
   *
   * @type      {Highcharts.ChartSelectionCallbackFunction}
   * @apioption chart.events.selection
   */
  /**
   * The margin between the outer edge of the chart and the plot area.
   * The numbers in the array designate top, right, bottom and left
   * respectively. Use the options `marginTop`, `marginRight`,
   * `marginBottom` and `marginLeft` for shorthand setting of one option.
   *
   * By default there is no margin. The actual space is dynamically
   * calculated from the offset of axis labels, axis title, title,
   * subtitle and legend in addition to the `spacingTop`, `spacingRight`,
   * `spacingBottom` and `spacingLeft` options.
   *
   * @sample {highcharts} highcharts/chart/margins-zero/
   *         Zero margins
   * @sample {highstock} stock/chart/margin-zero/
   *         Zero margins
   *
   * @type      {number|Array<number>}
   * @apioption chart.margin
   */
  /**
   * The margin between the bottom outer edge of the chart and the plot
   * area. Use this to set a fixed pixel value for the margin as opposed
   * to the default dynamic margin. See also `spacingBottom`.
   *
   * @sample {highcharts} highcharts/chart/marginbottom/
   *         100px bottom margin
   * @sample {highstock} stock/chart/marginbottom/
   *         100px bottom margin
   * @sample {highmaps} maps/chart/margin/
   *         100px margins
   *
   * @type      {number}
   * @since     2.0
   * @apioption chart.marginBottom
   */
  /**
   * The margin between the left outer edge of the chart and the plot
   * area. Use this to set a fixed pixel value for the margin as opposed
   * to the default dynamic margin. See also `spacingLeft`.
   *
   * @sample {highcharts} highcharts/chart/marginleft/
   *         150px left margin
   * @sample {highstock} stock/chart/marginleft/
   *         150px left margin
   * @sample {highmaps} maps/chart/margin/
   *         100px margins
   *
   * @type      {number}
   * @since     2.0
   * @apioption chart.marginLeft
   */
  /**
   * The margin between the right outer edge of the chart and the plot
   * area. Use this to set a fixed pixel value for the margin as opposed
   * to the default dynamic margin. See also `spacingRight`.
   *
   * @sample {highcharts} highcharts/chart/marginright/
   *         100px right margin
   * @sample {highstock} stock/chart/marginright/
   *         100px right margin
   * @sample {highmaps} maps/chart/margin/
   *         100px margins
   *
   * @type      {number}
   * @since     2.0
   * @apioption chart.marginRight
   */
  /**
   * The margin between the top outer edge of the chart and the plot area.
   * Use this to set a fixed pixel value for the margin as opposed to
   * the default dynamic margin. See also `spacingTop`.
   *
   * @sample {highcharts} highcharts/chart/margintop/ 100px top margin
   * @sample {highstock} stock/chart/margintop/
   *         100px top margin
   * @sample {highmaps} maps/chart/margin/
   *         100px margins
   *
   * @type      {number}
   * @since     2.0
   * @apioption chart.marginTop
   */
  /**
   * Callback function to override the default function that formats all
   * the numbers in the chart. Returns a string with the formatted number.
   *
   * @sample highcharts/members/highcharts-numberformat
   *      Arabic digits in Highcharts
   * @type {Highcharts.NumberFormatterCallbackFunction}
   * @since 8.0.0
   * @apioption chart.numberFormatter
   */
  /**
   * When a chart with an x and a y-axis is rendered, we first pre-render the
   * labels of both in order to measure them. Then, if either of the axis
   * labels take up so much space that it significantly affects the length of
   * the other axis, we repeat the process.
   *
   * By default we stop at two axis layout runs, but it may be that the second
   * run also alter the space required by either axis, for example if it
   * causes the labels to rotate. In this situation, a subsequent redraw of
   * the chart may cause the tick and label placement to change for apparently
   * no reason.
   *
   * Use the `axisLayoutRuns` option to set the maximum allowed number of
   * repetitions. But keep in mind that the default value of 2 is set because
   * every run costs performance time.
   *
   * **Note:** Changing that option to higher than the default might decrease
   * performance significantly, especially with bigger sets of data.
   *
   * @type      {number}
   * @default   2
   * @since     11.3.0
   * @apioption chart.axisLayoutRuns
   */
  /**
   * Allows setting a key to switch between zooming and panning. Can be
   * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows
   * key on Windows) or `shift`. The keys are mapped directly to the key
   * properties of the click event argument (`event.altKey`,
   * `event.ctrlKey`, `event.metaKey` and `event.shiftKey`).
   *
   * @type       {string}
   * @since      4.0.3
   * @product    highcharts gantt
   * @validvalue ["alt", "ctrl", "meta", "shift"]
   * @apioption  chart.panKey
   */
  /**
   * Allow panning in a chart. Best used with [panKey](#chart.panKey)
   * to combine zooming and panning.
   *
   * On touch devices, when the [tooltip.followTouchMove](
   * #tooltip.followTouchMove) option is `true` (default), panning
   * requires two fingers. To allow panning with one finger, set
   * `followTouchMove` to `false`.
   *
   * @sample  {highcharts} highcharts/chart/pankey/ Zooming and panning
   * @sample  {highstock} stock/chart/panning/ Zooming and xy panning
   */
  panning: {
    /**
     * Enable or disable chart panning.
     *
     * @type      {boolean}
     * @default   {highcharts} false
     * @default   {highstock|highmaps} true
     */
    enabled: false,
    /**
     * Decides in what dimensions the user can pan the chart. Can be
     * one of `x`, `y`, or `xy`.
     *
     * During panning, all axes will behave as if
     * [`startOnTick`](#yAxis.startOnTick) and
     * [`endOnTick`](#yAxis.endOnTick) were set to `false`. After the
     * panning action is finished, the axes will adjust to their actual
     * settings.
     *
     * @sample {highcharts} highcharts/chart/panning-type
     *         Zooming and xy panning
     *
     * @declare    Highcharts.OptionsChartPanningTypeValue
     * @type       {string}
     * @validvalue ["x", "y", "xy"]
     * @product    highcharts highstock gantt
     */
    type: "x"
  },
  /**
   * Equivalent to [zoomType](#chart.zoomType), but for multitouch
   * gestures only. By default, the `pinchType` is the same as the
   * `zoomType` setting. However, pinching can be enabled separately in
   * some cases, for example in stock charts where a mouse drag pans the
   * chart, while pinching is enabled. When [tooltip.followTouchMove](
   * #tooltip.followTouchMove) is true, pinchType only applies to
   * two-finger touches.
   *
   * @type       {string}
   * @default    {highcharts} undefined
   * @default    {highstock} undefined
   * @since      3.0
   * @product    highcharts highstock gantt
   * @deprecated
   * @validvalue ["x", "y", "xy"]
   * @apioption  chart.pinchType
   */
  /**
   * Whether to apply styled mode. When in styled mode, no presentational
   * attributes or CSS are applied to the chart SVG. Instead, CSS rules
   * are required to style the chart. The default style sheet is
   * available from `https://code.highcharts.com/css/highcharts.css`.
   *
   * [Read more in the docs](https://www.highcharts.com/docs/chart-design-and-style/style-by-css)
   * on what classes and variables are available.
   *
   * @sample highcharts/css/colors
   *         Color theming with CSS
   * @sample highcharts/css/prefers-color-scheme
   *         Dynamic theme based on system settings
   * @type       {boolean}
   * @default    false
   * @since      7.0
   * @apioption  chart.styledMode
   */
  styledMode: false,
  /**
   * The corner radius of the outer chart border.
   *
   * @sample {highcharts} highcharts/chart/borderradius/
   *         20px radius
   * @sample {highstock} stock/chart/border/
   *         10px radius
   * @sample {highmaps} maps/chart/border/
   *         Border options
   *
   */
  borderRadius: 0,
  /**
   * In styled mode, this sets how many colors the class names
   * should rotate between. With ten colors, series (or points) are
   * given class names like `highcharts-color-0`, `highcharts-color-1`
   * [...] `highcharts-color-9`. The equivalent in non-styled mode
   * is to set colors using the [colors](#colors) setting.
   *
   * @since      5.0.0
   */
  colorCount: 10,
  /**
   * By default, (because of memory and performance reasons) the chart does
   * not copy the data but keeps it as a reference. In some cases, this might
   * result in mutating the original data source. In order to prevent that,
   * set that property to false. Please note that changing that might decrease
   * performance, especially with bigger sets of data.
   *
   * @type       {boolean}
   * @since 10.1.0
   */
  allowMutatingData: true,
  /**
   * If true, the axes will scale to the remaining visible series once
   * one series is hidden. If false, hiding and showing a series will
   * not affect the axes or the other series. For stacks, once one series
   * within the stack is hidden, the rest of the stack will close in
   * around it even if the axis is not affected.
   *
   * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/
   *         True by default
   * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/
   *         False
   * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/
   *         True with stack
   * @sample {highstock} stock/chart/ignorehiddenseries-true/
   *         True by default
   * @sample {highstock} stock/chart/ignorehiddenseries-false/
   *         False
   *
   * @since   1.2.0
   * @product highcharts highstock gantt
   */
  ignoreHiddenSeries: true,
  /**
   * Whether to invert the axes so that the x axis is vertical and y axis
   * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)
   * by default.
   *
   * @productdesc {highcharts}
   * If a bar series is present in the chart, it will be inverted
   * automatically. Inverting the chart doesn't have an effect if there
   * are no cartesian series in the chart.
   *
   * @sample {highcharts} highcharts/chart/inverted/
   *         Inverted line
   * @sample {highstock} stock/navigator/inverted/
   *         Inverted stock chart
   *
   * @type      {boolean}
   * @default   false
   * @product   highcharts highstock gantt
   * @apioption chart.inverted
   */
  /**
   * The distance between the outer edge of the chart and the content,
   * like title or legend, or axis title and labels if present. The
   * numbers in the array designate top, right, bottom and left
   * respectively. Use the options spacingTop, spacingRight, spacingBottom
   * and spacingLeft options for shorthand setting of one option.
   *
   * @type    {Array<number>}
   * @see     [chart.margin](#chart.margin)
   * @default [10, 10, 15, 10]
   * @since   3.0.6
   */
  spacing: [10, 10, 15, 10],
  /**
   * The button that appears after a selection zoom, allowing the user
   * to reset zoom. This option is deprecated in favor of
   * [zooming](#chart.zooming).
   *
   * @since      2.2
   * @deprecated 10.2.1
   */
  resetZoomButton: {
    /**
     * What frame the button placement should be related to. Can be
     * either `plotBox` or `spacingBox`.
     *
     * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
     *         Relative to the chart
     * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
     *         Relative to the chart
     *
     * @type      {Highcharts.ButtonRelativeToValue}
     * @apioption chart.resetZoomButton.relativeTo
     */
    /**
     * A collection of attributes for the button. The object takes SVG
     * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
     * border radius. The theme also supports `style`, a collection of
     * CSS properties for the text. Equivalent attributes for the hover
     * state are given in `theme.states.hover`.
     *
     * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
     *         Theming the button
     * @sample {highstock} highcharts/chart/resetzoombutton-theme/
     *         Theming the button
     *
     * @type {Highcharts.SVGAttributes}
     */
    theme: {
      /**
       * The z-index of the button.
       *
       * @type {number}
       * @apioption chart.resetZoomButton.theme.zIndex
       */
    },
    /**
     * The position of the button.
     *
     * @sample {highcharts} highcharts/chart/resetzoombutton-position/
     *         Above the plot area
     * @sample {highstock} highcharts/chart/resetzoombutton-position/
     *         Above the plot area
     * @sample {highmaps} highcharts/chart/resetzoombutton-position/
     *         Above the plot area
     *
     * @type {Highcharts.AlignObject}
     */
    position: {
      /**
       * The horizontal alignment of the button.
       *
       * @type {number}
       * @apioption chart.resetZoomButton.position.align
       */
      /**
       * The horizontal offset of the button.
       *
       * @type {number}
       * @apioption chart.resetZoomButton.position.x
       */
      /**
       * The vertical alignment of the button.
       *
       * @type      {Highcharts.VerticalAlignValue}
       * @apioption chart.resetZoomButton.position.verticalAlign
       */
      /**
       * The vertical offset of the button.
       *
       * @type {number}
       * @apioption chart.resetZoomButton.position.y
       */
    }
  },
  /**
   * The pixel width of the plot area border.
   *
   * @sample {highcharts} highcharts/chart/plotborderwidth/
   *         1px border
   * @sample {highstock} stock/chart/plotborder/
   *         2px border
   * @sample {highmaps} maps/chart/plotborder/
   *         Plot border options
   *
   * @type      {number}
   * @default   0
   * @apioption chart.plotBorderWidth
   */
  /**
   * Whether to apply a drop shadow to the plot area. Requires that
   * plotBackgroundColor be set. The shadow can be an object configuration
   * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
   *
   * @sample {highcharts} highcharts/chart/plotshadow/
   *         Plot shadow
   * @sample {highstock} stock/chart/plotshadow/
   *         Plot shadow
   * @sample {highmaps} maps/chart/plotborder/
   *         Plot border options
   *
   * @type      {boolean|Highcharts.ShadowOptionsObject}
   * @default   false
   * @apioption chart.plotShadow
   */
  /**
   * When true, cartesian charts like line, spline, area and column are
   * transformed into the polar coordinate system. This produces _polar
   * charts_, also known as _radar charts_.
   *
   * @sample {highcharts} highcharts/demo/polar/
   *         Polar chart
   * @sample {highcharts} highcharts/demo/polar-wind-rose/
   *         Wind rose, stacked polar column chart
   * @sample {highcharts} highcharts/demo/polar-spider/
   *         Spider web chart
   * @sample {highcharts} highcharts/parallel-coordinates/polar/
   *         Star plot, multivariate data in a polar chart
   *
   * @type      {boolean}
   * @default   false
   * @since     2.3.0
   * @product   highcharts
   * @requires  highcharts-more
   * @apioption chart.polar
   */
  /**
   * Whether to reflow the chart to fit the width of the container div
   * on resizing the window.
   *
   * @sample {highcharts} highcharts/chart/reflow-true/
   *         True by default
   * @sample {highcharts} highcharts/chart/reflow-false/
   *         False
   * @sample {highstock} stock/chart/reflow-true/
   *         True by default
   * @sample {highstock} stock/chart/reflow-false/
   *         False
   * @sample {highmaps} maps/chart/reflow-true/
   *         True by default
   * @sample {highmaps} maps/chart/reflow-false/
   *         False
   *
   * @since     2.1
   */
  reflow: true,
  /**
   * The HTML element where the chart will be rendered. If it is a string,
   * the element by that id is used. The HTML element can also be passed
   * by direct reference, or as the first argument of the chart
   * constructor, in which case the option is not needed.
   *
   * @sample {highcharts} highcharts/chart/reflow-true/
   *         String
   * @sample {highcharts} highcharts/chart/renderto-object/
   *         Object reference
   * @sample {highstock} stock/chart/renderto-string/
   *         String
   * @sample {highstock} stock/chart/renderto-object/
   *         Object reference
   *
   * @type      {string|Highcharts.HTMLDOMElement}
   * @apioption chart.renderTo
   */
  /**
   * The background color of the marker square when selecting (zooming
   * in on) an area of the chart.
   *
   * @see In styled mode, the selection marker fill is set with the
   *      `.highcharts-selection-marker` class.
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default   rgba(51,92,173,0.25)
   * @since     2.1.7
   * @apioption chart.selectionMarkerFill
   */
  /**
   * Whether to apply a drop shadow to the global series group. This causes
   * all the series to have the same shadow. Contrary to the `series.shadow`
   * option, this prevents items from casting shadows on each other, like for
   * others series in a stack. The shadow can be an object configuration
   * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
   *
   * @sample highcharts/chart/seriesgroupshadow/ Shadow
   *
   * @type      {boolean|Highcharts.ShadowOptionsObject}
   * @default   false
   * @apioption chart.shadow
   */
  /**
   * Whether to apply a drop shadow to the outer chart area. Requires
   * that backgroundColor be set. The shadow can be an object
   * configuration containing `color`, `offsetX`, `offsetY`, `opacity` and
   * `width`.
   *
   * @sample {highcharts} highcharts/chart/shadow/
   *         Shadow
   * @sample {highstock} stock/chart/shadow/
   *         Shadow
   * @sample {highmaps} maps/chart/border/
   *         Chart border and shadow
   *
   * @type      {boolean|Highcharts.ShadowOptionsObject}
   * @default   false
   * @apioption chart.shadow
   */
  /**
   * Whether to show the axes initially. This only applies to empty charts
   * where series are added dynamically, as axes are automatically added
   * to cartesian series.
   *
   * @sample {highcharts} highcharts/chart/showaxes-false/
   *         False by default
   * @sample {highcharts} highcharts/chart/showaxes-true/
   *         True
   *
   * @type      {boolean}
   * @since     1.2.5
   * @product   highcharts gantt
   * @apioption chart.showAxes
   */
  /**
   * The space between the bottom edge of the chart and the content (plot
   * area, axis title and labels, title, subtitle or legend in top
   * position).
   *
   * @sample {highcharts} highcharts/chart/spacingbottom/
   *         Spacing bottom set to 100
   * @sample {highstock} stock/chart/spacingbottom/
   *         Spacing bottom set to 100
   * @sample {highmaps} maps/chart/spacing/
   *         Spacing 100 all around
   *
   * @type      {number}
   * @default   15
   * @since     2.1
   * @apioption chart.spacingBottom
   */
  /**
   * The space between the left edge of the chart and the content (plot
   * area, axis title and labels, title, subtitle or legend in top
   * position).
   *
   * @sample {highcharts} highcharts/chart/spacingleft/
   *         Spacing left set to 100
   * @sample {highstock} stock/chart/spacingleft/
   *         Spacing left set to 100
   * @sample {highmaps} maps/chart/spacing/
   *         Spacing 100 all around
   *
   * @type      {number}
   * @default   10
   * @since     2.1
   * @apioption chart.spacingLeft
   */
  /**
   * The space between the right edge of the chart and the content (plot
   * area, axis title and labels, title, subtitle or legend in top
   * position).
   *
   * @sample {highcharts} highcharts/chart/spacingright-100/
   *         Spacing set to 100
   * @sample {highcharts} highcharts/chart/spacingright-legend/
   *         Legend in right position with default spacing
   * @sample {highstock} stock/chart/spacingright/
   *         Spacing set to 100
   * @sample {highmaps} maps/chart/spacing/
   *         Spacing 100 all around
   *
   * @type      {number}
   * @default   10
   * @since     2.1
   * @apioption chart.spacingRight
   */
  /**
   * The space between the top edge of the chart and the content (plot
   * area, axis title and labels, title, subtitle or legend in top
   * position).
   *
   * @sample {highcharts} highcharts/chart/spacingtop-100/
   *         A top spacing of 100
   * @sample {highcharts} highcharts/chart/spacingtop-10/
   *         Floating chart title makes the plot area align to the default
   *         spacingTop of 10.
   * @sample {highstock} stock/chart/spacingtop/
   *         A top spacing of 100
   * @sample {highmaps} maps/chart/spacing/
   *         Spacing 100 all around
   *
   * @type      {number}
   * @default   10
   * @since     2.1
   * @apioption chart.spacingTop
   */
  /**
   * Additional CSS styles to apply inline to the container `div` and the root
   * SVG.
   *
   * According to the CSS syntax documentation, it is recommended to quote
   * font family names that contain white space, digits, or punctuation
   * characters other than hyphens. In such cases, wrap the fontFamily
   * name as follows: `fontFamily: '"Font name"'`.
   *
   * Since v11, the root font size is 1rem by default, and all child element
   * are given a relative `em` font size by default. This allows implementers
   * to control all the chart's font sizes by only setting the root level.
   *
   * @see    In styled mode, general chart styles can be set with the
   *         `.highcharts-root` class.
   * @sample {highcharts} highcharts/chart/style-serif-font/
   *         Using a serif type font
   * @sample {highcharts} highcharts/chart/style-special-font/
   *         Using a font with special character in name
   * @sample {highcharts} highcharts/members/relative-font-size/
   *         Relative font sizes
   * @sample {highcharts} highcharts/css/em/
   *         Styled mode with relative font sizes
   * @sample {highstock} stock/chart/style/
   *         Using a serif type font
   * @sample {highmaps} maps/chart/style-serif-font/
   *         Using a serif type font
   *
   * @type      {Highcharts.CSSObject}
   * @default   {"fontFamily": "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', sans-serif", "fontSize":"1rem"}
   * @apioption chart.style
   */
  /**
   * The default series type for the chart. Can be any of the chart types
   * listed under [plotOptions](#plotOptions) and [series](#series) or can
   * be a series provided by an additional module.
   *
   * In TypeScript this option has no effect in sense of typing and
   * instead the `type` option must always be set in the series.
   *
   * @sample {highcharts} highcharts/chart/type-bar/
   *         Bar
   * @sample {highstock} stock/chart/type/
   *         Areaspline
   * @sample {highmaps} maps/chart/type-mapline/
   *         Mapline
   *
   * @type       {string}
   * @default    {highcharts} line
   * @default    {highstock} line
   * @default    {highmaps} map
   * @since      2.1.0
   * @apioption  chart.type
   */
  type: "line",
  /**
   * Decides in what dimensions the user can zoom by dragging the mouse.
   * Can be one of `x`, `y` or `xy`.
   *
   * @see [panKey](#chart.panKey)
   *
   * @sample {highcharts} highcharts/chart/zoomtype-none/
   *         None by default
   * @sample {highcharts} highcharts/chart/zoomtype-x/
   *         X
   * @sample {highcharts} highcharts/chart/zoomtype-y/
   *         Y
   * @sample {highcharts} highcharts/chart/zoomtype-xy/
   *         Xy
   * @sample {highcharts} highcharts/chart/zoomtype-polar/
   *         Zoom on polar chart
   * @sample {highstock} stock/demo/basic-line/
   *         None by default
   * @sample {highstock} stock/chart/zoomtype-x/
   *         X
   * @sample {highstock} stock/chart/zoomtype-y/
   *         Y
   * @sample {highstock} stock/chart/zoomtype-xy/
   *         Xy
   * @sample {highmaps} maps/chart/zoomtype-xy/
   *         Map with selection zoom
   *
   * @type       {string}
   * @validvalue ["x", "y", "xy"]
   * @deprecated
   * @apioption  chart.zoomType
   */
  /**
   * Enables zooming by a single touch, in combination with
   * [chart.zoomType](#chart.zoomType). When enabled, two-finger pinch
   * will still work as set up by [chart.pinchType](#chart.pinchType).
   * However, `zoomBySingleTouch` will interfere with touch-dragging the
   * chart to read the tooltip. And especially when vertical zooming is
   * enabled, it will make it hard to scroll vertically on the page.
   * @since      9.0.0
   * @sample     highcharts/chart/zoombysingletouch
   *             Zoom by single touch enabled, with buttons to toggle
   * @product    highcharts highstock gantt
   * @deprecated
   */
  /**
   * Chart zooming options.
   * @since 10.2.1
   */
  zooming: {
    /**
     * Equivalent to [type](#chart.zooming.type), but for multitouch
     * gestures only. By default, the `pinchType` is the same as the
     * `type` setting. However, pinching can be enabled separately in
     * some cases, for example in stock charts where a mouse drag pans the
     * chart, while pinching is enabled. When [tooltip.followTouchMove](
     * #tooltip.followTouchMove) is true, pinchType only applies to
     * two-finger touches.
     *
     * @type       {string}
     * @default    {highcharts} undefined
     * @default    {highstock} x
     * @product    highcharts highstock gantt
     * @validvalue ["x", "y", "xy"]
     * @apioption  chart.zooming.pinchType
     */
    /**
     * Decides in what dimensions the user can zoom by dragging the mouse.
     * Can be one of `x`, `y` or `xy`.
     *
     * @declare    Highcharts.OptionsChartZoomingTypeValue
     * @type       {string}
     * @default    {highcharts} undefined
     * @product    highcharts highstock gantt
     * @validvalue ["x", "y", "xy"]
     * @apioption  chart.zooming.type
     */
    /**
     * Set a key to hold when dragging to zoom the chart. This is useful to
     * avoid zooming while moving points. Should be set different than
     * [chart.panKey](#chart.panKey).
     *
     * @type       {string}
     * @default    {highcharts} undefined
     * @validvalue ["alt", "ctrl", "meta", "shift"]
     * @requires   modules/draggable-points
     * @apioption  chart.zooming.key
     */
    /**
     * Enables zooming by a single touch, in combination with
     * [chart.zooming.type](#chart.zooming.type). When enabled, two-finger
     * pinch will still work as set up by [chart.zooming.pinchType]
     * (#chart.zooming.pinchType). However, `singleTouch` will interfere
     * with touch-dragging the chart to read the tooltip. And especially
     * when vertical zooming is enabled, it will make it hard to scroll
     * vertically on the page.
     *
     * @sample  highcharts/chart/zoombysingletouch
     *          Zoom by single touch enabled, with buttons to toggle
     *
     * @product highcharts highstock gantt
     */
    singleTouch: false,
    /**
     * The button that appears after a selection zoom, allowing the user
     * to reset zoom.
     */
    resetButton: {
      /**
       * What frame the button placement should be related to. Can be
       * either `plotBox` or `spacingBox`.
       *
       * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
       *         Relative to the chart
       * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
       *         Relative to the chart
       *
       * @type      {Highcharts.ButtonRelativeToValue}
       * @default   plot
       * @apioption chart.zooming.resetButton.relativeTo
       */
      /**
       * A collection of attributes for the button. The object takes SVG
       * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
       * border radius. The theme also supports `style`, a collection of
       * CSS properties for the text. Equivalent attributes for the hover
       * state are given in `theme.states.hover`.
       *
       * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
       *         Theming the button
       * @sample {highstock} highcharts/chart/resetzoombutton-theme/
       *         Theming the button
       *
       * @type  {Highcharts.SVGAttributes}
       * @since 10.2.1
       */
      theme: {
        /** @internal */
        zIndex: 6
      },
      /**
       * The position of the button.
       *
       * Note: Adjusting position values might cause overlap with chart
       * elements. Ensure coordinates do not obstruct other components or
       * data visibility.
       *
       * @sample {highcharts} highcharts/chart/resetzoombutton-position/
       *         Above the plot area
       * @sample {highstock} highcharts/chart/resetzoombutton-position/
       *         Above the plot area
       * @sample {highmaps} highcharts/chart/resetzoombutton-position/
       *         Above the plot area
       *
       * @type  {Highcharts.AlignObject}
       * @since 10.2.1
       */
      position: {
        /**
         * The horizontal alignment of the button.
         */
        align: "right",
        /**
         * The horizontal offset of the button.
         */
        x: -10,
        /**
         * The vertical alignment of the button.
         *
         * @type       {Highcharts.VerticalAlignValue}
         * @default    top
         * @apioption  chart.zooming.resetButton.position.verticalAlign
         */
        /**
         * The vertical offset of the button.
         */
        y: 10
      }
    }
  },
  /**
   * An explicit width for the chart. By default (when `null`) the width
   * is calculated from the offset width of the containing element.
   *
   * @sample {highcharts} highcharts/chart/width/
   *         800px wide
   * @sample {highstock} stock/chart/width/
   *         800px wide
   * @sample {highmaps} maps/chart/size/
   *         Chart with explicit size
   *
   * @type {null|number|string}
   */
  width: null,
  /**
   * An explicit height for the chart. If a _number_, the height is
   * given in pixels. If given a _percentage string_ (for example
   * `'56%'`), the height is given as the percentage of the actual chart
   * width. This allows for preserving the aspect ratio across responsive
   * sizes.
   *
   * By default (when `null`) the height is calculated from the offset
   * height of the containing element, or 400 pixels if the containing
   * element's height is 0.
   *
   * @sample {highcharts} highcharts/chart/height/
   *         Forced 200px height
   * @sample {highstock} stock/chart/height/
   *         300px height
   * @sample {highmaps} maps/chart/size/
   *         Chart with explicit size
   * @sample highcharts/chart/height-percent/
   *         Highcharts with percentage height
   * @sample highcharts/chart/height-inherited/
   *         Chart with inherited height
   *
   * @type {null|number|string}
   */
  height: null,
  /**
   * The color of the outer chart border.
   *
   * @see In styled mode, the stroke is set with the
   *      `.highcharts-background` class.
   *
   * @sample {highcharts} highcharts/chart/bordercolor/
   *         Brown border
   * @sample {highstock} stock/chart/border/
   *         Brown border
   * @sample {highmaps} maps/chart/border/
   *         Border options
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  borderColor: "#334eff",
  /**
   * The pixel width of the outer chart border.
   *
   * @see In styled mode, the stroke is set with the
   *      `.highcharts-background` class.
   *
   * @sample {highcharts} highcharts/chart/borderwidth/
   *         5px border
   * @sample {highstock} stock/chart/border/
   *         2px border
   * @sample {highmaps} maps/chart/border/
   *         Border options
   *
   * @type      {number}
   * @default   0
   * @apioption chart.borderWidth
   */
  /**
   * The background color or gradient for the outer chart area.
   *
   * @see In styled mode, the background is set with the
   *      `.highcharts-background` class.
   *
   * @sample {highcharts} highcharts/chart/backgroundcolor-color/
   *         Color
   * @sample {highcharts} highcharts/chart/backgroundcolor-gradient/
   *         Gradient
   * @sample {highstock} stock/chart/backgroundcolor-color/
   *         Color
   * @sample {highstock} stock/chart/backgroundcolor-gradient/
   *         Gradient
   * @sample {highmaps} maps/chart/backgroundcolor-color/
   *         Color
   * @sample {highmaps} maps/chart/backgroundcolor-gradient/
   *         Gradient
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  backgroundColor: "#ffffff",
  /**
   * The background color or gradient for the plot area.
   *
   * @see In styled mode, the plot background is set with the
   *      `.highcharts-plot-background` class.
   *
   * @sample {highcharts} highcharts/chart/plotbackgroundcolor-color/
   *         Color
   * @sample {highcharts} highcharts/chart/plotbackgroundcolor-gradient/
   *         Gradient
   * @sample {highstock} stock/chart/plotbackgroundcolor-color/
   *         Color
   * @sample {highstock} stock/chart/plotbackgroundcolor-gradient/
   *         Gradient
   * @sample {highmaps} maps/chart/plotbackgroundcolor-color/
   *         Color
   * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
   *         Gradient
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @apioption chart.plotBackgroundColor
   */
  /**
   * The URL for an image to use as the plot background. To set an image
   * as the background for the entire chart, set a CSS background image
   * to the container element. Note that for the image to be applied to
   * exported charts, its URL needs to be accessible by the export server.
   *
   * @see In styled mode, a plot background image can be set with the
   *      `.highcharts-plot-background` class and a [custom pattern](
   *      https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns).
   *
   * @sample {highcharts} highcharts/chart/plotbackgroundimage/
   *         Skies
   * @sample {highstock} stock/chart/plotbackgroundimage/
   *         Skies
   *
   * @type      {string}
   * @apioption chart.plotBackgroundImage
   */
  /**
   * The color of the inner chart or plot area border.
   *
   * @see In styled mode, a plot border stroke can be set with the
   *      `.highcharts-plot-border` class.
   *
   * @sample {highcharts} highcharts/chart/plotbordercolor/
   *         Blue border
   * @sample {highstock} stock/chart/plotborder/
   *         Blue border
   * @sample {highmaps} maps/chart/plotborder/
   *         Plot border options
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  plotBorderColor: "#cccccc"
  /* Palette.neutralColor20 */
};
var ChartDefaults_default = ChartDefaults;

// node_modules/highcharts/es-modules/Core/Color/Palettes.js
var SeriesPalettes = {
  /**
   * Colors for data series and points
   */
  colors: [
    "#2caffe",
    "#544fc5",
    "#00e272",
    "#fe6a35",
    "#6b8abc",
    "#d568fb",
    "#2ee0ca",
    "#fa4b42",
    "#feb56a",
    "#91e8e1"
  ]
};
var Palettes_default = SeriesPalettes;

// node_modules/highcharts/es-modules/Shared/TimeBase.js
var { pageLang, win: win2 } = Globals_default;
var { defined: defined2, error: error2, extend: extend2, isNumber: isNumber2, isObject: isObject2, isString: isString2, merge: merge2, objectEach: objectEach2, pad: pad2, splat: splat2, timeUnits: timeUnits2, ucfirst: ucfirst2 } = Utilities_default;
var hasOldSafariBug = Globals_default.isSafari && win2.Intl && !win2.Intl.DateTimeFormat.prototype.formatRange;
var isDateTimeFormatOptions = (obj) => obj.main === void 0;
var TimeBase = class {
  /* *
   *
   *  Constructors
   *
   * */
  constructor(options2, lang6) {
    this.options = {
      timezone: "UTC"
    };
    this.variableTimezone = false;
    this.Date = win2.Date;
    this.update(options2);
    this.lang = lang6;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Update the Time object with current options. It is called internally on
   * initializing Highcharts, after running `Highcharts.setOptions` and on
   * `Chart.update`.
   *
   * @private
   * @function Highcharts.Time#update
   *
   * @param {Highcharts.TimeOptions} [options]
   *
   */
  update(options2 = {}) {
    this.dTLCache = {};
    this.options = options2 = merge2(true, this.options, options2);
    const { timezoneOffset, useUTC } = options2;
    this.Date = options2.Date || win2.Date || Date;
    let timezone = options2.timezone;
    if (defined2(useUTC)) {
      timezone = useUTC ? "UTC" : void 0;
    }
    if (timezoneOffset && timezoneOffset % 60 === 0) {
      timezone = "Etc/GMT" + (timezoneOffset > 0 ? "+" : "") + timezoneOffset / 60;
    }
    this.variableTimezone = timezone !== "UTC" && timezone?.indexOf("Etc/GMT") !== 0;
    this.timezone = timezone;
    ["months", "shortMonths", "weekdays", "shortWeekdays"].forEach((name) => {
      const isMonth = /months/i.test(name), isShort = /short/.test(name), options3 = {
        timeZone: "UTC"
      };
      options3[isMonth ? "month" : "weekday"] = isShort ? "short" : "long";
      this[name] = (isMonth ? [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] : [3, 4, 5, 6, 7, 8, 9]).map((position) => this.dateFormat(options3, (isMonth ? 31 : 1) * 24 * 36e5 * position));
    });
  }
  /**
   * Get a date in terms of numbers (year, month, day etc) for further
   * processing. Takes the current `timezone` setting into account. Inverse of
   * `makeTime` and the native `Date` constructor and `Date.UTC`.
   *
   * The date is returned in array format with the following indices:
   *
   * 0: year,
   * 1: month (zero based),
   * 2: day,
   * 3: hours,
   * 4: minutes,
   * 5: seconds,
   * 6: milliseconds,
   * 7: weekday (Sunday as 0)
   *
   * @function Highcharts.Time#toParts
   *
   * @param {number|Date} [timestamp]
   *                 The timestamp in milliseconds since January 1st 1970.
   *                 A Date object is also accepted.
   *
   * @return {Array<number>} The date parts in array format.
   */
  toParts(timestamp) {
    const [weekday, dayOfMonth, month, year, hours, minutes, seconds] = this.dateTimeFormat({
      weekday: "narrow",
      day: "numeric",
      month: "numeric",
      year: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    }, timestamp, "es").split(/(?:, | |\/|:)/g);
    return [
      year,
      +month - 1,
      dayOfMonth,
      hours,
      minutes,
      seconds,
      // Milliseconds
      Math.floor(Number(timestamp) || 0) % 1e3,
      // Spanish weekday index
      "DLMXJVS".indexOf(weekday)
    ].map(Number);
  }
  /**
   * Shorthand to get a cached `Intl.DateTimeFormat` instance.
   */
  dateTimeFormat(options2, timestamp, locale = this.options.locale || pageLang) {
    const cacheKey = JSON.stringify(options2) + locale;
    if (isString2(options2)) {
      options2 = this.str2dtf(options2);
    }
    let dTL = this.dTLCache[cacheKey];
    if (!dTL) {
      options2.timeZone ?? (options2.timeZone = this.timezone);
      try {
        dTL = new Intl.DateTimeFormat(locale, options2);
      } catch (e) {
        if (/Invalid time zone/i.test(e.message)) {
          error2(34);
          options2.timeZone = "UTC";
          dTL = new Intl.DateTimeFormat(locale, options2);
        } else {
          error2(e.message, false);
        }
      }
    }
    this.dTLCache[cacheKey] = dTL;
    return dTL?.format(timestamp) || "";
  }
  /**
   * Take a locale-aware string format and return a full DateTimeFormat in
   * object form.
   */
  str2dtf(s, dtf = {}) {
    const mapping = {
      L: { fractionalSecondDigits: 3 },
      S: { second: "2-digit" },
      M: { minute: "numeric" },
      H: { hour: "2-digit" },
      k: { hour: "numeric" },
      E: { weekday: "narrow" },
      a: { weekday: "short" },
      A: { weekday: "long" },
      d: { day: "2-digit" },
      e: { day: "numeric" },
      b: { month: "short" },
      B: { month: "long" },
      m: { month: "2-digit" },
      o: { month: "numeric" },
      y: { year: "2-digit" },
      Y: { year: "numeric" }
    };
    Object.keys(mapping).forEach((key) => {
      if (s.indexOf(key) !== -1) {
        extend2(dtf, mapping[key]);
      }
    });
    return dtf;
  }
  /**
   * Make a time and returns milliseconds. Similar to `Date.UTC`, but takes
   * the current `timezone` setting into account.
   *
   * @function Highcharts.Time#makeTime
   *
   * @param {number} year
   *        The year
   *
   * @param {number} month
   *        The month. Zero-based, so January is 0.
   *
   * @param {number} [date=1]
   *        The day of the month
   *
   * @param {number} [hours=0]
   *        The hour of the day, 0-23.
   *
   * @param {number} [minutes=0]
   *        The minutes
   *
   * @param {number} [seconds=0]
   *        The seconds
   *
   * @return {number}
   *         The time in milliseconds since January 1st 1970.
   */
  makeTime(year, month, date = 1, hours = 0, minutes, seconds, milliseconds) {
    let d = this.Date.UTC(year, month, date, hours, minutes || 0, seconds || 0, milliseconds || 0);
    if (this.timezone !== "UTC") {
      const offset3 = this.getTimezoneOffset(d);
      d += offset3;
      if (
        // Optimize for speed by limiting the number of calls to
        // `getTimezoneOffset`. According to
        // https://en.wikipedia.org/wiki/Daylight_saving_time_by_country,
        // DST change may only occur in these months.
        [2, 3, 8, 9, 10, 11].indexOf(month) !== -1 && // DST transitions occur only in the night-time
        (hours < 5 || hours > 20)
      ) {
        const newOffset = this.getTimezoneOffset(d);
        if (offset3 !== newOffset) {
          d += newOffset - offset3;
        } else if (offset3 - 36e5 === this.getTimezoneOffset(d - 36e5) && !hasOldSafariBug) {
          d -= 36e5;
        }
      }
    }
    return d;
  }
  /**
   * Parse a datetime string. Unless the string contains time zone
   * information, apply the current `timezone` from options. If the argument
   * is a number, return it.
   *
   * @function Highcharts.Time#parse
   * @param    {string|number|undefined} s The datetime string to parse
   * @return   {number|undefined}          Parsed JavaScript timestamp
   */
  parse(s) {
    if (!isString2(s)) {
      return s ?? void 0;
    }
    s = s.replace(/\//g, "-").replace(/(GMT|UTC)/, "");
    const hasTimezone = s.indexOf("Z") > -1 || /([+-][0-9]{2}):?[0-9]{2}$/.test(s), isYYYYMMDD = /^[0-9]{4}-[0-9]{2}(-[0-9]{2}|)$/.test(s);
    if (!hasTimezone && !isYYYYMMDD) {
      s += "Z";
    }
    const ts = Date.parse(s);
    if (isNumber2(ts)) {
      return ts + (!hasTimezone || isYYYYMMDD ? this.getTimezoneOffset(ts) : 0);
    }
  }
  /**
   * Get the time zone offset based on the current timezone information as
   * set in the global options.
   *
   * @function Highcharts.Time#getTimezoneOffset
   *
   * @param {number} timestamp
   *        The JavaScript timestamp to inspect.
   *
   * @return {number}
   *         The timezone offset in minutes compared to UTC.
   */
  getTimezoneOffset(timestamp) {
    if (this.timezone !== "UTC") {
      const [date, gmt, hours, colon, minutes = 0] = this.dateTimeFormat({ timeZoneName: "shortOffset" }, timestamp, "en").split(/(GMT|:)/).map(Number), offset3 = -(hours + minutes / 60) * 60 * 6e4;
      if (isNumber2(offset3)) {
        return offset3;
      }
    }
    return 0;
  }
  /**
   * Formats a JavaScript date timestamp (milliseconds since January 1 1970)
   * into a human readable date string.
   *
   * The `format` parameter accepts two types of values:
   * - An object containing settings that are passed directly on to
   *   [Intl.DateTimeFormat.prototype.format](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/format).
   * - A format string containing either individual or locale-aware format
   *   keys. **Individual keys**, for example `%Y-%m-%d`, are listed below.
   *   **Locale-aware keys** are grouped by square brackets, for example
   *   `%[Ymd]`. The order of keys within the square bracket doesn't affect
   *   the output, which is determined by the locale. See example below.
   *   Internally, the locale-aware format keys are just a shorthand for the
   *   full object formats, but are particularly practical in
   *   [templating](https://www.highcharts.com/docs/chart-concepts/templating)
   *   where full object definitions are not an option.
   *
   * The available string format keys are listed below. Additional formats can
   * be given in the {@link Highcharts.dateFormats} hook.
   *
   * Supported format keys:
   * | Key  | Description                     | Notes on locale-aware format |
   * -------|----------------------------------------------|-------|
   * | `%A` | Long weekday, like 'Monday'                  |       |
   * | `%a` | Short weekday, like 'Mon'                    |       |
   * | `%E` | Narrow weekday, single character             |       |
   * | `%d` | Two digit day of the month, 01 to 31         |       |
   * | `%e` | Day of the month, 1 through 31               |       |
   * | `%w` | Day of the week, 0 through 6                 | N/A   |
   * | `%v` | The prefix "week from", read from `lang.weekFrom` | N/A |
   * | `%b` | Short month, like 'Jan'                      |       |
   * | `%B` | Long month, like 'January'                   |       |
   * | `%m` | Two digit month number, 01 through 12        |       |
   * | `%o` | Month number, 1 through 12                   |       |
   * | `%y` | Two digits year, like 24 for 2024            |       |
   * | `%Y` | Four digits year, like 2024                  |       |
   * | `%H` | Two digits hours in 24h format, 00 through 23 | Depending on the locale, 12h format may be instered. |
   * | `%k` | Hours in 24h format, 0 through 23            | Depending on the locale, 12h format may be instered. |
   * | `%I` | Two digits hours in 12h format, 00 through 11 | N/A. The locale determines the hour format. |
   * | `%l` | Hours in 12h format, 1 through 12            | N/A. The locale determines the hour format. |
   * | `%M` | Two digits minutes, 00 through 59            |       |
   * | `%p` | Upper case AM or PM                          | N/A. The locale determines whether to add AM and PM. |
   * | `%P` | Lower case AM or PM                          | N/A. The locale determines whether to add AM and PM. |
   * | `%S` | Two digits seconds, 00 through 59            |       |
   * | `%L` | Milliseconds (naming from Ruby)              |       |
   *
   * @example
   * // Object format, US English
   * const time1 = new Highcharts.Time({ locale: 'en-US' });
   * console.log(
   *     time1.dateFormat({
   *         day: 'numeric',
   *         month: 'short',
   *         year: 'numeric',
   *         hour: 'numeric',
   *         minute: 'numeric'
   *     }, Date.UTC(2024, 11, 31))
   * ); // => Dec 31, 2024, 12:00 AM
   *
   * // Object format, British English
   * const time2 = new Highcharts.Time({ locale: 'en-GB' });
   * console.log(
   *     time2.dateFormat({
   *         day: 'numeric',
   *         month: 'short',
   *         year: 'numeric',
   *         hour: 'numeric',
   *         minute: 'numeric'
   *     }, Date.UTC(2024, 11, 31))
   * ); // => 31 Dec 2024, 00:00
   *
   * // Individual key string replacement
   * const time3 = new Highcharts.Time();
   * console.log(
   *     time3.dateFormat('%Y-%m-%d %H:%M:%S', Date.UTC(2024, 11, 31))
   * ); // => 2024-12-31 00:00:00
   *
   * // Locale-aware keys, US English
   * const time4 = new Highcharts.Time({ locale: 'en-US' });
   * console.log(
   *     time4.dateFormat('%[YebHM]', Date.UTC(2024, 11, 31))
   * ); // => Dec 31, 2024, 12:00 AM
   *
   * // Locale-aware keys, British English
   * const time5 = new Highcharts.Time({ locale: 'en-GB' });
   * console.log(
   *     time5.dateFormat('%[YebHM]', Date.UTC(2024, 11, 31))
   * ); // => 31 Dec 2024, 00:00
   *
   * // Mixed locale-aware and individual keys
   * console.log(
   *     time5.dateFormat('%[Yeb], %H:%M', Date.UTC(2024, 11, 31))
   * ); // => 31 Dec 2024, 00:00
   *
   * @function Highcharts.Time#dateFormat
   *
   * @param {string|Highcharts.DateTimeFormatOptions} format
   *        The desired string format where various time representations are
   *        prefixed with %, or an object representing the locale-aware format
   *        options.
   *
   * @param {number} [timestamp]
   *        The JavaScript timestamp.
   *
   * @param {boolean} [upperCaseFirst=false]
   *        Upper case first letter in the return.
   *
   * @return {string}
   *         The formatted date.
   */
  dateFormat(format18, timestamp, upperCaseFirst) {
    const lang6 = this.lang;
    if (!defined2(timestamp) || isNaN(timestamp)) {
      return lang6?.invalidDate || "";
    }
    format18 = format18 ?? "%Y-%m-%d %H:%M:%S";
    if (isString2(format18)) {
      const localeAwareRegex = /%\[([a-zA-Z]+)\]/g;
      let match;
      while (match = localeAwareRegex.exec(format18)) {
        format18 = format18.replace(match[0], this.dateTimeFormat(match[1], timestamp, lang6?.locale));
      }
    }
    if (isString2(format18) && format18.indexOf("%") !== -1) {
      const time = this, [fullYear, month, dayOfMonth, hours, minutes, seconds, milliseconds, weekday] = this.toParts(timestamp), langWeekdays = lang6?.weekdays || this.weekdays, shortWeekdays = lang6?.shortWeekdays || this.shortWeekdays, months = lang6?.months || this.months, shortMonths = lang6?.shortMonths || this.shortMonths, replacements = extend2({
        // Day
        // Short weekday, like 'Mon'
        a: shortWeekdays ? shortWeekdays[weekday] : langWeekdays[weekday].substr(0, 3),
        // Long weekday, like 'Monday'
        A: langWeekdays[weekday],
        // Two digit day of the month, 01 to 31
        d: pad2(dayOfMonth),
        // Day of the month, 1 through 31
        e: pad2(dayOfMonth, 2, " "),
        // Day of the week, 0 through 6
        w: weekday,
        // Week (none implemented)
        // 'W': weekNumber(),
        v: lang6?.weekFrom ?? "",
        // Month
        // Short month, like 'Jan'
        b: shortMonths[month],
        // Long month, like 'January'
        B: months[month],
        // Two digit month number, 01 through 12
        m: pad2(month + 1),
        // Month number, 1 through 12 (#8150)
        o: month + 1,
        // Year
        // Two digits year, like 09 for 2009
        y: fullYear.toString().substr(2, 2),
        // Four digits year, like 2009
        Y: fullYear,
        // Time
        // Two digits hours in 24h format, 00 through 23
        H: pad2(hours),
        // Hours in 24h format, 0 through 23
        k: hours,
        // Two digits hours in 12h format, 00 through 11
        I: pad2(hours % 12 || 12),
        // Hours in 12h format, 1 through 12
        l: hours % 12 || 12,
        // Two digits minutes, 00 through 59
        M: pad2(minutes),
        // Upper case AM or PM
        p: hours < 12 ? "AM" : "PM",
        // Lower case AM or PM
        P: hours < 12 ? "am" : "pm",
        // Two digits seconds, 00 through 59
        S: pad2(seconds),
        // Milliseconds (naming from Ruby)
        L: pad2(milliseconds, 3)
      }, Globals_default.dateFormats);
      objectEach2(replacements, function(val, key) {
        if (isString2(format18)) {
          while (format18.indexOf("%" + key) !== -1) {
            format18 = format18.replace("%" + key, typeof val === "function" ? val.call(time, timestamp) : val);
          }
        }
      });
    } else if (isObject2(format18)) {
      const tzHours = (this.getTimezoneOffset(timestamp) || 0) / (6e4 * 60), timeZone = this.timezone || "Etc/GMT" + (tzHours >= 0 ? "+" : "") + tzHours, { prefix = "", suffix = "" } = format18;
      format18 = prefix + this.dateTimeFormat(extend2({ timeZone }, format18), timestamp) + suffix;
    }
    return upperCaseFirst ? ucfirst2(format18) : format18;
  }
  /**
   * Resolve legacy formats of dateTimeLabelFormats (strings and arrays) into
   * an object.
   * @private
   * @param {string|Array<T>|Highcharts.Dictionary<T>} f
   * General format description
   * @return {Highcharts.Dictionary<T>}
   * The object definition
   */
  resolveDTLFormat(f) {
    if (!isObject2(f, true)) {
      f = splat2(f);
      return {
        main: f[0],
        from: f[1],
        to: f[2]
      };
    }
    if (isObject2(f, true) && isDateTimeFormatOptions(f)) {
      return { main: f };
    }
    return f;
  }
  /**
   * Get the optimal date format for a point, based on a range.
   *
   * @private
   * @function Highcharts.Time#getDateFormat
   *
   * @param {number} range
   *        The time range
   *
   * @param {number} timestamp
   *        The timestamp of the date
   *
   * @param {number} startOfWeek
   *        An integer representing the first day of the week, where 0 is
   *        Sunday.
   *
   * @param {Highcharts.Dictionary<string>} dateTimeLabelFormats
   *        A map of time units to formats.
   *
   * @return {string}
   *         The optimal date format for a point.
   */
  getDateFormat(range2, timestamp, startOfWeek, dateTimeLabelFormats) {
    const dateStr = this.dateFormat("%m-%d %H:%M:%S.%L", timestamp), blank = "01-01 00:00:00.000", strpos = {
      millisecond: 15,
      second: 12,
      minute: 9,
      hour: 6,
      day: 3
    };
    let n = "millisecond", lastN = n;
    for (n in timeUnits2) {
      if (range2 && range2 === timeUnits2.week && +this.dateFormat("%w", timestamp) === startOfWeek && dateStr.substr(6) === blank.substr(6)) {
        n = "week";
        break;
      }
      if (range2 && timeUnits2[n] > range2) {
        n = lastN;
        break;
      }
      if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
        break;
      }
      if (n !== "week") {
        lastN = n;
      }
    }
    return this.resolveDTLFormat(dateTimeLabelFormats[n]).main;
  }
};
var TimeBase_default = TimeBase;

// node_modules/highcharts/es-modules/Core/Time.js
var { defined: defined3, extend: extend3, timeUnits: timeUnits3 } = Utilities_default;
var Time = class extends TimeBase_default {
  /**
   * Return an array with time positions distributed on round time values
   * right and right after min and max. Used in datetime axes as well as for
   * grouping data on a datetime axis.
   *
   * @function Highcharts.Time#getTimeTicks
   *
   * @param {Highcharts.TimeNormalizedObject} normalizedInterval
   *        The interval in axis values (ms) and the count
   *
   * @param {number} [min]
   *        The minimum in axis values
   *
   * @param {number} [max]
   *        The maximum in axis values
   *
   * @param {number} [startOfWeek=1]
   *
   * @return {Highcharts.AxisTickPositionsArray}
   * Time positions
   */
  getTimeTicks(normalizedInterval, min4, max4, startOfWeek) {
    const time = this, tickPositions = [], higherRanks = {}, { count = 1, unitRange } = normalizedInterval;
    let [year, month, dayOfMonth, hours, minutes, seconds] = time.toParts(min4), milliseconds = (min4 || 0) % 1e3, variableDayLength;
    startOfWeek ?? (startOfWeek = 1);
    if (defined3(min4)) {
      milliseconds = unitRange >= timeUnits3.second ? 0 : (
        // #3935
        count * Math.floor(milliseconds / count)
      );
      if (unitRange >= timeUnits3.second) {
        seconds = unitRange >= timeUnits3.minute ? 0 : (
          // #3935
          count * Math.floor(seconds / count)
        );
      }
      if (unitRange >= timeUnits3.minute) {
        minutes = unitRange >= timeUnits3.hour ? 0 : count * Math.floor(minutes / count);
      }
      if (unitRange >= timeUnits3.hour) {
        hours = unitRange >= timeUnits3.day ? 0 : count * Math.floor(hours / count);
      }
      if (unitRange >= timeUnits3.day) {
        dayOfMonth = unitRange >= timeUnits3.month ? 1 : Math.max(1, count * Math.floor(dayOfMonth / count));
      }
      if (unitRange >= timeUnits3.month) {
        month = unitRange >= timeUnits3.year ? 0 : count * Math.floor(month / count);
      }
      if (unitRange >= timeUnits3.year) {
        year -= year % count;
      }
      if (unitRange === timeUnits3.week) {
        if (count) {
          min4 = time.makeTime(year, month, dayOfMonth, hours, minutes, seconds, milliseconds);
        }
        const weekday = this.dateTimeFormat({
          timeZone: this.timezone,
          weekday: "narrow"
        }, min4, "es"), weekdayNo = "DLMXJVS".indexOf(weekday);
        dayOfMonth += -weekdayNo + startOfWeek + // We don't want to skip days that are before
        // startOfWeek (#7051)
        (weekdayNo < startOfWeek ? -7 : 0);
      }
      min4 = time.makeTime(year, month, dayOfMonth, hours, minutes, seconds, milliseconds);
      if (time.variableTimezone && defined3(max4)) {
        variableDayLength = // Long range, assume we're crossing over.
        max4 - min4 > 4 * timeUnits3.month || // Short range, check if min and max are in different time
        // zones.
        time.getTimezoneOffset(min4) !== time.getTimezoneOffset(max4);
      }
      let t = min4, i = 1;
      while (t < max4) {
        tickPositions.push(t);
        if (unitRange === timeUnits3.year) {
          t = time.makeTime(year + i * count, 0);
        } else if (unitRange === timeUnits3.month) {
          t = time.makeTime(year, month + i * count);
        } else if (variableDayLength && (unitRange === timeUnits3.day || unitRange === timeUnits3.week)) {
          t = time.makeTime(year, month, dayOfMonth + i * count * (unitRange === timeUnits3.day ? 1 : 7));
        } else if (variableDayLength && unitRange === timeUnits3.hour && count > 1) {
          t = time.makeTime(year, month, dayOfMonth, hours + i * count);
        } else {
          t += unitRange * count;
        }
        i++;
      }
      tickPositions.push(t);
      if (unitRange <= timeUnits3.hour && tickPositions.length < 1e4) {
        tickPositions.forEach((t2) => {
          if (
            // Speed optimization, no need to run dateFormat unless
            // we're on a full or half hour
            t2 % 18e5 === 0 && // Check for local or global midnight
            time.dateFormat("%H%M%S%L", t2) === "000000000"
          ) {
            higherRanks[t2] = "day";
          }
        });
      }
    }
    tickPositions.info = extend3(normalizedInterval, {
      higherRanks,
      totalRange: unitRange * count
    });
    return tickPositions;
  }
};
var Time_default = Time;

// node_modules/highcharts/es-modules/Core/Defaults.js
var { isTouchDevice } = Globals_default;
var { fireEvent: fireEvent2, merge: merge3 } = Utilities_default;
var defaultOptions = {
  /**
   * An array containing the default colors for the chart's series. When
   * all colors are used, new colors are pulled from the start again.
   *
   * Default colors can also be set on a series or series.type basis,
   * see [column.colors](#plotOptions.column.colors),
   * [pie.colors](#plotOptions.pie.colors).
   *
   * In styled mode, the colors option doesn't exist. Instead, colors
   * are defined in CSS and applied either through series or point class
   * names, or through the [chart.colorCount](#chart.colorCount) option.
   *
   * @sample {highcharts} highcharts/chart/colors/
   *         Assign a global color theme
   * @sample highcharts/members/theme-v10/
   *         Latest release styled like version 10
   *
   * @type    {Array<(Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject)>}
   * @default [
   *     "#2caffe",
   *     "#544fc5",
   *     "#00e272",
   *     "#fe6a35",
   *     "#6b8abc",
   *     "#d568fb",
   *     "#2ee0ca",
   *     "#fa4b42",
   *     "#feb56a",
   *     "#91e8e1"
   * ]
   */
  colors: Palettes_default.colors,
  /**
   * Styled mode only. Configuration object for adding SVG definitions for
   * reusable elements. See [gradients, shadows and
   * patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns)
   * for more information and code examples.
   *
   * @type      {*}
   * @since     5.0.0
   * @apioption defs
   */
  /**
   * @ignore-option
   */
  symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
  /**
   * An object containing language-related strings and settings. A typical
   * setup uses `Highcharts.setOptions` to make the options apply to all
   * charts in the same page.
   *
   * ```js
   * Highcharts.setOptions({
   *     lang: {
   *         locale: 'fr'
   *     }
   * });
   * ```
   *
   * @optionparent lang
   */
  lang: {
    weekFrom: "week from",
    /**
     * The default chart title.
     *
     * @since 12.2.0
     */
    chartTitle: "Chart title",
    /**
     * The browser locale to use for date and number formatting. The actual
     * locale used for each chart is determined in three steps:
     * 1. If this `lang.locale` option is specified, it is used.
     * 2. Else, look for the closest ancestor HTML element with a `lang`
     *    attribute, typically the `<html>` element.
     * 3. If no 'lang' attribute is found, use the default browser locale.
     *
     * Use `en-GB`, British English, for approximate consistency with
     * Highcharts v < 12.
     *
     * @sample highcharts/lang/locale/
     *         Set the locale using the `lang.locale` option
     * @sample highcharts/lang/locale-attribute/
     *         Pick up the locale from the HTML `lang` attribute
     * @sample highcharts/members/highcharts-numberformat
     *         Arabic locale with digits and dates         *
     *
     * @since 12.0.0
     * @type {string|Array<string>}
     */
    locale: void 0,
    /**
     * The loading text that appears when the chart is set into the loading
     * state following a call to `chart.showLoading`.
     */
    loading: "Loading...",
    /**
     * An array containing the months names. Corresponds to the `%B` format
     * in `Highcharts.dateFormat()`. Defaults to 'undefined',
     * meaning the default month names are used according to the
     * `lang.locale` setting.
     *
     * @type    {Array<string>}
     */
    months: void 0,
    /**
     * [Format string](https://www.highcharts.com/docs/chart-concepts/templating) for the default series name.
     *
     * @since 12.2.0
     */
    seriesName: "Series {add index 1}",
    /**
     * An array containing the months names in abbreviated form. Corresponds
     * to the `%b` format in `Highcharts.dateFormat()`. Defaults to
     * 'undefined', meaning the default short month names are used according
     * to the `lang.locale` setting.
     *
     * @type    {Array<string>}
     */
    shortMonths: void 0,
    /**
     * An array containing the weekday names. Defaults to 'undefined',
     * meaning the default weekday names are used according to the
     * `lang.locale` setting.
     *
     * @type    {Array<string>}
     */
    weekdays: void 0,
    /**
     * Short week days, starting Sunday. Defaults to 'undefined', meaning
     * the default short weekday names are used according to the
     * `lang.locale` setting.
     *
     * @sample highcharts/lang/shortweekdays/
     *         Finnish two-letter abbreviations
     *
     * @type      {Array<string>}
     * @since     4.2.4
     * @apioption lang.shortWeekdays
     */
    /**
     * What to show in a date field for invalid dates. Defaults to an empty
     * string.
     *
     * @type      {string}
     * @since     4.1.8
     * @product   highcharts highstock
     * @apioption lang.invalidDate
     */
    /**
     * The title appearing on hovering the zoom in button. The text itself
     * defaults to "+" and can be changed in the button options.
     *
     * @type      {string}
     * @default   Zoom in
     * @product   highmaps
     * @apioption lang.zoomIn
     */
    /**
     * The title appearing on hovering the zoom out button. The text itself
     * defaults to "-" and can be changed in the button options.
     *
     * @type      {string}
     * @default   Zoom out
     * @product   highmaps
     * @apioption lang.zoomOut
     */
    /**
     * The default decimal point used in the `Highcharts.numberFormat`
     * method unless otherwise specified in the function arguments. Defaults
     * to the locale decimal point as determined by `lang.locale`.
     *
     * @type      {string}
     * @default   undefined
     * @since     1.2.2
     * @apioption lang.decimalPoint
     */
    /**
     * [Metric prefixes](https://en.wikipedia.org/wiki/Metric_prefix) used
     * to shorten high numbers in axis labels. Replacing any of the
     * positions with `null` causes the full number to be written. Setting
     * `numericSymbols` to `undefined` disables shortening altogether.
     *
     * @sample {highcharts} highcharts/lang/numericsymbols/
     *         Replacing the symbols with text
     * @sample {highstock} highcharts/lang/numericsymbols/
     *         Replacing the symbols with text
     *
     * @type    {Array<string>}
     * @default ["k", "M", "G", "T", "P", "E"]
     * @since   2.3.0
     */
    numericSymbols: ["k", "M", "G", "T", "P", "E"],
    /**
     * The default name for a pie slice (point).
     * @since 12.2.0
     */
    pieSliceName: "Slice",
    /**
     * The magnitude of [numericSymbols](#lang.numericSymbol) replacements.
     * Use 10000 for Japanese, Korean and various Chinese locales, which
     * use symbols for 10^4, 10^8 and 10^12.
     *
     * @sample highcharts/lang/numericsymbolmagnitude/
     *         10000 magnitude for Japanese
     *
     * @type      {number}
     * @default   1000
     * @since     5.0.3
     * @apioption lang.numericSymbolMagnitude
     */
    /**
     * The default thousands separator used in the `Highcharts.numberFormat`
     * method unless otherwise specified in the function arguments. Defaults
     * to the locale thousands separator as determined by `lang.locale`.
     *
     * @type      {string}
     * @default   undefined
     * @since     1.2.2
     * @apioption lang.thousandsSep
     */
    /**
     * The text for the label appearing when a chart is zoomed.
     *
     * @since 1.2.4
     */
    resetZoom: "Reset zoom",
    /**
     * The tooltip title for the label appearing when a chart is zoomed.
     *
     * @since 1.2.4
     */
    /**
     * The default title of the Y axis
     *
     * @since 12.2.0
     */
    yAxisTitle: "Values",
    resetZoomTitle: "Reset zoom level 1:1"
  },
  /**
   * Global options that don't apply to each chart. These options must be set
   * using the `Highcharts.setOptions` method.
   *
   * ```js
   * Highcharts.setOptions({
   *     global: {
   *         buttonTheme: {
   *             fill: '#d0d0d0'
   *         }
   *     }
   * });
   * ```
   */
  global: {
    /**
     * General theme for buttons. This applies to the zoom button, exporting
     * context menu, map navigation, range selector buttons and custom
     * buttons generated using the `SVGRenderer.button` function. However,
     * each of these may be overridden with more specific options.
     *
     * @sample highcharts/global/buttontheme
     *         General button theme
     * @since 11.4.2
     */
    buttonTheme: {
      /**
       * The fill color for buttons
       */
      fill: "#f7f7f7",
      /**
       * The padding of buttons
       */
      padding: 8,
      /**
       * The border radius for buttons
       */
      r: 2,
      /**
       * The stroke color for buttons
       */
      stroke: "#cccccc",
      /**
       * The stroke width for buttons
       */
      "stroke-width": 1,
      /**
       * CSS styling for the buttons' text
       */
      style: {
        color: "#333333",
        cursor: "pointer",
        fontSize: "0.8em",
        fontWeight: "normal"
      },
      /**
       * State overrides for the buttons
       */
      states: {
        /**
         * Hover state overrides for the buttons are applied in addition
         * to the normal state options
         */
        hover: {
          fill: "#e6e6e6"
          /* Palette.neutralColor10 */
        },
        /**
         * Select state overrides for the buttons are applied in
         * addition to the normal state options
         */
        select: {
          fill: "#e6e9ff",
          style: {
            color: "#000000",
            fontWeight: "bold"
          }
        },
        /**
         * Disabled state overrides for the buttons are applied in
         * addition to the normal state options
         */
        disabled: {
          /**
           * Disabled state CSS style overrides for the buttons' text
           */
          style: {
            color: "#cccccc"
            /* Palette.neutralColor20 */
          }
        }
      }
    }
  },
  /**
   * Time options that can apply globally or to individual charts. These
   * settings affect how `datetime` axes are laid out, how tooltips are
   * formatted, how series
   * [pointIntervalUnit](#plotOptions.series.pointIntervalUnit) works and how
   * the Highcharts Stock range selector handles time.
   *
   * The common use case is that all charts in the same Highcharts object
   * share the same time settings, in which case the global settings are set
   * using `setOptions`.
   *
   * ```js
   * // Apply time settings globally
   * Highcharts.setOptions({
   *     time: {
   *         timezone: 'Europe/London'
   *     }
   * });
   * // Apply time settings by instance
   * const chart = Highcharts.chart('container', {
   *     time: {
   *         timezone: 'America/New_York'
   *     },
   *     series: [{
   *         data: [1, 4, 3, 5]
   *     }]
   * });
   *
   * // Use the Time object
   * console.log(
   *        'Current time in New York',
   *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
   * );
   * ```
   *
   * Since v6.0.5, the time options were moved from the `global` object to the
   * `time` object, and time options can be set on each individual chart.
   *
   * @sample {highcharts|highstock}
   *         highcharts/time/timezone/
   *         Set the timezone globally
   * @sample {highcharts}
   *         highcharts/time/individual/
   *         Set the timezone per chart instance
   * @sample {highstock}
   *         stock/time/individual/
   *         Set the timezone per chart instance
   *
   * @since     6.0.5
   * @optionparent time
   */
  time: {
    /**
     * A custom `Date` class for advanced date handling. For example,
     * [JDate](https://github.com/tahajahangir/jdate) can be hooked in to
     * handle Jalali dates.
     *
     * @type      {*}
     * @since     4.0.4
     * @product   highcharts highstock gantt
     */
    Date: void 0,
    /**
     * A named time zone. Supported time zone names rely on the browser
     * implementations, as described in the [mdn
     * docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat#timezone).
     * If the given time zone is not recognized by the browser, Highcharts
     * provides a warning and falls back to returning a 0 offset,
     * corresponding to the UTC time zone.
     *
     * The time zone affects axis scaling, tickmark placement and
     * time display in `Highcharts.dateFormat`.
     *
     * Setting `timezone` to `undefined` falls back to the default browser
     * timezone setting.
     *
     * Until v11.2.0, this option depended on moment.js.
     *
     * @sample {highcharts|highstock} highcharts/time/timezone/ Europe/Oslo
     *
     * @type      {string}
     * @since     5.0.7
     * @product   highcharts highstock gantt
     */
    timezone: "UTC",
    /**
     * The timezone offset in minutes. Positive values are west, negative
     * values are east of UTC, as in the ECMAScript
     * [getTimezoneOffset](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)
     * method. Use this to display UTC based data in a predefined time zone.
     *
     * This option is deprecated as of v11.4.1 and will be removed in a
     * future release. Use the [time.timezone](#time.timezone) option
     * instead.
     *
     * @see [time.getTimezoneOffset](#time.getTimezoneOffset)
     *
     * @sample {highcharts|highstock} highcharts/time/timezoneoffset/
     *         Timezone offset
     *
     * @since     3.0.8
     * @deprecated 11.4.2
     * @product   highcharts highstock gantt
     */
    timezoneOffset: 0,
    /**
     * Whether to use UTC time for axis scaling, tickmark placement and
     * time display in `Highcharts.dateFormat`. Advantages of using UTC
     * is that the time displays equally regardless of the user agent's
     * time zone settings. Local time can be used when the data is loaded
     * in real time or when correct Daylight Saving Time transitions are
     * required.
     *
     * Setting `useUTC` to true is equivalent to setting `time.timezone` to
     * `"UTC"`. Setting `useUTC` to false is equivalent to setting
     * `time.timezone` to `undefined`.
     *
     * @see [time.timezone](#timezone)
     *
     * @sample {highcharts} highcharts/time/useutc-true/
     *         True by default
     * @sample {highcharts} highcharts/time/useutc-false/
     *         False
     *
     * @deprecated
     */
    useUTC: void 0
  },
  chart: ChartDefaults_default,
  /**
   * The chart's main title.
   *
   * @sample {highmaps} maps/title/title/
   *         Title options demonstrated
   * @sample {highcharts} highcharts/title/align-auto/
   *         Default title alignment
   */
  title: {
    /**
     * When the title is floating, the plot area will not move to make space
     * for it.
     *
     * @sample {highcharts} highcharts/chart/zoomtype-none/
     *         False by default
     * @sample {highcharts} highcharts/title/floating/
     *         True - title on top of the plot area
     * @sample {highstock} stock/chart/title-floating/
     *         True - title on top of the plot area
     *
     * @type      {boolean}
     * @default   false
     * @since     2.1
     * @apioption title.floating
     */
    /**
     * Whether to
     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the text.
     *
     * @type      {boolean}
     * @default   false
     * @apioption title.useHTML
     */
    /**
     * The vertical alignment of the title. Can be one of `"top"`,
     * `"middle"` and `"bottom"`. When a value is given, the title behaves
     * as if [floating](#title.floating) were `true`.
     *
     * @sample {highcharts} highcharts/title/verticalalign/
     *         Chart title in bottom right corner
     * @sample {highstock} stock/chart/title-verticalalign/
     *         Chart title in bottom right corner
     *
     * @type      {Highcharts.VerticalAlignValue}
     * @since     2.1
     * @apioption title.verticalAlign
     */
    /**
     * The x position of the title relative to the alignment within
     * `chart.spacingLeft` and `chart.spacingRight`.
     *
     * @sample {highcharts} highcharts/title/align/
     *         Aligned to the plot area (x = 70px = margin left - spacing
     *         left)
     * @sample {highstock} stock/chart/title-align/
     *         Aligned to the plot area (x = 50px = margin left - spacing
     *         left)
     *
     * @type      {number}
     * @default   0
     * @since     2.0
     * @apioption title.x
     */
    /**
     * The y position of the title relative to the alignment within
     * [chart.spacingTop](#chart.spacingTop) and [chart.spacingBottom](
     * #chart.spacingBottom). By default it depends on the font size.
     *
     * @sample {highcharts} highcharts/title/y/
     *         Title inside the plot area
     * @sample {highstock} stock/chart/title-verticalalign/
     *         Chart title in bottom right corner
     *
     * @type      {number}
     * @since     2.0
     * @apioption title.y
     */
    /**
     * CSS styles for the title. Use this for font styling, but use `align`,
     * `x` and `y` for text alignment.
     *
     * Note that the default [title.minScale](#title.minScale) option also
     * affects the rendered font size. In order to keep the font size fixed
     * regardless of title length, set `minScale` to 1.
     *
     * In styled mode, the title style is given in the `.highcharts-title`
     * class.
     *
     * @sample {highcharts} highcharts/title/style/
     *         Custom color and weight
     * @sample {highstock} stock/chart/title-style/
     *         Custom color and weight
     * @sample highcharts/css/titles/
     *         Styled mode
     *
     * @type      {Highcharts.CSSObject}
     * @default   {highcharts|highmaps} { "color": "#333333", "fontSize": "18px" }
     * @default   {highstock} { "color": "#333333", "fontSize": "16px" }
     */
    style: {
      color: "#333333",
      fontWeight: "bold"
    },
    /**
     * The title of the chart. To disable the title, set the `text` to
     * `undefined`.
     *
     * @sample {highcharts} highcharts/title/text/
     *         Custom title
     * @sample {highstock} stock/chart/title-text/
     *         Custom title
     *
     * @default {highcharts|highmaps} Chart title
     * @default {highstock} undefined
     */
    text: "Chart title",
    /**
     * The horizontal alignment of the title. Can be one of "left", "center"
     * and "right".
     *
     * Since v12 it defaults to `undefined`, meaning the alignment is
     * computed for best fit. If the text fits in one line, it aligned to
     * the center, but if it is wrapped into multiple lines, it is aligned
     * to the left.
     *
     * @sample {highcharts} highcharts/title/align-auto/
     *         Default alignment, dynamic
     * @sample {highcharts} highcharts/title/align/
     *         Aligned to the plot area (x = 70px = margin left - spacing
     *         left)
     * @sample {highstock} stock/chart/title-align/
     *         Aligned to the plot area (x = 50px = margin left - spacing
     *         left)
     *
     * @type      {Highcharts.AlignValue}
     * @default   undefined
     * @since     2.0
     * @apioption title.align
     */
    /**
     * The margin between the title and the plot area, or if a subtitle
     * is present, the margin between the subtitle and the plot area.
     *
     * @sample {highcharts} highcharts/title/margin-50/
     *         A chart title margin of 50
     * @sample {highcharts} highcharts/title/margin-subtitle/
     *         The same margin applied with a subtitle
     * @sample {highstock} stock/chart/title-margin/
     *         A chart title margin of 50
     *
     * @since 2.1
     */
    margin: 15,
    /**
     * When the title is too wide to fit in the chart, the default behavior
     * is to scale it down to fit, or apply word wrap if it is scaled down
     * to `minScale` and still doesn't fit.
     *
     * The default value reflects the scale, when using default font sizes,
     * when the title font size matches that of the subtitle. The title
     * still stands out as it is bold by default.
     *
     * Set `minScale` to 1 to avoid downscaling.
     *
     * @sample {highcharts} highcharts/title/align-auto/
     *         Downscaling demonstrated
     *
     * @since 12.0.0
     */
    minScale: 0.67
  },
  /**
   * The chart's subtitle. This can be used both to display a subtitle below
   * the main title, and to display random text anywhere in the chart. The
   * subtitle can be updated after chart initialization through the
   * `Chart.setTitle` method.
   *
   * @sample {highcharts} highcharts/title/align-auto/
   *         Default title alignment
   * @sample {highmaps} maps/title/subtitle/
   *         Subtitle options demonstrated
   */
  subtitle: {
    /**
     * The horizontal alignment of the subtitle. Can be one of "left",
     * "center" and "right". Since v12, it defaults to `undefined`, meaning
     * the actual alignment is inherited from the alignment of the main
     * title.
     *
     * @sample {highcharts} highcharts/title/align-auto/
     *         Default title and subtitle alignment, dynamic
     * @sample {highcharts} highcharts/subtitle/align/
     *         Footnote at right of plot area
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote at bottom right of plot area
     *
     * @type  {Highcharts.AlignValue}
     * @default undefined
     * @since 2.0
     * @apioption subtitle.align
     */
    /**
     * When the subtitle is floating, the plot area will not move to make
     * space for it.
     *
     * @sample {highcharts} highcharts/subtitle/floating/
     *         Floating title and subtitle
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote floating at bottom right of plot area
     *
     * @type      {boolean}
     * @default   false
     * @since     2.1
     * @apioption subtitle.floating
     */
    /**
     * CSS styles for the title.
     *
     * In styled mode, the subtitle style is given in the
     * `.highcharts-subtitle` class.
     *
     * @sample {highcharts} highcharts/subtitle/style/
     *         Custom color and weight
     * @sample {highcharts} highcharts/css/titles/
     *         Styled mode
     * @sample {highstock} stock/chart/subtitle-style
     *         Custom color and weight
     * @sample {highstock} highcharts/css/titles/
     *         Styled mode
     * @sample {highmaps} highcharts/css/titles/
     *         Styled mode
     *
     * @type      {Highcharts.CSSObject}
     * @default   {"color": "#666666"}
     * @apioption subtitle.style
     */
    /**
     * Whether to
     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the text.
     *
     * @type      {boolean}
     * @default   false
     * @apioption subtitle.useHTML
     */
    /**
     * The vertical alignment of the title. Can be one of `"top"`,
     * `"middle"` and `"bottom"`. When middle, the subtitle behaves as
     * floating.
     *
     * @sample {highcharts} highcharts/subtitle/verticalalign/
     *         Footnote at the bottom right of plot area
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote at the bottom right of plot area
     *
     * @type      {Highcharts.VerticalAlignValue}
     * @since     2.1
     * @apioption subtitle.verticalAlign
     */
    /**
     * The x position of the subtitle relative to the alignment within
     * `chart.spacingLeft` and `chart.spacingRight`.
     *
     * @sample {highcharts} highcharts/subtitle/align/
     *         Footnote at right of plot area
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote at the bottom right of plot area
     *
     * @type      {number}
     * @default   0
     * @since     2.0
     * @apioption subtitle.x
     */
    /**
     * The y position of the subtitle relative to the alignment within
     * `chart.spacingTop` and `chart.spacingBottom`. By default the subtitle
     * is laid out below the title unless the title is floating.
     *
     * @sample {highcharts} highcharts/subtitle/verticalalign/
     *         Footnote at the bottom right of plot area
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote at the bottom right of plot area
     *
     * @type      {number}
     * @since     2.0
     * @apioption subtitle.y
     */
    /**
     * CSS styles for the title.
     *
     * In styled mode, the subtitle style is given in the
     * `.highcharts-subtitle` class.
     *
     * @sample {highcharts} highcharts/subtitle/style/
     *         Custom color and weight
     * @sample {highcharts} highcharts/css/titles/
     *         Styled mode
     * @sample {highstock} stock/chart/subtitle-style
     *         Custom color and weight
     * @sample {highstock} highcharts/css/titles/
     *         Styled mode
     * @sample {highmaps} highcharts/css/titles/
     *         Styled mode
     *
     * @type      {Highcharts.CSSObject}
     * @default   {"color": "#666666"}
     */
    style: {
      color: "#666666",
      /**
       * @type {number|string}
       */
      fontSize: "0.8em"
    },
    /**
     * The subtitle of the chart.
     *
     * @sample {highcharts|highstock} highcharts/subtitle/text/
     *         Custom subtitle
     * @sample {highcharts|highstock} highcharts/subtitle/text-formatted/
     *         Formatted and linked text.
     */
    text: ""
  },
  /**
   * The chart's caption, which will render below the chart and will be part
   * of exported charts. The caption can be updated after chart initialization
   * through the `Chart.update` or `Chart.caption.update` methods.
   *
   * @sample highcharts/caption/text/
   *         A chart with a caption
   * @since  7.2.0
   */
  caption: {
    /**
     * When the caption is floating, the plot area will not move to make
     * space for it.
     *
     * @type      {boolean}
     * @default   false
     * @apioption caption.floating
     */
    /**
     * The margin between the caption and the plot area.
     */
    margin: 15,
    /**
     * Whether to
     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the text.
     *
     * @type      {boolean}
     * @default   false
     * @apioption caption.useHTML
     */
    /**
     * The x position of the caption relative to the alignment within
     * `chart.spacingLeft` and `chart.spacingRight`.
     *
     * @type      {number}
     * @default   0
     * @apioption caption.x
     */
    /**
     * The y position of the caption relative to the alignment within
     * `chart.spacingTop` and `chart.spacingBottom`.
     *
     * @type      {number}
     * @apioption caption.y
     */
    /**
     * CSS styles for the caption.
     *
     * In styled mode, the caption style is given in the
     * `.highcharts-caption` class.
     *
     * @sample {highcharts} highcharts/css/titles/
     *         Styled mode
     *
     * @type      {Highcharts.CSSObject}
     * @default   {"color": "#666666"}
     */
    style: {
      color: "#666666",
      /**
       * @type {number|string}
       */
      fontSize: "0.8em"
    },
    /**
     * The caption text of the chart.
     *
     * @sample {highcharts} highcharts/caption/text/
     *         Custom caption
     */
    text: "",
    /**
     * The horizontal alignment of the caption. Can be one of "left",
     *  "center" and "right".
     *
     * @type  {Highcharts.AlignValue}
     */
    align: "left",
    /**
     * The vertical alignment of the caption. Can be one of `"top"`,
     * `"middle"` and `"bottom"`. When middle, the caption behaves as
     * floating.
     *
     * @type      {Highcharts.VerticalAlignValue}
     */
    verticalAlign: "bottom"
  },
  /**
   * The plotOptions is a wrapper object for config objects for each series
   * type. The config objects for each series can also be overridden for
   * each series item as given in the series array.
   *
   * Configuration options for the series are given in three levels. Options
   * for all series in a chart are given in the [plotOptions.series](
   * #plotOptions.series) object. Then options for all series of a specific
   * type are given in the plotOptions of that type, for example
   * `plotOptions.line`. Next, options for one single series are given in
   * [the series array](#series).
   */
  plotOptions: {},
  /**
   * The legend is a box containing a symbol and name for each series
   * item or point item in the chart. Each series (or points in case
   * of pie charts) is represented by a symbol and its name in the legend.
   *
   * It is possible to override the symbol creator function and create
   * [custom legend symbols](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-custom-symbol/).
   *
   * @productdesc {highmaps}
   * A Highmaps legend by default contains one legend item per series, but if
   * a `colorAxis` is defined, the axis will be displayed in the legend.
   * Either as a gradient, or as multiple legend items for `dataClasses`.
   */
  legend: {
    /**
     * The background color of the legend.
     *
     * @see In styled mode, the legend background fill can be applied with
     *      the `.highcharts-legend-box` class.
     *
     * @sample {highcharts} highcharts/legend/backgroundcolor/
     *         Yellowish background
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @apioption legend.backgroundColor
     */
    /**
     * The width of the drawn border around the legend.
     *
     * @see In styled mode, the legend border stroke width can be applied
     *      with the `.highcharts-legend-box` class.
     *
     * @sample {highcharts} highcharts/legend/borderwidth/
     *         2px border width
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     *
     * @type      {number}
     * @default   0
     * @apioption legend.borderWidth
     */
    /**
     * Enable or disable the legend. There is also a series-specific option,
     * [showInLegend](#plotOptions.series.showInLegend), that can hide the
     * series from the legend. In some series types this is `false` by
     * default, so it must set to `true` in order to show the legend for the
     * series.
     *
     * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled
     * @sample {highstock} stock/legend/align/ Various legend options
     * @sample {highmaps} maps/legend/enabled-false/ Legend disabled
     *
     * @default {highstock} false
     * @default {highmaps} true
     * @default {gantt} false
     */
    enabled: true,
    /**
     * The horizontal alignment of the legend box within the chart area.
     * Valid values are `left`, `center` and `right`.
     *
     * In the case that the legend is aligned in a corner position, the
     * `layout` option will determine whether to place it above/below
     * or on the side of the plot area.
     *
     * @sample {highcharts} highcharts/legend/align/
     *         Legend at the right of the chart
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/alignment/
     *         Legend alignment
     *
     * @type  {Highcharts.AlignValue}
     * @since 2.0
     */
    align: "center",
    /**
     * If the [layout](legend.layout) is `horizontal` and the legend items
     * span over two lines or more, whether to align the items into vertical
     * columns. Setting this to `false` makes room for more items, but will
     * look more messy.
     *
     * @since 6.1.0
     */
    alignColumns: true,
    /**
     * A CSS class name to apply to the legend group.
     */
    className: "highcharts-no-tooltip",
    /**
     * General event handlers for the legend. These event hooks can
     * also be attached to the legend at run time using the
     * `Highcharts.addEvent` function.
     *
     * @declare Highcharts.LegendEventsOptionsObject
     *
     * @private
     */
    events: {},
    /**
     * Fires when the legend item belonging to the series is clicked. One
     * parameter, `event`, is passed to the function. The default action
     * is to toggle the visibility of the series, point or data class. This
     * can be prevented by returning `false` or calling
     * `event.preventDefault()`.
     *
     * @sample {highcharts} highcharts/legend/itemclick/
     *         Confirm hiding and showing
     * @sample {highcharts} highcharts/legend/pie-legend-itemclick/
     *         Confirm toggle visibility of pie slices
     *
     * @type      {Highcharts.LegendItemClickCallbackFunction}
     * @context   Highcharts.Legend
     * @apioption legend.events.itemClick
     */
    /**
     * When the legend is floating, the plot area ignores it and is allowed
     * to be placed below it.
     *
     * @sample {highcharts} highcharts/legend/floating-false/
     *         False by default
     * @sample {highcharts} highcharts/legend/floating-true/
     *         True
     * @sample {highmaps} maps/legend/alignment/
     *         Floating legend
     *
     * @type      {boolean}
     * @default   false
     * @since     2.1
     * @apioption legend.floating
     */
    /**
     * The layout of the legend items. Can be one of `horizontal` or
     * `vertical` or `proximate`. When `proximate`, the legend items will be
     * placed as close as possible to the graphs they're representing,
     * except in inverted charts or when the legend position doesn't allow
     * it.
     *
     * @sample {highcharts} highcharts/legend/layout-horizontal/
     *         Horizontal by default
     * @sample {highcharts} highcharts/legend/layout-vertical/
     *         Vertical
     * @sample highcharts/legend/layout-proximate
     *         Labels proximate to the data
     * @sample {highstock} stock/legend/layout-horizontal/
     *         Horizontal by default
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Vertical with data classes
     * @sample {highmaps} maps/legend/layout-vertical/
     *         Vertical with color axis gradient
     *
     * @validvalue ["horizontal", "vertical", "proximate"]
     */
    layout: "horizontal",
    /**
     * In a legend with horizontal layout, the itemDistance defines the
     * pixel distance between each item.
     *
     * @sample {highcharts} highcharts/legend/layout-horizontal/
     *         50px item distance
     * @sample {highstock} highcharts/legend/layout-horizontal/
     *         50px item distance
     *
     * @type      {number}
     * @default   {highcharts} 20
     * @default   {highstock} 20
     * @default   {highmaps} 8
     * @since     3.0.3
     * @apioption legend.itemDistance
     */
    /**
     * The pixel bottom margin for each legend item.
     *
     * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     *
     * @since     2.2.0
     */
    itemMarginBottom: 2,
    /**
     * The pixel top margin for each legend item.
     *
     * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     *
     * @since     2.2.0
     */
    itemMarginTop: 2,
    /**
     * The width for each legend item. By default the items are laid out
     * successively. In a [horizontal layout](legend.layout), if the items
     * are laid out across two rows or more, they will be vertically aligned
     * depending on the [legend.alignColumns](legend.alignColumns) option.
     *
     * @sample {highcharts} highcharts/legend/itemwidth-default/
     *         Undefined by default
     * @sample {highcharts} highcharts/legend/itemwidth-80/
     *         80 for aligned legend items
     *
     * @type      {number}
     * @since     2.0
     * @apioption legend.itemWidth
     */
    /**
     * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
     * for each legend label. Available variables relates to properties on
     * the series, or the point in case of pies.
     *
     * @type      {string}
     * @default   {name}
     * @since     1.3
     * @apioption legend.labelFormat
     */
    /* eslint-disable valid-jsdoc */
    /**
     * Callback function to format each of the series' labels. The `this`
     * keyword refers to the series object, or the point object in case of
     * pie charts. By default the series or point name is printed.
     *
     * @productdesc {highmaps}
     * In Highmaps the context can also be a data class in case of a
     * `colorAxis`.
     *
     * @sample {highcharts} highcharts/legend/labelformatter/
     *         Add text
     * @sample {highmaps} maps/legend/labelformatter/
     *         Data classes with label formatter
     *
     * @type {Highcharts.FormatterCallbackFunction<Point|Series>}
     */
    labelFormatter: function() {
      return this.name;
    },
    /**
     * Line height for the legend items. Deprecated as of 2.1\. Instead,
     * the line height for each item can be set using
     * `itemStyle.lineHeight`, and the padding between items using
     * `itemMarginTop` and `itemMarginBottom`.
     *
     * @sample {highcharts} highcharts/legend/lineheight/
     *         Setting padding
     *
     * @deprecated
     *
     * @type      {number}
     * @default   16
     * @since     2.0
     * @product   highcharts gantt
     * @apioption legend.lineHeight
     */
    /**
     * If the plot area sized is calculated automatically and the legend is
     * not floating, the legend margin is the space between the legend and
     * the axis labels or plot area.
     *
     * @sample {highcharts} highcharts/legend/margin-default/
     *         12 pixels by default
     * @sample {highcharts} highcharts/legend/margin-30/
     *         30 pixels
     *
     * @type      {number}
     * @default   12
     * @since     2.1
     * @apioption legend.margin
     */
    /**
     * Maximum pixel height for the legend. When the maximum height is
     * extended, navigation will show.
     *
     * @type      {number}
     * @since     2.3.0
     * @apioption legend.maxHeight
     */
    /**
     * The color of the drawn border around the legend.
     *
     * @see In styled mode, the legend border stroke can be applied with the
     *      `.highcharts-legend-box` class.
     *
     * @sample {highcharts} highcharts/legend/bordercolor/
     *         Brown border
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     *
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    borderColor: "#999999",
    /**
     * The border corner radius of the legend.
     *
     * @sample {highcharts} highcharts/legend/borderradius-default/
     *         Square by default
     * @sample {highcharts} highcharts/legend/borderradius-round/
     *         5px rounded
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     */
    borderRadius: 0,
    /**
     * Options for the paging or navigation appearing when the legend is
     * overflown. Navigation works well on screen, but not in static
     * exported images. One way of working around that is to
     * [increase the chart height in
     * export](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-enabled-false/).
     *
     * @sample highcharts/legend/scrollable-vertical/
     *         Legend with vertical scrollable extension
     * @sample highcharts/legend/scrollable-horizontal/
     *         Legend with horizontal scrollable extension
     *
     */
    navigation: {
      /**
       * How to animate the pages when navigating up or down. A value of
       * `true` applies the default navigation given in the
       * `chart.animation` option. Additional options can be given as an
       * object containing values for easing and duration.
       *
       * @sample {highcharts} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       * @sample {highstock} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       *
       * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
       * @default   true
       * @since     2.2.4
       * @apioption legend.navigation.animation
       */
      /**
       * The pixel size of the up and down arrows in the legend paging
       * navigation.
       *
       * @sample {highcharts} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       * @sample {highstock} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       *
       * @type      {number}
       * @default   12
       * @since     2.2.4
       * @apioption legend.navigation.arrowSize
       */
      /**
       * Whether to enable the legend navigation. In most cases, disabling
       * the navigation results in an unwanted overflow.
       *
       * See also the
       * [adapt chart to legend](https://github.com/highcharts/adapt-chart-to-legend)
       * plugin for a solution to extend the chart height to make room for
       * the legend, optionally in exported charts only.
       *
       * @type      {boolean}
       * @default   true
       * @since     4.2.4
       * @apioption legend.navigation.enabled
       */
      /**
       * Text styles for the legend page navigation.
       *
       * @see In styled mode, the navigation items are styled with the
       *      `.highcharts-legend-navigation` class.
       *
       * @sample {highcharts} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       * @sample {highstock} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       *
       * @type      {Highcharts.CSSObject}
       * @since     2.2.4
       * @apioption legend.navigation.style
       */
      style: {
        /**
         * @type {number|string}
         */
        fontSize: "0.8em"
      },
      /**
       * The color for the active up or down arrow in the legend page
       * navigation.
       *
       * @see In styled mode, the active arrow be styled with the
       *      `.highcharts-legend-nav-active` class.
       *
       * @sample  {highcharts} highcharts/legend/navigation/
       *          Legend page navigation demonstrated
       * @sample  {highstock} highcharts/legend/navigation/
       *          Legend page navigation demonstrated
       *
       * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since 2.2.4
       */
      activeColor: "#0022ff",
      /**
       * The color of the inactive up or down arrow in the legend page
       * navigation. .
       *
       * @see In styled mode, the inactive arrow be styled with the
       *      `.highcharts-legend-nav-inactive` class.
       *
       * @sample {highcharts} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       * @sample {highstock} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       *
       * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since 2.2.4
       */
      inactiveColor: "#cccccc"
      /* Palette.neutralColor20 */
    },
    /**
     * The inner padding of the legend box.
     *
     * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     *
     * @type      {number}
     * @default   8
     * @since     2.2.0
     * @apioption legend.padding
     */
    /**
     * Whether to reverse the order of the legend items compared to the
     * order of the series or points as defined in the configuration object.
     *
     * @see [yAxis.reversedStacks](#yAxis.reversedStacks),
     *      [series.legendIndex](#series.legendIndex)
     *
     * @sample {highcharts} highcharts/legend/reversed/
     *         Stacked bar with reversed legend
     *
     * @type      {boolean}
     * @default   false
     * @since     1.2.5
     * @apioption legend.reversed
     */
    /**
     * Whether to show the symbol on the right side of the text rather than
     * the left side. This is common in Arabic and Hebrew.
     *
     * @sample {highcharts} highcharts/legend/rtl/
     *         Symbol to the right
     *
     * @type      {boolean}
     * @default   false
     * @since     2.2
     * @apioption legend.rtl
     */
    /**
     * CSS styles for the legend area. In the 1.x versions the position
     * of the legend area was determined by CSS. In 2.x, the position is
     * determined by properties like `align`, `verticalAlign`, `x` and `y`,
     * but the styles are still parsed for backwards compatibility.
     *
     * @deprecated
     *
     * @type      {Highcharts.CSSObject}
     * @product   highcharts highstock
     * @apioption legend.style
     */
    /**
     * CSS styles for each legend item. Only a subset of CSS is supported,
     * notably those options related to text. The default `textOverflow`
     * property makes long texts truncate. Set it to `undefined` to wrap
     * text instead. A `width` property can be added to control the text
     * width.
     *
     * @see In styled mode, the legend items can be styled with the
     *      `.highcharts-legend-item` class.
     *
     * @sample {highcharts} highcharts/legend/itemstyle/
     *         Bold black text
     * @sample {highmaps} maps/legend/itemstyle/
     *         Item text styles
     *
     * @type    {Highcharts.CSSObject}
     * @default {"color": "#333333", "cursor": "pointer", "fontSize": "0.8em", "fontWeight": "bold", "textOverflow": "ellipsis"}
     */
    itemStyle: {
      /**
       * @ignore
       */
      color: "#333333",
      /**
       * @ignore
       */
      cursor: "pointer",
      /**
       * @ignore
       */
      fontSize: "0.8em",
      /**
       * @ignore
       */
      textDecoration: "none",
      /**
       * @ignore
       */
      textOverflow: "ellipsis"
    },
    /**
     * CSS styles for each legend item in hover mode. Only a subset of
     * CSS is supported, notably those options related to text. Properties
     * are inherited from `style` unless overridden here.
     *
     * @see In styled mode, the hovered legend items can be styled with
     *      the `.highcharts-legend-item:hover` pseudo-class.
     *
     * @sample {highcharts} highcharts/legend/itemhoverstyle/
     *         Red on hover
     * @sample {highmaps} maps/legend/itemstyle/
     *         Item text styles
     *
     * @type    {Highcharts.CSSObject}
     * @default {"color": "#000000"}
     */
    itemHoverStyle: {
      /**
       * @ignore
       */
      color: "#000000"
      /* Palette.neutralColor100 */
    },
    /**
     * CSS styles for each legend item when the corresponding series or
     * point is hidden. Only a subset of CSS is supported, notably those
     * options related to text. Properties are inherited from `style`
     * unless overridden here.
     *
     * @see In styled mode, the hidden legend items can be styled with
     *      the `.highcharts-legend-item-hidden` class.
     *
     * @sample {highcharts} highcharts/legend/itemhiddenstyle/
     *         Darker gray color
     *
     * @type    {Highcharts.CSSObject}
     * @default {"color": "#cccccc"}
     */
    itemHiddenStyle: {
      /**
       * @ignore
       */
      color: "#666666",
      /**
       * @ignore
       */
      textDecoration: "line-through"
    },
    /**
     * Whether to apply a drop shadow to the legend. A `backgroundColor`
     * also needs to be applied for this to take effect. The shadow can be
     * an object configuration containing `color`, `offsetX`, `offsetY`,
     * `opacity` and `width`.
     *
     * @sample {highcharts} highcharts/legend/shadow/
     *         White background and drop shadow
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     *
     * @type {boolean|Highcharts.CSSObject}
     */
    shadow: false,
    /**
     * Default styling for the checkbox next to a legend item when
     * `showCheckbox` is true.
     *
     * @type {Highcharts.CSSObject}
     * @default {"width": "13px", "height": "13px", "position":"absolute"}
     */
    itemCheckboxStyle: {
      /**
       * @ignore
       */
      position: "absolute",
      /**
       * @ignore
       */
      width: "13px",
      // For IE precision
      /**
       * @ignore
       */
      height: "13px"
    },
    /// itemWidth: undefined,
    /**
     * When this is true, the legend symbol width will be the same as
     * the symbol height, which in turn defaults to the font size of the
     * legend items.
     *
     * @since 5.0.0
     */
    squareSymbol: true,
    /**
     * The pixel height of the symbol for series types that use a rectangle
     * in the legend. Defaults to the font size of legend items.
     *
     * Note: This option is a default source of color axis height, if the
     * [colorAxis.height](https://api.highcharts.com/highcharts/colorAxis.height)
     * option is not set.
     *
     * @productdesc {highmaps}
     * In Highmaps, when the symbol is the gradient of a vertical color
     * axis, the height defaults to 200.
     *
     * @sample {highmaps} maps/legend/layout-vertical-sized/
     *         Sized vertical gradient
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         No distance between data classes
     *
     * @type      {number}
     * @since     3.0.8
     * @apioption legend.symbolHeight
     */
    /**
     * The border radius of the symbol for series types that use a rectangle
     * in the legend. Defaults to half the `symbolHeight`, effectively
     * creating a circle.
     *
     * For color axis scales, it defaults to 3.
     *
     * @sample {highcharts} highcharts/legend/symbolradius/
     *         Round symbols
     * @sample {highstock} highcharts/legend/symbolradius/
     *         Round symbols
     * @sample {highmaps} highcharts/legend/symbolradius/
     *         Round symbols
     *
     * @type      {number}
     * @since     3.0.8
     * @apioption legend.symbolRadius
     */
    /**
     * The pixel width of the legend item symbol. When the `squareSymbol`
     * option is set, this defaults to the `symbolHeight`, otherwise 16.
     *
     * Note: This option is a default source of color axis width, if the
     * [colorAxis.width](https://api.highcharts.com/highcharts/colorAxis.width)
     * option is not set.
     *
     * @productdesc {highmaps}
     * In Highmaps, when the symbol is the gradient of a horizontal color
     * axis, the width defaults to 200.
     *
     * @sample {highcharts} highcharts/legend/symbolwidth/
     *         Greater symbol width and padding
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     * @sample {highmaps} maps/legend/layout-vertical-sized/
     *         Sized vertical gradient
     *
     * @type      {number}
     * @apioption legend.symbolWidth
     */
    /**
     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the legend item texts.
     *
     * Prior to 4.1.7, when using HTML, [legend.navigation](
     * #legend.navigation) was disabled.
     *
     * @sample highcharts/legend/scrollable-vertical/
     *         Legend with vertical scrollable extension
     * @sample highcharts/legend/scrollable-horizontal/
     *         Legend with horizontal scrollable extension
     *
     * @type      {boolean}
     * @default   false
     * @apioption legend.useHTML
     */
    /**
     * For a color axis with data classes, how many decimals to render in
     * the legend. The default preserves the decimals of the range numbers.
     *
     * @type      {number}
     * @default   -1
     * @product   highcharts highmaps
     * @apioption legend.valueDecimals
     */
    /**
     * For a color axis with data classes, a suffix for the range numbers in
     * the legend.
     *
     * @type      {string}
     * @default   ''
     * @product   highcharts highmaps
     * @apioption legend.valueSuffix
     */
    /**
     * The width of the legend box. If a number is set, it translates to
     * pixels. Since v7.0.2 it allows setting a percent string of the full
     * chart width, for example `40%`.
     *
     * Defaults to the full chart width for legends below or above the
     * chart, half the chart width for legends to the left and right.
     *
     * @sample {highcharts} highcharts/legend/width/
     *         Aligned to the plot area
     * @sample {highcharts} highcharts/legend/width-percent/
     *         A percent of the chart width
     *
     * @type      {number|string}
     * @since     2.0
     * @apioption legend.width
     */
    /**
     * The pixel padding between the legend item symbol and the legend
     * item text.
     *
     * @sample {highcharts} highcharts/legend/symbolpadding/
     *         Greater symbol width and padding
     */
    symbolPadding: 5,
    /**
     * The vertical alignment of the legend box. Can be one of `top`,
     * `middle` or `bottom`. Vertical position can be further determined
     * by the `y` option.
     *
     * In the case that the legend is aligned in a corner position, the
     * `layout` option will determine whether to place it above/below
     * or on the side of the plot area.
     *
     * When the [layout](#legend.layout) option is `proximate`, the
     * `verticalAlign` option doesn't apply.
     *
     * @sample {highcharts} highcharts/legend/verticalalign/
     *         Legend 100px from the top of the chart
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/alignment/
     *         Legend alignment
     *
     * @type  {Highcharts.VerticalAlignValue}
     * @since 2.0
     */
    verticalAlign: "bottom",
    // Width: undefined,
    /**
     * The x offset of the legend relative to its horizontal alignment
     * `align` within chart.spacingLeft and chart.spacingRight. Negative
     * x moves it to the left, positive x moves it to the right.
     *
     * @sample {highcharts} highcharts/legend/width/
     *         Aligned to the plot area
     *
     * @since 2.0
     */
    x: 0,
    /**
     * The vertical offset of the legend relative to it's vertical alignment
     * `verticalAlign` within chart.spacingTop and chart.spacingBottom.
     *  Negative y moves it up, positive y moves it down.
     *
     * @sample {highcharts} highcharts/legend/verticalalign/
     *         Legend 100px from the top of the chart
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/alignment/
     *         Legend alignment
     *
     * @since 2.0
     */
    y: 0,
    /**
     * A title to be added on top of the legend.
     *
     * @sample {highcharts} highcharts/legend/title/
     *         Legend title
     * @sample {highmaps} maps/legend/alignment/
     *         Legend with title
     *
     * @since 3.0
     */
    title: {
      /**
       * A text or HTML string for the title.
       *
       * @type      {string}
       * @since     3.0
       * @apioption legend.title.text
       */
      /**
       * Generic CSS styles for the legend title.
       *
       * @see In styled mode, the legend title is styled with the
       *      `.highcharts-legend-title` class.
       *
       * @type    {Highcharts.CSSObject}
       * @default {"fontSize": "0.8em", "fontWeight": "bold"}
       * @since   3.0
       */
      style: {
        /**
         * @ignore
         */
        fontSize: "0.8em",
        /**
         * @ignore
         */
        fontWeight: "bold"
      }
    }
  },
  /**
   * The loading options control the appearance of the loading screen
   * that covers the plot area on chart operations. This screen only
   * appears after an explicit call to `chart.showLoading()`. It is a
   * utility for developers to communicate to the end user that something
   * is going on, for example while retrieving new data via an XHR connection.
   * The "Loading..." text itself is not part of this configuration
   * object, but part of the `lang` object.
   */
  loading: {
    /**
     * The duration in milliseconds of the fade out effect.
     *
     * @sample highcharts/loading/hideduration/
     *         Fade in and out over a second
     *
     * @type      {number}
     * @default   100
     * @since     1.2.0
     * @apioption loading.hideDuration
     */
    /**
     * The duration in milliseconds of the fade in effect.
     *
     * @sample highcharts/loading/hideduration/
     *         Fade in and out over a second
     *
     * @type      {number}
     * @default   100
     * @since     1.2.0
     * @apioption loading.showDuration
     */
    /**
     * CSS styles for the loading label `span`.
     *
     * @see In styled mode, the loading label is styled with the
     *      `.highcharts-loading-inner` class.
     *
     * @sample {highcharts|highmaps} highcharts/loading/labelstyle/
     *         Vertically centered
     * @sample {highstock} stock/loading/general/
     *         Label styles
     *
     * @type    {Highcharts.CSSObject}
     * @default {"fontWeight": "bold", "position": "relative", "top": "45%"}
     * @since   1.2.0
     */
    labelStyle: {
      /**
       * @ignore
       */
      fontWeight: "bold",
      /**
       * @ignore
       */
      position: "relative",
      /**
       * @ignore
       */
      top: "45%"
    },
    /**
     * CSS styles for the loading screen that covers the plot area.
     *
     * In styled mode, the loading label is styled with the
     * `.highcharts-loading` class.
     *
     * @sample  {highcharts|highmaps} highcharts/loading/style/
     *          Gray plot area, white text
     * @sample  {highstock} stock/loading/general/
     *          Gray plot area, white text
     *
     * @type    {Highcharts.CSSObject}
     * @default {"position": "absolute", "backgroundColor": "#ffffff", "opacity": 0.5, "textAlign": "center"}
     * @since   1.2.0
     */
    style: {
      /**
       * @ignore
       */
      position: "absolute",
      /**
       * @ignore
       */
      backgroundColor: "#ffffff",
      /**
       * @ignore
       */
      opacity: 0.5,
      /**
       * @ignore
       */
      textAlign: "center"
    }
  },
  /**
   * Options for the tooltip that appears when the user hovers over a
   * series or point.
   *
   * @declare Highcharts.TooltipOptions
   */
  tooltip: {
    /**
     * The color of the tooltip border. When `undefined`, the border takes
     * the color of the corresponding series or point.
     *
     * Note that the [borderWidth](#tooltip.borderWidth) is usually 0 by
     * default, so the border color may not be visible until a border width
     * is set.
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/ Follow
     *         series by default
     * @sample {highcharts} highcharts/tooltip/bordercolor-black/ Black
     *         border
     * @sample {highstock} stock/tooltip/general/ Styled tooltip
     * @sample {highmaps} maps/tooltip/background-border/ Background and
     *         border demo
     *
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @apioption tooltip.borderColor
     */
    /**
     * A CSS class name to apply to the tooltip's container div,
     * allowing unique CSS styling for each chart.
     *
     * @type      {string}
     * @apioption tooltip.className
     */
    /**
     * Since 4.1, the crosshair definitions are moved to the Axis object
     * in order for a better separation from the tooltip. See
     * [xAxis.crosshair](#xAxis.crosshair).
     *
     * @sample {highcharts} highcharts/tooltip/crosshairs-x/
     *         Enable a crosshair for the x value
     *
     * @deprecated
     *
     * @type      {*}
     * @default   true
     * @apioption tooltip.crosshairs
     */
    /**
     * Distance from point to tooltip in pixels.
     *
     * @type      {number}
     * @default   16
     * @apioption tooltip.distance
     */
    /**
     * Whether the tooltip should be fixed to one position in the chart, or
     * located next to the point or mouse. When the tooltip is fixed, the
     * position can be further specified with the
     * [tooltip.position](#tooltip.position) options set.
     *
     * @sample    highcharts/tooltip/fixed/
     *            Fixed tooltip and position options
     * @sample    {highstock} stock/tooltip/fixed/
     *            Stock chart with fixed tooltip
     * @sample    {highmaps} maps/tooltip/fixed/
     *            Map with fixed tooltip
     *
     * @type      {boolean}
     * @default   false
     * @since 12.2.0
     * @apioption tooltip.fixed
     */
    /**
     * Whether the tooltip should follow the mouse as it moves across
     * columns, pie slices and other point types with an extent.
     * By default it behaves this way for pie, polygon, map, sankey
     * and wordcloud series by override in the `plotOptions`
     * for those series types.
     *
     * Does not apply if [split](#tooltip.split) is `true`.
     *
     * For touch moves to behave the same way, [followTouchMove](
     * #tooltip.followTouchMove) must be `true` also.
     *
     * @sample highcharts/tooltip/followpointer/
     *         Tooltip follow pointer comparison
     *
     * @type      {boolean}
     * @default   {highcharts} false
     * @default   {highstock} false
     * @default   {highmaps} true
     * @since     3.0
     * @apioption tooltip.followPointer
     */
    /**
     * Whether the tooltip should update as the finger moves on a touch
     * device. If this is `true` and [chart.panning](#chart.panning) is
     * set,`followTouchMove` will take over one-finger touches, so the user
     * needs to use two fingers for zooming and panning.
     *
     * Note the difference to [followPointer](#tooltip.followPointer) that
     * only defines the _position_ of the tooltip. If `followPointer` is
     * false in for example a column series, the tooltip will show above or
     * below the column, but as `followTouchMove` is true, the tooltip will
     * jump from column to column as the user swipes across the plot area.
     *
     * @type      {boolean}
     * @default   {highcharts} true
     * @default   {highstock} true
     * @default   {highmaps} false
     * @since     3.0.1
     * @apioption tooltip.followTouchMove
     */
    /**
     * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
     * for the whole shared tooltip. When format strings are a requirement,
     * it is usually more convenient to use `headerFormat`, `pointFormat`
     * and `footerFormat`, but the `format` option allows combining them
     * into one setting.
     *
     * The context of the format string is the same as that of the
     * `tooltip.formatter` callback.
     *
     * @sample {highcharts} highcharts/tooltip/format-shared/
     *         Format for shared tooltip
     *
     * @type      {string}
     * @default   undefined
     * @since     11.1.0
     * @apioption tooltip.format
     */
    /**
     * Callback function to format the text of the tooltip from scratch. In
     * case of single or [shared](#tooltip.shared) tooltips, a string should
     * be returned. In case of [split](#tooltip.split) tooltips, it should
     * return an array where the first item is the header, and subsequent
     * items are mapped to the points. Return `false` to disable tooltip for
     * a specific point on series.
     *
     * A subset of HTML is supported. Unless `useHTML` is true, the HTML of
     * the tooltip is parsed and converted to SVG, therefore this isn't a
     * complete HTML renderer. The following HTML tags are supported: `b`,
     * `br`, `em`, `i`, `span`, `strong`. Spans can be styled with a `style`
     * attribute, but only text-related CSS, that is shared with SVG, is
     * handled.
     *
     * The context of the formatter (since v12) is the
     * [Point](https://api.highcharts.com/class-reference/Highcharts.Point)
     * instance. If the tooltip is shared or split, an array `this.points`
     * contains all points of the hovered x-value.
     *
     * Common properties from the Point to use in the formatter include:
     *
     * - **Point.percentage**:
     *   Stacked series and pies only. The point's percentage of the total.
     *
     * - **Point.points**:
     *   In a shared or split tooltip, this is an array containing all the
     *   hovered points.
     *
     * - **this.series**:
     *   The series object. The series name is available through
     *   `this.series.name`.
     *
     * - **this.total**:
     *   The total value at this point's x value in a stacked series, or the
     *   sum of all slices in a pie series.
     *
     * - **this.x**:
     *   The x value.
     *
     * - **this.y**:
     *   The y value.
     *
     * @sample {highcharts} highcharts/tooltip/formatter-simple/
     *         Simple string formatting
     * @sample {highcharts} highcharts/tooltip/formatter-shared/
     *         Formatting with shared tooltip
     * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
     *         Formatting with split tooltip
     * @sample highcharts/tooltip/formatter-conditional-default/
     *         Extending default formatter
     * @sample {highstock} stock/tooltip/formatter/
     *         Formatting with shared tooltip
     * @sample {highmaps} maps/tooltip/formatter/
     *         String formatting
     *
     * @type      {Highcharts.TooltipFormatterCallbackFunction}
     * @apioption tooltip.formatter
     */
    /**
     * Callback function to format the text of the tooltip for
     * visible null points.
     * Works analogously to [formatter](#tooltip.formatter).
     *
     * @sample highcharts/plotoptions/series-nullformat
     *         Format data label and tooltip for null point.
     *
     * @type      {Highcharts.TooltipFormatterCallbackFunction}
     * @apioption tooltip.nullFormatter
     */
    /**
     * Whether to allow the tooltip to render outside the chart's SVG
     * element box. By default (`false`), the tooltip is rendered within the
     * chart's SVG element, which results in the tooltip being aligned
     * inside the chart area. For small charts, this may result in clipping
     * or overlapping. When `true`, a separate SVG element is created and
     * overlaid on the page, allowing the tooltip to be aligned inside the
     * page itself. Beware that with this option active, CSS classes on the
     * chart's target container, with classnames matching the pattern
     * 'highcharts-*', will be set on the tooltip as well. This is done to
     * support theming for tooltips with this option.
     *
     * Defaults to `true` if `chart.scrollablePlotArea` is activated,
     * otherwise `false`.
     *
     * @sample highcharts/tooltip/outside
     *         Small charts with tooltips outside
     *
     * @type      {boolean|undefined}
     * @default   undefined
     * @since     6.1.1
     * @apioption tooltip.outside
     */
    /**
     * A callback function for formatting the HTML output for a single point
     * in the tooltip. Like the `pointFormat` string, but with more
     * flexibility.
     *
     * @type      {Highcharts.FormatterCallbackFunction<Highcharts.Point>}
     * @since     4.1.0
     * @context   Highcharts.Point
     * @apioption tooltip.pointFormatter
     */
    /**
     * A callback function to place the tooltip in a custom position. The
     * callback receives three parameters: `labelWidth`, `labelHeight` and
     * `point`, where point contains values for `plotX` and `plotY` telling
     * where the reference point is in the plot area. Add `chart.plotLeft`
     * and `chart.plotTop` to get the full coordinates.
     *
     * To find the actual hovered `Point` instance, use
     * `this.chart.hoverPoint`. For shared or split tooltips, all the hover
     * points are available in `this.chart.hoverPoints`.
     *
     * Since v7, when [tooltip.split](#tooltip.split) option is enabled,
     * positioner is called for each of the boxes separately, including
     * xAxis header. xAxis header is not a point, instead `point` argument
     * contains info: `{ plotX: Number, plotY: Number, isHeader: Boolean }`
     *
     * Since v12.2, the [tooltip.fixed](#tooltip.fixed) option combined with
     * [tooltip.position](#tooltip.position) covers most of the use cases
     * for custom tooltip positioning.
     *
     * The return should be an object containing x and y values, for example
     * `{ x: 100, y: 100 }`.
     *
     * @sample {highcharts} highcharts/tooltip/positioner/
     *         A fixed tooltip position
     * @sample {highstock} stock/tooltip/positioner/
     *         A fixed tooltip position on top of the chart
     * @sample {highmaps} maps/tooltip/positioner/
     *         A fixed tooltip position
     * @sample {highstock} stock/tooltip/split-positioner/
     *         Split tooltip with fixed positions
     * @sample {highstock} stock/tooltip/positioner-scrollable-plotarea/
     *         Scrollable plot area combined with tooltip positioner
     *
     * @see [position](#tooltip.position)
     *
     * @type      {Highcharts.TooltipPositionerCallbackFunction}
     * @since     2.2.4
     * @apioption tooltip.positioner
     */
    /**
     * Shows tooltip for all points with the same X value. Splits the
     * tooltip into one label per series, with the header close to the axis.
     * This is recommended over [shared](#tooltip.shared)
     * tooltips for charts with multiple line series, generally making them
     * easier to read. This option takes precedence over `tooltip.shared`.
     *
     * Not supported for [polar](#chart.polar) and [inverted](#chart.inverted) charts.
     *
     * @productdesc {highstock} In Highcharts Stock, tooltips are split
     * by default since v6.0.0. Stock charts typically contain
     * multi-dimension points and multiple panes, making split tooltips
     * the preferred layout over
     * the previous `shared` tooltip.
     *
     * @sample highcharts/tooltip/split/
     *         Split tooltip
     * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
     *         Split tooltip and custom formatter callback
     *
     * @type      {boolean}
     * @default   {highcharts} false
     * @default   {highstock} true
     * @since     5.0.0
     * @product   highcharts highstock
     * @apioption tooltip.split
     */
    /**
     * Prevents the tooltip from switching or closing, when touched or
     * pointed.
     *
     * @sample highcharts/tooltip/stickoncontact/
     *         Tooltip sticks on pointer contact
     *
     * @type      {boolean}
     * @since     8.0.1
     * @apioption tooltip.stickOnContact
     */
    /**
     * Use HTML to render the contents of the tooltip instead of SVG. Using
     * HTML allows advanced formatting like tables and images in the
     * tooltip. It is also recommended for rtl languages as it works around
     * rtl bugs in early Firefox.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
     *         A table for value alignment
     * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
     *         Full HTML tooltip
     * @sample {highmaps} maps/tooltip/usehtml/
     *         Pure HTML tooltip
     *
     * @type      {boolean}
     * @default   false
     * @since     2.2
     * @apioption tooltip.useHTML
     */
    /**
     * How many decimals to show in each series' y value. This is
     * overridable in each series' tooltip options object. The default is to
     * preserve all decimals.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     * @sample {highmaps} maps/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     *
     * @type      {number|undefined}
     * @since     2.2
     * @apioption tooltip.valueDecimals
     */
    /**
     * A string to prepend to each series' y value. Overridable in each
     * series' tooltip options object.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     * @sample {highmaps} maps/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     *
     * @type      {string}
     * @since     2.2
     * @apioption tooltip.valuePrefix
     */
    /**
     * A string to append to each series' y value. Overridable in each
     * series' tooltip options object.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     * @sample {highmaps} maps/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     *
     * @type      {string}
     * @since     2.2
     * @apioption tooltip.valueSuffix
     */
    /**
     * The format for the date in the tooltip header if the X axis is a
     * datetime axis. The default is a best guess based on the smallest
     * distance between points in the chart.
     *
     * @sample {highcharts} highcharts/tooltip/xdateformat/
     *         A different format
     *
     * @type      {string|Highcharts.DateTimeFormatOptions}
     * @product   highcharts highstock gantt
     * @apioption tooltip.xDateFormat
     */
    /**
     * How many decimals to show for the `point.change`
     * or the `point.cumulativeSum` value when the `series.compare`
     * or the `series.cumulative` option is set.
     * This is overridable in each series' tooltip options object.
     *
     * @type      {number}
     * @default   2
     * @since     1.0.1
     * @product   highstock
     * @apioption tooltip.changeDecimals
     */
    /**
     * Enable or disable the tooltip.
     *
     * @sample {highcharts} highcharts/tooltip/enabled/
     *         Disabled
     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
     *         Disable tooltip and show values on chart instead
     */
    enabled: true,
    /**
     * Enable or disable animation of the tooltip.
     *
     * @type       {boolean|Partial<Highcharts.AnimationOptionsObject>}
     * @since      2.3.0
     */
    animation: {
      duration: 300,
      // EaseOutCirc
      easing: (x) => Math.sqrt(1 - Math.pow(x - 1, 2))
    },
    /**
     * The radius of the rounded border corners.
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/
     *         Default border radius
     * @sample {highcharts} highcharts/tooltip/borderradius-0/
     *         Square borders
     * @sample {highmaps} maps/tooltip/background-border/
     *         Background and border demo
     */
    borderRadius: 3,
    /**
     * For series on datetime axes, the date format in the tooltip's
     * header will by default be guessed based on the closest data points.
     * This member gives the default string representations used for
     * each unit. For an overview of the string or object configuration, see
     * [dateFormat](/class-reference/Highcharts.Time#dateFormat).
     *
     * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)
     *
     * @type    {Highcharts.Dictionary<string|Highcharts.DateTimeFormatOptions>}
     * @product highcharts highstock gantt
     */
    dateTimeLabelFormats: {
      /** @internal */
      millisecond: "%[AebHMSL]",
      /** @internal */
      second: "%[AebHMS]",
      /** @internal */
      minute: "%[AebHM]",
      /** @internal */
      hour: "%[AebHM]",
      /** @internal */
      day: "%[AebY]",
      /** @internal */
      week: "%v %[AebY]",
      /** @internal */
      month: "%[BY]",
      /** @internal */
      year: "%Y"
    },
    /**
     * A string to append to the tooltip format.
     *
     * @sample {highcharts} highcharts/tooltip/footerformat/
     *         A table for value alignment
     * @sample {highmaps} maps/tooltip/format/
     *         Format demo
     *
     * @since 2.2
     */
    footerFormat: "",
    /**
     * The name of a symbol to use for the border around the tooltip
     * header. Applies only when [tooltip.split](#tooltip.split) is
     * enabled.
     *
     * Custom callbacks for symbol path generation can also be added to
     * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
     * [series.marker.symbol](plotOptions.line.marker.symbol).
     *
     * @see [tooltip.shape](#tooltip.shape)
     *
     * @sample {highstock} stock/tooltip/split-positioner/
     *         Different shapes for header and split boxes
     *
     * @type       {Highcharts.TooltipShapeValue}
     * @validvalue ["callout", "rect"]
     * @since      7.0
     */
    headerShape: "callout",
    /**
     * The number of milliseconds to wait until the tooltip is hidden when
     * mouse out from a point or chart.
     *
     * @since 3.0
     */
    hideDelay: 500,
    /**
     * Padding inside the tooltip, in pixels.
     *
     * @since 5.0.0
     */
    padding: 8,
    /**
     * Positioning options for fixed tooltip, taking effect only when
     * [tooltip.fixed](#tooltip.fixed) is `true`.
     *
     * @sample {highcharts} highcharts/tooltip/fixed/
     *         Fixed tooltip and position options
     * @sample {highstock} stock/tooltip/fixed/
     *         Stock chart with fixed tooltip
     * @sample {highmaps} maps/tooltip/fixed/
     *         Map with fixed tooltip
     *
     * @since 12.2.0
     */
    position: {
      /**
       * The horizontal alignment of the fixed tooltip.
       *
       * @sample highcharts/tooltip/fixed/
       *         Fixed tooltip
       * @sample {highstock} stock/tooltip/fixed/
       *         Stock chart with fixed tooltip
       *
       * @type {Highcharts.AlignValue}
       * @default left
       * @apioption tooltip.position.align
       */
      /**
       * The vertical alignment of the fixed tooltip.
       *
       * @sample highcharts/tooltip/fixed/
       *         Fixed tooltip
       * @sample {highstock} stock/tooltip/fixed/
       *         Stock chart with fixed tooltip
       *
       * @type {Highcharts.VerticalAlignValue}
       * @default top
       * @apioption tooltip.position.verticalAlign
       */
      /**
       * What the fixed tooltip alignment should be relative to.
       *
       * The default, `pane`, means that it is aligned within the plot
       * area for that given series. If the tooltip is split (as default
       * in Stock charts), each partial tooltip is aligned within the
       * series' pane.
       *
       * @sample highcharts/tooltip/fixed/
       *         Fixed tooltip
       * @sample {highstock} stock/tooltip/fixed/
       *         Stock chart with fixed tooltip
       *
       * @type {string}
       * @default pane
       * @validvalue ["pane", "chart", "plotBox", "spacingBox"]
       * @apioption tooltip.position.relativeTo
       */
      /**
       * X pixel offset from the given position. Can be used to shy away
       * from axis lines, grid lines etc to avoid the tooltip overlapping
       * other elements.
       *
       * @sample highcharts/tooltip/fixed/
       *         Fixed tooltip
       * @sample {highstock} stock/tooltip/fixed/
       *         Stock chart with fixed tooltip
       */
      x: 0,
      /**
       * Y pixel offset from the given position. Can be used to shy away
       * from axis lines, grid lines etc to avoid the tooltip overlapping
       * other elements.
       *
       * @sample highcharts/tooltip/fixed/
       *         Fixed tooltip
       * @sample {highstock} stock/tooltip/fixed/
       *         Stock chart with fixed tooltip
       */
      y: 3
    },
    /**
     * The name of a symbol to use for the border around the tooltip. Can
     * be one of: `"callout"`, `"circle"` or `"rect"`. When
     * [tooltip.split](#tooltip.split)
     * option is enabled, shape is applied to all boxes except header, which
     * is controlled by
     * [tooltip.headerShape](#tooltip.headerShape).
     *
     * Custom callbacks for symbol path generation can also be added to
     * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
     * [series.marker.symbol](plotOptions.line.marker.symbol).
     *
     * Defaults to `callout` for floating tooltip, `rect` for
     * [fixed](#tooltip.fixed) tooltip.
     *
     * @type  {Highcharts.TooltipShapeValue}
     * @since 4.0
     * @default undefined
     * @apioption tooltip.shape
     */
    /**
     * Shows information in the tooltip for all points with the same X
     * value. When the tooltip is shared, the entire plot area will capture
     * mouse movement or touch events. Tooltip texts for series types with
     * ordered data (not pie, scatter, flags etc) will be shown in a single
     * bubble. This is recommended for single series charts and for
     * tablet/mobile optimized charts.
     *
     * See also [tooltip.split](#tooltip.split), that is better suited for
     * charts with many series, especially line-type series. The
     * `tooltip.split` option takes precedence over `tooltip.shared`.
     *
     * @sample {highcharts} highcharts/tooltip/shared-false/
     *         False by default
     * @sample {highcharts} highcharts/tooltip/shared-true/
     *         True
     * @sample {highcharts} highcharts/tooltip/shared-x-crosshair/
     *         True with x axis crosshair
     * @sample {highcharts} highcharts/tooltip/shared-true-mixed-types/
     *         True with mixed series types
     *
     * @since   2.1
     * @product highcharts highstock
     */
    shared: false,
    /**
     * Proximity snap for graphs or single points. It defaults to 10 for
     * mouse-powered devices and 25 for touch devices.
     *
     * Note that in most cases the whole plot area captures the mouse
     * movement, and in these cases `tooltip.snap` doesn't make sense. This
     * applies when [stickyTracking](#plotOptions.series.stickyTracking)
     * is `true` (default) and when the tooltip is [shared](#tooltip.shared)
     * or [split](#tooltip.split).
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/
     *         10 px by default
     * @sample {highcharts} highcharts/tooltip/snap-50/
     *         50 px on graph
     *
     * @type    {number}
     * @default 10/25
     * @since   1.2.0
     * @product highcharts highstock
     */
    snap: isTouchDevice ? 25 : 10,
    /**
     * The HTML of the tooltip header line. The context is the
     * [Point class](https://api.highcharts.com/class-reference/Highcharts.Point).
     * Variables are enclosed in curly brackets. Examples of common
     * variables to include are `x`, `y`, `series.name` and `series.color`
     * and other properties on the same form. The `point.key` variable
     * contains the category name, x value or datetime string depending on
     * the type of axis. For datetime axes, the `point.key` date format can
     * be set using `tooltip.xDateFormat`.
     *
     * @sample {highcharts} highcharts/tooltip/footerformat/
     *         An HTML table in the tooltip
     * @sample {highstock} highcharts/tooltip/footerformat/
     *         An HTML table in the tooltip
     * @sample {highmaps} maps/tooltip/format/
     *         Format demo
     *
     * @type      {string}
     * @apioption tooltip.headerFormat
     */
    headerFormat: '<span style="font-size: 0.8em">{ucfirst point.key}</span><br/>',
    /**
     * The HTML of the null point's line in the tooltip. Works analogously
     * to [pointFormat](#tooltip.pointFormat).
     *
     * @sample {highcharts} highcharts/series/null-interaction
     *         Line chart with null interaction
     * @sample {highcharts} highcharts/plotoptions/series-nullformat
     *         Heatmap with null interaction
     *
     * @type      {string}
     * @apioption tooltip.nullFormat
     */
    /**
     * The HTML of the point's line in the tooltip. The context is the
     * [Point class](https://api.highcharts.com/class-reference/Highcharts.Point).
     * Variables are enclosed in curly brackets. Examples of common
     * variables to include are `x`, `y`, `series.name` and `series.color`
     * and other properties on the same form. Furthermore, `y` can be
     * extended by the `tooltip.valuePrefix` and `tooltip.valueSuffix`
     * variables. This can also be overridden for each series, which makes
     * it a good hook for displaying units.
     *
     * In styled mode, the dot is colored by a class name rather than the
     * point color.
     *
     * @sample {highcharts} highcharts/tooltip/pointformat/
     *         A different point format with value suffix
     * @sample {highcharts|highstock} highcharts/tooltip/pointformat-extra-information/
     *         Show extra information about points in the tooltip
     * @sample {highmaps} maps/tooltip/format/
     *         Format demo
     *
     * @type       {string}
     * @since      2.2
     * @apioption  tooltip.pointFormat
     */
    pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.y}</b><br/>',
    /**
     * The background color or gradient for the tooltip.
     *
     * In styled mode, the stroke width is set in the
     * `.highcharts-tooltip-box` class.
     *
     * @sample {highcharts} highcharts/tooltip/backgroundcolor-solid/
     *         Yellowish background
     * @sample {highcharts} highcharts/tooltip/backgroundcolor-gradient/
     *         Gradient
     * @sample {highcharts} highcharts/css/tooltip-border-background/
     *         Tooltip in styled mode
     * @sample {highstock} stock/tooltip/general/
     *         Custom tooltip
     * @sample {highstock} highcharts/css/tooltip-border-background/
     *         Tooltip in styled mode
     * @sample {highmaps} maps/tooltip/background-border/
     *         Background and border demo
     * @sample {highmaps} highcharts/css/tooltip-border-background/
     *         Tooltip in styled mode
     *
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    backgroundColor: "#ffffff",
    /**
     * The pixel width of the tooltip border. Defaults to 0 for single
     * tooltips and fixed tooltips, otherwise 1 for split tooltips.
     *
     * In styled mode, the stroke width is set in the
     * `.highcharts-tooltip-box` class.
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/
     *         2 pixels
     * @sample {highcharts} highcharts/tooltip/borderwidth/
     *         No border (shadow only)
     * @sample {highcharts} highcharts/css/tooltip-border-background/
     *         Tooltip in styled mode
     * @sample {highstock} stock/tooltip/general/
     *         Custom tooltip
     * @sample {highstock} highcharts/css/tooltip-border-background/
     *         Tooltip in styled mode
     * @sample {highmaps} maps/tooltip/background-border/
     *         Background and border demo
     * @sample {highmaps} highcharts/css/tooltip-border-background/
     *         Tooltip in styled mode
     *
     * @type {number}
     */
    borderWidth: void 0,
    /**
     * Whether to apply a drop shadow to the tooltip. Defaults to true,
     * unless the tooltip is [fixed](#tooltip.fixed).
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/
     *         True by default
     * @sample {highcharts} highcharts/tooltip/shadow/
     *         False
     * @sample {highmaps} maps/tooltip/positioner/
     *         Fixed tooltip position, border and shadow disabled
     *
     * @type {boolean|Highcharts.ShadowOptionsObject}
     * @default undefined
     * @apioption tooltip.shadow
     */
    /**
     * Prevents the tooltip from switching or closing when touched or
     * pointed.
     *
     * @sample highcharts/tooltip/stickoncontact/
     *         Tooltip sticks on pointer contact
     *
     * @since 8.0.1
     */
    stickOnContact: false,
    /**
     * CSS styles for the tooltip. The tooltip can also be styled through
     * the CSS class `.highcharts-tooltip`.
     *
     * Note that the default `pointerEvents` style makes the tooltip ignore
     * mouse events, so in order to use clickable tooltips, this value must
     * be set to `auto`.
     *
     * @sample {highcharts} highcharts/tooltip/style/
     *         Greater padding, bold text
     *
     * @type {Highcharts.CSSObject}
     */
    style: {
      /** @internal */
      color: "#333333",
      /** @internal */
      cursor: "default",
      /**
       * @type {number|string}
       */
      fontSize: "0.8em"
    },
    /**
     * Use HTML to render the contents of the tooltip instead of SVG. Using
     * HTML allows advanced formatting like tables and images in the
     * tooltip. It is also recommended for rtl languages as it works around
     * rtl bugs in early Firefox.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
     *         A table for value alignment
     * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
     *         Full HTML tooltip
     * @sample {highmaps} maps/tooltip/usehtml/
     *         Pure HTML tooltip
     *
     * @since 2.2
     */
    useHTML: false
  },
  /**
   * Highchart by default puts a credits label in the lower right corner
   * of the chart. This can be changed using these options.
   */
  credits: {
    /**
     * Credits for map source to be concatenated with conventional credit
     * text. By default this is a format string that collects copyright
     * information from the map if available.
     *
     * @see [mapTextFull](#credits.mapTextFull)
     * @see [text](#credits.text)
     *
     * @type      {string}
     * @default   \u00a9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>
     * @since     4.2.2
     * @product   highmaps
     * @apioption credits.mapText
     */
    /**
     * Detailed credits for map source to be displayed on hover of credits
     * text. By default this is a format string that collects copyright
     * information from the map if available.
     *
     * @see [mapText](#credits.mapText)
     * @see [text](#credits.text)
     *
     * @type      {string}
     * @default   {geojson.copyright}
     * @since     4.2.2
     * @product   highmaps
     * @apioption credits.mapTextFull
     */
    /**
     * Whether to show the credits text.
     *
     * @sample {highcharts} highcharts/credits/enabled-false/
     *         Credits disabled
     * @sample {highstock} stock/credits/enabled/
     *         Credits disabled
     * @sample {highmaps} maps/credits/enabled-false/
     *         Credits disabled
     */
    enabled: true,
    /**
     * The URL for the credits label.
     *
     * @sample {highcharts} highcharts/credits/href/
     *         Custom URL and text
     * @sample {highmaps} maps/credits/customized/
     *         Custom URL and text
     */
    href: "https://www.highcharts.com?credits",
    /**
     * Position configuration for the credits label.
     *
     * @sample {highcharts} highcharts/credits/position-left/
     *         Left aligned
     * @sample {highcharts} highcharts/credits/position-left/
     *         Left aligned
     * @sample {highmaps} maps/credits/customized/
     *         Left aligned
     * @sample {highmaps} maps/credits/customized/
     *         Left aligned
     *
     * @type    {Highcharts.AlignObject}
     * @since   2.1
     */
    position: {
      /** @internal */
      align: "right",
      /** @internal */
      x: -10,
      /** @internal */
      verticalAlign: "bottom",
      /** @internal */
      y: -5
    },
    /**
     * CSS styles for the credits label.
     *
     * @see In styled mode, credits styles can be set with the
     *      `.highcharts-credits` class.
     *
     * @type {Highcharts.CSSObject}
     */
    style: {
      /** @internal */
      cursor: "pointer",
      /** @internal */
      color: "#999999",
      /**
       * @type {number|string}
       */
      fontSize: "0.6em"
    },
    /**
     * The text for the credits label.
     *
     * @productdesc {highmaps}
     * If a map is loaded as GeoJSON, the text defaults to
     * `Highcharts @ {map-credits}`. Otherwise, it defaults to
     * `Highcharts.com`.
     *
     * @sample {highcharts} highcharts/credits/href/
     *         Custom URL and text
     * @sample {highmaps} maps/credits/customized/
     *         Custom URL and text
     */
    text: "Highcharts.com"
  }
};
var defaultTime = new Time_default(defaultOptions.time, defaultOptions.lang);
function getOptions() {
  return defaultOptions;
}
function setOptions(options2) {
  fireEvent2(Globals_default, "setOptions", { options: options2 });
  merge3(true, defaultOptions, options2);
  if (options2.time) {
    defaultTime.update(defaultOptions.time);
  }
  if (options2.lang && "locale" in options2.lang) {
    defaultTime.update({
      locale: options2.lang.locale
    });
  }
  if (options2.lang?.chartTitle) {
    defaultOptions.title = {
      ...defaultOptions.title,
      text: options2.lang.chartTitle
    };
  }
  return defaultOptions;
}
var DefaultOptions = {
  defaultOptions,
  defaultTime,
  getOptions,
  setOptions
};
var Defaults_default = DefaultOptions;

// node_modules/highcharts/es-modules/Core/Color/Color.js
var { win: win3 } = Globals_default;
var { isNumber: isNumber3, isString: isString3, merge: merge4, pInt: pInt2, defined: defined4 } = Utilities_default;
var colorMix = (color1, color22, weight) => `color-mix(in srgb,${color1},${color22} ${weight * 100}%)`;
var isStringColor = (color14) => isString3(color14) && !!color14 && color14 !== "none";
var Color = class _Color {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * Creates a color instance out of a color string or object.
   *
   * @function Highcharts.Color.parse
   *
   * @param {Highcharts.ColorType} [input]
   * The input color in either rgba or hex format.
   *
   * @return {Highcharts.Color}
   * Color instance.
   */
  static parse(input) {
    return input ? new _Color(input) : _Color.None;
  }
  /* *
   *
   *  Constructor
   *
   * */
  constructor(input) {
    this.rgba = [NaN, NaN, NaN, NaN];
    this.input = input;
    const GlobalColor = Globals_default.Color;
    if (GlobalColor && GlobalColor !== _Color) {
      return new GlobalColor(input);
    }
    let result, rgba, i, parser;
    if (typeof input === "object" && typeof input.stops !== "undefined") {
      this.stops = input.stops.map((stop4) => new _Color(stop4[1]));
    } else if (typeof input === "string") {
      this.input = input = _Color.names[input.toLowerCase()] || input;
      i = _Color.parsers.length;
      while (i-- && !rgba) {
        parser = _Color.parsers[i];
        result = parser.regex.exec(input);
        if (result) {
          rgba = parser.parse(result);
        }
      }
    }
    if (rgba) {
      this.rgba = rgba;
    }
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Return the color or gradient stops in the specified format
   *
   * @function Highcharts.Color#get
   *
   * @param {string} [format]
   * Possible values are 'a', 'rgb', 'rgba' (default).
   *
   * @return {Highcharts.ColorType}
   * This color as a string or gradient stops.
   */
  get(format18) {
    const input = this.input, rgba = this.rgba;
    if (this.output) {
      return this.output;
    }
    if (typeof input === "object" && typeof this.stops !== "undefined") {
      const ret = merge4(input);
      ret.stops = [].slice.call(ret.stops);
      this.stops.forEach((stop4, i) => {
        ret.stops[i] = [
          ret.stops[i][0],
          stop4.get(format18)
        ];
      });
      return ret;
    }
    if (rgba && isNumber3(rgba[0])) {
      if (format18 === "rgb" || !format18 && rgba[3] === 1) {
        return "rgb(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + ")";
      }
      if (format18 === "a") {
        return `${rgba[3]}`;
      }
      return "rgba(" + rgba.join(",") + ")";
    }
    return input;
  }
  /**
   * Brighten the color instance.
   *
   * @function Highcharts.Color#brighten
   *
   * @param {number} alpha
   * The alpha value.
   *
   * @return {Highcharts.Color}
   * This color with modifications.
   */
  brighten(alpha) {
    const rgba = this.rgba;
    if (this.stops) {
      this.stops.forEach(function(stop4) {
        stop4.brighten(alpha);
      });
    } else if (isNumber3(alpha) && alpha !== 0) {
      if (isNumber3(rgba[0])) {
        for (let i = 0; i < 3; i++) {
          rgba[i] += pInt2(alpha * 255);
          if (rgba[i] < 0) {
            rgba[i] = 0;
          }
          if (rgba[i] > 255) {
            rgba[i] = 255;
          }
        }
      } else if (_Color.useColorMix && isStringColor(this.input)) {
        this.output = colorMix(this.input, alpha > 0 ? "white" : "black", Math.abs(alpha));
      }
    }
    return this;
  }
  /**
   * Set the color's opacity to a given alpha value.
   *
   * @function Highcharts.Color#setOpacity
   *
   * @param {number} alpha
   *        Opacity between 0 and 1.
   *
   * @return {Highcharts.Color}
   *         Color with modifications.
   */
  setOpacity(alpha) {
    this.rgba[3] = alpha;
    return this;
  }
  /**
   * Return an intermediate color between two colors.
   *
   * @function Highcharts.Color#tweenTo
   *
   * @param {Highcharts.Color} to
   * The color object to tween to.
   *
   * @param {number} pos
   * The intermediate position, where 0 is the from color (current color
   * item), and 1 is the `to` color.
   *
   * @return {Highcharts.ColorType}
   * The intermediate color in rgba notation, or unsupported type.
   */
  tweenTo(to, pos) {
    const fromRgba = this.rgba, toRgba = to.rgba;
    if (!isNumber3(fromRgba[0]) || !isNumber3(toRgba[0])) {
      if (_Color.useColorMix && isStringColor(this.input) && isStringColor(to.input) && pos < 0.99) {
        return colorMix(this.input, to.input, pos);
      }
      return to.input || "none";
    }
    const hasAlpha = toRgba[3] !== 1 || fromRgba[3] !== 1, channel = (to2, i) => to2 + (fromRgba[i] - to2) * (1 - pos), rgba = toRgba.slice(0, 3).map(channel).map(Math.round);
    if (hasAlpha) {
      rgba.push(channel(toRgba[3], 3));
    }
    return (hasAlpha ? "rgba(" : "rgb(") + rgba.join(",") + ")";
  }
};
Color.names = {
  white: "#ffffff",
  black: "#000000"
};
Color.parsers = [{
  // RGBA color
  // eslint-disable-next-line max-len
  regex: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/,
  parse: function(result) {
    return [
      pInt2(result[1]),
      pInt2(result[2]),
      pInt2(result[3]),
      parseFloat(result[4], 10)
    ];
  }
}, {
  // RGB color
  regex: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/,
  parse: function(result) {
    return [pInt2(result[1]), pInt2(result[2]), pInt2(result[3]), 1];
  }
}, {
  // RGBA 3 & 4 digit hex color, e.g. #F0F, #F0FA
  regex: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i,
  parse: function(result) {
    return [
      pInt2(result[1] + result[1], 16),
      pInt2(result[2] + result[2], 16),
      pInt2(result[3] + result[3], 16),
      !defined4(result[4]) ? 1 : pInt2(result[4] + result[4], 16) / 255
    ];
  }
}, {
  // RGBA 6 & 8 digit hex color, e.g. #FFCC00, #FFCC00FF
  regex: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i,
  parse: function(result) {
    return [
      pInt2(result[1], 16),
      pInt2(result[2], 16),
      pInt2(result[3], 16),
      !defined4(result[4]) ? 1 : pInt2(result[4], 16) / 255
    ];
  }
}];
Color.useColorMix = win3.CSS?.supports("color", "color-mix(in srgb,red,blue 9%)");
Color.None = new Color("");
var Color_default = Color;

// node_modules/highcharts/es-modules/Core/Animation/Fx.js
var { parse: color } = Color_default;
var { win: win4 } = Globals_default;
var { isNumber: isNumber4, objectEach: objectEach3 } = Utilities_default;
var Fx = class _Fx {
  /* *
   *
   *  Constructors
   *
   * */
  constructor(elem, options2, prop) {
    this.pos = NaN;
    this.options = options2;
    this.elem = elem;
    this.prop = prop;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Set the current step of a path definition on SVGElement.
   *
   * @function Highcharts.Fx#dSetter
   *
   */
  dSetter() {
    const paths = this.paths, start = paths?.[0], end = paths?.[1], now = this.now || 0;
    let path = [];
    if (now === 1 || !start || !end) {
      path = this.toD || [];
    } else if (start.length === end.length && now < 1) {
      for (let i = 0; i < end.length; i++) {
        const startSeg = start[i];
        const endSeg = end[i];
        const tweenSeg = [];
        for (let j = 0; j < endSeg.length; j++) {
          const startItem = startSeg[j];
          const endItem = endSeg[j];
          if (isNumber4(startItem) && isNumber4(endItem) && // Arc boolean flags
          !(endSeg[0] === "A" && (j === 4 || j === 5))) {
            tweenSeg[j] = startItem + now * (endItem - startItem);
          } else {
            tweenSeg[j] = endItem;
          }
        }
        path.push(tweenSeg);
      }
    } else {
      path = end;
    }
    this.elem.attr("d", path, void 0, true);
  }
  /**
   * Update the element with the current animation step.
   *
   * @function Highcharts.Fx#update
   *
   */
  update() {
    const elem = this.elem, prop = this.prop, now = this.now, step = this.options.step;
    if (this[prop + "Setter"]) {
      this[prop + "Setter"]();
    } else if (elem.attr) {
      if (elem.element) {
        elem.attr(prop, now, null, true);
      }
    } else {
      elem.style[prop] = now + this.unit;
    }
    if (step) {
      step.call(elem, now, this);
    }
  }
  /**
   * Run an animation.
   *
   * @function Highcharts.Fx#run
   *
   * @param {number} from
   *        The current value, value to start from.
   *
   * @param {number} to
   *        The end value, value to land on.
   *
   * @param {string} unit
   *        The property unit, for example `px`.
   *
   */
  run(from, to, unit) {
    const self = this, options2 = self.options, timer = function(gotoEnd) {
      return timer.stopped ? false : self.step(gotoEnd);
    }, requestAnimationFrame2 = win4.requestAnimationFrame || function(step2) {
      setTimeout(step2, 13);
    }, step = function() {
      for (let i = 0; i < _Fx.timers.length; i++) {
        if (!_Fx.timers[i]()) {
          _Fx.timers.splice(i--, 1);
        }
      }
      if (_Fx.timers.length) {
        requestAnimationFrame2(step);
      }
    };
    if (from === to && !this.elem["forceAnimate:" + this.prop]) {
      delete options2.curAnim[this.prop];
      if (options2.complete && Object.keys(options2.curAnim).length === 0) {
        options2.complete.call(this.elem);
      }
    } else {
      this.startTime = +/* @__PURE__ */ new Date();
      this.start = from;
      this.end = to;
      this.unit = unit;
      this.now = this.start;
      this.pos = 0;
      timer.elem = this.elem;
      timer.prop = this.prop;
      if (timer() && _Fx.timers.push(timer) === 1) {
        requestAnimationFrame2(step);
      }
    }
  }
  /**
   * Run a single step in the animation.
   *
   * @function Highcharts.Fx#step
   *
   * @param {boolean} [gotoEnd]
   *        Whether to go to the endpoint of the animation after abort.
   *
   * @return {boolean}
   *         Returns `true` if animation continues.
   */
  step(gotoEnd) {
    const t = +/* @__PURE__ */ new Date(), options2 = this.options, elem = this.elem, complete = options2.complete, duration = options2.duration, curAnim = options2.curAnim;
    let ret, done;
    if (!!elem.attr && !elem.element) {
      ret = false;
    } else if (gotoEnd || t >= duration + this.startTime) {
      this.now = this.end;
      this.pos = 1;
      this.update();
      curAnim[this.prop] = true;
      done = true;
      objectEach3(curAnim, function(val) {
        if (val !== true) {
          done = false;
        }
      });
      if (done && complete) {
        complete.call(elem);
      }
      ret = false;
    } else {
      this.pos = options2.easing((t - this.startTime) / duration);
      this.now = this.start + (this.end - this.start) * this.pos;
      this.update();
      ret = true;
    }
    return ret;
  }
  /**
   * Prepare start and end values so that the path can be animated one to one.
   *
   * @function Highcharts.Fx#initPath
   *
   * @param {Highcharts.SVGElement} elem
   *        The SVGElement item.
   *
   * @param {Highcharts.SVGPathArray|undefined} fromD
   *        Starting path definition.
   *
   * @param {Highcharts.SVGPathArray} toD
   *        Ending path definition.
   *
   * @return {Array<Highcharts.SVGPathArray,Highcharts.SVGPathArray>}
   *         An array containing start and end paths in array form so that
   *         they can be animated in parallel.
   */
  initPath(elem, fromD, toD) {
    const startX = elem.startX, endX = elem.endX, end = toD.slice(), isArea = elem.isArea, positionFactor = isArea ? 2 : 1, disableAnimation = fromD && toD.length > fromD.length && toD.hasStackedCliffs;
    let shift, fullLength, i, reverse, start = fromD?.slice();
    if (!start || disableAnimation) {
      return [end, end];
    }
    function prepend(arr, other) {
      while (arr.length < fullLength) {
        const moveSegment = arr[0], otherSegment = other[fullLength - arr.length];
        if (otherSegment && moveSegment[0] === "M") {
          if (otherSegment[0] === "C") {
            arr[0] = [
              "C",
              moveSegment[1],
              moveSegment[2],
              moveSegment[1],
              moveSegment[2],
              moveSegment[1],
              moveSegment[2]
            ];
          } else {
            arr[0] = ["L", moveSegment[1], moveSegment[2]];
          }
        }
        arr.unshift(moveSegment);
        if (isArea) {
          const z = arr.pop();
          arr.push(arr[arr.length - 1], z);
        }
      }
    }
    function append(arr) {
      while (arr.length < fullLength) {
        const segmentToAdd = arr[Math.floor(arr.length / positionFactor) - 1].slice();
        if (segmentToAdd[0] === "C") {
          segmentToAdd[1] = segmentToAdd[5];
          segmentToAdd[2] = segmentToAdd[6];
        }
        if (!isArea) {
          arr.push(segmentToAdd);
        } else {
          const lowerSegmentToAdd = arr[Math.floor(arr.length / positionFactor)].slice();
          arr.splice(arr.length / 2, 0, segmentToAdd, lowerSegmentToAdd);
        }
      }
    }
    if (startX && endX && endX.length) {
      for (i = 0; i < startX.length; i++) {
        if (startX[i] === endX[0]) {
          shift = i;
          break;
        } else if (startX[0] === endX[endX.length - startX.length + i]) {
          shift = i;
          reverse = true;
          break;
        } else if (startX[startX.length - 1] === endX[endX.length - startX.length + i]) {
          shift = startX.length - i;
          break;
        }
      }
      if (typeof shift === "undefined") {
        start = [];
      }
    }
    if (start.length && isNumber4(shift)) {
      fullLength = end.length + shift * positionFactor;
      if (!reverse) {
        prepend(end, start);
        append(start);
      } else {
        prepend(start, end);
        append(end);
      }
    }
    return [start, end];
  }
  /**
   * Handle animation of the color attributes directly.
   *
   * @function Highcharts.Fx#fillSetter
   *
   */
  fillSetter() {
    _Fx.prototype.strokeSetter.apply(this, arguments);
  }
  /**
   * Handle animation of the color attributes directly.
   *
   * @function Highcharts.Fx#strokeSetter
   *
   */
  strokeSetter() {
    this.elem.attr(this.prop, color(this.start).tweenTo(color(this.end), this.pos), void 0, true);
  }
};
Fx.timers = [];
var Fx_default = Fx;

// node_modules/highcharts/es-modules/Core/Animation/AnimationUtilities.js
var { defined: defined5, getStyle: getStyle2, isArray: isArray2, isNumber: isNumber5, isObject: isObject3, merge: merge5, objectEach: objectEach4, pick: pick2 } = Utilities_default;
function setAnimation(animation, chart) {
  chart.renderer.globalAnimation = pick2(animation, chart.options.chart.animation, true);
}
function animObject(animation) {
  return isObject3(animation) ? merge5({ duration: 500, defer: 0 }, animation) : { duration: animation ? 500 : 0, defer: 0 };
}
function getDeferredAnimation(chart, animation, series) {
  const labelAnimation = animObject(animation), s = series ? [series] : chart.series;
  let defer = 0, duration = 0;
  s.forEach((series2) => {
    const seriesAnim = animObject(series2.options.animation);
    defer = isObject3(animation) && defined5(animation.defer) ? labelAnimation.defer : Math.max(defer, seriesAnim.duration + seriesAnim.defer);
    duration = Math.min(labelAnimation.duration, seriesAnim.duration);
  });
  if (chart.renderer.forExport) {
    defer = 0;
  }
  const anim = {
    defer: Math.max(0, defer - duration),
    duration: Math.min(defer, duration)
  };
  return anim;
}
function animate(el, params, opt) {
  let start, unit = "", end, fx, args;
  if (!isObject3(opt)) {
    args = arguments;
    opt = {
      duration: args[2],
      easing: args[3],
      complete: args[4]
    };
  }
  if (!isNumber5(opt.duration)) {
    opt.duration = 400;
  }
  opt.easing = typeof opt.easing === "function" ? opt.easing : Math[opt.easing] || Math.easeInOutSine;
  opt.curAnim = merge5(params);
  objectEach4(params, function(val, prop) {
    stop(el, prop);
    fx = new Fx_default(el, opt, prop);
    end = void 0;
    if (prop === "d" && isArray2(params.d)) {
      fx.paths = fx.initPath(el, el.pathArray, params.d);
      fx.toD = params.d;
      start = 0;
      end = 1;
    } else if (el.attr) {
      start = el.attr(prop);
    } else {
      start = parseFloat(getStyle2(el, prop)) || 0;
      if (prop !== "opacity") {
        unit = "px";
      }
    }
    if (!end) {
      end = val;
    }
    if (typeof end === "string" && end.match("px")) {
      end = end.replace(/px/g, "");
    }
    fx.run(start, end, unit);
  });
}
function stop(el, prop) {
  let i = Fx_default.timers.length;
  while (i--) {
    if (Fx_default.timers[i].elem === el && (!prop || prop === Fx_default.timers[i].prop)) {
      Fx_default.timers[i].stopped = true;
    }
  }
}
var animationExports = {
  animate,
  animObject,
  getDeferredAnimation,
  setAnimation,
  stop
};
var AnimationUtilities_default = animationExports;

// node_modules/highcharts/es-modules/Core/Renderer/HTML/AST.js
var { SVG_NS, win: win5 } = Globals_default;
var { attr: attr3, createElement: createElement2, css: css3, error: error3, isFunction: isFunction2, isString: isString4, objectEach: objectEach5, splat: splat3 } = Utilities_default;
var { trustedTypes } = win5;
var trustedTypesPolicy = trustedTypes && isFunction2(trustedTypes.createPolicy) && trustedTypes.createPolicy("highcharts", {
  createHTML: (s) => s
});
var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
var AST = class _AST {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * Filter an object of SVG or HTML attributes against the allow list.
   *
   * @static
   *
   * @function Highcharts.AST#filterUserAttributes
   *
   * @param {Highcharts.SVGAttributes} attributes The attributes to filter
   *
   * @return {Highcharts.SVGAttributes}
   * The filtered attributes
   */
  static filterUserAttributes(attributes) {
    objectEach5(attributes, (val, key) => {
      let valid = true;
      if (_AST.allowedAttributes.indexOf(key) === -1) {
        valid = false;
      }
      if (["background", "dynsrc", "href", "lowsrc", "src"].indexOf(key) !== -1) {
        valid = isString4(val) && _AST.allowedReferences.some((ref) => val.indexOf(ref) === 0);
      }
      if (!valid) {
        error3(33, false, void 0, {
          "Invalid attribute in config": `${key}`
        });
        delete attributes[key];
      }
      if (isString4(val) && attributes[key]) {
        attributes[key] = val.replace(/</g, "&lt;");
      }
    });
    return attributes;
  }
  static parseStyle(style) {
    return style.split(";").reduce((styles, line2) => {
      const pair = line2.split(":").map((s) => s.trim()), key = pair.shift();
      if (key && pair.length) {
        styles[key.replace(/-([a-z])/g, (g) => g[1].toUpperCase())] = pair.join(":");
      }
      return styles;
    }, {});
  }
  /**
   * Utility function to set html content for an element by passing in a
   * markup string. The markup is safely parsed by the AST class to avoid
   * XSS vulnerabilities. This function should be used instead of setting
   * `innerHTML` in all cases where the content is not fully trusted.
   *
   * @static
   * @function Highcharts.AST#setElementHTML
   *
   * @param {SVGDOMElement|HTMLDOMElement} el
   * Node to set content of.
   *
   * @param {string} html
   * Markup string
   */
  static setElementHTML(el, html2) {
    el.innerHTML = _AST.emptyHTML;
    if (html2) {
      const ast = new _AST(html2);
      ast.addToDOM(el);
    }
  }
  /* *
   *
   *  Constructor
   *
   * */
  // Construct an AST from HTML markup, or wrap an array of existing AST nodes
  constructor(source) {
    this.nodes = typeof source === "string" ? this.parseMarkup(source) : source;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Add the tree defined as a hierarchical JS structure to the DOM
   *
   * @function Highcharts.AST#addToDOM
   *
   * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} parent
   * The node where it should be added
   *
   * @return {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement}
   * The inserted node.
   */
  addToDOM(parent) {
    function recurse(subtree, subParent) {
      let ret;
      splat3(subtree).forEach(function(item) {
        const tagName = item.tagName;
        const textNode = item.textContent ? Globals_default.doc.createTextNode(item.textContent) : void 0;
        const bypassHTMLFiltering = _AST.bypassHTMLFiltering;
        let node;
        if (tagName) {
          if (tagName === "#text") {
            node = textNode;
          } else if (_AST.allowedTags.indexOf(tagName) !== -1 || bypassHTMLFiltering) {
            const NS = tagName === "svg" ? SVG_NS : subParent.namespaceURI || SVG_NS;
            const element = Globals_default.doc.createElementNS(NS, tagName);
            const attributes = item.attributes || {};
            objectEach5(item, function(val, key) {
              if (key !== "tagName" && key !== "attributes" && key !== "children" && key !== "style" && key !== "textContent") {
                attributes[key] = val;
              }
            });
            attr3(element, bypassHTMLFiltering ? attributes : _AST.filterUserAttributes(attributes));
            if (item.style) {
              css3(element, item.style);
            }
            if (textNode) {
              element.appendChild(textNode);
            }
            recurse(item.children || [], element);
            node = element;
          } else {
            error3(33, false, void 0, {
              "Invalid tagName in config": tagName
            });
          }
        }
        if (node) {
          subParent.appendChild(node);
        }
        ret = node;
      });
      return ret;
    }
    return recurse(this.nodes, parent);
  }
  /**
   * Parse HTML/SVG markup into AST Node objects. Used internally from the
   * constructor.
   *
   * @private
   *
   * @function Highcharts.AST#getNodesFromMarkup
   *
   * @param {string} markup The markup string.
   *
   * @return {Array<Highcharts.ASTNode>} The parsed nodes.
   */
  parseMarkup(markup) {
    const nodes = [];
    markup = markup.trim().replace(/ style=(["'])/g, " data-style=$1");
    let doc30;
    try {
      doc30 = new DOMParser().parseFromString(trustedTypesPolicy ? trustedTypesPolicy.createHTML(markup) : markup, "text/html");
    } catch (e) {
    }
    if (!doc30) {
      const body = createElement2("div");
      body.innerHTML = markup;
      doc30 = { body };
    }
    const appendChildNodes = (node, addTo) => {
      const tagName = node.nodeName.toLowerCase();
      const astNode = {
        tagName
      };
      if (tagName === "#text") {
        astNode.textContent = node.textContent || "";
      }
      const parsedAttributes = node.attributes;
      if (parsedAttributes) {
        const attributes = {};
        [].forEach.call(parsedAttributes, (attrib) => {
          if (attrib.name === "data-style") {
            astNode.style = _AST.parseStyle(attrib.value);
          } else {
            attributes[attrib.name] = attrib.value;
          }
        });
        astNode.attributes = attributes;
      }
      if (node.childNodes.length) {
        const children = [];
        [].forEach.call(node.childNodes, (childNode) => {
          appendChildNodes(childNode, children);
        });
        if (children.length) {
          astNode.children = children;
        }
      }
      addTo.push(astNode);
    };
    [].forEach.call(doc30.body.childNodes, (childNode) => appendChildNodes(childNode, nodes));
    return nodes;
  }
};
AST.allowedAttributes = [
  "alt",
  "aria-controls",
  "aria-describedby",
  "aria-expanded",
  "aria-haspopup",
  "aria-hidden",
  "aria-label",
  "aria-labelledby",
  "aria-live",
  "aria-pressed",
  "aria-readonly",
  "aria-roledescription",
  "aria-selected",
  "class",
  "clip-path",
  "color",
  "colspan",
  "cx",
  "cy",
  "d",
  "dx",
  "dy",
  "disabled",
  "fill",
  "filterUnits",
  "flood-color",
  "flood-opacity",
  "height",
  "href",
  "id",
  "in",
  "in2",
  "markerHeight",
  "markerWidth",
  "offset",
  "opacity",
  "operator",
  "orient",
  "padding",
  "paddingLeft",
  "paddingRight",
  "patternUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "role",
  "scope",
  "slope",
  "src",
  "startOffset",
  "stdDeviation",
  "stroke",
  "stroke-linecap",
  "stroke-width",
  "style",
  "tableValues",
  "result",
  "rowspan",
  "summary",
  "target",
  "tabindex",
  "text-align",
  "text-anchor",
  "textAnchor",
  "textLength",
  "title",
  "type",
  "valign",
  "width",
  "x",
  "x1",
  "x2",
  "xlink:href",
  "y",
  "y1",
  "y2",
  "zIndex"
];
AST.allowedReferences = [
  "https://",
  "http://",
  "mailto:",
  "/",
  "../",
  "./",
  "#"
];
AST.allowedTags = [
  "a",
  "abbr",
  "b",
  "br",
  "button",
  "caption",
  "circle",
  "clipPath",
  "code",
  "dd",
  "defs",
  "div",
  "dl",
  "dt",
  "em",
  "feComponentTransfer",
  "feComposite",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feMorphology",
  "feOffset",
  "feMerge",
  "feMergeNode",
  "filter",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "i",
  "img",
  "li",
  "linearGradient",
  "marker",
  "ol",
  "p",
  "path",
  "pattern",
  "pre",
  "rect",
  "small",
  "span",
  "stop",
  "strong",
  "style",
  "sub",
  "sup",
  "svg",
  "table",
  "text",
  "textPath",
  "thead",
  "title",
  "tbody",
  "tspan",
  "td",
  "th",
  "tr",
  "u",
  "ul",
  "#text"
];
AST.emptyHTML = emptyHTML;
AST.bypassHTMLFiltering = false;
var AST_default = AST;

// node_modules/highcharts/es-modules/Core/Templating.js
var { defaultOptions: defaultOptions2, defaultTime: defaultTime2 } = Defaults_default;
var { pageLang: pageLang2 } = Globals_default;
var { extend: extend4, getNestedProperty: getNestedProperty2, isArray: isArray3, isNumber: isNumber6, isObject: isObject4, isString: isString5, pick: pick3, ucfirst: ucfirst3 } = Utilities_default;
var helpers = {
  // Built-in helpers
  add: (a, b) => a + b,
  divide: (a, b) => b !== 0 ? a / b : "",
  // eslint-disable-next-line eqeqeq
  eq: (a, b) => a == b,
  each: function(arr) {
    const match = arguments[arguments.length - 1];
    return isArray3(arr) ? arr.map((item, i) => format(match.body, extend4(isObject4(item) ? item : { "@this": item }, {
      "@index": i,
      "@first": i === 0,
      "@last": i === arr.length - 1
    }))).join("") : false;
  },
  ge: (a, b) => a >= b,
  gt: (a, b) => a > b,
  "if": (condition) => !!condition,
  le: (a, b) => a <= b,
  lt: (a, b) => a < b,
  multiply: (a, b) => a * b,
  // eslint-disable-next-line eqeqeq
  ne: (a, b) => a != b,
  subtract: (a, b) => a - b,
  ucfirst: ucfirst3,
  unless: (condition) => !condition
};
var numberFormatCache = {};
var isQuotedString = (str) => /^["'].+["']$/.test(str);
function dateFormat(format18, timestamp, upperCaseFirst) {
  return defaultTime2.dateFormat(format18, timestamp, upperCaseFirst);
}
function format(str = "", ctx, owner) {
  const regex = /\{([a-zA-Z\u00C0-\u017F\d:\.,;\-\/<>\[\]%_@+"'= #\(\)]+)\}/g, subRegex = /\(([a-zA-Z\u00C0-\u017F\d:\.,;\-\/<>\[\]%_@+"'= ]+)\)/g, matches = [], floatRegex = /f$/, decRegex = /\.(\d)/, lang6 = owner?.options?.lang || defaultOptions2.lang, time = owner?.time || defaultTime2, numberFormatter = owner?.numberFormatter || numberFormat;
  const resolveProperty = (key = "") => {
    let n;
    if (key === "true") {
      return true;
    }
    if (key === "false") {
      return false;
    }
    if ((n = Number(key)).toString() === key) {
      return n;
    }
    if (isQuotedString(key)) {
      return key.slice(1, -1);
    }
    return getNestedProperty2(key, ctx);
  };
  let match, currentMatch, depth = 0, hasSub;
  while ((match = regex.exec(str)) !== null) {
    const mainMatch = match, subMatch = subRegex.exec(match[1]);
    if (subMatch) {
      match = subMatch;
      hasSub = true;
    }
    if (!currentMatch?.isBlock) {
      currentMatch = {
        ctx,
        expression: match[1],
        find: match[0],
        isBlock: match[1].charAt(0) === "#",
        start: match.index,
        startInner: match.index + match[0].length,
        length: match[0].length
      };
    }
    const fn = (currentMatch.isBlock ? mainMatch : match)[1].split(" ")[0].replace("#", "");
    if (helpers[fn]) {
      if (currentMatch.isBlock && fn === currentMatch.fn) {
        depth++;
      }
      if (!currentMatch.fn) {
        currentMatch.fn = fn;
      }
    }
    const startingElseSection = match[1] === "else";
    if (currentMatch.isBlock && currentMatch.fn && (match[1] === `/${currentMatch.fn}` || startingElseSection)) {
      if (!depth) {
        const start = currentMatch.startInner, body = str.substr(start, match.index - start);
        if (currentMatch.body === void 0) {
          currentMatch.body = body;
          currentMatch.startInner = match.index + match[0].length;
        } else {
          currentMatch.elseBody = body;
        }
        currentMatch.find += body + match[0];
        if (!startingElseSection) {
          matches.push(currentMatch);
          currentMatch = void 0;
        }
      } else if (!startingElseSection) {
        depth--;
      }
    } else if (!currentMatch.isBlock) {
      matches.push(currentMatch);
    }
    if (subMatch && !currentMatch?.isBlock) {
      break;
    }
  }
  matches.forEach((match2) => {
    const { body, elseBody, expression, fn } = match2;
    let replacement, i;
    if (fn) {
      const args = [match2], parts = [], len = expression.length;
      let start = 0, startChar;
      for (i = 0; i <= len; i++) {
        const char = expression.charAt(i);
        if (!startChar && (char === '"' || char === "'")) {
          startChar = char;
        } else if (startChar === char) {
          startChar = "";
        }
        if (!startChar && (char === " " || i === len)) {
          parts.push(expression.substr(start, i - start));
          start = i + 1;
        }
      }
      i = helpers[fn].length;
      while (i--) {
        args.unshift(resolveProperty(parts[i + 1]));
      }
      replacement = helpers[fn].apply(ctx, args);
      if (match2.isBlock && typeof replacement === "boolean") {
        replacement = format(replacement ? body : elseBody, ctx, owner);
      }
    } else {
      const valueAndFormat = isQuotedString(expression) ? [expression] : expression.split(":");
      replacement = resolveProperty(valueAndFormat.shift() || "");
      if (valueAndFormat.length && typeof replacement === "number") {
        const segment = valueAndFormat.join(":");
        if (floatRegex.test(segment)) {
          const decimals = parseInt((segment.match(decRegex) || ["", "-1"])[1], 10);
          if (replacement !== null) {
            replacement = numberFormatter(replacement, decimals, lang6.decimalPoint, segment.indexOf(",") > -1 ? lang6.thousandsSep : "");
          }
        } else {
          replacement = time.dateFormat(segment, replacement);
        }
      }
      subRegex.lastIndex = 0;
      if (subRegex.test(match2.find) && isString5(replacement)) {
        replacement = `"${replacement}"`;
      }
    }
    str = str.replace(match2.find, pick3(replacement, ""));
  });
  return hasSub ? format(str, ctx, owner) : str;
}
function numberFormat(number, decimals, decimalPoint, thousandsSep) {
  number = +number || 0;
  decimals = +decimals;
  let ret, fractionDigits, [mantissa, exp] = number.toString().split("e").map(Number);
  const lang6 = this?.options?.lang || defaultOptions2.lang, origDec = (number.toString().split(".")[1] || "").split("e")[0].length, firstDecimals = decimals, options2 = {};
  decimalPoint ?? (decimalPoint = lang6.decimalPoint);
  thousandsSep ?? (thousandsSep = lang6.thousandsSep);
  if (decimals === -1) {
    decimals = Math.min(origDec, 20);
  } else if (!isNumber6(decimals)) {
    decimals = 2;
  } else if (decimals && exp < 0) {
    fractionDigits = decimals + exp;
    if (fractionDigits >= 0) {
      mantissa = +mantissa.toExponential(fractionDigits).split("e")[0];
      decimals = fractionDigits;
    } else {
      mantissa = Math.floor(mantissa);
      if (decimals < 20) {
        number = +(mantissa * Math.pow(10, exp)).toFixed(decimals);
      } else {
        number = 0;
      }
      exp = 0;
    }
  }
  if (exp) {
    decimals ?? (decimals = 2);
    number = mantissa;
  }
  if (isNumber6(decimals) && decimals >= 0) {
    options2.minimumFractionDigits = decimals;
    options2.maximumFractionDigits = decimals;
  }
  if (thousandsSep === "") {
    options2.useGrouping = false;
  }
  const hasSeparators = thousandsSep || decimalPoint, locale = hasSeparators ? "en" : this?.locale || lang6.locale || pageLang2, cacheKey = JSON.stringify(options2) + locale, nf = numberFormatCache[cacheKey] ?? (numberFormatCache[cacheKey] = new Intl.NumberFormat(locale, options2));
  ret = nf.format(number);
  if (hasSeparators) {
    ret = ret.replace(/([,\.])/g, "_$1").replace(/_\,/g, thousandsSep ?? ",").replace("_.", decimalPoint ?? ".");
  }
  if (
    // Remove signed zero (#20564)
    !decimals && +ret === 0 || // Small numbers, no decimals (#14023)
    exp < 0 && !firstDecimals
  ) {
    ret = "0";
  }
  if (exp && +ret !== 0) {
    ret += "e" + (exp < 0 ? "" : "+") + exp;
  }
  return ret;
}
var Templating = {
  dateFormat,
  format,
  helpers,
  numberFormat
};
var Templating_default = Templating;

// node_modules/highcharts/es-modules/Core/Renderer/RendererRegistry.js
var RendererRegistry;
(function(RendererRegistry2) {
  RendererRegistry2.rendererTypes = {};
  let defaultRenderer;
  function getRendererType2(rendererType = defaultRenderer) {
    return RendererRegistry2.rendererTypes[rendererType] || RendererRegistry2.rendererTypes[defaultRenderer];
  }
  RendererRegistry2.getRendererType = getRendererType2;
  function registerRendererType(rendererType, rendererClass, setAsDefault) {
    RendererRegistry2.rendererTypes[rendererType] = rendererClass;
    if (!defaultRenderer || setAsDefault) {
      defaultRenderer = rendererType;
      Globals_default.Renderer = rendererClass;
    }
  }
  RendererRegistry2.registerRendererType = registerRendererType;
})(RendererRegistry || (RendererRegistry = {}));
var RendererRegistry_default = RendererRegistry;

// node_modules/highcharts/es-modules/Core/Renderer/RendererUtilities.js
var { clamp: clamp2, pick: pick4, pushUnique: pushUnique2, stableSort: stableSort2 } = Utilities_default;
var RendererUtilities;
(function(RendererUtilities2) {
  function distribute5(boxes, len, maxDistance) {
    const origBoxes = boxes, reducedLen = origBoxes.reducedLen || len, sortByRank = (a, b) => (b.rank || 0) - (a.rank || 0), sortByTarget = (a, b) => a.target - b.target, restBoxes = [], boxesLength = boxes.length, forDeletion = [], push = restBoxes.push;
    let i, cursor, step, overlapping = true, box, target, total = 0, equalRank;
    i = boxesLength;
    while (i--) {
      total += boxes[i].size;
    }
    if (total > reducedLen) {
      stableSort2(boxes, sortByRank);
      equalRank = boxes[0].rank === boxes[boxes.length - 1].rank;
      step = equalRank ? boxesLength / 2 : -1;
      cursor = equalRank ? step : boxesLength - 1;
      while (step && total > reducedLen) {
        i = Math.floor(cursor);
        box = boxes[i];
        if (pushUnique2(forDeletion, i)) {
          total -= box.size;
        }
        cursor += step;
        if (equalRank && cursor >= boxes.length) {
          step /= 2;
          cursor = step;
        }
      }
      forDeletion.sort((a, b) => b - a).forEach((i2) => push.apply(restBoxes, boxes.splice(i2, 1)));
    }
    stableSort2(boxes, sortByTarget);
    boxes = boxes.map((box2) => ({
      size: box2.size,
      targets: [box2.target],
      align: pick4(box2.align, 0.5)
    }));
    while (overlapping) {
      i = boxes.length;
      while (i--) {
        box = boxes[i];
        target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;
        box.pos = clamp2(target - box.size * box.align, 0, len - box.size);
      }
      i = boxes.length;
      overlapping = false;
      while (i--) {
        if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {
          boxes[i - 1].size += boxes[i].size;
          boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);
          boxes[i - 1].align = 0.5;
          if (boxes[i - 1].pos + boxes[i - 1].size > len) {
            boxes[i - 1].pos = len - boxes[i - 1].size;
          }
          boxes.splice(i, 1);
          overlapping = true;
        }
      }
    }
    push.apply(origBoxes, restBoxes);
    i = 0;
    boxes.some((box2) => {
      let posInCompositeBox = 0;
      return (box2.targets || []).some(() => {
        origBoxes[i].pos = box2.pos + posInCompositeBox;
        if (typeof maxDistance !== "undefined" && Math.abs(origBoxes[i].pos - origBoxes[i].target) > maxDistance) {
          origBoxes.slice(0, i + 1).forEach((box3) => delete box3.pos);
          origBoxes.reducedLen = (origBoxes.reducedLen || len) - len * 0.1;
          if (origBoxes.reducedLen > len * 0.1) {
            distribute5(origBoxes, len, maxDistance);
          }
          return true;
        }
        posInCompositeBox += origBoxes[i].size;
        i++;
        return false;
      });
    });
    stableSort2(origBoxes, sortByTarget);
    return origBoxes;
  }
  RendererUtilities2.distribute = distribute5;
})(RendererUtilities || (RendererUtilities = {}));
var RendererUtilities_default = RendererUtilities;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGElement.js
var { animate: animate2, animObject: animObject2, stop: stop2 } = AnimationUtilities_default;
var { deg2rad, doc: doc2, svg, SVG_NS: SVG_NS2, win: win6, isFirefox } = Globals_default;
var { addEvent: addEvent2, attr: attr4, createElement: createElement3, crisp: crisp2, css: css4, defined: defined6, erase: erase2, extend: extend5, fireEvent: fireEvent3, getAlignFactor: getAlignFactor2, isArray: isArray4, isFunction: isFunction3, isNumber: isNumber7, isObject: isObject5, isString: isString6, merge: merge6, objectEach: objectEach6, pick: pick5, pInt: pInt3, pushUnique: pushUnique3, replaceNested: replaceNested2, syncTimeout: syncTimeout2, uniqueKey: uniqueKey2 } = Utilities_default;
var SVGElement = class _SVGElement {
  // @todo public zIndex?: number;
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Get the current value of an attribute or pseudo attribute,
   * used mainly for animation. Called internally from
   * the {@link Highcharts.SVGRenderer#attr} function.
   *
   * @private
   * @function Highcharts.SVGElement#_defaultGetter
   *
   * @param {string} key
   *        Property key.
   *
   * @return {number|string}
   *         Property value.
   */
  _defaultGetter(key) {
    let ret = pick5(
      this[key + "Value"],
      // Align getter
      this[key],
      this.element ? this.element.getAttribute(key) : null,
      0
    );
    if (/^-?[\d\.]+$/.test(ret)) {
      ret = parseFloat(ret);
    }
    return ret;
  }
  /**
   * @private
   * @function Highcharts.SVGElement#_defaultSetter
   *
   * @param {string} value
   *
   * @param {string} key
   *
   * @param {Highcharts.SVGDOMElement} element
   *
   */
  _defaultSetter(value, key, element) {
    element.setAttribute(key, value);
  }
  /**
   * Add the element to the DOM. All elements must be added this way.
   *
   * @sample highcharts/members/renderer-g
   *         Elements added to a group
   *
   * @function Highcharts.SVGElement#add
   *
   * @param {Highcharts.SVGElement} [parent]
   *        The parent item to add it to. If undefined, the element is added
   *        to the {@link Highcharts.SVGRenderer.box}.
   *
   * @return {Highcharts.SVGElement}
   *         Returns the SVGElement for chaining.
   */
  add(parent) {
    const renderer = this.renderer, element = this.element;
    let inserted;
    if (parent) {
      this.parentGroup = parent;
    }
    if (typeof this.textStr !== "undefined" && this.element.nodeName === "text") {
      renderer.buildText(this);
    }
    this.added = true;
    if (!parent || parent.handleZ || this.zIndex) {
      inserted = this.zIndexSetter();
    }
    if (!inserted) {
      (parent ? parent.element : renderer.box).appendChild(element);
    }
    if (this.onAdd) {
      this.onAdd();
    }
    return this;
  }
  /**
   * Add a class name to an element.
   *
   * @function Highcharts.SVGElement#addClass
   *
   * @param {string} className
   * The new class name to add.
   *
   * @param {boolean} [replace=false]
   * When true, the existing class name(s) will be overwritten with the new
   * one. When false, the new one is added.
   *
   * @return {Highcharts.SVGElement}
   * Return the SVG element for chainability.
   */
  addClass(className, replace) {
    const currentClassName = replace ? "" : this.attr("class") || "";
    className = (className || "").split(/ /g).reduce(function(newClassName, name) {
      if (currentClassName.indexOf(name) === -1) {
        newClassName.push(name);
      }
      return newClassName;
    }, currentClassName ? [currentClassName] : []).join(" ");
    if (className !== currentClassName) {
      this.attr("class", className);
    }
    return this;
  }
  /**
   * This method is executed in the end of `attr()`, after setting all
   * attributes in the hash. In can be used to efficiently consolidate
   * multiple attributes in one SVG property -- e.g., translate, rotate and
   * scale are merged in one "transform" attribute in the SVG node.
   *
   * @private
   * @function Highcharts.SVGElement#afterSetters
   */
  afterSetters() {
    if (this.doTransform) {
      this.updateTransform();
      this.doTransform = false;
    }
  }
  /**
   * Align the element relative to the chart or another box.
   *
   * @function Highcharts.SVGElement#align
   *
   * @param {Highcharts.AlignObject} [alignOptions]
   *        The alignment options. The function can be called without this
   *        parameter in order to re-align an element after the box has been
   *        updated.
   *
   * @param {boolean} [alignByTranslate]
   *        Align element by translation.
   *
   * @param {string|Highcharts.BBoxObject} [alignTo]
   *        The box to align to, needs a width and height. When the box is a
   *        string, it refers to an object in the Renderer. For example, when
   *        box is `spacingBox`, it refers to `Renderer.spacingBox` which
   *        holds `width`, `height`, `x` and `y` properties.
   *
   * @param {boolean} [redraw]
   *        Decide if SVGElement should be redrawn with new alignment or
   *        just change its attributes.
   *
   * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.
   */
  align(alignOptions, alignByTranslate, alignTo, redraw = true) {
    const renderer = this.renderer, alignedObjects = renderer.alignedObjects, initialAlignment = Boolean(alignOptions);
    if (alignOptions) {
      this.alignOptions = alignOptions;
      this.alignByTranslate = alignByTranslate;
      this.alignTo = alignTo;
    } else {
      alignOptions = this.alignOptions || {};
      alignByTranslate = this.alignByTranslate;
      alignTo = this.alignTo;
    }
    const alignToKey = !alignTo || isString6(alignTo) ? alignTo || "renderer" : void 0;
    if (alignToKey) {
      if (initialAlignment) {
        pushUnique3(alignedObjects, this);
      }
      alignTo = void 0;
    }
    const alignToBox = pick5(alignTo, renderer[alignToKey], renderer), x = (alignToBox.x || 0) + (alignOptions.x || 0) + ((alignToBox.width || 0) - (alignOptions.width || 0)) * getAlignFactor2(alignOptions.align), y = (alignToBox.y || 0) + (alignOptions.y || 0) + ((alignToBox.height || 0) - (alignOptions.height || 0)) * getAlignFactor2(alignOptions.verticalAlign), attribs = {
      "text-align": alignOptions?.align
    };
    attribs[alignByTranslate ? "translateX" : "x"] = Math.round(x);
    attribs[alignByTranslate ? "translateY" : "y"] = Math.round(y);
    if (redraw) {
      this[this.placed ? "animate" : "attr"](attribs);
      this.placed = true;
    }
    this.alignAttr = attribs;
    return this;
  }
  /**
   * @private
   * @function Highcharts.SVGElement#alignSetter
   * @param {"left"|"center"|"right"} value
   */
  alignSetter(value) {
    const convert = {
      left: "start",
      center: "middle",
      right: "end"
    };
    if (convert[value]) {
      this.alignValue = value;
      this.element.setAttribute("text-anchor", convert[value]);
    }
  }
  /**
   * Animate to given attributes or CSS properties.
   *
   * @sample highcharts/members/element-on/
   *         Setting some attributes by animation
   *
   * @function Highcharts.SVGElement#animate
   *
   * @param {Highcharts.SVGAttributes} params
   *        SVG attributes or CSS to animate.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [options]
   *        Animation options.
   *
   * @param {Function} [complete]
   *        Function to perform at the end of animation.
   *
   * @return {Highcharts.SVGElement}
   *         Returns the SVGElement for chaining.
   */
  animate(params, options2, complete) {
    const animOptions = animObject2(pick5(options2, this.renderer.globalAnimation, true)), deferTime = animOptions.defer;
    if (doc2.hidden) {
      animOptions.duration = 0;
    }
    if (animOptions.duration !== 0) {
      if (complete) {
        animOptions.complete = complete;
      }
      syncTimeout2(() => {
        if (this.element) {
          animate2(this, params, animOptions);
        }
      }, deferTime);
    } else {
      this.attr(params, void 0, complete || animOptions.complete);
      objectEach6(params, function(val, prop) {
        if (animOptions.step) {
          animOptions.step.call(this, val, { prop, pos: 1, elem: this });
        }
      }, this);
    }
    return this;
  }
  /**
   * Apply a text outline through a custom CSS property, by copying the text
   * element and apply stroke to the copy. Used internally. Contrast checks at
   * [example](https://jsfiddle.net/highcharts/43soe9m1/2/).
   *
   * @example
   * // Specific color
   * text.css({
   *    textOutline: '1px black'
   * });
   * // Automatic contrast
   * text.css({
   *    color: '#000000', // black text
   *    textOutline: '1px contrast' // => white outline
   * });
   *
   * @private
   * @function Highcharts.SVGElement#applyTextOutline
   *
   * @param {string} textOutline
   *        A custom CSS `text-outline` setting, defined by `width color`.
   */
  applyTextOutline(textOutline) {
    const elem = this.element, hasContrast = textOutline.indexOf("contrast") !== -1, styles = {};
    if (hasContrast) {
      styles.textOutline = textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
    }
    const spacePos = textOutline.indexOf(" "), color14 = textOutline.substring(spacePos + 1);
    let strokeWidth = textOutline.substring(0, spacePos);
    if (strokeWidth && strokeWidth !== "none" && Globals_default.svg) {
      this.fakeTS = true;
      strokeWidth = strokeWidth.replace(/(^[\d\.]+)(.*?)$/g, function(match, digit, unit) {
        return 2 * Number(digit) + unit;
      });
      this.removeTextOutline();
      const outline = doc2.createElementNS(SVG_NS2, "tspan");
      attr4(outline, {
        "class": "highcharts-text-outline",
        fill: color14,
        stroke: color14,
        "stroke-width": strokeWidth,
        "stroke-linejoin": "round"
      });
      const parentElem = elem.querySelector("textPath") || elem;
      [].forEach.call(parentElem.childNodes, (childNode) => {
        const clone = childNode.cloneNode(true);
        if (clone.removeAttribute) {
          ["fill", "stroke", "stroke-width", "stroke"].forEach((prop) => clone.removeAttribute(prop));
        }
        outline.appendChild(clone);
      });
      let totalHeight = 0;
      [].forEach.call(parentElem.querySelectorAll("text tspan"), (element) => {
        totalHeight += Number(element.getAttribute("dy"));
      });
      const br = doc2.createElementNS(SVG_NS2, "tspan");
      br.textContent = "";
      attr4(br, {
        x: Number(elem.getAttribute("x")),
        dy: -totalHeight
      });
      outline.appendChild(br);
      parentElem.insertBefore(outline, parentElem.firstChild);
    }
  }
  /**
   * @function Highcharts.SVGElement#attr
   * @param {string} key
   * @return {number|string}
   */
  /**
  * Apply native and custom attributes to the SVG elements.
  *
  * In order to set the rotation center for rotation, set x and y to 0 and
  * use `translateX` and `translateY` attributes to position the element
  * instead.
  *
  * Attributes frequently used in Highcharts are `fill`, `stroke`,
  * `stroke-width`.
  *
  * @sample highcharts/members/renderer-rect/
  *         Setting some attributes
  *
  * @example
  * // Set multiple attributes
  * element.attr({
  *     stroke: 'red',
  *     fill: 'blue',
  *     x: 10,
  *     y: 10
  * });
  *
  * // Set a single attribute
  * element.attr('stroke', 'red');
  *
  * // Get an attribute
  * element.attr('stroke'); // => 'red'
  *
  * @function Highcharts.SVGElement#attr
  *
  * @param {string|Highcharts.SVGAttributes} [hash]
  *        The native and custom SVG attributes.
  *
  * @param {number|string|Highcharts.SVGPathArray} [val]
  *        If the type of the first argument is `string`, the second can be a
  *        value, which will serve as a single attribute setter. If the first
  *        argument is a string and the second is undefined, the function
  *        serves as a getter and the current value of the property is
  *        returned.
  *
  * @param {Function} [complete]
  *        A callback function to execute after setting the attributes. This
  *        makes the function compliant and interchangeable with the
  *        {@link SVGElement#animate} function.
  *
  * @param {boolean} [continueAnimation=true]
  *        Used internally when `.attr` is called as part of an animation
  *        step. Otherwise, calling `.attr` for an attribute will stop
  *        animation for that attribute.
  *
  * @return {Highcharts.SVGElement}
  *         If used as a setter, it returns the current
  *         {@link Highcharts.SVGElement} so the calls can be chained. If
  *         used as a getter, the current value of the attribute is returned.
  */
  attr(hash, val, complete, continueAnimation) {
    const { element } = this, symbolCustomAttribs = _SVGElement.symbolCustomAttribs;
    let key, hasSetSymbolSize, ret = this, skipAttr, setter;
    if (typeof hash === "string" && typeof val !== "undefined") {
      key = hash;
      hash = {};
      hash[key] = val;
    }
    if (typeof hash === "string") {
      ret = (this[hash + "Getter"] || this._defaultGetter).call(this, hash, element);
    } else {
      objectEach6(hash, function eachAttribute(val2, key2) {
        skipAttr = false;
        if (!continueAnimation) {
          stop2(this, key2);
        }
        if (this.symbolName && symbolCustomAttribs.indexOf(key2) !== -1) {
          if (!hasSetSymbolSize) {
            this.symbolAttr(hash);
            hasSetSymbolSize = true;
          }
          skipAttr = true;
        }
        if (this.rotation && (key2 === "x" || key2 === "y")) {
          this.doTransform = true;
        }
        if (!skipAttr) {
          setter = this[key2 + "Setter"] || this._defaultSetter;
          setter.call(this, val2, key2, element);
        }
      }, this);
      this.afterSetters();
    }
    if (complete) {
      complete.call(this);
    }
    return ret;
  }
  /**
   * Apply a clipping shape to this element.
   *
   * @function Highcharts.SVGElement#clip
   *
   * @param {SVGElement} [clipElem]
   *        The clipping shape. If skipped, the current clip is removed.
   *
   * @return {Highcharts.SVGElement}
   *         Returns the SVG element to allow chaining.
   */
  clip(clipElem) {
    if (clipElem && !clipElem.clipPath) {
      const id = uniqueKey2() + "-", clipPath = this.renderer.createElement("clipPath").attr({ id }).add(this.renderer.defs);
      extend5(clipElem, { clipPath, id, count: 0 });
      clipElem.add(clipPath);
    }
    return this.attr("clip-path", clipElem ? `url(${this.renderer.url}#${clipElem.id})` : "none");
  }
  /**
   * Calculate the coordinates needed for drawing a rectangle crisply and
   * return the calculated attributes.
   *
   * @function Highcharts.SVGElement#crisp
   *
   * @param {Highcharts.RectangleObject} rect
   * Rectangle to crisp.
   *
   * @param {number} [strokeWidth]
   * The stroke width to consider when computing crisp positioning. It can
   * also be set directly on the rect parameter.
   *
   * @return {Highcharts.RectangleObject}
   * The modified rectangle arguments.
   */
  crisp(rect2, strokeWidth) {
    strokeWidth = Math.round(strokeWidth || rect2.strokeWidth || 0);
    const x1 = rect2.x || this.x || 0, y1 = rect2.y || this.y || 0, x2 = (rect2.width || this.width || 0) + x1, y2 = (rect2.height || this.height || 0) + y1, x = crisp2(x1, strokeWidth), y = crisp2(y1, strokeWidth), x2Crisp = crisp2(x2, strokeWidth), y2Crisp = crisp2(y2, strokeWidth);
    extend5(rect2, {
      x,
      y,
      width: x2Crisp - x,
      height: y2Crisp - y
    });
    if (defined6(rect2.strokeWidth)) {
      rect2.strokeWidth = strokeWidth;
    }
    return rect2;
  }
  /**
   * Build and apply an SVG gradient out of a common JavaScript configuration
   * object. This function is called from the attribute setters. An event
   * hook is added for supporting other complex color types.
   *
   * @private
   * @function Highcharts.SVGElement#complexColor
   *
   * @param {Highcharts.GradientColorObject|Highcharts.PatternObject} colorOptions
   * The gradient or pattern options structure.
   *
   * @param {string} prop
   * The property to apply, can either be `fill` or `stroke`.
   *
   * @param {Highcharts.SVGDOMElement} elem
   * SVG element to apply the gradient on.
   */
  complexColor(colorOptions, prop, elem) {
    const renderer = this.renderer;
    let colorObject, gradName, gradAttr, radAttr, gradients, stops, stopColor, stopOpacity, radialReference, id, key = [], value;
    fireEvent3(this.renderer, "complexColor", {
      args: arguments
    }, function() {
      if (colorOptions.radialGradient) {
        gradName = "radialGradient";
      } else if (colorOptions.linearGradient) {
        gradName = "linearGradient";
      }
      if (gradName) {
        gradAttr = colorOptions[gradName];
        gradients = renderer.gradients;
        stops = colorOptions.stops;
        radialReference = elem.radialReference;
        if (isArray4(gradAttr)) {
          colorOptions[gradName] = gradAttr = {
            x1: gradAttr[0],
            y1: gradAttr[1],
            x2: gradAttr[2],
            y2: gradAttr[3],
            gradientUnits: "userSpaceOnUse"
          };
        }
        if (gradName === "radialGradient" && radialReference && !defined6(gradAttr.gradientUnits)) {
          radAttr = gradAttr;
          gradAttr = merge6(gradAttr, renderer.getRadialAttr(radialReference, radAttr), { gradientUnits: "userSpaceOnUse" });
        }
        objectEach6(gradAttr, function(value2, n) {
          if (n !== "id") {
            key.push(n, value2);
          }
        });
        objectEach6(stops, function(val) {
          key.push(val);
        });
        key = key.join(",");
        if (gradients[key]) {
          id = gradients[key].attr("id");
        } else {
          gradAttr.id = id = uniqueKey2();
          const gradientObject = gradients[key] = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);
          gradientObject.radAttr = radAttr;
          gradientObject.stops = [];
          stops.forEach(function(stop4) {
            if (stop4[1].indexOf("rgba") === 0) {
              colorObject = Color_default.parse(stop4[1]);
              stopColor = colorObject.get("rgb");
              stopOpacity = colorObject.get("a");
            } else {
              stopColor = stop4[1];
              stopOpacity = 1;
            }
            const stopObject = renderer.createElement("stop").attr({
              offset: stop4[0],
              "stop-color": stopColor,
              "stop-opacity": stopOpacity
            }).add(gradientObject);
            gradientObject.stops.push(stopObject);
          });
        }
        value = "url(" + renderer.url + "#" + id + ")";
        elem.setAttribute(prop, value);
        elem.gradient = key;
        colorOptions.toString = function() {
          return value;
        };
      }
    });
  }
  /**
   * Set styles for the element. In addition to CSS styles supported by
   * native SVG and HTML elements, there are also some custom made for
   * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text
   * elements.
   *
   * @sample highcharts/members/renderer-text-on-chart/
   *         Styled text
   *
   * @function Highcharts.SVGElement#css
   *
   * @param {Highcharts.CSSObject} styles
   *        The new CSS styles.
   *
   * @return {Highcharts.SVGElement}
   *         Return the SVG element for chaining.
   */
  css(styles) {
    const oldStyles = this.styles, newStyles = {}, elem = this.element;
    let textWidth, hasNew = !oldStyles;
    if (oldStyles) {
      objectEach6(styles, function(value, n) {
        if (oldStyles && oldStyles[n] !== value) {
          newStyles[n] = value;
          hasNew = true;
        }
      });
    }
    if (hasNew) {
      if (oldStyles) {
        styles = extend5(oldStyles, newStyles);
      }
      if (styles.width === null || styles.width === "auto") {
        delete this.textWidth;
      } else if (elem.nodeName.toLowerCase() === "text" && styles.width) {
        textWidth = this.textWidth = pInt3(styles.width);
      }
      extend5(this.styles, styles);
      if (textWidth && (!svg && this.renderer.forExport)) {
        delete styles.width;
      }
      const fontSize = isFirefox && styles.fontSize || null;
      if (fontSize && (isNumber7(fontSize) || /^\d+$/.test(fontSize))) {
        styles.fontSize += "px";
      }
      const stylesToApply = merge6(styles);
      if (elem.namespaceURI === this.SVG_NS) {
        ["textOutline", "textOverflow", "whiteSpace", "width"].forEach((key) => stylesToApply && delete stylesToApply[key]);
        if (stylesToApply.color) {
          stylesToApply.fill = stylesToApply.color;
          delete stylesToApply.color;
        }
      }
      css4(elem, stylesToApply);
    }
    if (this.added) {
      if (this.element.nodeName === "text") {
        this.renderer.buildText(this);
      }
      if (styles.textOutline) {
        this.applyTextOutline(styles.textOutline);
      }
    }
    return this;
  }
  /**
   * @private
   * @function Highcharts.SVGElement#dashstyleSetter
   * @param {string} value
   */
  dashstyleSetter(value) {
    let i, strokeWidth = this["stroke-width"];
    if (strokeWidth === "inherit") {
      strokeWidth = 1;
    }
    if (value) {
      value = value.toLowerCase();
      const v = value.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
      i = v.length;
      while (i--) {
        v[i] = "" + pInt3(v[i]) * pick5(strokeWidth, NaN);
      }
      value = v.join(",").replace(/NaN/g, "none");
      this.element.setAttribute("stroke-dasharray", value);
    }
  }
  /**
   * Destroy the element and element wrapper and clear up the DOM and event
   * hooks.
   *
   * @function Highcharts.SVGElement#destroy
   */
  destroy() {
    const wrapper = this, element = wrapper.element || {}, renderer = wrapper.renderer, ownerSVGElement = element.ownerSVGElement;
    let parentToClean = element.nodeName === "SPAN" && wrapper.parentGroup || void 0, grandParent, i;
    element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
    stop2(wrapper);
    if (wrapper.clipPath && ownerSVGElement) {
      const clipPath = wrapper.clipPath;
      [].forEach.call(ownerSVGElement.querySelectorAll("[clip-path],[CLIP-PATH]"), function(el) {
        if (el.getAttribute("clip-path").indexOf(clipPath.element.id) > -1) {
          el.removeAttribute("clip-path");
        }
      });
      wrapper.clipPath = clipPath.destroy();
    }
    if (wrapper.stops) {
      for (i = 0; i < wrapper.stops.length; i++) {
        wrapper.stops[i].destroy();
      }
      wrapper.stops.length = 0;
      wrapper.stops = void 0;
    }
    wrapper.safeRemoveChild(element);
    while (parentToClean?.div && parentToClean.div.childNodes.length === 0) {
      grandParent = parentToClean.parentGroup;
      wrapper.safeRemoveChild(parentToClean.div);
      delete parentToClean.div;
      parentToClean = grandParent;
    }
    if (wrapper.alignOptions) {
      erase2(renderer.alignedObjects, wrapper);
    }
    objectEach6(wrapper, (val, key) => {
      if (
        // Destroy child elements of a group
        wrapper[key]?.parentGroup === wrapper || // Destroy own elements
        ["connector", "foreignObject"].indexOf(key) !== -1
      ) {
        wrapper[key]?.destroy?.();
      }
      delete wrapper[key];
    });
    return;
  }
  /**
   * @private
   * @function Highcharts.SVGElement#dSettter
   * @param {number|string|Highcharts.SVGPathArray} value
   * @param {string} key
   * @param {Highcharts.SVGDOMElement} element
   */
  dSetter(value, key, element) {
    if (isArray4(value)) {
      if (typeof value[0] === "string") {
        value = this.renderer.pathToSegments(value);
      }
      this.pathArray = value;
      value = value.reduce((acc, seg, i) => {
        if (!seg?.join) {
          return (seg || "").toString();
        }
        return (i ? acc + " " : "") + seg.join(" ");
      }, "");
    }
    if (/(NaN| {2}|^$)/.test(value)) {
      value = "M 0 0";
    }
    if (this[key] !== value) {
      element.setAttribute(key, value);
      this[key] = value;
    }
  }
  /**
   * @private
   * @function Highcharts.SVGElement#fillSetter
   * @param {Highcharts.ColorType} value
   * @param {string} key
   * @param {Highcharts.SVGDOMElement} element
   */
  fillSetter(value, key, element) {
    if (typeof value === "string") {
      element.setAttribute(key, value);
    } else if (value) {
      this.complexColor(value, key, element);
    }
  }
  /**
   * @private
   * @function Highcharts.SVGElement#hrefSetter
   * @param {Highcharts.ColorType} value
   * @param {string} key
   * @param {Highcharts.SVGDOMElement} element
   */
  hrefSetter(value, key, element) {
    element.setAttributeNS("http://www.w3.org/1999/xlink", key, value);
  }
  /**
   * Get the bounding box (width, height, x and y) for the element. Generally
   * used to get rendered text size. Since this is called a lot in charts,
   * the results are cached based on text properties, in order to save DOM
   * traffic. The returned bounding box includes the rotation, so for example
   * a single text line of rotation 90 will report a greater height, and a
   * width corresponding to the line-height.
   *
   * @sample highcharts/members/renderer-on-chart/
   *         Draw a rectangle based on a text's bounding box
   *
   * @function Highcharts.SVGElement#getBBox
   *
   * @param {boolean} [reload]
   *        Skip the cache and get the updated DOM bounding box.
   *
   * @param {number} [rot]
   *        Override the element's rotation. This is internally used on axis
   *        labels with a value of 0 to find out what the bounding box would
   *        be have been if it were not rotated.
   *
   * @return {Highcharts.BBoxObject}
   *         The bounding box with `x`, `y`, `width` and `height` properties.
   */
  getBBox(reload, rot) {
    const wrapper = this, { alignValue, element, renderer, styles, textStr } = wrapper, { cache, cacheKeys } = renderer, isSVG = element.namespaceURI === wrapper.SVG_NS, rotation = pick5(rot, wrapper.rotation, 0), fontSize = renderer.styledMode ? element && _SVGElement.prototype.getStyle.call(element, "font-size") : styles.fontSize;
    let bBox, height, toggleTextShadowShim, cacheKey;
    if (defined6(textStr)) {
      cacheKey = textStr.toString();
      if (cacheKey.indexOf("<") === -1) {
        cacheKey = cacheKey.replace(/\d/g, "0");
      }
      cacheKey += [
        "",
        renderer.rootFontSize,
        fontSize,
        rotation,
        wrapper.textWidth,
        // #7874, also useHTML
        alignValue,
        styles.lineClamp,
        styles.textOverflow,
        // #5968
        styles.fontWeight
        // #12163
      ].join(",");
    }
    if (cacheKey && !reload) {
      bBox = cache[cacheKey];
    }
    if (!bBox || bBox.polygon) {
      if (isSVG || renderer.forExport) {
        try {
          toggleTextShadowShim = this.fakeTS && function(display) {
            const outline = element.querySelector(".highcharts-text-outline");
            if (outline) {
              css4(outline, { display });
            }
          };
          if (isFunction3(toggleTextShadowShim)) {
            toggleTextShadowShim("none");
          }
          bBox = element.getBBox ? (
            // SVG: use extend because IE9 is not allowed to change
            // width and height in case of rotation (below)
            extend5({}, element.getBBox())
          ) : {
            // HTML elements with `exporting.allowHTML` and
            // legacy IE in export mode
            width: element.offsetWidth,
            height: element.offsetHeight,
            x: 0,
            y: 0
          };
          if (isFunction3(toggleTextShadowShim)) {
            toggleTextShadowShim("");
          }
        } catch (e2) {
          "";
        }
        if (!bBox || bBox.width < 0) {
          bBox = { x: 0, y: 0, width: 0, height: 0 };
        }
      } else {
        bBox = wrapper.htmlGetBBox();
      }
      height = bBox.height;
      if (isSVG) {
        bBox.height = height = {
          "11px,17": 14,
          "13px,20": 16
        }[`${fontSize || ""},${Math.round(height)}`] || height;
      }
      if (rotation) {
        bBox = this.getRotatedBox(bBox, rotation);
      }
      const e = { bBox };
      fireEvent3(this, "afterGetBBox", e);
      bBox = e.bBox;
    }
    if (cacheKey && (textStr === "" || bBox.height > 0)) {
      while (cacheKeys.length > 250) {
        delete cache[cacheKeys.shift()];
      }
      if (!cache[cacheKey]) {
        cacheKeys.push(cacheKey);
      }
      cache[cacheKey] = bBox;
    }
    return bBox;
  }
  /**
   * Get the rotated box.
   * @private
   */
  getRotatedBox(box, rotation) {
    const { x: boxX, y: boxY, width, height } = box, { alignValue, translateY, rotationOriginX = 0, rotationOriginY = 0 } = this, alignFactor = getAlignFactor2(alignValue), baseline = Number(this.element.getAttribute("y") || 0) - (translateY ? 0 : boxY), rad = rotation * deg2rad, rad90 = (rotation - 90) * deg2rad, cosRad = Math.cos(rad), sinRad = Math.sin(rad), wCosRad = width * cosRad, wSinRad = width * sinRad, cosRad90 = Math.cos(rad90), sinRad90 = Math.sin(rad90), [[xOriginCosRad, xOriginSinRad], [yOriginCosRad, yOriginSinRad]] = [
      rotationOriginX,
      rotationOriginY
    ].map((rotOrigin) => [
      rotOrigin - rotOrigin * cosRad,
      rotOrigin * sinRad
    ]), pX = boxX + alignFactor * (width - wCosRad) + xOriginCosRad + yOriginSinRad, pY = boxY + baseline - alignFactor * wSinRad - xOriginSinRad + yOriginCosRad, aX = pX + baseline * cosRad90, bX = aX + wCosRad, cX = bX - height * cosRad90, dX = cX - wCosRad, aY = pY + baseline * sinRad90, bY = aY + wSinRad, cY = bY - height * sinRad90, dY = cY - wSinRad;
    const x = Math.min(aX, bX, cX, dX), y = Math.min(aY, bY, cY, dY), boxWidth = Math.max(aX, bX, cX, dX) - x, boxHeight = Math.max(aY, bY, cY, dY) - y;
    return {
      x,
      y,
      width: boxWidth,
      height: boxHeight,
      polygon: [
        [aX, aY],
        [bX, bY],
        [cX, cY],
        [dX, dY]
      ]
    };
  }
  /**
   * Get the computed style. Only in styled mode.
   *
   * @example
   * chart.series[0].points[0].graphic.getStyle('stroke-width'); // => '1px'
   *
   * @function Highcharts.SVGElement#getStyle
   *
   * @param {string} prop
   *        The property name to check for.
   *
   * @return {string}
   *         The current computed value.
   */
  getStyle(prop) {
    return win6.getComputedStyle(this.element || this, "").getPropertyValue(prop);
  }
  /**
   * Check if an element has the given class name.
   *
   * @function Highcharts.SVGElement#hasClass
   *
   * @param {string} className
   * The class name to check for.
   *
   * @return {boolean}
   * Whether the class name is found.
   */
  hasClass(className) {
    return ("" + this.attr("class")).split(" ").indexOf(className) !== -1;
  }
  /**
   * Hide the element, similar to setting the `visibility` attribute to
   * `hidden`.
   *
   * @function Highcharts.SVGElement#hide
   *
   * @return {Highcharts.SVGElement}
   *         Returns the SVGElement for chaining.
   */
  hide() {
    return this.attr({ visibility: "hidden" });
  }
  /**
   * @private
   */
  htmlGetBBox() {
    return { height: 0, width: 0, x: 0, y: 0 };
  }
  /**
   * Initialize the SVG element. This function only exists to make the
   * initialization process overridable. It should not be called directly.
   *
   * @function Highcharts.SVGElement#init
   *
   * @param {Highcharts.SVGRenderer} renderer
   * The SVGRenderer instance to initialize to.
   *
   * @param {string} nodeName
   * The SVG node name.
   */
  constructor(renderer, nodeName) {
    this.onEvents = {};
    this.opacity = 1;
    this.SVG_NS = SVG_NS2;
    this.element = nodeName === "span" || nodeName === "body" ? createElement3(nodeName) : doc2.createElementNS(this.SVG_NS, nodeName);
    this.renderer = renderer;
    this.styles = {};
    fireEvent3(this, "afterInit");
  }
  /**
   * Add an event listener. This is a simple setter that replaces the
   * previous event of the same type added by this function, as opposed to
   * the {@link Highcharts#addEvent} function.
   *
   * @sample highcharts/members/element-on/
   *         A clickable rectangle
   *
   * @function Highcharts.SVGElement#on
   *
   * @param {string} eventType
   * The event type.
   *
   * @param {Function} handler
   * The handler callback.
   *
   * @return {Highcharts.SVGElement}
   * The SVGElement for chaining.
   */
  on(eventType, handler) {
    const { onEvents } = this;
    if (onEvents[eventType]) {
      onEvents[eventType]();
    }
    onEvents[eventType] = addEvent2(this.element, eventType, handler);
    return this;
  }
  /**
   * @private
   * @function Highcharts.SVGElement#opacitySetter
   * @param {string} value
   * @param {string} key
   * @param {Highcharts.SVGDOMElement} element
   */
  opacitySetter(value, key, element) {
    const opacity = Number(Number(value).toFixed(3));
    this.opacity = opacity;
    element.setAttribute(key, opacity);
  }
  /**
   * Re-align an aligned text or label after setting the text.
   *
   * @private
   * @function Highcharts.SVGElement#reAlign
   *
   */
  reAlign() {
    if (this.alignOptions?.width && this.alignOptions.align !== "left") {
      this.alignOptions.width = this.getBBox().width;
      this.placed = false;
      this.align();
    }
  }
  /**
   * Remove a class name from the element.
   *
   * @function Highcharts.SVGElement#removeClass
   *
   * @param {string|RegExp} className
   *        The class name to remove.
   *
   * @return {Highcharts.SVGElement} Returns the SVG element for chainability.
   */
  removeClass(className) {
    return this.attr("class", ("" + this.attr("class")).replace(isString6(className) ? new RegExp(`(^| )${className}( |$)`) : (
      // #12064, #13590
      className
    ), " ").replace(/ +/g, " ").trim());
  }
  /**
   *
   * @private
   */
  removeTextOutline() {
    const outline = this.element.querySelector("tspan.highcharts-text-outline");
    if (outline) {
      this.safeRemoveChild(outline);
    }
  }
  /**
   * Removes an element from the DOM.
   *
   * @private
   * @function Highcharts.SVGElement#safeRemoveChild
   *
   * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element
   * The DOM node to remove.
   */
  safeRemoveChild(element) {
    const parentNode = element.parentNode;
    if (parentNode) {
      parentNode.removeChild(element);
    }
  }
  /**
   * Set the coordinates needed to draw a consistent radial gradient across
   * a shape regardless of positioning inside the chart. Used on pie slices
   * to make all the slices have the same radial reference point.
   *
   * @function Highcharts.SVGElement#setRadialReference
   *
   * @param {Array<number>} coordinates
   * The center reference. The format is `[centerX, centerY, diameter]` in
   * pixels.
   *
   * @return {Highcharts.SVGElement}
   * Returns the SVGElement for chaining.
   */
  setRadialReference(coordinates) {
    const existingGradient = this.element.gradient && this.renderer.gradients[this.element.gradient] || void 0;
    this.element.radialReference = coordinates;
    if (existingGradient?.radAttr) {
      existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));
    }
    return this;
  }
  /**
   * Add a shadow to the element. In styled mode, this method is not used,
   * instead use `defs` and filters.
   *
   * @example
   * renderer.rect(10, 100, 100, 100)
   *     .attr({ fill: 'red' })
   *     .shadow(true);
   *
   * @function Highcharts.SVGElement#shadow
   *
   * @param {boolean|Highcharts.ShadowOptionsObject} [shadowOptions] The
   *        shadow options. If `true`, the default options are applied. If
   *        `false`, the current shadow will be removed.
   *
   * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.
   */
  shadow(shadowOptions) {
    const { renderer } = this, options2 = merge6(this.parentGroup?.rotation === 90 ? {
      offsetX: -1,
      offsetY: -1
    } : {}, isObject5(shadowOptions) ? shadowOptions : {}), id = renderer.shadowDefinition(options2);
    return this.attr({
      filter: shadowOptions ? `url(${renderer.url}#${id})` : "none"
    });
  }
  /**
   * Show the element after it has been hidden.
   *
   * @function Highcharts.SVGElement#show
   *
   * @param {boolean} [inherit=true]
   *        Set the visibility attribute to `inherit` rather than `visible`.
   *        The difference is that an element with `visibility="visible"`
   *        will be visible even if the parent is hidden.
   *
   * @return {Highcharts.SVGElement}
   *         Returns the SVGElement for chaining.
   */
  show(inherit = true) {
    return this.attr({ visibility: inherit ? "inherit" : "visible" });
  }
  /**
   * Set the stroke-width and record it on the SVGElement
   *
   * @private
   * @function Highcharts.SVGElement#strokeSetter
   * @param {number|string|ColorType} value
   * @param {string} key
   * @param {Highcharts.SVGDOMElement} element
   */
  "stroke-widthSetter"(value, key, element) {
    this[key] = value;
    element.setAttribute(key, value);
  }
  /**
   * Get the computed stroke width in pixel values. This is used extensively
   * when drawing shapes to ensure the shapes are rendered crisp and
   * positioned correctly relative to each other. Using
   * `shape-rendering: crispEdges` leaves us less control over positioning,
   * for example when we want to stack columns next to each other, or position
   * things pixel-perfectly within the plot box.
   *
   * The common pattern when placing a shape is:
   * - Create the SVGElement and add it to the DOM. In styled mode, it will
   *   now receive a stroke width from the style sheet. In classic mode we
   *   will add the `stroke-width` attribute.
   * - Read the computed `elem.strokeWidth()`.
   * - Place it based on the stroke width.
   *
   * @function Highcharts.SVGElement#strokeWidth
   *
   * @return {number}
   * The stroke width in pixels. Even if the given stroke width (in CSS or by
   * attributes) is based on `em` or other units, the pixel size is returned.
   */
  strokeWidth() {
    if (!this.renderer.styledMode) {
      return this["stroke-width"] || 0;
    }
    const val = this.getStyle("stroke-width");
    let ret = 0, tempElement;
    if (/px$/.test(val)) {
      ret = pInt3(val);
    } else if (val !== "") {
      tempElement = doc2.createElementNS(SVG_NS2, "rect");
      attr4(tempElement, {
        width: val,
        "stroke-width": 0
      });
      this.element.parentNode.appendChild(tempElement);
      ret = tempElement.getBBox().width;
      tempElement.parentNode.removeChild(tempElement);
    }
    return ret;
  }
  /**
   * If one of the symbol size affecting parameters are changed,
   * check all the others only once for each call to an element's
   * .attr() method
   *
   * @private
   * @function Highcharts.SVGElement#symbolAttr
   *
   * @param {Highcharts.SVGAttributes} hash
   * The attributes to set.
   */
  symbolAttr(hash) {
    const wrapper = this;
    _SVGElement.symbolCustomAttribs.forEach(function(key) {
      wrapper[key] = pick5(hash[key], wrapper[key]);
    });
    wrapper.attr({
      d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
    });
  }
  /**
   * @private
   * @function Highcharts.SVGElement#textSetter
   * @param {string} value
   */
  textSetter(value) {
    if (value !== this.textStr) {
      delete this.textPxLength;
      this.textStr = value;
      if (this.added) {
        this.renderer.buildText(this);
      }
      this.reAlign();
    }
  }
  /**
   * @private
   * @function Highcharts.SVGElement#titleSetter
   * @param {string} value
   */
  titleSetter(value) {
    const el = this.element;
    const titleNode = el.getElementsByTagName("title")[0] || doc2.createElementNS(this.SVG_NS, "title");
    if (el.insertBefore) {
      el.insertBefore(titleNode, el.firstChild);
    } else {
      el.appendChild(titleNode);
    }
    titleNode.textContent = replaceNested2(
      // Scan #[73]
      pick5(value, ""),
      // #3276, #3895
      [/<[^>]*>/g, ""]
    ).replace(/&lt;/g, "<").replace(/&gt;/g, ">");
  }
  /**
   * Bring the element to the front. Alternatively, a new zIndex can be set.
   *
   * @sample highcharts/members/element-tofront/
   *         Click an element to bring it to front
   *
   * @function Highcharts.SVGElement#toFront
   *
   * @return {Highcharts.SVGElement}
   * Returns the SVGElement for chaining.
   */
  toFront() {
    const element = this.element;
    element.parentNode.appendChild(element);
    return this;
  }
  /**
   * Move an object and its children by x and y values.
   *
   * @function Highcharts.SVGElement#translate
   *
   * @param {number} x
   * The x value.
   *
   * @param {number} y
   * The y value.
   *
   * @return {Highcharts.SVGElement}
   * Translated element.
   */
  translate(x, y) {
    return this.attr({
      translateX: x,
      translateY: y
    });
  }
  /**
   * Update the transform attribute based on internal properties. Deals with
   * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`
   * attributes and updates the SVG `transform` attribute.
   *
   * @private
   * @function Highcharts.SVGElement#updateTransform
   */
  updateTransform(attrib = "transform") {
    const { element, foreignObject, matrix, padding, rotation = 0, rotationOriginX, rotationOriginY, scaleX, scaleY, text, translateX = 0, translateY = 0 } = this;
    const transform = ["translate(" + translateX + "," + translateY + ")"];
    if (defined6(matrix)) {
      transform.push("matrix(" + matrix.join(",") + ")");
    }
    if (rotation) {
      transform.push("rotate(" + rotation + " " + (rotationOriginX ?? element.getAttribute("x") ?? this.x ?? 0) + " " + (rotationOriginY ?? element.getAttribute("y") ?? this.y ?? 0) + ")");
      if (text?.element.tagName === "SPAN" && !text?.foreignObject) {
        text.attr({
          rotation,
          rotationOriginX: (rotationOriginX || 0) - padding,
          rotationOriginY: (rotationOriginY || 0) - padding
        });
      }
    }
    if (defined6(scaleX) || defined6(scaleY)) {
      transform.push("scale(" + pick5(scaleX, 1) + " " + pick5(scaleY, 1) + ")");
    }
    if (transform.length && !(text || this).textPath) {
      (foreignObject?.element || element).setAttribute(attrib, transform.join(" "));
    }
  }
  /**
   * @private
   * @function Highcharts.SVGElement#visibilitySetter
   *
   * @param {string} value
   *
   * @param {string} key
   *
   * @param {Highcharts.SVGDOMElement} element
   *
   */
  visibilitySetter(value, key, element) {
    if (value === "inherit") {
      element.removeAttribute(key);
    } else if (this[key] !== value) {
      element.setAttribute(key, value);
    }
    this[key] = value;
  }
  /**
   * @private
   * @function Highcharts.SVGElement#xGetter
   */
  xGetter(key) {
    if (this.element.nodeName === "circle") {
      if (key === "x") {
        key = "cx";
      } else if (key === "y") {
        key = "cy";
      }
    }
    return this._defaultGetter(key);
  }
  /**
   * @private
   * @function Highcharts.SVGElement#zIndexSetter
   */
  zIndexSetter(value, key) {
    const renderer = this.renderer, parentGroup = this.parentGroup, parentWrapper = parentGroup || renderer, parentNode = parentWrapper.element || renderer.box, element = this.element, svgParent = parentNode === renderer.box;
    let childNodes, otherElement, otherZIndex, inserted = false, undefinedOtherZIndex, run = this.added, i;
    if (defined6(value)) {
      element.setAttribute("data-z-index", value);
      value = +value;
      if (this[key] === value) {
        run = false;
      }
    } else if (defined6(this[key])) {
      element.removeAttribute("data-z-index");
    }
    this[key] = value;
    if (run) {
      value = this.zIndex;
      if (value && parentGroup) {
        parentGroup.handleZ = true;
      }
      childNodes = parentNode.childNodes;
      for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {
        otherElement = childNodes[i];
        otherZIndex = otherElement.getAttribute("data-z-index");
        undefinedOtherZIndex = !defined6(otherZIndex);
        if (otherElement !== element) {
          if (
            // Negative zIndex versus no zIndex:
            // On all levels except the highest. If the parent is
            // <svg>, then we don't want to put items before <desc>
            // or <defs>
            value < 0 && undefinedOtherZIndex && !svgParent && !i
          ) {
            parentNode.insertBefore(element, childNodes[i]);
            inserted = true;
          } else if (
            // Insert after the first element with a lower zIndex
            pInt3(otherZIndex) <= value || // If negative zIndex, add this before first undefined
            // zIndex element
            undefinedOtherZIndex && (!defined6(value) || value >= 0)
          ) {
            parentNode.insertBefore(element, childNodes[i + 1]);
            inserted = true;
          }
        }
      }
      if (!inserted) {
        parentNode.insertBefore(element, childNodes[svgParent ? 3 : 0]);
        inserted = true;
      }
    }
    return inserted;
  }
};
SVGElement.symbolCustomAttribs = [
  "anchorX",
  "anchorY",
  "clockwise",
  "end",
  "height",
  "innerR",
  "r",
  "start",
  "width",
  "x",
  "y"
];
SVGElement.prototype.strokeSetter = SVGElement.prototype.fillSetter;
SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
SVGElement.prototype.matrixSetter = SVGElement.prototype.rotationOriginXSetter = SVGElement.prototype.rotationOriginYSetter = SVGElement.prototype.rotationSetter = SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = SVGElement.prototype.verticalAlignSetter = function(value, key) {
  this[key] = value;
  this.doTransform = true;
};
var SVGElement_default = SVGElement;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGLabel.js
var { defined: defined7, extend: extend6, getAlignFactor: getAlignFactor3, isNumber: isNumber8, merge: merge7, pick: pick6, removeEvent: removeEvent2 } = Utilities_default;
var SVGLabel = class _SVGLabel extends SVGElement_default {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(renderer, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
    super(renderer, "g");
    this.paddingLeftSetter = this.paddingSetter;
    this.paddingRightSetter = this.paddingSetter;
    this.doUpdate = false;
    this.textStr = str;
    this.x = x;
    this.y = y;
    this.anchorX = anchorX;
    this.anchorY = anchorY;
    this.baseline = baseline;
    this.className = className;
    this.addClass(className === "button" ? "highcharts-no-tooltip" : "highcharts-label");
    if (className) {
      this.addClass("highcharts-" + className);
    }
    this.text = renderer.text(void 0, 0, 0, useHTML).attr({ zIndex: 1 });
    let hasBGImage;
    if (typeof shape === "string") {
      hasBGImage = /^url\((.*?)\)$/.test(shape);
      if (hasBGImage || this.renderer.symbols[shape]) {
        this.symbolKey = shape;
      }
    }
    this.bBox = _SVGLabel.emptyBBox;
    this.padding = 3;
    this.baselineOffset = 0;
    this.needsBox = renderer.styledMode || hasBGImage;
    this.deferredAttr = {};
    this.alignFactor = 0;
  }
  /* *
   *
   *  Functions
   *
   * */
  alignSetter(value) {
    const alignFactor = getAlignFactor3(value);
    this.textAlign = value;
    if (alignFactor !== this.alignFactor) {
      this.alignFactor = alignFactor;
      if (this.bBox && isNumber8(this.xSetting)) {
        this.attr({ x: this.xSetting });
      }
    }
  }
  anchorXSetter(value, key) {
    this.anchorX = value;
    this.boxAttr(key, Math.round(value) - this.getCrispAdjust() - this.xSetting);
  }
  anchorYSetter(value, key) {
    this.anchorY = value;
    this.boxAttr(key, value - this.ySetting);
  }
  /*
   * Set a box attribute, or defer it if the box is not yet created
   */
  boxAttr(key, value) {
    if (this.box) {
      this.box.attr(key, value);
    } else {
      this.deferredAttr[key] = value;
    }
  }
  /*
   * Pick up some properties and apply them to the text instead of the
   * wrapper.
   */
  css(styles) {
    if (styles) {
      const textStyles = {};
      styles = merge7(styles);
      _SVGLabel.textProps.forEach((prop) => {
        if (typeof styles[prop] !== "undefined") {
          textStyles[prop] = styles[prop];
          delete styles[prop];
        }
      });
      this.text.css(textStyles);
      if ("fontSize" in textStyles || "fontWeight" in textStyles) {
        this.updateTextPadding();
      } else if ("width" in textStyles || "textOverflow" in textStyles) {
        this.updateBoxSize();
      }
    }
    return SVGElement_default.prototype.css.call(this, styles);
  }
  /*
   * Destroy and release memory.
   */
  destroy() {
    removeEvent2(this.element, "mouseenter");
    removeEvent2(this.element, "mouseleave");
    if (this.text) {
      this.text.destroy();
    }
    if (this.box) {
      this.box = this.box.destroy();
    }
    SVGElement_default.prototype.destroy.call(this);
    return void 0;
  }
  fillSetter(value, key) {
    if (value) {
      this.needsBox = true;
    }
    this.fill = value;
    this.boxAttr(key, value);
  }
  /*
   * Return the bounding box of the box, not the group.
   */
  getBBox(reload, rot) {
    if (this.textStr && this.bBox.width === 0 && this.bBox.height === 0) {
      this.updateBoxSize();
    }
    const { padding, height = 0, translateX = 0, translateY = 0, width = 0 } = this, paddingLeft = pick6(this.paddingLeft, padding), rotation = rot ?? (this.rotation || 0);
    let bBox = {
      width,
      height,
      x: translateX + this.bBox.x - paddingLeft,
      y: translateY + this.bBox.y - padding + this.baselineOffset
    };
    if (rotation) {
      bBox = this.getRotatedBox(bBox, rotation);
    }
    return bBox;
  }
  getCrispAdjust() {
    return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
  }
  heightSetter(value) {
    this.heightSetting = value;
    this.doUpdate = true;
  }
  /**
   * This method is executed in the end of `attr()`, after setting all
   * attributes in the hash. In can be used to efficiently consolidate
   * multiple attributes in one SVG property -- e.g., translate, rotate and
   * scale are merged in one "transform" attribute in the SVG node.
   * Also updating height or width should trigger update of the box size.
   *
   * @private
   * @function Highcharts.SVGLabel#afterSetters
   */
  afterSetters() {
    super.afterSetters();
    if (this.doUpdate) {
      this.updateBoxSize();
      this.doUpdate = false;
    }
  }
  /*
   * After the text element is added, get the desired size of the border
   * box and add it before the text in the DOM.
   */
  onAdd() {
    this.text.add(this);
    this.attr({
      // Alignment is available now  (#3295, 0 not rendered if given
      // as a value)
      text: pick6(this.textStr, ""),
      x: this.x || 0,
      y: this.y || 0
    });
    if (this.box && defined7(this.anchorX)) {
      this.attr({
        anchorX: this.anchorX,
        anchorY: this.anchorY
      });
    }
  }
  paddingSetter(value, key) {
    if (!isNumber8(value)) {
      this[key] = void 0;
    } else if (value !== this[key]) {
      this[key] = value;
      this.updateTextPadding();
    }
  }
  rSetter(value, key) {
    this.boxAttr(key, value);
  }
  strokeSetter(value, key) {
    this.stroke = value;
    this.boxAttr(key, value);
  }
  "stroke-widthSetter"(value, key) {
    if (value) {
      this.needsBox = true;
    }
    this["stroke-width"] = value;
    this.boxAttr(key, value);
  }
  "text-alignSetter"(value) {
    this.textAlign = this["text-align"] = value;
    this.updateTextPadding();
  }
  textSetter(text) {
    if (typeof text !== "undefined") {
      this.text.attr({ text });
    }
    this.updateTextPadding();
    this.reAlign();
  }
  /*
   * This function runs after the label is added to the DOM (when the bounding
   * box is available), and after the text of the label is updated to detect
   * the new bounding box and reflect it in the border box.
   */
  updateBoxSize() {
    const text = this.text, attribs = {}, padding = this.padding, bBox = this.bBox = (!isNumber8(this.widthSetting) || !isNumber8(this.heightSetting) || this.textAlign) && defined7(text.textStr) ? text.getBBox(void 0, 0) : _SVGLabel.emptyBBox;
    let crispAdjust;
    this.width = this.getPaddedWidth();
    this.height = (this.heightSetting || bBox.height || 0) + 2 * padding;
    const metrics = this.renderer.fontMetrics(text);
    this.baselineOffset = padding + Math.min(
      // When applicable, use the font size of the first line (#15707)
      (this.text.firstLineMetrics || metrics).b,
      // When the height is 0, there is no bBox, so go with the font
      // metrics. Highmaps CSS demos.
      bBox.height || Infinity
    );
    if (this.heightSetting) {
      this.baselineOffset += (this.heightSetting - metrics.h) / 2;
    }
    if (this.needsBox && !text.textPath) {
      if (!this.box) {
        const box = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
        box.addClass(
          // Don't use label className for buttons
          (this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")
        );
        box.add(this);
      }
      crispAdjust = this.getCrispAdjust();
      attribs.x = crispAdjust;
      attribs.y = (this.baseline ? -this.baselineOffset : 0) + crispAdjust;
      attribs.width = Math.round(this.width);
      attribs.height = Math.round(this.height);
      this.box.attr(extend6(attribs, this.deferredAttr));
      this.deferredAttr = {};
    }
  }
  /*
   * This function runs after setting text or padding, but only if padding
   * is changed.
   */
  updateTextPadding() {
    const text = this.text, textAlign = text.styles.textAlign || this.textAlign;
    if (!text.textPath) {
      this.updateBoxSize();
      const textY = this.baseline ? 0 : this.baselineOffset, textX = (this.paddingLeft ?? this.padding) + // Compensate for alignment
      getAlignFactor3(textAlign) * (this.widthSetting ?? this.bBox.width);
      if (textX !== text.x || textY !== text.y) {
        text.attr({
          align: textAlign,
          x: textX
        });
        if (typeof textY !== "undefined") {
          text.attr("y", textY);
        }
      }
      text.x = textX;
      text.y = textY;
    }
  }
  widthSetter(value) {
    this.widthSetting = isNumber8(value) ? value : void 0;
    this.doUpdate = true;
  }
  getPaddedWidth() {
    const padding = this.padding;
    const paddingLeft = pick6(this.paddingLeft, padding);
    const paddingRight = pick6(this.paddingRight, padding);
    return (this.widthSetting || this.bBox.width || 0) + paddingLeft + paddingRight;
  }
  xSetter(value) {
    this.x = value;
    if (this.alignFactor) {
      value -= this.alignFactor * this.getPaddedWidth();
      this["forceAnimate:x"] = true;
    }
    this.xSetting = Math.round(value);
    this.attr("translateX", this.xSetting);
  }
  ySetter(value) {
    this.ySetting = this.y = Math.round(value);
    this.attr("translateY", this.ySetting);
  }
};
SVGLabel.emptyBBox = {
  width: 0,
  height: 0,
  x: 0,
  y: 0
};
SVGLabel.textProps = [
  "color",
  "direction",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lineClamp",
  "lineHeight",
  "textAlign",
  "textDecoration",
  "textOutline",
  "textOverflow",
  "whiteSpace",
  "width"
];
var SVGLabel_default = SVGLabel;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/Symbols.js
var { defined: defined8, isNumber: isNumber9, pick: pick7 } = Utilities_default;
function arc(cx, cy, w, h, options2) {
  const arc3 = [];
  if (options2) {
    let start = options2.start || 0, end = options2.end || 0;
    const rx = pick7(options2.r, w), ry = pick7(options2.r, h || w), proximity = 2e-4 / (options2.borderRadius ? 1 : Math.max(rx, 1)), fullCircle = Math.abs(end - start - 2 * Math.PI) < proximity;
    if (fullCircle) {
      start = Math.PI / 2;
      end = Math.PI * 2.5 - proximity;
    }
    const innerRadius = options2.innerR, open2 = pick7(options2.open, fullCircle), cosStart = Math.cos(start), sinStart = Math.sin(start), cosEnd = Math.cos(end), sinEnd = Math.sin(end), longArc = pick7(options2.longArc, end - start - Math.PI < proximity ? 0 : 1);
    let arcSegment = [
      "A",
      // ArcTo
      rx,
      // X radius
      ry,
      // Y radius
      0,
      // Slanting
      longArc,
      // Long or short arc
      pick7(options2.clockwise, 1),
      // Clockwise
      cx + rx * cosEnd,
      cy + ry * sinEnd
    ];
    arcSegment.params = { start, end, cx, cy };
    arc3.push([
      "M",
      cx + rx * cosStart,
      cy + ry * sinStart
    ], arcSegment);
    if (defined8(innerRadius)) {
      arcSegment = [
        "A",
        // ArcTo
        innerRadius,
        // X radius
        innerRadius,
        // Y radius
        0,
        // Slanting
        longArc,
        // Long or short arc
        // Clockwise - opposite to the outer arc clockwise
        defined8(options2.clockwise) ? 1 - options2.clockwise : 0,
        cx + innerRadius * cosStart,
        cy + innerRadius * sinStart
      ];
      arcSegment.params = {
        start: end,
        end: start,
        cx,
        cy
      };
      arc3.push(open2 ? [
        "M",
        cx + innerRadius * cosEnd,
        cy + innerRadius * sinEnd
      ] : [
        "L",
        cx + innerRadius * cosEnd,
        cy + innerRadius * sinEnd
      ], arcSegment);
    }
    if (!open2) {
      arc3.push(["Z"]);
    }
  }
  return arc3;
}
function callout(x, y, w, h, options2) {
  const arrowLength = 6, halfDistance = 6, r = Math.min(options2?.r || 0, w, h), safeDistance = r + halfDistance, anchorX = options2?.anchorX, anchorY = options2?.anchorY || 0;
  const path = roundedRect(x, y, w, h, { r });
  if (!isNumber9(anchorX)) {
    return path;
  }
  if (anchorX < w && anchorX > 0 && anchorY < h && anchorY > 0) {
    return path;
  }
  if (x + anchorX > w - safeDistance) {
    if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
      path.splice(3, 1, ["L", x + w, anchorY - halfDistance], ["L", x + w + arrowLength, anchorY], ["L", x + w, anchorY + halfDistance], ["L", x + w, y + h - r]);
    } else {
      if (anchorX < w) {
        const isTopCorner = anchorY < y + safeDistance, cornerY = isTopCorner ? y : y + h, sliceStart = isTopCorner ? 2 : 5;
        path.splice(sliceStart, 0, ["L", anchorX, anchorY], ["L", x + w - r, cornerY]);
      } else {
        path.splice(3, 1, ["L", x + w, h / 2], ["L", anchorX, anchorY], ["L", x + w, h / 2], ["L", x + w, y + h - r]);
      }
    }
  } else if (x + anchorX < safeDistance) {
    if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
      path.splice(7, 1, ["L", x, anchorY + halfDistance], ["L", x - arrowLength, anchorY], ["L", x, anchorY - halfDistance], ["L", x, y + r]);
    } else {
      if (anchorX > 0) {
        const isTopCorner = anchorY < y + safeDistance, cornerY = isTopCorner ? y : y + h, sliceStart = isTopCorner ? 1 : 6;
        path.splice(sliceStart, 0, ["L", anchorX, anchorY], ["L", x + r, cornerY]);
      } else {
        path.splice(7, 1, ["L", x, h / 2], ["L", anchorX, anchorY], ["L", x, h / 2], ["L", x, y + r]);
      }
    }
  } else if (
    // Replace bottom
    anchorY > h && anchorX < w - safeDistance
  ) {
    path.splice(5, 1, ["L", anchorX + halfDistance, y + h], ["L", anchorX, y + h + arrowLength], ["L", anchorX - halfDistance, y + h], ["L", x + r, y + h]);
  } else if (
    // Replace top
    anchorY < 0 && anchorX > safeDistance
  ) {
    path.splice(1, 1, ["L", anchorX - halfDistance, y], ["L", anchorX, y - arrowLength], ["L", anchorX + halfDistance, y], ["L", w - r, y]);
  }
  return path;
}
function circle(x, y, w, h) {
  return arc(x + w / 2, y + h / 2, w / 2, h / 2, {
    start: Math.PI * 0.5,
    end: Math.PI * 2.5,
    open: false
  });
}
function diamond(x, y, w, h) {
  return [
    ["M", x + w / 2, y],
    ["L", x + w, y + h / 2],
    ["L", x + w / 2, y + h],
    ["L", x, y + h / 2],
    ["Z"]
  ];
}
function rect(x, y, w, h, options2) {
  if (options2?.r) {
    return roundedRect(x, y, w, h, options2);
  }
  return [
    ["M", x, y],
    ["L", x + w, y],
    ["L", x + w, y + h],
    ["L", x, y + h],
    ["Z"]
  ];
}
function roundedRect(x, y, w, h, options2) {
  const r = options2?.r || 0;
  return [
    ["M", x + r, y],
    ["L", x + w - r, y],
    // Top side
    ["A", r, r, 0, 0, 1, x + w, y + r],
    // Top-right corner
    ["L", x + w, y + h - r],
    // Right side
    ["A", r, r, 0, 0, 1, x + w - r, y + h],
    // Bottom-right corner
    ["L", x + r, y + h],
    // Bottom side
    ["A", r, r, 0, 0, 1, x, y + h - r],
    // Bottom-left corner
    ["L", x, y + r],
    // Left side
    ["A", r, r, 0, 0, 1, x + r, y],
    ["Z"]
    // Top-left corner
  ];
}
function triangle(x, y, w, h) {
  return [
    ["M", x + w / 2, y],
    ["L", x + w, y + h],
    ["L", x, y + h],
    ["Z"]
  ];
}
function triangleDown(x, y, w, h) {
  return [
    ["M", x, y],
    ["L", x + w, y],
    ["L", x + w / 2, y + h],
    ["Z"]
  ];
}
var Symbols = {
  arc,
  callout,
  circle,
  diamond,
  rect,
  roundedRect,
  square: rect,
  triangle,
  "triangle-down": triangleDown
};
var Symbols_default = Symbols;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/TextBuilder.js
var { doc: doc3, SVG_NS: SVG_NS3, win: win7 } = Globals_default;
var { attr: attr5, extend: extend7, fireEvent: fireEvent4, isString: isString7, objectEach: objectEach7, pick: pick8 } = Utilities_default;
var stringWithEllipsis = (text, currentIndex) => text.substring(0, currentIndex) + "";
var TextBuilder = class {
  constructor(svgElement) {
    const textStyles = svgElement.styles;
    this.renderer = svgElement.renderer;
    this.svgElement = svgElement;
    this.width = svgElement.textWidth;
    this.textLineHeight = textStyles?.lineHeight;
    this.textOutline = textStyles?.textOutline;
    this.ellipsis = Boolean(textStyles?.textOverflow === "ellipsis");
    this.lineClamp = textStyles?.lineClamp;
    this.noWrap = Boolean(textStyles?.whiteSpace === "nowrap");
  }
  /**
   * Build an SVG representation of the pseudo HTML given in the object's
   * svgElement.
   *
   * @private
   *
   * @return {void}.
   */
  buildSVG() {
    const wrapper = this.svgElement, textNode = wrapper.element, renderer = wrapper.renderer, textStr = pick8(wrapper.textStr, "").toString(), hasMarkup = textStr.indexOf("<") !== -1, childNodes = textNode.childNodes, tempParent = !wrapper.added && renderer.box, regexMatchBreaks = /<br.*?>/g, textCache = [
      textStr,
      this.ellipsis,
      this.noWrap,
      this.textLineHeight,
      this.textOutline,
      wrapper.getStyle("font-size"),
      wrapper.styles.lineClamp,
      this.width
    ].join(",");
    if (textCache === wrapper.textCache) {
      return;
    }
    wrapper.textCache = textCache;
    delete wrapper.actualWidth;
    for (let i = childNodes.length; i--; ) {
      textNode.removeChild(childNodes[i]);
    }
    if (!hasMarkup && !this.ellipsis && !this.width && !wrapper.textPath && (textStr.indexOf(" ") === -1 || this.noWrap && !regexMatchBreaks.test(textStr))) {
      textNode.appendChild(doc3.createTextNode(this.unescapeEntities(textStr)));
    } else if (textStr !== "") {
      if (tempParent) {
        tempParent.appendChild(textNode);
      }
      const ast = new AST_default(textStr);
      this.modifyTree(ast.nodes);
      ast.addToDOM(textNode);
      this.modifyDOM();
      if (this.ellipsis && (textNode.textContent || "").indexOf("") !== -1) {
        wrapper.attr(
          "title",
          this.unescapeEntities(wrapper.textStr || "", ["&lt;", "&gt;"])
          // #7179
        );
      }
      if (tempParent) {
        tempParent.removeChild(textNode);
      }
    }
    if (isString7(this.textOutline) && wrapper.applyTextOutline) {
      wrapper.applyTextOutline(this.textOutline);
    }
  }
  /**
   * Modify the DOM of the generated SVG structure. This function only does
   * operations that cannot be done until the elements are attached to the
   * DOM, like doing layout based on rendered metrics of the added elements.
   *
   * @private
   *
   */
  modifyDOM() {
    const wrapper = this.svgElement;
    const x = attr5(wrapper.element, "x");
    wrapper.firstLineMetrics = void 0;
    let firstChild;
    while (firstChild = wrapper.element.firstChild) {
      if (/^[\s\u200B]*$/.test(firstChild.textContent || " ")) {
        wrapper.element.removeChild(firstChild);
      } else {
        break;
      }
    }
    [].forEach.call(wrapper.element.querySelectorAll("tspan.highcharts-br"), (br, i) => {
      if (br.nextSibling && br.previousSibling) {
        if (i === 0 && br.previousSibling.nodeType === 1) {
          wrapper.firstLineMetrics = wrapper.renderer.fontMetrics(br.previousSibling);
        }
        attr5(br, {
          // Since the break is inserted in front of the next
          // line, we need to use the next sibling for the line
          // height
          dy: this.getLineHeight(br.nextSibling),
          x
        });
      }
    });
    const width = this.width || 0;
    if (!width) {
      return;
    }
    const modifyTextNode = (textNode, parentElement) => {
      const text = textNode.textContent || "";
      const words = text.replace(/([^\^])-/g, "$1- ").split(" ");
      const hasWhiteSpace = !this.noWrap && (words.length > 1 || wrapper.element.childNodes.length > 1);
      const dy = this.getLineHeight(parentElement), ellipsisWidth = Math.max(
        0,
        // Subtract the font face to make room for
        // the ellipsis itself
        width - 0.8 * dy
      );
      let lineNo = 0;
      let startAt = wrapper.actualWidth;
      if (hasWhiteSpace) {
        const lines = [];
        const precedingSiblings = [];
        while (parentElement.firstChild && parentElement.firstChild !== textNode) {
          precedingSiblings.push(parentElement.firstChild);
          parentElement.removeChild(parentElement.firstChild);
        }
        while (words.length) {
          if (words.length && !this.noWrap && lineNo > 0) {
            lines.push(textNode.textContent || "");
            textNode.textContent = words.join(" ").replace(/- /g, "-");
          }
          this.truncate(
            textNode,
            void 0,
            words,
            lineNo === 0 ? startAt || 0 : 0,
            width,
            ellipsisWidth,
            // Build the text to test for
            (t, currentIndex) => words.slice(0, currentIndex).join(" ").replace(/- /g, "-")
          );
          startAt = wrapper.actualWidth;
          lineNo++;
          if (this.lineClamp && lineNo >= this.lineClamp) {
            if (words.length) {
              this.truncate(
                textNode,
                textNode.textContent || "",
                void 0,
                0,
                // Target width
                width,
                ellipsisWidth,
                stringWithEllipsis
              );
              textNode.textContent = textNode.textContent?.replace("", "") + "";
            }
            break;
          }
        }
        precedingSiblings.forEach((childNode) => {
          parentElement.insertBefore(childNode, textNode);
        });
        lines.forEach((line2) => {
          parentElement.insertBefore(doc3.createTextNode(line2), textNode);
          const br = doc3.createElementNS(SVG_NS3, "tspan");
          br.textContent = "";
          attr5(br, { dy, x });
          parentElement.insertBefore(br, textNode);
        });
      } else if (this.ellipsis) {
        if (text) {
          this.truncate(
            textNode,
            text,
            void 0,
            0,
            // Target width
            width,
            ellipsisWidth,
            stringWithEllipsis
          );
        }
      }
    };
    const modifyChildren = ((node) => {
      const childNodes = [].slice.call(node.childNodes);
      childNodes.forEach((childNode) => {
        if (childNode.nodeType === win7.Node.TEXT_NODE) {
          modifyTextNode(childNode, node);
        } else {
          if (childNode.className.baseVal.indexOf("highcharts-br") !== -1) {
            wrapper.actualWidth = 0;
          }
          modifyChildren(childNode);
        }
      });
    });
    modifyChildren(wrapper.element);
  }
  /**
   * Get the rendered line height of a <text>, <tspan> or pure text node.
   * @private
   * @param {DOMElementType|Text} node The node to check for
   * @return {number} The rendered line height
   */
  getLineHeight(node) {
    const element = node.nodeType === win7.Node.TEXT_NODE ? node.parentElement : node;
    return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(element || this.svgElement.element).h;
  }
  /**
   * Transform a pseudo HTML AST node tree into an SVG structure. We do as
   * much heavy lifting as we can here, before doing the final processing in
   * the modifyDOM function. The original data is mutated.
   *
   * @private
   *
   * @param {ASTNode[]} nodes The AST nodes
   *
   */
  modifyTree(nodes) {
    const modifyChild = (node, i) => {
      const { attributes = {}, children, style = {}, tagName } = node, styledMode = this.renderer.styledMode;
      if (tagName === "b" || tagName === "strong") {
        if (styledMode) {
          attributes["class"] = "highcharts-strong";
        } else {
          style.fontWeight = "bold";
        }
      } else if (tagName === "i" || tagName === "em") {
        if (styledMode) {
          attributes["class"] = "highcharts-emphasized";
        } else {
          style.fontStyle = "italic";
        }
      }
      if (style?.color) {
        style.fill = style.color;
      }
      if (tagName === "br") {
        attributes["class"] = "highcharts-br";
        node.textContent = "";
        const nextNode = nodes[i + 1];
        if (nextNode?.textContent) {
          nextNode.textContent = nextNode.textContent.replace(/^ +/gm, "");
        }
      } else if (tagName === "a" && children && children.some((child) => child.tagName === "#text")) {
        node.children = [{ children, tagName: "tspan" }];
      }
      if (tagName !== "#text" && tagName !== "a") {
        node.tagName = "tspan";
      }
      extend7(node, { attributes, style });
      if (children) {
        children.filter((c) => c.tagName !== "#text").forEach(modifyChild);
      }
    };
    nodes.forEach(modifyChild);
    fireEvent4(this.svgElement, "afterModifyTree", { nodes });
  }
  /*
   * Truncate the text node contents to a given length. Used when the css
   * width is set. If the `textOverflow` is `ellipsis`, the text is truncated
   * character by character to the given length. If not, the text is
   * word-wrapped line by line.
   */
  truncate(textNode, text, words, startAt, width, ellipsisWidth, getString) {
    const svgElement = this.svgElement;
    const { rotation } = svgElement;
    const lengths = [];
    let minIndex = words && !startAt ? 1 : 0;
    let maxIndex = (text || words || "").length;
    let currentIndex = maxIndex;
    let str;
    let actualWidth;
    if (!words) {
      width = ellipsisWidth;
    }
    const getSubStringLength = function(charEnd, concatenatedEnd) {
      const end = concatenatedEnd || charEnd;
      const parentNode = textNode.parentNode;
      if (parentNode && typeof lengths[end] === "undefined") {
        if (parentNode.getSubStringLength) {
          try {
            lengths[end] = startAt + parentNode.getSubStringLength(0, words ? end + 1 : end);
          } catch (e) {
            "";
          }
        }
      }
      return lengths[end];
    };
    svgElement.rotation = 0;
    actualWidth = getSubStringLength(textNode.textContent.length);
    if (startAt + actualWidth > width) {
      while (minIndex <= maxIndex) {
        currentIndex = Math.ceil((minIndex + maxIndex) / 2);
        if (words) {
          str = getString(words, currentIndex);
        }
        actualWidth = getSubStringLength(currentIndex, str && str.length - 1);
        if (minIndex === maxIndex) {
          minIndex = maxIndex + 1;
        } else if (actualWidth > width) {
          maxIndex = currentIndex - 1;
        } else {
          minIndex = currentIndex;
        }
      }
      if (maxIndex === 0) {
        textNode.textContent = "";
      } else if (!(text && maxIndex === text.length - 1)) {
        textNode.textContent = str || getString(text || words, currentIndex);
      }
      if (this.ellipsis && actualWidth > width) {
        this.truncate(textNode, textNode.textContent || "", void 0, 0, width, ellipsisWidth, stringWithEllipsis);
      }
    }
    if (words) {
      words.splice(0, currentIndex);
    }
    svgElement.actualWidth = actualWidth;
    svgElement.rotation = rotation;
  }
  /*
   * Un-escape HTML entities based on the public `renderer.escapes` list
   *
   * @private
   *
   * @param {string} inputStr The string to unescape
   * @param {Array<string>} [except] Exceptions
   *
   * @return {string} The processed string
   */
  unescapeEntities(inputStr, except) {
    objectEach7(this.renderer.escapes, function(value, key) {
      if (!except || except.indexOf(value) === -1) {
        inputStr = inputStr.toString().replace(new RegExp(value, "g"), key);
      }
    });
    return inputStr;
  }
};
var TextBuilder_default = TextBuilder;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGRenderer.js
var { defaultOptions: defaultOptions3 } = Defaults_default;
var { charts: charts2, deg2rad: deg2rad2, doc: doc4, isFirefox: isFirefox2, isMS, isWebKit, noop, SVG_NS: SVG_NS4, symbolSizes, win: win8 } = Globals_default;
var { addEvent: addEvent3, attr: attr6, createElement: createElement4, crisp: crisp3, css: css5, defined: defined9, destroyObjectProperties: destroyObjectProperties2, extend: extend8, isArray: isArray5, isNumber: isNumber10, isObject: isObject6, isString: isString8, merge: merge8, pick: pick9, pInt: pInt4, replaceNested: replaceNested3, uniqueKey: uniqueKey3 } = Utilities_default;
var hasInternalReferenceBug;
var SVGRenderer = class {
  /**
   * The root `svg` node of the renderer.
   *
   * @name Highcharts.SVGRenderer#box
   * @type {Highcharts.SVGDOMElement}
   */
  /**
   * The wrapper for the root `svg` node of the renderer.
   *
   * @name Highcharts.SVGRenderer#boxWrapper
   * @type {Highcharts.SVGElement}
   */
  /**
   * A pointer to the `defs` node of the root SVG.
   *
   * @name Highcharts.SVGRenderer#defs
   * @type {Highcharts.SVGElement}
   */
  /**
   * Whether the rendered content is intended for export.
   *
   * @name Highcharts.SVGRenderer#forExport
   * @type {boolean | undefined}
   */
  /**
   * Page url used for internal references.
   *
   * @private
   * @name Highcharts.SVGRenderer#url
   * @type {string}
   */
  /**
   * Initialize the SVGRenderer. Overridable initializer function that takes
   * the same parameters as the constructor.
   *
   * @function Highcharts.SVGRenderer#init
   *
   * @param {Highcharts.HTMLDOMElement} container
   * Where to put the SVG in the web page.
   *
   * @param {number} width
   * The width of the SVG.
   *
   * @param {number} height
   * The height of the SVG.
   *
   * @param {Highcharts.CSSObject} [style]
   * The box style, if not in styleMode
   *
   * @param {boolean} [forExport=false]
   * Whether the rendered content is intended for export.
   *
   * @param {boolean} [allowHTML=true]
   * Whether the renderer is allowed to include HTML text, which will be
   * projected on top of the SVG.
   *
   * @param {boolean} [styledMode=false]
   * Whether the renderer belongs to a chart that is in styled mode. If it
   * does, it will avoid setting presentational attributes in some cases, but
   * not when set explicitly through `.attr` and `.css` etc.
   */
  constructor(container, width, height, style, forExport, allowHTML, styledMode) {
    this.x = 0;
    this.y = 0;
    const renderer = this, boxWrapper = renderer.createElement("svg").attr({
      version: "1.1",
      "class": "highcharts-root"
    }), element = boxWrapper.element;
    if (!styledMode) {
      boxWrapper.css(this.getStyle(style || {}));
    }
    container.appendChild(element);
    attr6(container, "dir", "ltr");
    if (container.innerHTML.indexOf("xmlns") === -1) {
      attr6(element, "xmlns", this.SVG_NS);
    }
    this.box = element;
    this.boxWrapper = boxWrapper;
    this.alignedObjects = [];
    this.url = this.getReferenceURL();
    const desc = this.createElement("desc").add();
    desc.element.appendChild(doc4.createTextNode("Created with Highcharts 12.2.0"));
    this.defs = this.createElement("defs").add();
    this.allowHTML = allowHTML;
    this.forExport = forExport;
    this.styledMode = styledMode;
    this.gradients = {};
    this.cache = {};
    this.cacheKeys = [];
    this.imgCount = 0;
    this.rootFontSize = boxWrapper.getStyle("font-size");
    renderer.setSize(width, height, false);
    let subPixelFix, rect2;
    if (isFirefox2 && container.getBoundingClientRect) {
      subPixelFix = function() {
        css5(container, { left: 0, top: 0 });
        rect2 = container.getBoundingClientRect();
        css5(container, {
          left: Math.ceil(rect2.left) - rect2.left + "px",
          top: Math.ceil(rect2.top) - rect2.top + "px"
        });
      };
      subPixelFix();
      renderer.unSubPixelFix = addEvent3(win8, "resize", subPixelFix);
    }
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * General method for adding a definition to the SVG `defs` tag. Can be used
   * for gradients, fills, filters etc. Styled mode only. A hook for adding
   * general definitions to the SVG's defs tag. Definitions can be referenced
   * from the CSS by its `id`. Read more in
   * [gradients, shadows and patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns).
   * Styled mode only.
   *
   * @function Highcharts.SVGRenderer#definition
   *
   * @param {Highcharts.ASTNode} def
   * A serialized form of an SVG definition, including children.
   *
   * @return {Highcharts.SVGElement}
   * The inserted node.
   */
  definition(def) {
    const ast = new AST_default([def]);
    return ast.addToDOM(this.defs.element);
  }
  /**
   * Get the prefix needed for internal URL references to work in certain
   * cases. Some older browser versions had a bug where internal url
   * references in SVG attributes, on the form `url(#some-id)`, would fail if
   * a base tag was present in the page. There were also issues with
   * `history.pushState` related to this prefix.
   *
   * Related issues: #24, #672, #1070, #5244.
   *
   * The affected browsers are:
   * - Chrome <= 53 (May 2018)
   * - Firefox <= 51 (January 2017)
   * - Safari/Mac <= 12.1 (2018 or 2019)
   * - Safari/iOS <= 13
   *
   * @todo Remove this hack when time has passed. All the affected browsers
   * are evergreens, so it is increasingly unlikely that users are affected by
   * the bug.
   *
   * @return {string}
   * The prefix to use. An empty string for modern browsers.
   */
  getReferenceURL() {
    if ((isFirefox2 || isWebKit) && doc4.getElementsByTagName("base").length) {
      if (!defined9(hasInternalReferenceBug)) {
        const id = uniqueKey3();
        const ast = new AST_default([{
          tagName: "svg",
          attributes: {
            width: 8,
            height: 8
          },
          children: [{
            tagName: "defs",
            children: [{
              tagName: "clipPath",
              attributes: {
                id
              },
              children: [{
                tagName: "rect",
                attributes: {
                  width: 4,
                  height: 4
                }
              }]
            }]
          }, {
            tagName: "rect",
            attributes: {
              id: "hitme",
              width: 8,
              height: 8,
              "clip-path": `url(#${id})`,
              fill: "rgba(0,0,0,0.001)"
            }
          }]
        }]);
        const svg4 = ast.addToDOM(doc4.body);
        css5(svg4, {
          position: "fixed",
          top: 0,
          left: 0,
          zIndex: 9e5
        });
        const hitElement = doc4.elementFromPoint(6, 6);
        hasInternalReferenceBug = hitElement?.id === "hitme";
        doc4.body.removeChild(svg4);
      }
      if (hasInternalReferenceBug) {
        return replaceNested3(
          win8.location.href.split("#")[0],
          // Remove hash
          [/<[^>]*>/g, ""],
          // Wing cut HTML
          [/([\('\)])/g, "\\$1"],
          // Escape parantheses and quotes
          [/ /g, "%20"]
          // Replace spaces (needed for Safari only)
        );
      }
    }
    return "";
  }
  /**
   * Get the global style setting for the renderer.
   *
   * @private
   * @function Highcharts.SVGRenderer#getStyle
   *
   * @param {Highcharts.CSSObject} style
   * Style settings.
   *
   * @return {Highcharts.CSSObject}
   * The style settings mixed with defaults.
   */
  getStyle(style) {
    this.style = extend8({
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif',
      fontSize: "1rem"
    }, style);
    return this.style;
  }
  /**
   * Apply the global style on the renderer, mixed with the default styles.
   *
   * @function Highcharts.SVGRenderer#setStyle
   *
   * @param {Highcharts.CSSObject} style
   * CSS to apply.
   */
  setStyle(style) {
    this.boxWrapper.css(this.getStyle(style));
  }
  /**
   * Detect whether the renderer is hidden. This happens when one of the
   * parent elements has `display: none`. Used internally to detect when we
   * need to render preliminarily in another div to get the text bounding
   * boxes right.
   *
   * @function Highcharts.SVGRenderer#isHidden
   *
   * @return {boolean}
   * True if it is hidden.
   */
  isHidden() {
    return !this.boxWrapper.getBBox().width;
  }
  /**
   * Destroys the renderer and its allocated members.
   *
   * @function Highcharts.SVGRenderer#destroy
   *
   * @return {null}
   * Pass through value.
   */
  destroy() {
    const renderer = this, rendererDefs = renderer.defs;
    renderer.box = null;
    renderer.boxWrapper = renderer.boxWrapper.destroy();
    destroyObjectProperties2(renderer.gradients || {});
    renderer.gradients = null;
    renderer.defs = rendererDefs.destroy();
    if (renderer.unSubPixelFix) {
      renderer.unSubPixelFix();
    }
    renderer.alignedObjects = null;
    return null;
  }
  /**
   * Create a wrapper for an SVG element. Serves as a factory for
   * {@link SVGElement}, but this function is itself mostly called from
   * primitive factories like {@link SVGRenderer#path}, {@link
   * SVGRenderer#rect} or {@link SVGRenderer#text}.
   *
   * @function Highcharts.SVGRenderer#createElement
   *
   * @param {string} nodeName
   * The node name, for example `rect`, `g` etc.
   *
   * @return {Highcharts.SVGElement}
   * The generated SVGElement.
   */
  createElement(nodeName) {
    return new this.Element(this, nodeName);
  }
  /**
   * Get converted radial gradient attributes according to the radial
   * reference. Used internally from the {@link SVGElement#colorGradient}
   * function.
   *
   * @private
   * @function Highcharts.SVGRenderer#getRadialAttr
   */
  getRadialAttr(radialReference, gradAttr) {
    return {
      cx: radialReference[0] - radialReference[2] / 2 + (gradAttr.cx || 0) * radialReference[2],
      cy: radialReference[1] - radialReference[2] / 2 + (gradAttr.cy || 0) * radialReference[2],
      r: (gradAttr.r || 0) * radialReference[2]
    };
  }
  /**
   * Create a drop shadow definition and return its id
   *
   * @private
   * @function Highcharts.SVGRenderer#shadowDefinition
   *
   * @param {boolean|Highcharts.ShadowOptionsObject} [shadowOptions] The
   *        shadow options. If `true`, the default options are applied
   */
  shadowDefinition(shadowOptions) {
    const id = [
      `highcharts-drop-shadow-${this.chartIndex}`,
      ...Object.keys(shadowOptions).map((key) => `${key}-${shadowOptions[key]}`)
    ].join("-").toLowerCase().replace(/[^a-z\d\-]/g, ""), options2 = merge8({
      color: "#000000",
      offsetX: 1,
      offsetY: 1,
      opacity: 0.15,
      width: 5
    }, shadowOptions);
    if (!this.defs.element.querySelector(`#${id}`)) {
      this.definition({
        tagName: "filter",
        attributes: {
          id,
          filterUnits: options2.filterUnits
        },
        children: this.getShadowFilterContent(options2)
      });
    }
    return id;
  }
  /**
   * Get shadow filter content.
   * NOTE! Overridden in es5 module for IE11 compatibility.
   *
   * @private
   * @function Highcharts.SVGRenderer#getShadowFilterContent
   *
   * @param {ShadowOptionsObject} options
   * The shadow options.
   * @return {Array<AST.Node>}
   * The shadow filter content.
   */
  getShadowFilterContent(options2) {
    return [{
      tagName: "feDropShadow",
      attributes: {
        dx: options2.offsetX,
        dy: options2.offsetY,
        "flood-color": options2.color,
        // Tuned and modified to keep a preserve compatibility
        // with the old settings
        "flood-opacity": Math.min(options2.opacity * 5, 1),
        stdDeviation: options2.width / 2
      }
    }];
  }
  /**
   * Parse a simple HTML string into SVG tspans. Called internally when text
   * is set on an SVGElement. The function supports a subset of HTML tags, CSS
   * text features like `width`, `text-overflow`, `white-space`, and also
   * attributes like `href` and `style`.
   *
   * @private
   * @function Highcharts.SVGRenderer#buildText
   *
   * @param {Highcharts.SVGElement} wrapper
   * The parent SVGElement.
   */
  buildText(wrapper) {
    new TextBuilder_default(wrapper).buildSVG();
  }
  /**
   * Returns white for dark colors and black for bright colors, based on W3C's
   * definition of [Relative luminance](
   * https://www.w3.org/WAI/GL/wiki/Relative_luminance).
   *
   * @function Highcharts.SVGRenderer#getContrast
   *
   * @param {Highcharts.ColorString} color
   * The color to get the contrast for.
   *
   * @return {Highcharts.ColorString}
   * The contrast color, either `#000000` or `#FFFFFF`.
   */
  getContrast(color14) {
    const rgba256 = Color_default.parse(color14).rgba, channelFunc = " clamp(0,calc(9e9*(0.5 - (0.2126*r + 0.7152*g + 0.0722*b))),1)";
    if (isNumber10(rgba256[0]) || !Color_default.useColorMix) {
      const rgba = rgba256.map((b8) => {
        const c = b8 / 255;
        return c <= 0.04 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      }), l = 0.2126 * rgba[0] + 0.7152 * rgba[1] + 0.0722 * rgba[2];
      return 1.05 / (l + 0.05) > (l + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
    }
    return "color(from " + color14 + " srgb" + channelFunc + channelFunc + channelFunc + ")";
  }
  /**
   * Create a button with preset states. Styles for the button can either be
   * set as arguments, or a general theme for all buttons can be set by the
   * `global.buttonTheme` option.
   *
   * @function Highcharts.SVGRenderer#button
   *
   * @param {string} text
   * The text or HTML to draw.
   *
   * @param {number} x
   * The x position of the button's left side.
   *
   * @param {number} y
   * The y position of the button's top side.
   *
   * @param {Highcharts.EventCallbackFunction<Highcharts.SVGElement>} callback
   * The function to execute on button click or touch.
   *
   * @param {Highcharts.SVGAttributes} [theme]
   * SVG attributes for the normal state.
   *
   * @param {Highcharts.SVGAttributes} [hoverState]
   * SVG attributes for the hover state.
   *
   * @param {Highcharts.SVGAttributes} [selectState]
   * SVG attributes for the pressed state.
   *
   * @param {Highcharts.SVGAttributes} [disabledState]
   * SVG attributes for the disabled state.
   *
   * @param {Highcharts.SymbolKeyValue} [shape=rect]
   * The shape type.
   *
   * @param {boolean} [useHTML=false]
   * Whether to use HTML to render the label.
   *
   * @return {Highcharts.SVGElement}
   * The button element.
   */
  button(text, x, y, callback, theme2 = {}, hoverState, selectState, disabledState, shape, useHTML) {
    const label = this.label(text, x, y, shape, void 0, void 0, useHTML, void 0, "button"), styledMode = this.styledMode, args = arguments;
    let curState = 0;
    theme2 = merge8(defaultOptions3.global.buttonTheme, theme2);
    if (styledMode) {
      delete theme2.fill;
      delete theme2.stroke;
      delete theme2["stroke-width"];
    }
    const states = theme2.states || {}, normalStyle = theme2.style || {};
    delete theme2.states;
    delete theme2.style;
    const stateAttribs = [
      AST_default.filterUserAttributes(theme2)
    ], stateStyles = [normalStyle];
    if (!styledMode) {
      ["hover", "select", "disabled"].forEach((stateName, i) => {
        stateAttribs.push(merge8(stateAttribs[0], AST_default.filterUserAttributes(args[i + 5] || states[stateName] || {})));
        stateStyles.push(stateAttribs[i + 1].style);
        delete stateAttribs[i + 1].style;
      });
    }
    addEvent3(label.element, isMS ? "mouseover" : "mouseenter", function() {
      if (curState !== 3) {
        label.setState(1);
      }
    });
    addEvent3(label.element, isMS ? "mouseout" : "mouseleave", function() {
      if (curState !== 3) {
        label.setState(curState);
      }
    });
    label.setState = (state = 0) => {
      if (state !== 1) {
        label.state = curState = state;
      }
      label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][state]);
      if (!styledMode) {
        label.attr(stateAttribs[state]);
        const css19 = stateStyles[state];
        if (isObject6(css19)) {
          label.css(css19);
        }
      }
    };
    label.attr(stateAttribs[0]);
    if (!styledMode) {
      label.css(extend8({ cursor: "default" }, normalStyle));
      if (useHTML) {
        label.text.css({ pointerEvents: "none" });
      }
    }
    return label.on("touchstart", (e) => e.stopPropagation()).on("click", function(e) {
      if (curState !== 3) {
        callback?.call(label, e);
      }
    });
  }
  /**
   * Make a straight line crisper by not spilling out to neighbour pixels.
   *
   * @function Highcharts.SVGRenderer#crispLine
   *
   * @param {Highcharts.SVGPathArray} points
   *        The original points on the format `[['M', 0, 0], ['L', 100, 0]]`.
   *
   * @param {number} width
   *        The width of the line.
   *
   * @return {Highcharts.SVGPathArray}
   *         The original points array, but modified to render crisply.
   */
  crispLine(points, width) {
    const [start, end] = points;
    if (defined9(start[1]) && start[1] === end[1]) {
      start[1] = end[1] = crisp3(start[1], width);
    }
    if (defined9(start[2]) && start[2] === end[2]) {
      start[2] = end[2] = crisp3(start[2], width);
    }
    return points;
  }
  /**
   * Draw a path, wraps the SVG `path` element.
   *
   * @sample highcharts/members/renderer-path-on-chart/
   *         Draw a path in a chart
   * @sample highcharts/members/renderer-path/
   *         Draw a path independent from a chart
   *
   * @example
   * let path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])
   *     .attr({ stroke: '#ff00ff' })
   *     .add();
   *
   * @function Highcharts.SVGRenderer#path
   *
   * @param {Highcharts.SVGPathArray} [path]
   * An SVG path definition in array form.
   *
   * @return {Highcharts.SVGElement}
   * The generated wrapper element.
   *
   */
  /**
  * Draw a path, wraps the SVG `path` element.
  *
  * @function Highcharts.SVGRenderer#path
  *
  * @param {Highcharts.SVGAttributes} [attribs]
  * The initial attributes.
  *
  * @return {Highcharts.SVGElement}
  * The generated wrapper element.
  */
  path(path) {
    const attribs = this.styledMode ? {} : {
      fill: "none"
    };
    if (isArray5(path)) {
      attribs.d = path;
    } else if (isObject6(path)) {
      extend8(attribs, path);
    }
    return this.createElement("path").attr(attribs);
  }
  /**
   * Draw a circle, wraps the SVG `circle` element.
   *
   * @sample highcharts/members/renderer-circle/
   *         Drawing a circle
   *
   * @function Highcharts.SVGRenderer#circle
   *
   * @param {number} [x]
   * The center x position.
   *
   * @param {number} [y]
   * The center y position.
   *
   * @param {number} [r]
   * The radius.
   *
   * @return {Highcharts.SVGElement}
   * The generated wrapper element.
   */
  /**
  * Draw a circle, wraps the SVG `circle` element.
  *
  * @function Highcharts.SVGRenderer#circle
  *
  * @param {Highcharts.SVGAttributes} [attribs]
  * The initial attributes.
  *
  * @return {Highcharts.SVGElement}
  * The generated wrapper element.
  */
  circle(x, y, r) {
    const attribs = isObject6(x) ? x : typeof x === "undefined" ? {} : { x, y, r }, wrapper = this.createElement("circle");
    wrapper.xSetter = wrapper.ySetter = function(value, key, element) {
      element.setAttribute("c" + key, value);
    };
    return wrapper.attr(attribs);
  }
  /**
   * Draw and return an arc.
   *
   * @sample highcharts/members/renderer-arc/
   *         Drawing an arc
   *
   * @function Highcharts.SVGRenderer#arc
   *
   * @param {number} [x=0]
   * Center X position.
   *
   * @param {number} [y=0]
   * Center Y position.
   *
   * @param {number} [r=0]
   * The outer radius' of the arc.
   *
   * @param {number} [innerR=0]
   * Inner radius like used in donut charts.
   *
   * @param {number} [start=0]
   * The starting angle of the arc in radians, where 0 is to the right and
   * `-Math.PI/2` is up.
   *
   * @param {number} [end=0]
   * The ending angle of the arc in radians, where 0 is to the right and
   * `-Math.PI/2` is up.
   *
   * @return {Highcharts.SVGElement}
   * The generated wrapper element.
   */
  /**
  * Draw and return an arc. Overloaded function that takes arguments object.
  *
  * @function Highcharts.SVGRenderer#arc
  *
  * @param {Highcharts.SVGAttributes} attribs
  * Initial SVG attributes.
  *
  * @return {Highcharts.SVGElement}
  * The generated wrapper element.
  */
  arc(x, y, r, innerR, start, end) {
    let options2;
    if (isObject6(x)) {
      options2 = x;
      y = options2.y;
      r = options2.r;
      innerR = options2.innerR;
      start = options2.start;
      end = options2.end;
      x = options2.x;
    } else {
      options2 = { innerR, start, end };
    }
    const arc3 = this.symbol("arc", x, y, r, r, options2);
    arc3.r = r;
    return arc3;
  }
  /**
   * Draw and return a rectangle.
   *
   * @function Highcharts.SVGRenderer#rect
   *
   * @param {number} [x]
   * Left position.
   *
   * @param {number} [y]
   * Top position.
   *
   * @param {number} [width]
   * Width of the rectangle.
   *
   * @param {number} [height]
   * Height of the rectangle.
   *
   * @param {number} [r]
   * Border corner radius.
   *
   * @param {number} [strokeWidth]
   * A stroke width can be supplied to allow crisp drawing.
   *
   * @return {Highcharts.SVGElement}
   * The generated wrapper element.
   */
  /**
  * Draw and return a rectangle.
  *
  * @sample highcharts/members/renderer-rect-on-chart/
  *         Draw a rectangle in a chart
  * @sample highcharts/members/renderer-rect/
  *         Draw a rectangle independent from a chart
  *
  * @function Highcharts.SVGRenderer#rect
  *
  * @param {Highcharts.SVGAttributes} [attributes]
  * General SVG attributes for the rectangle.
  *
  * @return {Highcharts.SVGElement}
  * The generated wrapper element.
  */
  rect(x, y, width, height, r, strokeWidth) {
    const attribs = isObject6(x) ? x : typeof x === "undefined" ? {} : {
      x,
      y,
      r,
      width: Math.max(width || 0, 0),
      height: Math.max(height || 0, 0)
    }, wrapper = this.createElement("rect");
    if (!this.styledMode) {
      if (typeof strokeWidth !== "undefined") {
        attribs["stroke-width"] = strokeWidth;
        extend8(attribs, wrapper.crisp(attribs));
      }
      attribs.fill = "none";
    }
    wrapper.rSetter = function(value, _key, element) {
      wrapper.r = value;
      attr6(element, {
        rx: value,
        ry: value
      });
    };
    wrapper.rGetter = function() {
      return wrapper.r || 0;
    };
    return wrapper.attr(attribs);
  }
  /**
   * Draw and return a rectangle with advanced corner rounding options.
   *
   * @function Highcharts.SVGRenderer#roundedRect
   *
   * @param {Highcharts.SVGAttributes} attribs
   *      Attributes
   * @return {Highcharts.SVGElement}
   * The generated wrapper element.
   */
  roundedRect(attribs) {
    return this.symbol("roundedRect").attr(attribs);
  }
  /**
   * Resize the {@link SVGRenderer#box} and re-align all aligned child
   * elements.
   *
   * @sample highcharts/members/renderer-g/
   *         Show and hide grouped objects
   *
   * @function Highcharts.SVGRenderer#setSize
   *
   * @param {number} width
   * The new pixel width.
   *
   * @param {number} height
   * The new pixel height.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animate=true]
   * Whether and how to animate.
   */
  setSize(width, height, animate4) {
    const renderer = this;
    renderer.width = width;
    renderer.height = height;
    renderer.boxWrapper.animate({
      width,
      height
    }, {
      step: function() {
        this.attr({
          viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
        });
      },
      duration: pick9(animate4, true) ? void 0 : 0
    });
    renderer.alignElements();
  }
  /**
   * Create and return an svg group element. Child
   * {@link Highcharts.SVGElement} objects are added to the group by using the
   * group as the first parameter in {@link Highcharts.SVGElement#add|add()}.
   *
   * @function Highcharts.SVGRenderer#g
   *
   * @param {string} [name]
   *        The group will be given a class name of `highcharts-{name}`. This
   *        can be used for styling and scripting.
   *
   * @return {Highcharts.SVGElement}
   *         The generated wrapper element.
   */
  g(name) {
    const elem = this.createElement("g");
    return name ? elem.attr({ "class": "highcharts-" + name }) : elem;
  }
  /**
   * Display an image.
   *
   * @sample highcharts/members/renderer-image-on-chart/
   *         Add an image in a chart
   * @sample highcharts/members/renderer-image/
   *         Add an image independent of a chart
   *
   * @function Highcharts.SVGRenderer#image
   *
   * @param {string} href
   *        The image source.
   *
   * @param {number} [x]
   *        The X position.
   *
   * @param {number} [y]
   *        The Y position.
   *
   * @param {number} [width]
   *        The image width. If omitted, it defaults to the image file width.
   *
   * @param {number} [height]
   *        The image height. If omitted it defaults to the image file
   *        height.
   *
   * @param {Function} [onload]
   *        Event handler for image load.
   *
   * @return {Highcharts.SVGElement}
   *         The generated wrapper element.
   */
  image(href, x, y, width, height, onload) {
    const attribs = { preserveAspectRatio: "none" };
    if (isNumber10(x)) {
      attribs.x = x;
    }
    if (isNumber10(y)) {
      attribs.y = y;
    }
    if (isNumber10(width)) {
      attribs.width = width;
    }
    if (isNumber10(height)) {
      attribs.height = height;
    }
    const elemWrapper = this.createElement("image").attr(attribs), onDummyLoad = function(e) {
      elemWrapper.attr({ href });
      onload.call(elemWrapper, e);
    };
    if (onload) {
      elemWrapper.attr({
        /* eslint-disable-next-line max-len */
        href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
      });
      const dummy = new win8.Image();
      addEvent3(dummy, "load", onDummyLoad);
      dummy.src = href;
      if (dummy.complete) {
        onDummyLoad({});
      }
    } else {
      elemWrapper.attr({ href });
    }
    return elemWrapper;
  }
  /**
   * Draw a symbol out of pre-defined shape paths from
   * {@link SVGRenderer#symbols}.
   * It is used in Highcharts for point makers, which cake a `symbol` option,
   * and label and button backgrounds like in the tooltip and stock flags.
   *
   * @function Highcharts.SVGRenderer#symbol
   *
   * @param {string} symbol
   * The symbol name.
   *
   * @param {number} [x]
   * The X coordinate for the top left position.
   *
   * @param {number} [y]
   * The Y coordinate for the top left position.
   *
   * @param {number} [width]
   * The pixel width.
   *
   * @param {number} [height]
   * The pixel height.
   *
   * @param {Highcharts.SymbolOptionsObject} [options]
   * Additional options, depending on the actual symbol drawn.
   *
   * @return {Highcharts.SVGElement}
   * SVG symbol.
   */
  symbol(symbol, x, y, width, height, options2) {
    const ren = this, imageRegex = /^url\((.*?)\)$/, isImage = imageRegex.test(symbol), sym = !isImage && (this.symbols[symbol] ? symbol : "circle"), symbolFn = sym && this.symbols[sym];
    let obj, path, imageSrc, centerImage;
    if (symbolFn) {
      if (typeof x === "number") {
        path = symbolFn.call(this.symbols, x || 0, y || 0, width || 0, height || 0, options2);
      }
      obj = this.path(path);
      if (!ren.styledMode) {
        obj.attr("fill", "none");
      }
      extend8(obj, {
        symbolName: sym || void 0,
        x,
        y,
        width,
        height
      });
      if (options2) {
        extend8(obj, options2);
      }
    } else if (isImage) {
      imageSrc = symbol.match(imageRegex)[1];
      const img = obj = this.image(imageSrc);
      img.imgwidth = pick9(options2?.width, symbolSizes[imageSrc]?.width);
      img.imgheight = pick9(options2?.height, symbolSizes[imageSrc]?.height);
      centerImage = (obj2) => obj2.attr({
        width: obj2.width,
        height: obj2.height
      });
      ["width", "height"].forEach((key) => {
        img[`${key}Setter`] = function(value, key2) {
          this[key2] = value;
          const { alignByTranslate, element, width: width2, height: height2, imgwidth, imgheight } = this, imgSize = key2 === "width" ? imgwidth : imgheight;
          let scale = 1;
          if (options2 && options2.backgroundSize === "within" && width2 && height2 && imgwidth && imgheight) {
            scale = Math.min(width2 / imgwidth, height2 / imgheight);
            attr6(element, {
              width: Math.round(imgwidth * scale),
              height: Math.round(imgheight * scale)
            });
          } else if (element && imgSize) {
            element.setAttribute(key2, imgSize);
          }
          if (!alignByTranslate && imgwidth && imgheight) {
            this.translate(((width2 || 0) - imgwidth * scale) / 2, ((height2 || 0) - imgheight * scale) / 2);
          }
        };
      });
      if (defined9(x)) {
        img.attr({
          x,
          y
        });
      }
      img.isImg = true;
      img.symbolUrl = symbol;
      if (defined9(img.imgwidth) && defined9(img.imgheight)) {
        centerImage(img);
      } else {
        img.attr({ width: 0, height: 0 });
        createElement4("img", {
          onload: function() {
            const chart = charts2[ren.chartIndex];
            if (this.width === 0) {
              css5(this, {
                position: "absolute",
                top: "-999em"
              });
              doc4.body.appendChild(this);
            }
            symbolSizes[imageSrc] = {
              width: this.width,
              height: this.height
            };
            img.imgwidth = this.width;
            img.imgheight = this.height;
            if (img.element) {
              centerImage(img);
            }
            if (this.parentNode) {
              this.parentNode.removeChild(this);
            }
            ren.imgCount--;
            if (!ren.imgCount && chart && !chart.hasLoaded) {
              chart.onload();
            }
          },
          src: imageSrc
        });
        this.imgCount++;
      }
    }
    return obj;
  }
  /**
   * Define a clipping rectangle. The clipping rectangle is later applied
   * to {@link SVGElement} objects through the {@link SVGElement#clip}
   * function.
   *
   * This function is deprecated as of v11.2. Instead, use a regular shape
   * (`rect`, `path` etc), and the `SVGElement.clipTo` function.
   *
   * @example
   * let circle = renderer.circle(100, 100, 100)
   *     .attr({ fill: 'red' })
   *     .add();
   * let clipRect = renderer.clipRect(100, 100, 100, 100);
   *
   * // Leave only the lower right quarter visible
   * circle.clip(clipRect);
   *
   * @deprecated
   *
   * @function Highcharts.SVGRenderer#clipRect
   *
   * @param {number} [x]
   *
   * @param {number} [y]
   *
   * @param {number} [width]
   *
   * @param {number} [height]
   *
   * @return {Highcharts.ClipRectElement}
   *         A clipping rectangle.
   */
  clipRect(x, y, width, height) {
    return this.rect(x, y, width, height, 0);
  }
  /**
   * Draw text. The text can contain a subset of HTML, like spans and anchors
   * and some basic text styling of these. For more advanced features like
   * border and background, use {@link Highcharts.SVGRenderer#label} instead.
   * To update the text after render, run `text.attr({ text: 'New text' })`.
   *
   * @sample highcharts/members/renderer-text-on-chart/
   *         Annotate the chart freely
   * @sample highcharts/members/renderer-on-chart/
   *         Annotate with a border and in response to the data
   * @sample highcharts/members/renderer-text/
   *         Formatted text
   *
   * @function Highcharts.SVGRenderer#text
   *
   * @param {string} [str]
   * The text of (subset) HTML to draw.
   *
   * @param {number} [x]
   * The x position of the text's lower left corner.
   *
   * @param {number} [y]
   * The y position of the text's lower left corner.
   *
   * @param {boolean} [useHTML=false]
   * Use HTML to render the text.
   *
   * @return {Highcharts.SVGElement}
   * The text object.
   */
  text(str, x, y, useHTML) {
    const renderer = this, attribs = {};
    if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
      return renderer.html(str, x, y);
    }
    attribs.x = Math.round(x || 0);
    if (y) {
      attribs.y = Math.round(y);
    }
    if (defined9(str)) {
      attribs.text = str;
    }
    const wrapper = renderer.createElement("text").attr(attribs);
    if (!useHTML || renderer.forExport && !renderer.allowHTML) {
      wrapper.xSetter = function(value, key, element) {
        const tspans = element.getElementsByTagName("tspan"), parentVal = element.getAttribute(key);
        for (let i = 0, tspan; i < tspans.length; i++) {
          tspan = tspans[i];
          if (tspan.getAttribute(key) === parentVal) {
            tspan.setAttribute(key, value);
          }
        }
        element.setAttribute(key, value);
      };
    }
    return wrapper;
  }
  /**
   * Utility to return the baseline offset and total line height from the font
   * size.
   *
   * @function Highcharts.SVGRenderer#fontMetrics
   *
   * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement|number} [element]
   *        The element to inspect for a current font size. If a number is
   *        given, it's used as a fall back for direct font size in pixels.
   *
   * @return {Highcharts.FontMetricsObject}
   *         The font metrics.
   */
  fontMetrics(element) {
    const f = pInt4(SVGElement_default.prototype.getStyle.call(element, "font-size") || 0);
    const h = f < 24 ? f + 3 : Math.round(f * 1.2), b = Math.round(h * 0.8);
    return {
      // Line height
      h,
      // Baseline
      b,
      // Font size
      f
    };
  }
  /**
   * Correct X and Y positioning of a label for rotation (#1764).
   *
   * @private
   * @function Highcharts.SVGRenderer#rotCorr
   */
  rotCorr(baseline, rotation, alterY) {
    let y = baseline;
    if (rotation && alterY) {
      y = Math.max(y * Math.cos(rotation * deg2rad2), 4);
    }
    return {
      x: -baseline / 3 * Math.sin(rotation * deg2rad2),
      y
    };
  }
  /**
   * Compatibility function to convert the legacy one-dimensional path array
   * into an array of segments.
   *
   * It is used in maps to parse the `path` option, and in SVGRenderer.dSetter
   * to support legacy paths from demos.
   *
   * @private
   * @function Highcharts.SVGRenderer#pathToSegments
   */
  pathToSegments(path) {
    const ret = [];
    const segment = [];
    const commandLength = {
      A: 8,
      C: 7,
      H: 2,
      L: 3,
      M: 3,
      Q: 5,
      S: 5,
      T: 3,
      V: 2
    };
    for (let i = 0; i < path.length; i++) {
      if (isString8(segment[0]) && isNumber10(path[i]) && segment.length === commandLength[segment[0].toUpperCase()]) {
        path.splice(i, 0, segment[0].replace("M", "L").replace("m", "l"));
      }
      if (typeof path[i] === "string") {
        if (segment.length) {
          ret.push(segment.slice(0));
        }
        segment.length = 0;
      }
      segment.push(path[i]);
    }
    ret.push(segment.slice(0));
    return ret;
  }
  /**
   * Draw a label, which is an extended text element with support for border
   * and background. Highcharts creates a `g` element with a text and a `path`
   * or `rect` inside, to make it behave somewhat like a HTML div. Border and
   * background are set through `stroke`, `stroke-width` and `fill` attributes
   * using the {@link Highcharts.SVGElement#attr|attr} method. To update the
   * text after render, run `label.attr({ text: 'New text' })`.
   *
   * @sample highcharts/members/renderer-label-on-chart/
   *         A label on the chart
   *
   * @function Highcharts.SVGRenderer#label
   *
   * @param {string} str
   *        The initial text string or (subset) HTML to render.
   *
   * @param {number} x
   *        The x position of the label's left side.
   *
   * @param {number} [y]
   *        The y position of the label's top side or baseline, depending on
   *        the `baseline` parameter.
   *
   * @param {string} [shape='rect']
   *        The shape of the label's border/background, if any. Defaults to
   *        `rect`. Other possible values are `callout` or other shapes
   *        defined in {@link Highcharts.SVGRenderer#symbols}.
   *
   * @param {number} [anchorX]
   *        In case the `shape` has a pointer, like a flag, this is the
   *        coordinates it should be pinned to.
   *
   * @param {number} [anchorY]
   *        In case the `shape` has a pointer, like a flag, this is the
   *        coordinates it should be pinned to.
   *
   * @param {boolean} [useHTML=false]
   *        Whether to use HTML to render the label.
   *
   * @param {boolean} [baseline=false]
   *        Whether to position the label relative to the text baseline,
   *        like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the
   *        upper border of the rectangle.
   *
   * @param {string} [className]
   *        Class name for the group.
   *
   * @return {Highcharts.SVGElement}
   *         The generated label.
   */
  label(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
    return new SVGLabel_default(this, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className);
  }
  /**
   * Re-align all aligned elements.
   *
   * @private
   * @function Highcharts.SVGRenderer#alignElements
   */
  alignElements() {
    this.alignedObjects.forEach((el) => el.align());
  }
};
extend8(SVGRenderer.prototype, {
  /**
   * A pointer to the renderer's associated Element class.
   *
   * @name Highcharts.SVGRenderer#Element
   * @type {Highcharts.SVGElement}
   */
  Element: SVGElement_default,
  SVG_NS: SVG_NS4,
  /**
   * A collection of characters mapped to HTML entities. When `useHTML` on an
   * element is true, these entities will be rendered correctly by HTML. In
   * the SVG pseudo-HTML, they need to be unescaped back to simple characters,
   * so for example `&lt;` will render as `<`.
   *
   * @example
   * // Add support for unescaping quotes
   * Highcharts.SVGRenderer.prototype.escapes['"'] = '&quot;';
   *
   * @name Highcharts.SVGRenderer#escapes
   * @type {Highcharts.Dictionary<string>}
   */
  escapes: {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "'": "&#39;",
    // eslint-disable-line quotes
    '"': "&quot;"
  },
  /**
   * An extendable collection of functions for defining symbol paths.
   *
   * @name Highcharts.SVGRenderer#symbols
   * @type {Highcharts.SymbolDictionary}
   */
  symbols: Symbols_default,
  /**
   * Dummy function for plugins, called every time the renderer is updated.
   * Prior to Highcharts 5, this was used for the canvg renderer.
   *
   * @deprecated
   * @function Highcharts.SVGRenderer#draw
   */
  draw: noop
});
RendererRegistry_default.registerRendererType("svg", SVGRenderer, true);
var SVGRenderer_default = SVGRenderer;

// node_modules/highcharts/es-modules/Core/Renderer/HTML/HTMLElement.js
var { composed, isFirefox: isFirefox3 } = Globals_default;
var { attr: attr7, css: css6, createElement: createElement5, defined: defined10, extend: extend9, getAlignFactor: getAlignFactor4, isNumber: isNumber11, pInt: pInt5, pushUnique: pushUnique4 } = Utilities_default;
function commonSetter(value, key, elem) {
  const style = this.div?.style || elem.style;
  SVGElement_default.prototype[`${key}Setter`].call(this, value, key, elem);
  if (style) {
    style[key] = value;
  }
}
var decorateSVGGroup = (g, container) => {
  if (!g.div) {
    const className = attr7(g.element, "class"), cssProto = g.css;
    const div = createElement5(
      "div",
      className ? { className } : void 0,
      {
        // Add HTML specific styles
        position: "absolute",
        left: `${g.translateX || 0}px`,
        top: `${g.translateY || 0}px`,
        // Add pre-existing styles
        ...g.styles,
        // Add g attributes that correspond to CSS
        display: g.display,
        opacity: g.opacity,
        // #5075
        visibility: g.visibility
      },
      // The top group is appended to container
      g.parentGroup?.div || container
    );
    g.classSetter = (value, key, element) => {
      element.setAttribute("class", value);
      div.className = value;
    };
    g.translateXSetter = g.translateYSetter = (value, key) => {
      g[key] = value;
      div.style[key === "translateX" ? "left" : "top"] = `${value}px`;
      g.doTransform = true;
    };
    g.opacitySetter = g.visibilitySetter = commonSetter;
    g.css = (styles) => {
      cssProto.call(g, styles);
      if (styles.cursor) {
        div.style.cursor = styles.cursor;
      }
      if (styles.pointerEvents) {
        div.style.pointerEvents = styles.pointerEvents;
      }
      return g;
    };
    g.on = function() {
      SVGElement_default.prototype.on.apply({
        element: div,
        onEvents: g.onEvents
      }, arguments);
      return g;
    };
    g.div = div;
  }
  return g.div;
};
var HTMLElement = class _HTMLElement extends SVGElement_default {
  /**
   * Compose
   * @private
   */
  static compose(SVGRendererClass) {
    if (pushUnique4(composed, this.compose)) {
      SVGRendererClass.prototype.html = function(str, x, y) {
        return new _HTMLElement(this, "span").attr({
          text: str,
          x: Math.round(x),
          y: Math.round(y)
        });
      };
    }
  }
  /* *
   *
   *  Functions
   *
   * */
  constructor(renderer, nodeName) {
    super(renderer, nodeName);
    if (_HTMLElement.useForeignObject) {
      this.foreignObject = renderer.createElement("foreignObject").attr({
        zIndex: 2
      });
    } else {
      this.css({
        position: "absolute",
        ...renderer.styledMode ? {} : {
          fontFamily: renderer.style.fontFamily,
          fontSize: renderer.style.fontSize
        }
      });
    }
    this.element.style.whiteSpace = "nowrap";
  }
  /**
   * Get the correction in X and Y positioning as the element is rotated.
   * @private
   */
  getSpanCorrection(width, baseline, alignCorrection) {
    this.xCorr = -width * alignCorrection;
    this.yCorr = -baseline;
  }
  /**
   * Apply CSS to HTML elements. This is used in text within SVG rendering.
   * @private
   */
  css(styles) {
    const { element } = this, isSettingWidth = element.tagName === "SPAN" && styles && "width" in styles, textWidth = isSettingWidth && styles.width;
    let doTransform;
    if (isSettingWidth) {
      delete styles.width;
      this.textWidth = pInt5(textWidth) || void 0;
      doTransform = true;
    }
    if (styles?.textOverflow === "ellipsis") {
      styles.overflow = "hidden";
      styles.whiteSpace = "nowrap";
    }
    if (styles?.lineClamp) {
      styles.display = "-webkit-box";
      styles.WebkitLineClamp = styles.lineClamp;
      styles.WebkitBoxOrient = "vertical";
      styles.overflow = "hidden";
    }
    if (isNumber11(Number(styles?.fontSize))) {
      styles.fontSize += "px";
    }
    extend9(this.styles, styles);
    css6(element, styles);
    if (doTransform) {
      this.updateTransform();
    }
    return this;
  }
  /**
   * The useHTML method for calculating the bounding box based on offsets.
   * Called internally from the `SVGElement.getBBox` function and subsequently
   * rotated.
   *
   * @private
   */
  htmlGetBBox() {
    const { element } = this;
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  /**
   * Batch update styles and attributes related to transform
   *
   * @private
   */
  updateTransform() {
    if (!this.added) {
      this.alignOnAdd = true;
      return;
    }
    const { element, foreignObject, oldTextWidth, renderer, rotation, rotationOriginX, rotationOriginY, scaleX, scaleY, styles: { display = "inline-block", whiteSpace }, textAlign = "left", textWidth, translateX = 0, translateY = 0, x = 0, y = 0 } = this;
    const getTextPxLength = () => {
      if (this.textPxLength) {
        return this.textPxLength;
      }
      css6(element, {
        width: "",
        whiteSpace: whiteSpace || "nowrap"
      });
      return element.offsetWidth;
    };
    if (!foreignObject) {
      css6(element, {
        marginLeft: `${translateX}px`,
        marginTop: `${translateY}px`
      });
    }
    if (element.tagName === "SPAN") {
      const currentTextTransform = [
        rotation,
        textAlign,
        element.innerHTML,
        textWidth,
        this.textAlign
      ].join(","), parentPadding = this.parentGroup?.padding * -1 || 0;
      let baseline;
      if (textWidth !== oldTextWidth) {
        const textPxLength = getTextPxLength(), textWidthNum = textWidth || 0, willOverWrap = element.style.textOverflow === "" && element.style.webkitLineClamp;
        if ((textWidthNum > oldTextWidth || textPxLength > textWidthNum || willOverWrap) && // Only set the width if the text is able to word-wrap,
        // or text-overflow is ellipsis (#9537)
        (/[\-\s\u00AD]/.test(element.textContent || element.innerText) || element.style.textOverflow === "ellipsis")) {
          const usePxWidth = rotation || scaleX || textPxLength > textWidthNum || // Set width to prevent over-wrapping (#22609)
          willOverWrap;
          css6(element, {
            width: usePxWidth && isNumber11(textWidth) ? textWidth + "px" : "auto",
            // #16261
            display,
            whiteSpace: whiteSpace || "normal"
            // #3331
          });
          this.oldTextWidth = textWidth;
        }
      }
      if (foreignObject) {
        css6(element, {
          // Inline block must be set before we can read the offset
          // width
          display: "inline-block",
          verticalAlign: "top"
        });
        foreignObject.attr({
          width: renderer.width,
          height: renderer.height
        });
      }
      if (currentTextTransform !== this.cTT) {
        baseline = renderer.fontMetrics(element).b;
        if (defined10(rotation) && !foreignObject && (rotation !== (this.oldRotation || 0) || textAlign !== this.oldAlign)) {
          css6(element, {
            transform: `rotate(${rotation}deg)`,
            transformOrigin: `${parentPadding}% ${parentPadding}px`
          });
        }
        this.getSpanCorrection(
          // Avoid elem.offsetWidth if we can, it affects rendering
          // time heavily (#7656)
          !defined10(rotation) && !this.textWidth && this.textPxLength || // #7920
          element.offsetWidth,
          baseline,
          getAlignFactor4(textAlign)
        );
      }
      const { xCorr = 0, yCorr = 0 } = this, rotOriginX = (rotationOriginX ?? x) - xCorr - x - parentPadding, rotOriginY = (rotationOriginY ?? y) - yCorr - y - parentPadding, styles = {
        left: `${x + xCorr}px`,
        top: `${y + yCorr}px`,
        textAlign,
        transformOrigin: `${rotOriginX}px ${rotOriginY}px`
      };
      if (scaleX || scaleY) {
        styles.transform = `scale(${scaleX ?? 1},${scaleY ?? 1})`;
      }
      if (foreignObject) {
        super.updateTransform();
        if (isNumber11(x) && isNumber11(y)) {
          foreignObject.attr({
            x: x + xCorr,
            y: y + yCorr,
            width: element.offsetWidth + 3,
            height: element.offsetHeight,
            "transform-origin": element.getAttribute("transform-origin") || "0 0"
          });
          css6(element, { display, textAlign });
        } else if (isFirefox3) {
          foreignObject.attr({
            width: 0,
            height: 0
          });
        }
      } else {
        css6(element, styles);
      }
      this.cTT = currentTextTransform;
      this.oldRotation = rotation;
      this.oldAlign = textAlign;
    }
  }
  /**
   * Add the element to a group wrapper. For HTML elements, a parallel div
   * will be created for each ancenstor SVG `g` element.
   *
   * @private
   */
  add(parentGroup) {
    const { foreignObject, renderer } = this, container = renderer.box.parentNode, parents = [];
    if (foreignObject) {
      foreignObject.add(parentGroup);
      super.add(
        // Create a body inside the foreignObject
        renderer.createElement("body").attr({ xmlns: "http://www.w3.org/1999/xhtml" }).css({
          background: "transparent",
          // 3px is to avoid clipping on the right
          margin: "0 3px 0 0"
          // For export
        }).add(foreignObject)
      );
    } else {
      let div;
      this.parentGroup = parentGroup;
      if (parentGroup) {
        div = parentGroup.div;
        if (!div) {
          let svgGroup = parentGroup;
          while (svgGroup) {
            parents.push(svgGroup);
            svgGroup = svgGroup.parentGroup;
          }
          for (const parentGroup2 of parents.reverse()) {
            div = decorateSVGGroup(parentGroup2, container);
          }
        }
      }
      (div || container).appendChild(this.element);
    }
    this.added = true;
    if (this.alignOnAdd) {
      this.updateTransform();
    }
    return this;
  }
  /**
   * Text setter
   * @private
   */
  textSetter(value) {
    if (value !== this.textStr) {
      delete this.bBox;
      delete this.oldTextWidth;
      AST_default.setElementHTML(this.element, value ?? "");
      this.textStr = value;
      this.doTransform = true;
    }
  }
  /**
   * Align setter
   *
   * @private
   */
  alignSetter(value) {
    this.alignValue = this.textAlign = value;
    this.doTransform = true;
  }
  /**
   * Various setters which rely on update transform
   * @private
   */
  xSetter(value, key) {
    this[key] = value;
    this.doTransform = true;
  }
};
var proto = HTMLElement.prototype;
proto.visibilitySetter = proto.opacitySetter = commonSetter;
proto.ySetter = proto.rotationSetter = proto.rotationOriginXSetter = proto.rotationOriginYSetter = proto.xSetter;
var HTMLElement_default = HTMLElement;

// node_modules/highcharts/es-modules/Core/Axis/AxisDefaults.js
var AxisDefaults;
(function(AxisDefaults2) {
  AxisDefaults2.xAxis = {
    /**
     * When using multiple axis, the ticks of two or more opposite axes
     * will automatically be aligned by adding ticks to the axis or axes
     * with the least ticks, as if `tickAmount` were specified.
     *
     * This can be prevented by setting `alignTicks` to false. If the grid
     * lines look messy, it's a good idea to hide them for the secondary
     * axis by setting `gridLineWidth` to 0.
     *
     * If `startOnTick` or `endOnTick` in an Axis options are set to false,
     * then the `alignTicks ` will be disabled for the Axis.
     *
     * Disabled for logarithmic axes.
     *
     * @product   highcharts highstock gantt
     */
    alignTicks: true,
    /**
     * Whether to allow decimals in this axis' ticks. When counting
     * integers, like persons or hits on a web page, decimals should
     * be avoided in the labels. By default, decimals are allowed on small
     * scale axes.
     *
     * @see [minTickInterval](#xAxis.minTickInterval)
     *
     * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-true/
     *         True by default
     * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-false/
     *         False
     *
     * @type      {boolean|undefined}
     * @default   undefined
     * @since     2.0
     */
    allowDecimals: void 0,
    /**
     * When using an alternate grid color, a band is painted across the
     * plot area between every other grid line.
     *
     * @sample {highcharts} highcharts/yaxis/alternategridcolor/
     *         Alternate grid color on the Y axis
     * @sample {highstock} stock/xaxis/alternategridcolor/
     *         Alternate grid color on the Y axis
     *
     * @type      {Highcharts.ColorType}
     * @apioption xAxis.alternateGridColor
     */
    /**
     * An array defining breaks in the axis, the sections defined will be
     * left out and all the points shifted closer to each other.
     *
     * @productdesc {highcharts}
     * Requires that the broken-axis.js module is loaded.
     *
     * @sample {highcharts} highcharts/axisbreak/break-simple/
     *         Simple break
     * @sample {highcharts|highstock} highcharts/axisbreak/break-visualized/
     *         Advanced with callback
     * @sample {highstock} stock/demo/intraday-breaks/
     *         Break on nights and weekends
     *
     * @type      {Array<*>}
     * @since     4.1.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.breaks
     */
    /**
     * A number indicating how much space should be left between the start
     * and the end of the break. The break size is given in axis units,
     * so for instance on a `datetime` axis, a break size of 3600000 would
     * indicate the equivalent of an hour.
     *
     * @type      {number}
     * @default   0
     * @since     4.1.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.breaks.breakSize
     */
    /**
     * The axis value where the break starts. On datetime axes, this may be
     * a date string.
     *
     * @type      {number|string}
     * @since     4.1.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.breaks.from
     */
    /**
     * Defines an interval after which the break appears again. By default
     * the breaks do not repeat.
     *
     * @type      {number}
     * @default   0
     * @since     4.1.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.breaks.repeat
     */
    /**
     * The axis value where the break ends. On datetime axes, this may be
     * a date string.
     *
     * @type      {number|string}
     * @since     4.1.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.breaks.to
     */
    /**
     * If categories are present for the xAxis, names are used instead of
     * numbers for that axis.
     *
     * Since Highcharts 3.0, categories can also
     * be extracted by giving each point a [name](#series.data) and setting
     * axis [type](#xAxis.type) to `category`. However, if you have multiple
     * series, best practice remains defining the `categories` array.
     *
     * Example: `categories: ['Apples', 'Bananas', 'Oranges']`
     *
     * @sample {highcharts} highcharts/demo/line-labels/
     *         With
     * @sample {highcharts} highcharts/xaxis/categories/
     *         Without
     *
     * @type      {Array<string>}
     * @product   highcharts gantt
     * @apioption xAxis.categories
     */
    /**
     * The highest allowed value for automatically computed axis extremes.
     *
     * @see [floor](#xAxis.floor)
     *
     * @sample {highcharts|highstock} highcharts/yaxis/floor-ceiling/
     *         Floor and ceiling
     *
     * @type       {number}
     * @since      4.0
     * @product    highcharts highstock gantt
     * @apioption  xAxis.ceiling
     */
    /**
     * A class name that opens for styling the axis by CSS, especially in
     * Highcharts styled mode. The class name is applied to group elements
     * for the grid, axis elements and labels.
     *
     * @sample {highcharts|highstock|highmaps} highcharts/css/axis/
     *         Multiple axes with separate styling
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption xAxis.className
     */
    /**
     * Configure a crosshair that follows either the mouse pointer or the
     * hovered point.
     *
     * In styled mode, the crosshairs are styled in the
     * `.highcharts-crosshair`, `.highcharts-crosshair-thin` or
     * `.highcharts-xaxis-category` classes.
     *
     * @productdesc {highstock}
     * In Highcharts stock, by default, the crosshair is enabled on the
     * X axis and disabled on the Y axis.
     *
     * @sample {highcharts} highcharts/xaxis/crosshair-both/
     *         Crosshair on both axes
     * @sample {highstock} stock/xaxis/crosshairs-xy/
     *         Crosshair on both axes, with y axis label
     * @sample {highmaps} highcharts/xaxis/crosshair-both/
     *         Crosshair on both axes
     *
     * @declare   Highcharts.AxisCrosshairOptions
     * @type      {boolean|*}
     * @default   false
     * @since     4.1
     * @apioption xAxis.crosshair
     */
    /**
     * The value on a perpendicular axis where this axis should cross. This
     * is typically used on mathematical plots where the axes cross at 0.
     * When `crossing` is set, space will not be reserved at the sides of
     * the chart for axis labels and title, so those may be clipped. In this
     * case it is better to place the axes without the `crossing` option.
     *
     * @type      {number}
     * @sample    highcharts/xaxis/crossing
     *            Function plot with axes crossing at 0
     * @since 11.0.1
     * @apioption xAxis.crossing
     */
    /**
     * A class name for the crosshair, especially as a hook for styling.
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption xAxis.crosshair.className
     */
    /**
     * The color of the crosshair. Defaults to `#cccccc` for numeric and
     * datetime axes, and `rgba(204,214,235,0.25)` for category axes, where
     * the crosshair by default highlights the whole category.
     *
     * @sample {highcharts|highstock|highmaps} highcharts/xaxis/crosshair-customized/
     *         Customized crosshairs
     *
     * @type      {Highcharts.ColorType}
     * @default   #cccccc
     * @since     4.1
     * @apioption xAxis.crosshair.color
     */
    /**
     * The dash style for the crosshair. See
     * [plotOptions.series.dashStyle](#plotOptions.series.dashStyle)
     * for possible values.
     *
     * @sample {highcharts|highmaps} highcharts/xaxis/crosshair-dotted/
     *         Dotted crosshair
     * @sample {highstock} stock/xaxis/crosshair-dashed/
     *         Dashed X axis crosshair
     *
     * @type      {Highcharts.DashStyleValue}
     * @default   Solid
     * @since     4.1
     * @apioption xAxis.crosshair.dashStyle
     */
    /**
     * A label on the axis next to the crosshair.
     *
     * In styled mode, the label is styled with the
     * `.highcharts-crosshair-label` class.
     *
     * @sample {highstock} stock/xaxis/crosshair-label/
     *         Crosshair labels
     * @sample {highstock} highcharts/css/crosshair-label/
     *         Style mode
     *
     * @declare   Highcharts.AxisCrosshairLabelOptions
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label
     */
    /**
     * Alignment of the label compared to the axis. Defaults to `"left"` for
     * right-side axes, `"right"` for left-side axes and `"center"` for
     * horizontal axes.
     *
     * @type      {Highcharts.AlignValue}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.align
     */
    /**
     * The background color for the label. Defaults to the related series
     * color, or `#666666` if that is not available.
     *
     * @type      {Highcharts.ColorType}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.backgroundColor
     */
    /**
     * The border color for the crosshair label
     *
     * @type      {Highcharts.ColorType}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.borderColor
     */
    /**
     * The border corner radius of the crosshair label.
     *
     * @type      {number}
     * @default   3
     * @since     2.1.10
     * @product   highstock
     * @apioption xAxis.crosshair.label.borderRadius
     */
    /**
     * The border width for the crosshair label.
     *
     * @type      {number}
     * @default   0
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.borderWidth
     */
    /**
     * Flag to enable crosshair's label.
     *
     * @sample {highstock} stock/xaxis/crosshairs-xy/
     *         Enabled label for yAxis' crosshair
     *
     * @type      {boolean}
     * @default   false
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.enabled
     */
    /**
     * A format string for the crosshair label. Defaults to `{value}` for
     * numeric axes and `{value:%b %d, %Y}` for datetime axes.
     *
     * @type      {string}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.format
     */
    /**
     * Formatter function for the label text.
     *
     * @type      {Highcharts.XAxisCrosshairLabelFormatterCallbackFunction}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.formatter
     */
    /**
     * Padding inside the crosshair label.
     *
     * @type      {number}
     * @default   8
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.padding
     */
    /**
     * The shape to use for the label box.
     *
     * @type      {string}
     * @default   callout
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.shape
     */
    /**
     * Text styles for the crosshair label.
     *
     * @type      {Highcharts.CSSObject}
     * @default   {"color": "white", "fontWeight": "normal", "fontSize": "11px", "textAlign": "center"}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.style
     */
    /**
     * Whether the crosshair should snap to the point or follow the pointer
     * independent of points.
     *
     * @sample {highcharts|highstock} highcharts/xaxis/crosshair-snap-false/
     *         True by default
     * @sample {highmaps} maps/demo/latlon-advanced/
     *         Snap is false
     *
     * @type      {boolean}
     * @default   true
     * @since     4.1
     * @apioption xAxis.crosshair.snap
     */
    /**
     * The pixel width of the crosshair. Defaults to 1 for numeric or
     * datetime axes, and for one category width for category axes.
     *
     * @sample {highcharts} highcharts/xaxis/crosshair-customized/
     *         Customized crosshairs
     * @sample {highstock} highcharts/xaxis/crosshair-customized/
     *         Customized crosshairs
     * @sample {highmaps} highcharts/xaxis/crosshair-customized/
     *         Customized crosshairs
     *
     * @type      {number}
     * @default   1
     * @since     4.1
     * @apioption xAxis.crosshair.width
     */
    /**
     * The Z index of the crosshair. Higher Z indices allow drawing the
     * crosshair on top of the series or behind the grid lines.
     *
     * @type      {number}
     * @default   2
     * @since     4.1
     * @apioption xAxis.crosshair.zIndex
     */
    /**
     * Whether to pan axis. If `chart.panning` is enabled, the option
     * allows to disable panning on an individual axis.
     */
    panningEnabled: true,
    /**
     * The Z index for the axis group.
     *
     * @see [axis.gridZIndex](#xAxis.gridZIndex)
     * @see [axis.labels.zIndex](#xAxis.labels.zIndex)
     */
    zIndex: 2,
    /**
     * Whether to zoom axis. If `chart.zoomType` is set, the option allows
     * to disable zooming on an individual axis.
     *
     * @sample {highcharts} highcharts/xaxis/zoomenabled/
     *         Zoom enabled is false
     */
    zoomEnabled: true,
    /**
     * For a datetime axis, the scale will automatically adjust to the
     * appropriate unit. This member gives the default string
     * representations used for each unit. For intermediate values,
     * different units may be used, for example the `day` unit can be used
     * on midnight and `hour` unit be used for intermediate values on the
     * same axis.
     *
     * For an overview of the string or object configuration, see
     * [dateFormat](/class-reference/Highcharts.Time#dateFormat).
     *
     * Defaults to:
     * ```js
     * {
     *     millisecond: '%[HMSL]',
     *     second: '%[HMS]',
     *     minute: '%[HM]',
     *     hour: '%[HM]',
     *     day: '%[eb]',
     *     week: '%[eb]',
     *     month: '%[bY]',
     *     year: '%Y'
     * }
     * ```
     *
     * @sample {highcharts} highcharts/xaxis/datetimelabelformats-object/
     *         Object day format on X axis
     * @sample {highcharts} highcharts/xaxis/datetimelabelformats/
     *         String day format on X axis
     * @sample {highstock} stock/xaxis/datetimelabelformats/
     *         More information in x axis labels
     *
     * @declare Highcharts.AxisDateTimeLabelFormatsOptions
     * @product highcharts highstock gantt
     */
    dateTimeLabelFormats: {
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      millisecond: {
        /**
         * @type {Array<string|Highcharts.DateTimeFormatOptions>}
         * @default undefined
         * @apioption xAxis.dateTimeLabelFormats.millisecond.list
         */
        /**
         * @type {string|Highcharts.DateTimeFormatOptions}
         * @apioption xAxis.dateTimeLabelFormats.millisecond.main
         */
        main: "%[HMSL]",
        range: false
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      second: {
        /**
         * @type {Array<string|Highcharts.DateTimeFormatOptions>}
         * @default undefined
         * @apioption xAxis.dateTimeLabelFormats.second.list
         */
        /**
         * @type {string|Highcharts.DateTimeFormatOptions}
         * @apioption xAxis.dateTimeLabelFormats.second.main
         */
        main: "%[HMS]",
        range: false
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      minute: {
        /**
         * @type {Array<string|Highcharts.DateTimeFormatOptions>}
         * @default undefined
         * @apioption xAxis.dateTimeLabelFormats.minute.list
         */
        /**
         * @type {string|Highcharts.DateTimeFormatOptions}
         * @apioption xAxis.dateTimeLabelFormats.minute.main
         */
        main: "%[HM]",
        range: false
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      hour: {
        /**
         * @type {Array<string|Highcharts.DateTimeFormatOptions>}
         * @default undefined
         * @apioption xAxis.dateTimeLabelFormats.hour.list
         */
        /**
         * @type {string|Highcharts.DateTimeFormatOptions}
         * @apioption xAxis.dateTimeLabelFormats.hour.main
         */
        main: "%[HM]",
        range: false
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      day: {
        /**
         * @type {Array<string|Highcharts.DateTimeFormatOptions>}
         * @default undefined
         * @apioption xAxis.dateTimeLabelFormats.day.list
         */
        /**
         * @type {string|Highcharts.DateTimeFormatOptions}
         * @apioption xAxis.dateTimeLabelFormats.day.main
         */
        main: "%[eb]"
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      week: {
        /**
         * @type {Array<string|Highcharts.DateTimeFormatOptions>}
         * @default undefined
         * @apioption xAxis.dateTimeLabelFormats.week.list
         */
        /**
         * @type {string|Highcharts.DateTimeFormatOptions}
         * @apioption xAxis.dateTimeLabelFormats.week.main
         */
        main: "%[eb]"
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      month: {
        /**
         * @type {Array<string|Highcharts.DateTimeFormatOptions>}
         * @default undefined
         * @apioption xAxis.dateTimeLabelFormats.month.list
         */
        /**
         * @type {string|Highcharts.DateTimeFormatOptions}
         * @apioption xAxis.dateTimeLabelFormats.month.main
         */
        main: "%[bY]"
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      year: {
        /**
         * @type {Array<string|Highcharts.DateTimeFormatOptions>}
         * @default undefined
         * @apioption xAxis.dateTimeLabelFormats.year.list
         */
        /**
         * @type {string|Highcharts.DateTimeFormatOptions}
         * @apioption xAxis.dateTimeLabelFormats.year.main
         */
        main: "%Y"
      }
    },
    /**
     * Whether to force the axis to end on a tick. Use this option with
     * the `maxPadding` option to control the axis end.
     *
     * @productdesc {highstock}
     * In Highcharts Stock, `endOnTick` is always `false` when the navigator
     * is enabled, to prevent jumpy scrolling. With disabled navigator
     * enabling `endOnTick` may lead to extending the xAxis to show the last
     * tick, therefore range selector buttons may not have an active state
     * if the axis gets extended.
     *
     * @sample {highcharts} highcharts/yaxis/endontick/
     *         True by default
     * @sample {highcharts} highcharts/yaxis/endontick-false/
     *         False
     * @sample {highstock} stock/demo/basic-line/
     *         True by default
     * @sample {highstock} stock/xaxis/endontick/
     *         False
     *
     * @since 1.2.0
     */
    endOnTick: false,
    /**
     * Event handlers for the axis.
     *
     * @type      {*}
     * @apioption xAxis.events
     */
    /**
     * An event fired after the breaks have rendered.
     *
     * @see [breaks](#xAxis.breaks)
     *
     * @sample {highcharts} highcharts/axisbreak/break-event/
     *         AfterBreak Event
     *
     * @type      {Highcharts.AxisEventCallbackFunction}
     * @since     4.1.0
     * @product   highcharts gantt
     * @apioption xAxis.events.afterBreaks
     */
    /**
     * As opposed to the `setExtremes` event, this event fires after the
     * final min and max values are computed and corrected for `minRange`.
     *
     * Fires when the minimum and maximum is set for the axis, either by
     * calling the `.setExtremes()` method or by selecting an area in the
     * chart. One parameter, `event`, is passed to the function, containing
     * common event information.
     *
     * The new user set minimum and maximum values can be found by
     * `event.min` and `event.max`. These reflect the axis minimum and
     * maximum in axis values. The actual data extremes are found in
     * `event.dataMin` and `event.dataMax`.
     *
     * @type      {Highcharts.AxisSetExtremesEventCallbackFunction}
     * @since     2.3
     * @context   Highcharts.Axis
     * @apioption xAxis.events.afterSetExtremes
     */
    /**
     * An event fired when a break from this axis occurs on a point.
     *
     * @see [breaks](#xAxis.breaks)
     *
     * @sample {highcharts} highcharts/axisbreak/break-visualized/
     *         Visualization of a Break
     *
     * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
     * @since     4.1.0
     * @product   highcharts gantt
     * @context   Highcharts.Axis
     * @apioption xAxis.events.pointBreak
     */
    /**
     * An event fired when a point falls inside a break from this axis.
     *
     * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
     * @product   highcharts highstock gantt
     * @context   Highcharts.Axis
     * @apioption xAxis.events.pointInBreak
     */
    /**
     * An event fired when a point is outside a break after zoom.
     *
     * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
     * @product   highcharts highstock gantt
     * @context   Highcharts.Axis
     * @apioption xAxis.events.pointBreakOut
     */
    /**
     * Fires when the minimum and maximum is set for the axis, either by
     * calling the `.setExtremes()` method or by selecting an area in the
     * chart. One parameter, `event`, is passed to the function,
     * containing common event information.
     *
     * The new user set minimum and maximum values can be found by
     * `event.min` and `event.max`. These reflect the axis minimum and
     * maximum in data values. When an axis is zoomed all the way out from
     * the "Reset zoom" button, `event.min` and `event.max` are null, and
     * the new extremes are set based on `this.dataMin` and `this.dataMax`.
     *
     * @sample {highstock} stock/xaxis/events-setextremes/
     *         Log new extremes on x axis
     *
     * @type      {Highcharts.AxisSetExtremesEventCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Axis
     * @apioption xAxis.events.setExtremes
     */
    /**
     * The lowest allowed value for automatically computed axis extremes.
     *
     * @see [ceiling](#yAxis.ceiling)
     *
     * @sample {highcharts} highcharts/yaxis/floor-ceiling/
     *         Floor and ceiling
     * @sample {highstock} stock/demo/lazy-loading/
     *         Prevent negative stock price on Y axis
     *
     * @type      {number}
     * @since     4.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.floor
     */
    /**
     * The dash or dot style of the grid lines. For possible values, see
     * [this demonstration](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/).
     *
     * @sample {highcharts} highcharts/yaxis/gridlinedashstyle/
     *         Long dashes
     * @sample {highstock} stock/xaxis/gridlinedashstyle/
     *         Long dashes
     *
     * @type      {Highcharts.DashStyleValue}
     * @since     1.2
     */
    gridLineDashStyle: "Solid",
    /**
     * The Z index of the grid lines.
     *
     * @sample {highcharts|highstock} highcharts/xaxis/gridzindex/
     *         A Z index of 4 renders the grid above the graph
     *
     * @product   highcharts highstock gantt
     *
     * @see [axis.zIndex](#xAxis.zIndex)
     * @see [axis.labels.zIndex](#xAxis.labels.zIndex)
     */
    gridZIndex: 1,
    /**
     * An id for the axis. This can be used after render time to get
     * a pointer to the axis object through `chart.get()`.
     *
     * @sample {highcharts} highcharts/xaxis/id/
     *         Get the object
     * @sample {highstock} stock/xaxis/id/
     *         Get the object
     *
     * @type      {string}
     * @since     1.2.0
     * @apioption xAxis.id
     */
    /**
     * The axis labels show the number or category for each tick.
     *
     * Since v8.0.0: Labels are animated in categorized x-axis with
     * updating data if `tickInterval` and `step` is set to 1.
     *
     * @productdesc {highmaps}
     * X and Y axis labels are by default disabled in Highmaps, but the
     * functionality is inherited from Highcharts and used on `colorAxis`,
     * and can be enabled on X and Y axes too.
     */
    labels: {
      /**
       * What part of the string the given position is anchored to.
       * If `left`, the left side of the string is at the axis position.
       * Can be one of `"left"`, `"center"` or `"right"`. Defaults to
       * an intelligent guess based on which side of the chart the axis
       * is on and the rotation of the label.
       *
       * @see [reserveSpace](#xAxis.labels.reserveSpace)
       *
       * @sample {highcharts} highcharts/xaxis/labels-align-left/
       *         Left
       * @sample {highcharts} highcharts/xaxis/labels-align-right/
       *         Right
       * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
       *         Left-aligned labels on a vertical category axis
       *
       * @type      {Highcharts.AlignValue}
       * @apioption xAxis.labels.align
       */
      /**
       * Whether to allow the axis labels to overlap. When false,
       * overlapping labels are hidden.
       *
       * @sample {highcharts} highcharts/xaxis/labels-allowoverlap-true/
       *         X axis labels overlap enabled
       *
       * @type      {boolean}
       * @default   false
       * @apioption xAxis.labels.allowOverlap
       */
      /**
       * For horizontal axes, the allowed degrees of label rotation
       * to prevent overlapping labels. If there is enough space,
       * labels are not rotated. As the chart gets narrower, it
       * will start rotating the labels -45 degrees, then remove
       * every second label and try again with rotations 0 and -45 etc.
       * Set it to `undefined` to disable rotation, which will
       * cause the labels to word-wrap if possible. Defaults to `[-45]``
       * on bottom and top axes, `undefined` on left and right axes.
       *
       * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-default/
       *         Default auto rotation of 0 or -45
       * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-0-90/
       *         Custom graded auto rotation
       *
       * @type      {Array<number>}
       * @default   undefined
       * @since     4.1.0
       * @product   highcharts highstock gantt
       * @apioption xAxis.labels.autoRotation
       */
      /**
       * When each category width is more than this many pixels, we don't
       * apply auto rotation. Instead, we lay out the axis label with word
       * wrap. A lower limit makes sense when the label contains multiple
       * short words that don't extend the available horizontal space for
       * each label.
       *
       * @sample {highcharts} highcharts/xaxis/labels-autorotationlimit/
       *         Lower limit
       *
       * @since     4.1.5
       * @product   highcharts gantt
       */
      autoRotationLimit: 80,
      /**
       * The label's pixel distance from the perimeter of the plot area.
       * On cartesian charts, this is overridden if the `labels.y` setting
       * is set.
       *
       * @sample {highcharts} highcharts/yaxis/labels-distance/
       *         Polar chart, labels centered under the arc
       *
       * @type      {number}
       * @product   highcharts gantt
       */
      distance: 15,
      /**
       * Enable or disable the axis labels.
       *
       * @sample {highcharts} highcharts/xaxis/labels-enabled/
       *         X axis labels disabled
       * @sample {highstock} stock/xaxis/labels-enabled/
       *         X axis labels disabled
       *
       */
      enabled: true,
      /**
       * A format string for the axis label. The context is available as
       * format string variables. For example, you can use `{text}` to
       * insert the default formatted text. The recommended way of adding
       * units for the label is using `text`, for example `{text} km`.
       *
       * To add custom numeric or datetime formatting, use `{value}` with
       * formatting, for example `{value:.1f}` or `{value:%Y-%m-%d}`.
       *
       * See
       * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
       * for more examples of formatting.
       *
       * The default value is not specified due to the dynamic
       * nature of the default implementation.
       *
       * @sample {highcharts|highstock} highcharts/yaxis/labels-format/
       *         Add units to Y axis label
       * @sample {highcharts} highcharts/xaxis/labels-format-linked/
       *         Linked category names
       * @sample {highcharts} highcharts/xaxis/labels-format-custom/
       *         Custom number format
       *
       * @type      {string}
       * @since     3.0
       * @apioption xAxis.labels.format
       */
      /**
       * Callback JavaScript function to format the label. The value
       * is given by `this.value`. Additional properties for `this` are
       * `axis`, `chart`, `isFirst`, `isLast` and `text` which holds the
       * value of the default formatter.
       *
       * Defaults to a built in function returning a formatted string
       * depending on whether the axis is `category`, `datetime`,
       * `numeric` or other.
       *
       * @sample {highcharts} highcharts/xaxis/labels-formatter-linked/
       *         Linked category names
       * @sample {highcharts} highcharts/xaxis/labels-formatter-extended/
       *         Modified numeric labels
       * @sample {highstock} stock/xaxis/labels-formatter/
       *         Added units on Y axis
       *
       * @type      {Highcharts.AxisLabelsFormatterCallbackFunction}
       * @apioption xAxis.labels.formatter
       */
      /**
       * The number of pixels to indent the labels per level in a treegrid
       * axis.
       *
       * @sample gantt/treegrid-axis/demo
       *         Indentation 10px by default.
       * @sample gantt/treegrid-axis/indentation-0px
       *         Indentation set to 0px.
       *
       * @product gantt
       */
      indentation: 10,
      /**
       * Horizontal axis only. When `staggerLines` is not set,
       * `maxStaggerLines` defines how many lines the axis is allowed to
       * add to automatically avoid overlapping X labels. Set to `1` to
       * disable overlap detection.
       *
       * @deprecated
       * @type      {number}
       * @default   5
       * @since     1.3.3
       * @apioption xAxis.labels.maxStaggerLines
       */
      /**
       * How to handle overflowing labels on horizontal axis. If set to
       * `"allow"`, it will not be aligned at all. By default it
       * `"justify"` labels inside the chart area. If there is room to
       * move it, it will be aligned to the edge, else it will be removed.
       *
       * @since      2.2.5
       * @validvalue ["allow", "justify"]
       */
      overflow: "justify",
      /**
       * The pixel padding for axis labels, to ensure white space between
       * them. Defaults to 4 for horizontal axes, 1 for vertical.
       *
       * @type      {number}
       * @default   undefined
       * @product   highcharts gantt
       * @apioption xAxis.labels.padding
       */
      /**
       * Whether to reserve space for the labels. By default, space is
       * reserved for the labels in these cases:
       *
       * * On all horizontal axes.
       * * On vertical axes if `label.align` is `right` on a left-side
       * axis or `left` on a right-side axis.
       * * On vertical axes if `label.align` is `center`.
       *
       * This can be turned off when for example the labels are rendered
       * inside the plot area instead of outside.
       *
       * @see [labels.align](#xAxis.labels.align)
       *
       * @sample {highcharts} highcharts/xaxis/labels-reservespace/
       *         No reserved space, labels inside plot
       * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
       *         Left-aligned labels on a vertical category axis
       *
       * @type      {boolean}
       * @since     4.1.10
       * @product   highcharts highstock gantt
       * @apioption xAxis.labels.reserveSpace
       */
      reserveSpace: void 0,
      /**
       * Rotation of the labels in degrees. When `undefined`, the
       * `autoRotation` option takes precedence.
       *
       * @sample {highcharts} highcharts/xaxis/labels-rotation/
       *         X axis labels rotated 90
       *
       * @type      {number}
       * @default   0
       * @apioption xAxis.labels.rotation
       */
      rotation: void 0,
      /**
       * Horizontal axes only. The number of lines to spread the labels
       * over to make room or tighter labels. 0 disables staggering.
       *
       * @sample {highcharts} highcharts/xaxis/labels-staggerlines/
       *         Show labels over two lines
       * @sample {highstock} stock/xaxis/labels-staggerlines/
       *         Show labels over two lines
       *
       * @since     2.1
       */
      staggerLines: 0,
      /**
       * To show only every _n_'th label on the axis, set the step to _n_.
       * Setting the step to 2 shows every other label.
       *
       * By default, when 0, the step is calculated automatically to avoid
       * overlap. To prevent this, set it to 1\. This usually only
       * happens on a category axis, and is often a sign that you have
       * chosen the wrong axis type.
       *
       * Read more at
       * [Axis docs](https://www.highcharts.com/docs/chart-concepts/axes)
       * => What axis should I use?
       *
       * @sample {highcharts} highcharts/xaxis/labels-step/
       *         Showing only every other axis label on a categorized
       *         x-axis
       * @sample {highcharts} highcharts/xaxis/labels-step-auto/
       *         Auto steps on a category axis
       *
       * @since     2.1
       */
      step: 0,
      /**
       * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
       * to render the labels.
       */
      useHTML: false,
      /**
       * The x position offset of all labels relative to the tick
       * positions on the axis. Overrides the `labels.distance` option.
       *
       * @type      {number}
       * @apioption xAxis.labels.x
       */
      /**
       * The y position offset of all labels relative to the tick
       * positions on the axis. Overrides the `labels.distance` option.
       *
       * @sample {highcharts} highcharts/xaxis/labels-x/
       *         X axis labels placed on grid lines
       *
       * @type      {number}
       * @apioption xAxis.labels.y
       */
      /**
       * The Z index for the axis labels.
       *
       * @see [axis.zIndex](#xAxis.zIndex)
       * @see [axis.gridZIndex](#xAxis.gridZIndex)
       */
      zIndex: 7,
      /**
       * CSS styles for the label. Use `lineClamp` to control wrapping of
       * category labels. Use `textOverflow: 'none'` to prevent ellipsis
       * (dots).
       *
       * In styled mode, the labels are styled with the
       * `.highcharts-axis-labels` class.
       *
       * @sample {highcharts} highcharts/xaxis/labels-style/
       *         Red X axis labels
       *
       * @type      {Highcharts.CSSObject}
       */
      style: {
        /** @internal */
        color: "#333333",
        /** @internal */
        cursor: "default",
        /**
         * @type {number|string}
         */
        fontSize: "0.8em",
        /** @internal */
        textOverflow: "ellipsis"
      }
    },
    /**
     * The left position as the horizontal axis. If it's a number, it is
     * interpreted as pixel position relative to the chart.
     *
     * Since Highcharts v5.0.13: If it's a percentage string, it is
     * interpreted as percentages of the plot width, offset from plot area
     * left.
     *
     * @sample {highcharts} highcharts/xaxis/axis-position-properties
     *         Different axis position properties
     *
     * @type      {number|string}
     * @product   highcharts highstock
     * @apioption xAxis.left
     */
    /**
     * The top position as the vertical axis. If it's a number, it is
     * interpreted as pixel position relative to the chart.
     *
     * Since Highcharts 2: If it's a percentage string, it is interpreted
     * as percentages of the plot height, offset from plot area top.
     *
     * @sample {highcharts} highcharts/xaxis/axis-position-properties
     *         Different axis position properties
     *
     * @type      {number|string}
     * @product   highcharts highstock
     * @apioption xAxis.top
     */
    /**
     * Index of another axis that this axis is linked to. When an axis is
     * linked to a master axis, it will take the same extremes as
     * the master, but as assigned by min or max or by setExtremes.
     * It can be used to show additional info, or to ease reading the
     * chart by duplicating the scales.
     *
     * @sample {highcharts} highcharts/xaxis/linkedto/
     *         Different string formats of the same date
     * @sample {highcharts} highcharts/yaxis/linkedto/
     *         Y values on both sides
     *
     * @type      {number}
     * @since     2.0.2
     * @product   highcharts highstock gantt
     * @apioption xAxis.linkedTo
     */
    /**
     * The maximum value of the axis. If `undefined`, the max value is
     * automatically calculated.
     *
     * If a datetime string is passed, it is parsed into epoch time
     * according to the time zone given in [time.timezone](#time.timezone).
     *
     * If the [endOnTick](#yAxis.endOnTick) option is true, the `max` value
     * might be rounded up.
     *
     * If a [tickAmount](#yAxis.tickAmount) is set, the axis may be extended
     * beyond the set max in order to reach the given number of ticks. The
     * same may happen in a chart with multiple axes, determined by [chart.
     * alignTicks](#chart), where a `tickAmount` is applied internally.
     *
     * @sample {highcharts} highcharts/yaxis/max-200/
     *         Y axis max of 200
     * @sample {highcharts} highcharts/yaxis/max-logarithmic/
     *         Y axis max on logarithmic axis
     * @sample {highstock} stock/xaxis/min-max/
     *         Fixed min and max on X axis
     *
     * @type      {number|string|null}
     * @apioption xAxis.max
     */
    /**
     * Padding of the max value relative to the length of the axis. A
     * padding of 0.05 will make a 100px axis 5px longer. This is useful
     * when you don't want the highest data value to appear on the edge
     * of the plot area. When the axis' `max` option is set or a max extreme
     * is set using `axis.setExtremes()`, the maxPadding will be ignored.
     *
     * @productdesc {highstock}
     * For an [ordinal](#xAxis.ordinal) axis, `minPadding` and `maxPadding`
     * are ignored. Use [overscroll](#xAxis.overscroll) instead.
     *
     * @sample {highcharts} highcharts/yaxis/maxpadding/
     *         Max padding of 0.25 on y axis
     * @sample {highstock} stock/xaxis/minpadding-maxpadding/
     *         Greater min- and maxPadding
     * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
     *         Add some padding
     *
     * @default   {highcharts} 0.01
     * @default   {highstock|highmaps} 0
     * @since     1.2.0
     */
    maxPadding: 0.01,
    /**
     * Deprecated. Use `minRange` instead.
     *
     * @deprecated
     * @type      {number}
     * @product   highcharts highstock
     * @apioption xAxis.maxZoom
     */
    /**
     * The minimum value of the axis. If `undefined`, the min value is
     * automatically calculated.
     *
     * If a datetime string is passed, it is parsed into epoch time
     * according to the time zone given in [time.timezone](#time.timezone).
     *
     * If the [startOnTick](#yAxis.startOnTick) option is true (default),
     * the `min` value might be rounded down.
     *
     * The automatically calculated minimum value is also affected by
     * [floor](#yAxis.floor), [softMin](#yAxis.softMin),
     * [minPadding](#yAxis.minPadding), [minRange](#yAxis.minRange)
     * as well as [series.threshold](#plotOptions.series.threshold)
     * and [series.softThreshold](#plotOptions.series.softThreshold).
     *
     * @sample {highcharts} highcharts/yaxis/min-startontick-false/
     *         -50 with startOnTick to false
     * @sample {highcharts} highcharts/yaxis/min-startontick-true/
     *         -50 with startOnTick true by default
     * @sample {highstock} stock/xaxis/min-max/
     *         Set min and max on X axis
     *
     * @type      {number|string|null}
     * @apioption xAxis.min
     */
    /**
     * The dash or dot style of the minor grid lines. For possible values,
     * see [this demonstration](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/).
     *
     * @sample {highcharts} highcharts/yaxis/minorgridlinedashstyle/
     *         Long dashes on minor grid lines
     * @sample {highstock} stock/xaxis/minorgridlinedashstyle/
     *         Long dashes on minor grid lines
     *
     * @type      {Highcharts.DashStyleValue}
     * @since     1.2
     */
    minorGridLineDashStyle: "Solid",
    /**
     * Specific tick interval in axis units for the minor ticks. On a linear
     * axis, if `"auto"`, the minor tick interval is calculated as a fifth
     * of the tickInterval. If `undefined`, minor ticks are not shown.
     *
     * On logarithmic axes, the unit is the power of the value. For example,
     * setting the minorTickInterval to 1 puts one tick on each of 0.1, 1,
     * 10, 100 etc. Setting the minorTickInterval to 0.1 produces 9 ticks
     * between 1 and 10, 10 and 100 etc.
     *
     * If user settings dictate minor ticks to become too dense, they don't
     * make sense, and will be ignored to prevent performance problems.
     *
     * @sample {highcharts} highcharts/yaxis/minortickinterval-null/
     *         Undefined by default
     * @sample {highcharts} highcharts/yaxis/minortickinterval-5/ 5 units
     * @sample {highcharts} highcharts/yaxis/minortickinterval-log-auto/
     *         "auto"
     * @sample {highcharts} highcharts/yaxis/minortickinterval-log/ 0.1
     * @sample {highstock} stock/demo/basic-line/ Null by default
     * @sample {highstock} stock/xaxis/minortickinterval-auto/ "auto"
     *
     * @type      {number|'auto'}
     * @apioption xAxis.minorTickInterval
     */
    /**
     * The pixel length of the minor tick marks.
     *
     * @sample {highcharts} highcharts/yaxis/minorticklength/
     *         10px on Y axis
     * @sample {highstock} stock/xaxis/minorticks/
     *         10px on Y axis
     */
    minorTickLength: 2,
    /**
     * The position of the minor tick marks relative to the axis line.
     *  Can be one of `inside` and `outside`.
     *
     * @sample {highcharts} highcharts/yaxis/minortickposition-outside/
     *         Outside by default
     * @sample {highcharts} highcharts/yaxis/minortickposition-inside/
     *         Inside
     * @sample {highstock} stock/xaxis/minorticks/
     *         Inside
     *
     * @validvalue ["inside", "outside"]
     */
    minorTickPosition: "outside",
    /**
     * Enable or disable minor ticks. The interval between the minor ticks
     * can be controlled either by the
     * [minorTicksPerMajor](#xAxis.minorTicksPerMajor) setting, or as an
     * absolute [minorTickInterval](#xAxis.minorTickInterval) value.
     *
     * On a logarithmic axis, minor ticks are laid out based on a best
     * guess, attempting to enter an approximate number of minor ticks
     * between each major tick based on
     * [minorTicksPerMajor](#xAxis.minorTicksPerMajor).
     *
     * Prior to v6.0.0, ticks were enabled in auto layout by setting
     * `minorTickInterval` to `"auto"`.
     *
     * @productdesc {highcharts} On axes using
     * [categories](#xAxis.categories), minor ticks are not supported.
     *
     * @sample {highcharts} highcharts/yaxis/minorticks-true/ Enabled on
     *         linear Y axis
     *
     * @type      {boolean}
     * @default   false
     * @since     6.0.0
     * @apioption xAxis.minorTicks
     */
    /**
     * The number of minor ticks per major tick. Works for `linear`,
     * `logarithmic` and `datetime` axes.
     *
     * @sample {highcharts} highcharts/yaxis/minortickspermajor/
     *         2 minor ticks per major tick on Y axis
     *
     * @since  11.0.0
     *
     * @type {number}
     */
    minorTicksPerMajor: 5,
    /**
     * The pixel width of the minor tick mark.
     *
     * @sample {highcharts} highcharts/yaxis/minortickwidth/
     *         3px width
     * @sample {highstock} stock/xaxis/minorticks/
     *         1px width
     *
     * @type      {number}
     * @default   0
     * @apioption xAxis.minorTickWidth
     */
    /**
     * Padding of the min value relative to the length of the axis. A
     * padding of 0.05 will make a 100px axis 5px longer. This is useful
     * when you don't want the lowest data value to appear on the edge
     * of the plot area. When the axis' `min` option is set or a min extreme
     * is set using `axis.setExtremes()`, the minPadding will be ignored.
     *
     * @productdesc {highstock}
     * For an [ordinal](#xAxis.ordinal) axis, `minPadding` and `maxPadding`
     * are ignored. Use [overscroll](#xAxis.overscroll) instead.
     *
     * @sample {highcharts} highcharts/yaxis/minpadding/
     *         Min padding of 0.2
     * @sample {highstock} stock/xaxis/minpadding-maxpadding/
     *         Greater min- and maxPadding
     * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
     *         Add some padding
     *
     * @default    {highcharts} 0.01
     * @default    {highstock|highmaps} 0
     * @since      1.2.0
     * @product    highcharts highstock gantt
     */
    minPadding: 0.01,
    /**
     * The minimum range to display on this axis. The entire axis will not
     * be allowed to span over a smaller interval than this. For example,
     * for a datetime axis the main unit is milliseconds. If minRange is
     * set to 3600000, you can't zoom in more than to one hour.
     *
     * The default minRange for the x axis is five times the smallest
     * interval between any of the data points.
     *
     * On a logarithmic axis, the unit for the minimum range is the power.
     * So a minRange of 1 means that the axis can be zoomed to 10-100,
     * 100-1000, 1000-10000 etc.
     *
     * **Note**: The `minPadding`, `maxPadding`, `startOnTick` and
     * `endOnTick` settings also affect how the extremes of the axis
     * are computed.
     *
     * @sample {highcharts} highcharts/xaxis/minrange/
     *         Minimum range of 5
     * @sample {highstock} stock/xaxis/minrange/
     *         Max zoom of 6 months overrides user selections
     *
     * @type      {number}
     * @apioption xAxis.minRange
     */
    /**
     * The minimum tick interval allowed in axis values. For example on
     * zooming in on an axis with daily data, this can be used to prevent
     * the axis from showing hours. Defaults to the closest distance between
     * two points on the axis.
     *
     * @type      {number}
     * @since     2.3.0
     * @apioption xAxis.minTickInterval
     */
    /**
     * The distance in pixels from the plot area to the axis line.
     * A positive offset moves the axis with it's line, labels and ticks
     * away from the plot area. This is typically used when two or more
     * axes are displayed on the same side of the plot. With multiple
     * axes the offset is dynamically adjusted to avoid collision, this
     * can be overridden by setting offset explicitly.
     *
     * @sample {highcharts} highcharts/yaxis/offset/
     *         Y axis offset of 70
     * @sample {highcharts} highcharts/yaxis/offset-centered/
     *         Axes positioned in the center of the plot
     * @sample {highstock} stock/xaxis/offset/
     *         Y axis offset by 70 px
     *
     * @type {number}
     */
    offset: void 0,
    /**
     * Whether to display the axis on the opposite side of the normal. The
     * normal is on the left side for vertical axes and bottom for
     * horizontal, so the opposite sides will be right and top respectively.
     * This is typically used with dual or multiple axes.
     *
     * @sample {highcharts} highcharts/yaxis/opposite/
     *         Secondary Y axis opposite
     * @sample {highstock} stock/xaxis/opposite/
     *         Y axis on left side
     *
     * @default   {highcharts|highstock|highmaps} false
     * @default   {gantt} true
     * @type      Boolean
     * @apioption xAxis.opposite
     */
    /**
     * In an ordinal axis, the points are equally spaced in the chart
     * regardless of the actual time or x distance between them. This means
     * that missing data periods (e.g. nights or weekends for a stock chart)
     * will not take up space in the chart.
     * Having `ordinal: false` will show any gaps created by the `gapSize`
     * setting proportionate to their duration.
     *
     * In stock charts the X axis is ordinal by default, unless
     * the boost module is used and at least one of the series' data length
     * exceeds the [boostThreshold](#series.line.boostThreshold).
     *
     * For an ordinal axis, `minPadding` and `maxPadding` are ignored. Use
     * [overscroll](#xAxis.overscroll) instead.
     *
     * @sample {highstock} stock/xaxis/ordinal-true/
     *         True by default
     * @sample {highstock} stock/xaxis/ordinal-false/
     *         False
     *
     * @see [overscroll](#xAxis.overscroll)
     *
     * @type      {boolean}
     * @default   true
     * @since     1.1
     * @product   highstock
     * @apioption xAxis.ordinal
     */
    /**
     * Additional range on the right side of the xAxis. Works similar to
     * `xAxis.maxPadding`, but the value is set in terms of axis values,
     * percentage or pixels.
     *
     * If it's a number, it is interpreted as axis values, which in a
     * datetime axis equals milliseconds.
     *
     * If it's a percentage string, is interpreted as percentages of axis
     * length. An overscroll of 50% will make a 100px axis 50px longer.
     *
     * If it's a pixel string, it is interpreted as a fixed pixel value, but
     * limited to 90% of the axis length.
     *
     * @sample {highstock} stock/xaxis/overscroll/ One minute overscroll
     *         with live data
     * @sample {highstock} stock/xaxis/overscroll-percent/ Overscroll set in
     *         percentage
     * @sample {highstock} stock/xaxis/overscroll-pixel/ Overscroll set in
     *         pixels
     *
     * @type      {number | string}
     * @default   0
     * @since     6.0.0
     * @product   highstock
     * @apioption xAxis.overscroll
     */
    /**
     * Refers to the index in the [panes](#panes) array. Used for circular
     * gauges and polar charts. When the option is not set then first pane
     * will be used.
     *
     * @sample highcharts/demo/gauge-vu-meter
     *         Two gauges with different center
     *
     * @type      {number}
     * @product   highcharts
     * @apioption xAxis.pane
     */
    /**
     * The zoomed range to display when only defining one or none of `min`
     * or `max`. For example, to show the latest month, a range of one month
     * can be set.
     *
     * @sample {highstock} stock/xaxis/range/
     *         Setting a zoomed range when the rangeSelector is disabled
     *
     * @type      {number}
     * @product   highstock
     * @apioption xAxis.range
     */
    /**
     * Whether to reverse the axis so that the highest number is closest
     * to the origin. If the chart is inverted, the x axis is reversed by
     * default.
     *
     * @sample {highcharts} highcharts/yaxis/reversed/
     *         Reversed Y axis
     * @sample {highstock} stock/xaxis/reversed/
     *         Reversed Y axis
     *
     * @type      {boolean}
     * @default   undefined
     * @apioption xAxis.reversed
     */
    reversed: void 0,
    /**
     * This option determines how stacks should be ordered within a group.
     * For example reversed xAxis also reverses stacks, so first series
     * comes last in a group. To keep order like for non-reversed xAxis
     * enable this option.
     *
     * @sample {highcharts} highcharts/xaxis/reversedstacks/
     *         Reversed stacks comparison
     * @sample {highstock} highcharts/xaxis/reversedstacks/
     *         Reversed stacks comparison
     *
     * @since     6.1.1
     * @product   highcharts highstock
     */
    reversedStacks: false,
    /**
     * An optional scrollbar to display on the X axis in response to
     * limiting the minimum and maximum of the axis values.
     *
     * In styled mode, all the presentational options for the scrollbar are
     * replaced by the classes `.highcharts-scrollbar-thumb`,
     * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
     * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
     *
     * @sample {highstock} stock/yaxis/heatmap-scrollbars/
     *         Heatmap with both scrollbars
     *
     * @extends   scrollbar
     * @since     4.2.6
     * @product   highstock
     * @apioption xAxis.scrollbar
     */
    /**
     * Whether to show the axis line and title when the axis has no data.
     *
     * @sample {highcharts} highcharts/yaxis/showempty/
     *         When clicking the legend to hide series, one axis preserves
     *         line and title, the other doesn't
     * @sample {highstock} highcharts/yaxis/showempty/
     *         When clicking the legend to hide series, one axis preserves
     *         line and title, the other doesn't
     *
     * @since     1.1
     */
    showEmpty: true,
    /**
     * Whether to show the first tick label.
     *
     * @sample {highcharts} highcharts/xaxis/showfirstlabel-false/
     *         Set to false on X axis
     * @sample {highstock} stock/xaxis/showfirstlabel/
     *         Labels below plot lines on Y axis
     */
    showFirstLabel: true,
    /**
     * Whether to show the last tick label. Defaults to `true` on cartesian
     * charts, and `false` on polar charts.
     *
     * @sample {highcharts} highcharts/xaxis/showlastlabel-true/
     *         Set to true on X axis
     * @sample {highstock} stock/xaxis/showfirstlabel/
     *         Labels below plot lines on Y axis
     *
     * @type    {boolean}
     * @default undefined
     * @product highcharts highstock gantt
     */
    showLastLabel: true,
    /**
     * A soft maximum for the axis. If the series data maximum is less than
     * this, the axis will stay at this maximum, but if the series data
     * maximum is higher, the axis will flex to show all data.
     *
     * @sample highcharts/yaxis/softmin-softmax/
     *         Soft min and max
     *
     * @type      {number}
     * @since     5.0.1
     * @product   highcharts highstock gantt
     * @apioption xAxis.softMax
     */
    /**
     * A soft minimum for the axis. If the series data minimum is greater
     * than this, the axis will stay at this minimum, but if the series
     * data minimum is lower, the axis will flex to show all data.
     *
     * @sample highcharts/yaxis/softmin-softmax/
     *         Soft min and max
     *
     * @type      {number}
     * @since     5.0.1
     * @product   highcharts highstock gantt
     * @apioption xAxis.softMin
     */
    /**
     * For datetime axes, this decides where to put the tick between weeks.
     *  0 = Sunday, 1 = Monday.
     *
     * @sample {highcharts} highcharts/xaxis/startofweek-monday/
     *         Monday by default
     * @sample {highcharts} highcharts/xaxis/startofweek-sunday/
     *         Sunday
     * @sample {highstock} stock/xaxis/startofweek-1
     *         Monday by default
     * @sample {highstock} stock/xaxis/startofweek-0
     *         Sunday
     *
     * @product highcharts highstock gantt
     */
    startOfWeek: 1,
    /**
     * Whether to force the axis to start on a tick. Use this option with
     * the `minPadding` option to control the axis start.
     *
     * @productdesc {highstock}
     * In Highcharts Stock, `startOnTick` is always `false` when
     * the navigator is enabled, to prevent jumpy scrolling.
     *
     * @sample {highcharts} highcharts/xaxis/startontick-false/
     *         False by default
     * @sample {highcharts} highcharts/xaxis/startontick-true/
     *         True
     *
     * @since 1.2.0
     */
    startOnTick: false,
    /**
     * The amount of ticks to draw on the axis. This opens up for aligning
     * the ticks of multiple charts or panes within a chart. This option
     * overrides the `tickPixelInterval` option.
     *
     * This option only has an effect on linear axes. Datetime, logarithmic
     * or category axes are not affected.
     *
     * @sample {highcharts} highcharts/yaxis/tickamount/
     *         8 ticks on Y axis
     * @sample {highstock} highcharts/yaxis/tickamount/
     *         8 ticks on Y axis
     *
     * @type      {number}
     * @since     4.1.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.tickAmount
     */
    /**
     * The interval of the tick marks in axis units. When `undefined`, the
     * tick interval is computed to approximately follow the
     * [tickPixelInterval](#xAxis.tickPixelInterval) on linear and datetime
     * axes. On categorized axes, a `undefined` tickInterval will default to
     * 1, one category. Note that datetime axes are based on milliseconds,
     * so for example an interval of one day is expressed as
     * `24 * 3600 * 1000`.
     *
     * On logarithmic axes, the tickInterval is based on powers, so a
     * tickInterval of 1 means one tick on each of 0.1, 1, 10, 100 etc. A
     * tickInterval of 2 means a tick of 0.1, 10, 1000 etc. A tickInterval
     * of 0.2 puts a tick on 0.1, 0.2, 0.4, 0.6, 0.8, 1, 2, 4, 6, 8, 10, 20,
     * 40 etc.
     *
     *
     * If the tickInterval is too dense for labels to be drawn, Highcharts
     * may remove ticks.
     *
     * If the chart has multiple axes, the [alignTicks](#chart.alignTicks)
     * option may interfere with the `tickInterval` setting.
     *
     * @see [tickPixelInterval](#xAxis.tickPixelInterval)
     * @see [tickPositions](#xAxis.tickPositions)
     * @see [tickPositioner](#xAxis.tickPositioner)
     *
     * @sample {highcharts} highcharts/xaxis/tickinterval-5/
     *         Tick interval of 5 on a linear axis
     * @sample {highstock} stock/xaxis/tickinterval/
     *         Tick interval of 0.01 on Y axis
     *
     * @type      {number}
     * @apioption xAxis.tickInterval
     */
    /**
     * The pixel length of the main tick marks.
     *
     * @sample {highcharts} highcharts/xaxis/ticklength/
     *         20 px tick length on the X axis
     * @sample {highstock} stock/xaxis/ticks/
     *         Formatted ticks on X axis
     */
    tickLength: 10,
    /**
     * If tickInterval is `null` this option sets the approximate pixel
     * interval of the tick marks. Not applicable to categorized axis.
     *
     * The tick interval is also influenced by the [minTickInterval](
     * #xAxis.minTickInterval) option, that, by default prevents ticks from
     * being denser than the data points.
     *
     * @see [tickInterval](#xAxis.tickInterval)
     * @see [tickPositioner](#xAxis.tickPositioner)
     * @see [tickPositions](#xAxis.tickPositions)
     *
     * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/
     *         50 px on X axis
     * @sample {highstock} stock/xaxis/tickpixelinterval/
     *         200 px on X axis
     */
    tickPixelInterval: 100,
    /**
     * For categorized axes only. If `on` the tick mark is placed in the
     * center of the category, if `between` the tick mark is placed between
     * categories. The default is `between` if the `tickInterval` is 1, else
     * `on`. In order to render tick marks on a category axis it is necessary
     * to provide a [tickWidth](#xAxis.tickWidth).
     *
     * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/
     *         "between" by default
     * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/
     *         "on"
     *
     * @product    highcharts gantt
     * @validvalue ["on", "between"]
     */
    tickmarkPlacement: "between",
    /**
     * The position of the major tick marks relative to the axis line.
     * Can be one of `inside` and `outside`.
     *
     * @sample {highcharts} highcharts/xaxis/tickposition-outside/
     *         "outside" by default
     * @sample {highcharts} highcharts/xaxis/tickposition-inside/
     *         "inside"
     * @sample {highstock} stock/xaxis/ticks/
     *         Formatted ticks on X axis
     *
     * @validvalue ["inside", "outside"]
     */
    tickPosition: "outside",
    /**
     * A callback function returning array defining where the ticks are
     * laid out on the axis. This overrides the default behaviour of
     * [tickPixelInterval](#xAxis.tickPixelInterval) and [tickInterval](
     * #xAxis.tickInterval). The automatic tick positions are accessible
     * through `this.tickPositions` and can be modified by the callback.
     *
     * @see [tickPositions](#xAxis.tickPositions)
     *
     * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
     *         Demo of tickPositions and tickPositioner
     * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
     *         Demo of tickPositions and tickPositioner
     *
     * @type      {Highcharts.AxisTickPositionerCallbackFunction}
     * @apioption xAxis.tickPositioner
     */
    /**
     * An array defining where the ticks are laid out on the axis. This
     * overrides the default behaviour of [tickPixelInterval](
     * #xAxis.tickPixelInterval) and [tickInterval](#xAxis.tickInterval).
     *
     * @see [tickPositioner](#xAxis.tickPositioner)
     *
     * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
     *         Demo of tickPositions and tickPositioner
     * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
     *         Demo of tickPositions and tickPositioner
     *
     * @type      {Array<number>}
     * @apioption xAxis.tickPositions
     */
    /**
     * The pixel width of the major tick marks. Defaults to 0 on category
     * axes, otherwise 1.
     *
     * In styled mode, the stroke width is given in the `.highcharts-tick`
     * class, but in order for the element to be generated on category axes,
     * the option must be explicitly set to 1.
     *
     * @sample {highcharts} highcharts/xaxis/tickwidth/
     *         10 px width
     * @sample {highcharts} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/ticks/
     *         Formatted ticks on X axis
     * @sample {highstock} highcharts/css/axis-grid/
     *         Styled mode
     *
     * @type      {undefined|number}
     * @default   {highstock} 1
     * @default   {highmaps} 0
     * @apioption xAxis.tickWidth
     */
    /**
     * The axis title, showing next to the axis line.
     *
     * @productdesc {highmaps}
     * In Highmaps, the axis is hidden by default, but adding an axis title
     * is still possible. X axis and Y axis titles will appear at the bottom
     * and left by default.
     */
    title: {
      /**
       * Alignment of the title relative to the axis values. Possible
       * values are "low", "middle" or "high".
       *
       * @sample {highcharts} highcharts/xaxis/title-align-low/
       *         "low"
       * @sample {highcharts} highcharts/xaxis/title-align-center/
       *         "middle" by default
       * @sample {highcharts} highcharts/xaxis/title-align-high/
       *         "high"
       * @sample {highcharts} highcharts/yaxis/title-offset/
       *         Place the Y axis title on top of the axis
       * @sample {highstock} stock/xaxis/title-align/
       *         Aligned to "high" value
       *
       * @type {Highcharts.AxisTitleAlignValue}
       */
      align: "middle",
      /**
       * Deprecated. Set the `text` to `undefined` to disable the title.
       *
       * @deprecated
       * @type      {boolean}
       * @product   highcharts
       * @apioption xAxis.title.enabled
       */
      /**
       * The pixel distance between the axis labels or line and the title.
       * Defaults to 0 for horizontal axes, 10 for vertical
       *
       * @sample {highcharts} highcharts/xaxis/title-margin/
       *         Y axis title margin of 60
       *
       * @type      {number}
       * @apioption xAxis.title.margin
       */
      /**
       * The distance of the axis title from the axis line. By default,
       * this distance is computed from the offset width of the labels,
       * the labels' distance from the axis and the title's margin.
       * However when the offset option is set, it overrides all this.
       *
       * @sample {highcharts} highcharts/yaxis/title-offset/
       *         Place the axis title on top of the axis
       * @sample {highstock} highcharts/yaxis/title-offset/
       *         Place the axis title on top of the Y axis
       *
       * @type      {number}
       * @since     2.2.0
       * @apioption xAxis.title.offset
       */
      /**
       * Whether to reserve space for the title when laying out the axis.
       *
       * @type      {boolean}
       * @default   true
       * @since     5.0.11
       * @product   highcharts highstock gantt
       * @apioption xAxis.title.reserveSpace
       */
      /**
       * The rotation of the text in degrees. 0 is horizontal, 270 is
       * vertical reading from bottom to top. Defaults to 0 for horizontal
       * axes, 270 for left-side axes and 90 for right-side axes.
       *
       * @sample    {highcharts} highcharts/yaxis/title-offset/
       *            Horizontal
       *
       * @type      {number}
       * @default   undefined
       * @apioption xAxis.title.rotation
       */
      /**
       * The actual text of the axis title. It can contain basic HTML tags
       * like `b`, `i` and `span` with style.
       *
       * @sample {highcharts} highcharts/xaxis/title-text/
       *         Custom HTML
       * @sample {highstock} stock/xaxis/title-text/
       *         Titles for both axes
       *
       * @type      {string|null}
       * @apioption xAxis.title.text
       */
      /**
       * Alignment of the text, can be `"left"`, `"right"` or `"center"`.
       * Default alignment depends on the
       * [title.align](xAxis.title.align):
       *
       * Horizontal axes:
       * - for `align` = `"low"`, `textAlign` is set to `left`
       * - for `align` = `"middle"`, `textAlign` is set to `center`
       * - for `align` = `"high"`, `textAlign` is set to `right`
       *
       * Vertical axes:
       * - for `align` = `"low"` and `opposite` = `true`, `textAlign` is
       *   set to `right`
       * - for `align` = `"low"` and `opposite` = `false`, `textAlign` is
       *   set to `left`
       * - for `align` = `"middle"`, `textAlign` is set to `center`
       * - for `align` = `"high"` and `opposite` = `true` `textAlign` is
       *   set to `left`
       * - for `align` = `"high"` and `opposite` = `false` `textAlign` is
       *   set to `right`
       *
       * @type      {Highcharts.AlignValue}
       * @apioption xAxis.title.textAlign
       */
      /**
       * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
       * to render the axis title.
       *
       * @product   highcharts highstock gantt
       */
      useHTML: false,
      /**
       * Horizontal pixel offset of the title position.
       *
       * @since     4.1.6
       * @product   highcharts highstock gantt
       */
      x: 0,
      /**
       * Vertical pixel offset of the title position.
       *
       * @product   highcharts highstock gantt
       */
      y: 0,
      /**
       * CSS styles for the title. If the title text is longer than the
       * axis length, it will wrap to multiple lines by default. This can
       * be customized by setting the `lineClamp` property, by setting a
       * specific `width` or by setting `whiteSpace: 'nowrap'`.
       *
       * In styled mode, the stroke width is given in the
       * `.highcharts-axis-title` class.
       *
       * @sample {highcharts} highcharts/xaxis/title-style/
       *         Red
       * @sample {highcharts} highcharts/css/axis/
       *         Styled mode
       *
       * @type    {Highcharts.CSSObject}
       */
      style: {
        /** @internal */
        color: "#666666",
        /**
         * @type {number|string}
         */
        fontSize: "0.8em"
      }
    },
    /**
     * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`
     * or `category`. In a datetime axis, the numbers are given in
     * milliseconds, and tick marks are placed on appropriate values like
     * full hours or days. In a category axis, the
     * [point names](#series.line.data.name) of the chart's series are used
     * for categories, if not a [categories](#xAxis.categories) array is
     * defined.
     *
     * @sample {highcharts} highcharts/xaxis/type-linear/
     *         Linear
     * @sample {highcharts} highcharts/yaxis/type-log/
     *         Logarithmic
     * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
     *         Logarithmic with minor grid lines
     * @sample {highcharts} highcharts/xaxis/type-log-both/
     *         Logarithmic on two axes
     * @sample {highcharts} highcharts/yaxis/type-log-negative/
     *         Logarithmic with extension to emulate negative values
     *
     * @type    {Highcharts.AxisTypeValue}
     * @default linear
     * @product highcharts gantt
     * @apioption xAxis.type
     */
    /**
     * If there are multiple axes on the same side of the chart, the pixel
     * margin between the axes. Defaults to 0 on vertical axes, 15 on
     * horizontal axes.
     *
     * @type      {number}
     * @since     7.0.3
     * @apioption xAxis.margin
     */
    /**
     * Applies only when the axis `type` is `category`. When `uniqueNames`
     * is true, points are placed on the X axis according to their names.
     * If the same point name is repeated in the same or another series,
     * the point is placed on the same X position as other points of the
     * same name. When `uniqueNames` is false, the points are laid out in
     * increasing X positions regardless of their names, and the X axis
     * category will take the name of the last point in each position.
     *
     * @sample {highcharts} highcharts/xaxis/uniquenames-true/
     *         True by default
     * @sample {highcharts} highcharts/xaxis/uniquenames-false/
     *         False
     *
     * @since     4.2.7
     * @product   highcharts gantt
     * @type      {boolean}
     * @default   true
     * @apioption xAxis.uniqueNames
     */
    /**
     * Datetime axis only. An array determining what time intervals the
     * ticks are allowed to fall on. Each array item is an array where the
     * first value is the time unit and the second value another array of
     * allowed multiples.
     *
     * Defaults to:
     * ```js
     * units: [[
     *     'millisecond', // unit name
     *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
     * ], [
     *     'second',
     *     [1, 2, 5, 10, 15, 30]
     * ], [
     *     'minute',
     *     [1, 2, 5, 10, 15, 30]
     * ], [
     *     'hour',
     *     [1, 2, 3, 4, 6, 8, 12]
     * ], [
     *     'day',
     *     [1, 2]
     * ], [
     *     'week',
     *     [1, 2]
     * ], [
     *     'month',
     *     [1, 2, 3, 4, 6]
     * ], [
     *     'year',
     *     null
     * ]]
     * ```
     *
     * @sample {highcharts} highcharts/xaxis/units/
     *         Axis units demonstrated
     *
     * @type      {Array<Array<string,(Array<number>|null)>>}
     * @product   highcharts highstock gantt
     * @apioption xAxis.units
     */
    /**
     * Whether axis, including axis title, line, ticks and labels, should
     * be visible.
     *
     * @since     4.1.9
     * @product   highcharts highstock gantt
     */
    visible: true,
    /**
     * Color of the minor, secondary grid lines.
     *
     * In styled mode, the stroke width is given in the
     * `.highcharts-minor-grid-line` class.
     *
     * @sample {highcharts} highcharts/yaxis/minorgridlinecolor/
     *         Bright grey lines from Y axis
     * @sample {highcharts|highstock} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/minorgridlinecolor/
     *         Bright grey lines from Y axis
     *
     * @type    {Highcharts.ColorType}
     * @default #f2f2f2
     */
    minorGridLineColor: "#f2f2f2",
    /**
     * Width of the minor, secondary grid lines.
     *
     * In styled mode, the stroke width is given in the
     * `.highcharts-grid-line` class.
     *
     * @sample {highcharts} highcharts/yaxis/minorgridlinewidth/
     *         2px lines from Y axis
     * @sample {highcharts|highstock} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/minorgridlinewidth/
     *         2px lines from Y axis
     */
    minorGridLineWidth: 1,
    /**
     * Color for the minor tick marks.
     *
     * @sample {highcharts} highcharts/yaxis/minortickcolor/
     *         Black tick marks on Y axis
     * @sample {highstock} stock/xaxis/minorticks/
     *         Black tick marks on Y axis
     *
     * @type    {Highcharts.ColorType}
     * @default #999999
     */
    minorTickColor: "#999999",
    /**
     * The color of the line marking the axis itself.
     *
     * In styled mode, the line stroke is given in the
     * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
     *
     * @sample {highcharts} highcharts/yaxis/linecolor/
     *         A red line on Y axis
     * @sample {highcharts|highstock} highcharts/css/axis/
     *         Axes in styled mode
     * @sample {highstock} stock/xaxis/linecolor/
     *         A red line on X axis
     *
     * @type    {Highcharts.ColorType}
     */
    lineColor: "#333333",
    /**
     * The width of the line marking the axis itself.
     *
     * In styled mode, the stroke width is given in the
     * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
     *
     * @sample {highcharts} highcharts/yaxis/linecolor/
     *         A 1px line on Y axis
     * @sample {highcharts|highstock} highcharts/css/axis/
     *         Axes in styled mode
     * @sample {highstock} stock/xaxis/linewidth/
     *         A 2px line on X axis
     *
     * @default {highcharts|highstock} 1
     * @default {highmaps} 0
     */
    lineWidth: 1,
    /**
     * Color of the grid lines extending the ticks across the plot area.
     *
     * In styled mode, the stroke is given in the `.highcharts-grid-line`
     * class.
     *
     * @productdesc {highmaps}
     * In Highmaps, the grid lines are hidden by default.
     *
     * @sample {highcharts} highcharts/yaxis/gridlinecolor/
     *         Green lines
     * @sample {highcharts|highstock} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/gridlinecolor/
     *         Green lines
     *
     * @type    {Highcharts.ColorType}
     * @default #e6e6e6
     */
    gridLineColor: "#e6e6e6",
    /**
     * The width of the grid lines extending the ticks across the plot area.
     * Defaults to 1 on the Y axis and 0 on the X axis, except for 3d
     * charts.
     *
     * In styled mode, the stroke width is given in the
     * `.highcharts-grid-line` class.
     *
     * @sample {highcharts} highcharts/yaxis/gridlinewidth/
     *         2px lines
     * @sample {highcharts|highstock} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/gridlinewidth/
     *         2px lines
     *
     * @type      {number}
     * @apioption xAxis.gridLineWidth
     */
    gridLineWidth: void 0,
    /**
     * The height as the vertical axis. If it's a number, it is
     * interpreted as pixels.
     *
     * Since Highcharts 2: If it's a percentage string, it is interpreted
     * as percentages of the total plot height.
     *
     * @sample {highcharts} highcharts/xaxis/axis-position-properties
     *         Different axis position properties
     *
     * @type      {number|string}
     * @product   highcharts highstock
     * @apioption xAxis.height
     */
    /**
     * The width as the horizontal axis. If it's a number, it is interpreted
     * as pixels.
     *
     * Since Highcharts v5.0.13: If it's a percentage string, it is
     * interpreted as percentages of the total plot width.
     *
     * @sample {highcharts} highcharts/xaxis/axis-position-properties
     *         Different axis position properties
     *
     * @type      {number|string}
     * @product   highcharts highstock
     * @apioption xAxis.width
     */
    /**
     * Color for the main tick marks.
     *
     * In styled mode, the stroke is given in the `.highcharts-tick`
     * class.
     *
     * @sample {highcharts} highcharts/xaxis/tickcolor/
     *         Red ticks on X axis
     * @sample {highcharts|highstock} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/ticks/
     *         Formatted ticks on X axis
     *
     * @type    {Highcharts.ColorType}
     */
    tickColor: "#333333"
    /* Palette.neutralColor80 */
    // `tickWidth: 1`
  };
  AxisDefaults2.yAxis = {
    /**
     * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`,
     * `category` or `treegrid`. Defaults to `treegrid` for Gantt charts,
     * `linear` for other chart types.
     *
     * In a datetime axis, the numbers are given in milliseconds, and tick
     * marks are placed on appropriate values, like full hours or days. In a
     * category or treegrid axis, the [point names](#series.line.data.name)
     * of the chart's series are used for categories, if a
     * [categories](#xAxis.categories) array is not defined.
     *
     * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
     *         Logarithmic with minor grid lines
     * @sample {highcharts} highcharts/yaxis/type-log-negative/
     *         Logarithmic with extension to emulate negative values
     * @sample {gantt} gantt/treegrid-axis/demo
     *         Treegrid axis
     *
     * @type      {Highcharts.AxisTypeValue}
     * @default   {highcharts} linear
     * @default   {gantt} treegrid
     * @product   highcharts gantt
     * @apioption yAxis.type
     */
    /**
     * The height of the Y axis. If it's a number, it is interpreted as
     * pixels.
     *
     * Since Highcharts 2: If it's a percentage string, it is interpreted as
     * percentages of the total plot height.
     *
     * @see [yAxis.top](#yAxis.top)
     *
     * @sample {highstock} stock/demo/candlestick-and-volume/
     *         Percentage height panes
     *
     * @type      {number|string}
     * @product   highcharts highstock
     * @apioption yAxis.height
     */
    /**
     * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
     * to represent the maximum value of the Y axis.
     *
     * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
     *         Min and max colors
     *
     * @type      {Highcharts.ColorType}
     * @default   #003399
     * @since     4.0
     * @product   highcharts
     * @apioption yAxis.maxColor
     */
    /**
     * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
     * to represent the minimum value of the Y axis.
     *
     * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
     *         Min and max color
     *
     * @type      {Highcharts.ColorType}
     * @default   #e6ebf5
     * @since     4.0
     * @product   highcharts
     * @apioption yAxis.minColor
     */
    /**
     * Whether to reverse the axis so that the highest number is closest
     * to the origin.
     *
     * @sample {highcharts} highcharts/yaxis/reversed/
     *         Reversed Y axis
     * @sample {highstock} stock/xaxis/reversed/
     *         Reversed Y axis
     *
     * @type      {boolean}
     * @default   {highcharts} false
     * @default   {highstock} false
     * @default   {highmaps} true
     * @default   {gantt} true
     * @apioption yAxis.reversed
     */
    /**
     * If `true`, the first series in a stack will be drawn on top in a
     * positive, non-reversed Y axis. If `false`, the first series is in
     * the base of the stack.
     *
     * @sample {highcharts} highcharts/yaxis/reversedstacks-false/
     *         Non-reversed stacks
     * @sample {highstock} highcharts/yaxis/reversedstacks-false/
     *         Non-reversed stacks
     *
     * @type      {boolean}
     * @default   true
     * @since     3.0.10
     * @product   highcharts highstock
     * @apioption yAxis.reversedStacks
     */
    reversedStacks: true,
    /**
     * Solid gauge series only. Color stops for the solid gauge. Use this
     * in cases where a linear gradient between a `minColor` and `maxColor`
     * is not sufficient. The stops is an array of tuples, where the first
     * item is a float between 0 and 1 assigning the relative position in
     * the gradient, and the second item is the color.
     *
     * For solid gauges, the Y axis also inherits the concept of
     * [data classes](https://api.highcharts.com/highmaps#colorAxis.dataClasses)
     * from the Highmaps color axis.
     *
     * @sample {highcharts} highcharts/demo/gauge-solid/
     *         Gauge with stops
     *
     * @see [minColor](#yAxis.minColor)
     * @see [maxColor](#yAxis.maxColor)
     *
     * @type      {Array<Array<number,Highcharts.ColorType>>}
     * @since     4.0
     * @product   highcharts
     * @apioption yAxis.stops
     */
    /**
     * The pixel width of the major tick marks.
     *
     * @sample {highcharts} highcharts/xaxis/tickwidth/ 10 px width
     * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
     *
     * @type      {number}
     * @default   0
     * @product   highcharts highstock gantt
     * @apioption yAxis.tickWidth
     */
    /**
     * Whether to force the axis to end on a tick. Use this option with
     * the `maxPadding` option to control the axis end.
     *
     * This option is always disabled, when panning type is
     * either `y` or `xy`.
     *
     * @see [type](#chart.panning.type)
     *
     *
     * @sample {highcharts} highcharts/yaxis/endontick/
     *         True by default
     * @sample {highcharts} highcharts/yaxis/endontick-false/
     *         False
     * @sample {highstock} stock/demo/basic-line/
     *         True by default
     * @sample {highstock} stock/xaxis/endontick/
     *         False for Y axis
     *
     * @since 1.2.0
     */
    endOnTick: true,
    /**
     * Padding of the max value relative to the length of the axis. A
     * padding of 0.05 will make a 100px axis 5px longer. This is useful
     * when you don't want the highest data value to appear on the edge
     * of the plot area. When the axis' `max` option is set or a max extreme
     * is set using `axis.setExtremes()`, the maxPadding will be ignored.
     *
     * Also the `softThreshold` option takes precedence over `maxPadding`,
     * so if the data is tangent to the threshold, `maxPadding` may not
     * apply unless `softThreshold` is set to false.
     *
     * @sample {highcharts} highcharts/yaxis/maxpadding-02/
     *         Max padding of 0.2
     * @sample {highstock} stock/xaxis/minpadding-maxpadding/
     *         Greater min- and maxPadding
     *
     * @since   1.2.0
     * @product highcharts highstock gantt
     */
    maxPadding: 0.05,
    /**
     * Padding of the min value relative to the length of the axis. A
     * padding of 0.05 will make a 100px axis 5px longer. This is useful
     * when you don't want the lowest data value to appear on the edge
     * of the plot area. When the axis' `min` option is set or a max extreme
     * is set using `axis.setExtremes()`, the maxPadding will be ignored.
     *
     * Also the `softThreshold` option takes precedence over `minPadding`,
     * so if the data is tangent to the threshold, `minPadding` may not
     * apply unless `softThreshold` is set to false.
     *
     * @sample {highcharts} highcharts/yaxis/minpadding/
     *         Min padding of 0.2
     * @sample {highstock} stock/xaxis/minpadding-maxpadding/
     *         Greater min- and maxPadding
     *
     * @since   1.2.0
     * @product highcharts highstock gantt
     */
    minPadding: 0.05,
    /**
     * @productdesc {highstock}
     * In Highcharts Stock 1.x, the Y axis was placed
     * on the left side by default.
     *
     * @sample {highcharts} highcharts/yaxis/opposite/
     *         Secondary Y axis opposite
     * @sample {highstock} stock/xaxis/opposite/
     *         Y axis on left side
     *
     * @type      {boolean}
     * @default   {highstock} true
     * @default   {highcharts} false
     * @product   highstock highcharts gantt
     * @apioption yAxis.opposite
     */
    /**
     * @see [tickInterval](#xAxis.tickInterval)
     * @see [tickPositioner](#xAxis.tickPositioner)
     * @see [tickPositions](#xAxis.tickPositions)
     */
    tickPixelInterval: 72,
    /**
     * Whether to show the last tick label.
     *
     * @productdesc {highcharts|gantt}
     * Defaults to `true` on cartesian charts, and `false` on polar charts.
     *
     * @productdesc {highstock}
     * Defaults to `true` for categorized yAxis and `false` for other types
     * of yAxis.
     *
     * @default undefined
     */
    showLastLabel: true,
    /**
     * @extends xAxis.labels
     */
    labels: {
      /**
       * The label's pixel distance from the perimeter of the plot area.
       * On cartesian charts, this is overridden if the `labels.y` setting
       * is set.
       *
       * On polar charts, if it's a percentage string, it is interpreted
       * the same as [series.radius](#plotOptions.gauge.radius), so the
       * label can be aligned under the gauge's shape.
       *
       * @sample {highcharts} highcharts/yaxis/labels-distance/
       *         Polar chart, labels centered under the arc
       *
       * @type      {number|string}
       * @product   highcharts
       * @apioption yAxis.labels.distance
       */
      /**
       * The y position offset of all labels relative to the tick
       * positions on the axis. For polar and radial axis consider the use
       * of the [distance](#yAxis.labels.distance) option.
       *
       * @sample {highcharts} highcharts/xaxis/labels-x/
       *         Y axis labels placed on grid lines
       *
       * @type      {number}
       * @default   {highcharts} 3
       * @default   {highstock} -2
       * @default   {highmaps} 3
       * @apioption yAxis.labels.y
       */
      /**
       * What part of the string the given position is anchored to. Can
       * be one of `"left"`, `"center"` or `"right"`. The exact position
       * also depends on the `labels.x` setting.
       *
       * Angular gauges and solid gauges defaults to `"center"`.
       * Solid gauges with two labels have additional option `"auto"`
       * for automatic horizontal and vertical alignment.
       *
       * @sample {highcharts} highcharts/yaxis/labels-align-left/
       *         Left
       * @sample {highcharts} highcharts/series-solidgauge/labels-auto-aligned/
       *         Solid gauge labels auto aligned
       *
       * @type       {Highcharts.AlignValue}
       * @default    {highstock} right
       * @apioption  yAxis.labels.align
       */
      /**
       * The x position offset of all labels relative to the tick
       * positions on the axis. Defaults to -15 for left axis, 15 for
       * right axis.
       *
       * @sample {highcharts} highcharts/xaxis/labels-x/
       *         Y axis labels placed on grid lines
       *
       * @type {number}
       */
      x: void 0
    },
    /**
     * @sample {highcharts} highcharts/yaxis/max-200/
     *         Y axis max of 200
     * @sample {highcharts} highcharts/yaxis/max-logarithmic/
     *         Y axis max on logarithmic axis
     * @sample {highstock} stock/yaxis/min-max/
     *         Fixed min and max on Y axis
     *
     * @apioption yAxis.max
     */
    /**
     * @sample {highcharts} highcharts/yaxis/min-startontick-false/
     *         -50 with startOnTick to false
     * @sample {highcharts} highcharts/yaxis/min-startontick-true/
     *         -50 with startOnTick true by default
     * @sample {highstock} stock/yaxis/min-max/
     *         Fixed min and max on Y axis
     *
     * @apioption yAxis.min
     */
    /**
     * An optional scrollbar to display on the Y axis in response to
     * limiting the minimum an maximum of the axis values.
     *
     * In styled mode, all the presentational options for the scrollbar
     * are replaced by the classes `.highcharts-scrollbar-thumb`,
     * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
     * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
     *
     * @sample {highstock} stock/yaxis/scrollbar/
     *         Scrollbar on the Y axis
     *
     * @extends   scrollbar
     * @since     4.2.6
     * @product   highstock
     * @excluding height
     * @apioption yAxis.scrollbar
     */
    /**
     * Enable the scrollbar on the Y axis.
     *
     * @sample {highstock} stock/yaxis/scrollbar/
     *         Enabled on Y axis
     *
     * @type      {boolean}
     * @default   false
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.enabled
     */
    /**
     * Pixel margin between the scrollbar and the axis elements.
     *
     * @type      {number}
     * @default   10
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.margin
     */
    /* eslint-disable @highcharts/highcharts/doclet-apioption-last */
    /**
     * Defines the position of the scrollbar. By default, it is positioned
     * on the opposite of the main axis (right side of the chart).
     * However, in the case of RTL languages could be set to `false`
     * which positions the scrollbar on the left.
     *
     * Works only for vertical axes.
     * This means yAxis in a non-inverted chart and xAxis in the inverted.
     *
     * @sample stock/yaxis/scrollbar-opposite/
     *         A scrollbar not on the opposite side
     *
     * @type      {boolean}
     * @default   true
     * @since 9.3.0
     *
     * @apioption yAxis.scrollbar.opposite
     * @apioption xAxis.scrollbar.opposite
     *
     */
    /* eslint-enable @highcharts/highcharts/doclet-apioption-last */
    /**
     * Whether to show the scrollbar when it is fully zoomed out at max
     * range. Setting it to `false` on the Y axis makes the scrollbar stay
     * hidden until the user zooms in, like common in browsers.
     *
     * @type      {boolean}
     * @default   true
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.showFull
     */
    /**
     * The width of a vertical scrollbar or height of a horizontal
     * scrollbar. Defaults to 20 on touch devices.
     *
     * @type      {number}
     * @default   14
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.size
     */
    /**
     * Z index of the scrollbar elements.
     *
     * @type      {number}
     * @default   3
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.zIndex
     */
    /**
     * A soft maximum for the axis. If the series data maximum is less
     * than this, the axis will stay at this maximum, but if the series
     * data maximum is higher, the axis will flex to show all data.
     *
     * **Note**: The [series.softThreshold](
     * #plotOptions.series.softThreshold) option takes precedence over this
     * option.
     *
     * @sample highcharts/yaxis/softmin-softmax/
     *         Soft min and max
     *
     * @type      {number}
     * @since     5.0.1
     * @product   highcharts highstock gantt
     * @apioption yAxis.softMax
     */
    /**
     * A soft minimum for the axis. If the series data minimum is greater
     * than this, the axis will stay at this minimum, but if the series
     * data minimum is lower, the axis will flex to show all data.
     *
     * **Note**: The [series.softThreshold](
     * #plotOptions.series.softThreshold) option takes precedence over this
     * option.
     *
     * @sample highcharts/yaxis/softmin-softmax/
     *         Soft min and max
     *
     * @type      {number}
     * @since     5.0.1
     * @product   highcharts highstock gantt
     * @apioption yAxis.softMin
     */
    /**
     * Defines the horizontal alignment of the stack total label. Can be one
     * of `"left"`, `"center"` or `"right"`. The default value is calculated
     * at runtime and depends on orientation and whether the stack is
     * positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-align-left/
     *         Aligned to the left
     * @sample {highcharts} highcharts/yaxis/stacklabels-align-center/
     *         Aligned in center
     * @sample {highcharts} highcharts/yaxis/stacklabels-align-right/
     *         Aligned to the right
     *
     * @type      {Highcharts.AlignValue}
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.align
     */
    /**
     * A format string for the data label. Available variables are the same
     * as for `formatter`.
     *
     * @type      {string}
     * @default   {total}
     * @since     3.0.2
     * @product   highcharts highstock
     * @apioption yAxis.stackLabels.format
     */
    /**
     * Rotation of the labels in degrees.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-rotation/
     *         Labels rotated 45
     *
     * @type      {number}
     * @default   0
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.rotation
     */
    /**
     * The text alignment for the label. While `align` determines where the
     * texts anchor point is placed with regards to the stack, `textAlign`
     * determines how the text is aligned against its anchor point. Possible
     * values are `"left"`, `"center"` and `"right"`. The default value is
     * calculated at runtime and depends on orientation and whether the
     * stack is positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-textalign-left/
     *         Label in center position but text-aligned left
     *
     * @type      {Highcharts.AlignValue}
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.textAlign
     */
    /**
     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the labels.
     *
     * @type      {boolean}
     * @default   false
     * @since     3.0
     * @product   highcharts highstock
     * @apioption yAxis.stackLabels.useHTML
     */
    /**
     * Defines the vertical alignment of the stack total label. Can be one
     * of `"top"`, `"middle"` or `"bottom"`. The default value is calculated
     * at runtime and depends on orientation and whether the stack is
     * positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-top/
     *         Vertically aligned top
     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-middle/
     *         Vertically aligned middle
     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-bottom/
     *         Vertically aligned bottom
     *
     * @type      {Highcharts.VerticalAlignValue}
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.verticalAlign
     */
    /**
     * The x position offset of the label relative to the left of the
     * stacked bar. The default value is calculated at runtime and depends
     * on orientation and whether the stack is positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-x/
     *         Stack total labels with x offset
     *
     * @type      {number}
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.x
     */
    /**
     * The y position offset of the label relative to the tick position
     * on the axis. The default value is calculated at runtime and depends
     * on orientation and whether the stack is positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-y/
     *         Stack total labels with y offset
     *
     * @type      {number}
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.y
     */
    /**
     * Whether to force the axis to start on a tick. Use this option with
     * the `maxPadding` option to control the axis start.
     *
     * This option is always disabled, when panning type is
     * either `y` or `xy`.
     *
     * @see [type](#chart.panning.type)
     *
     * @sample {highcharts} highcharts/xaxis/startontick-false/
     *         False by default
     * @sample {highcharts} highcharts/xaxis/startontick-true/
     *         True
     * @sample {highstock} stock/xaxis/endontick/
     *         False for Y axis
     *
     * @since   1.2.0
     * @product highcharts highstock gantt
     */
    startOnTick: true,
    title: {
      /**
       * The pixel distance between the axis labels and the title.
       * Positive values are outside the axis line, negative are inside.
       *
       * @sample {highcharts} highcharts/xaxis/title-margin/
       *         Y axis title margin of 60
       *
       * @type      {number}
       * @default   40
       * @apioption yAxis.title.margin
       */
      /**
       * The actual text of the axis title. Horizontal texts can contain
       * HTML, but rotated texts are painted using vector techniques and
       * must be clean text. The Y axis title is disabled by setting the
       * `text` option to `undefined`. The default value is overriden by
       * the `lang.yAxisTitle` language option.
       *
       * @sample {highcharts} highcharts/xaxis/title-text/
       *         Custom HTML
       *
       * @type    {string|undefined}
       * @default {highcharts} Values
       * @default {highstock} undefined
       * @product highcharts highstock gantt
       */
    },
    /**
     * The top position of the Y axis. If it's a number, it is interpreted
     * as pixel position relative to the chart.
     *
     * Since Highcharts 2: If it's a percentage string, it is interpreted as
     * percentages of the plot height, offset from plot area top.
     *
     * @see [yAxis.height](#yAxis.height)
     *
     * @sample {highstock} stock/demo/candlestick-and-volume/
     *         Percentage height panes
     *
     * @type      {number|string}
     * @product   highcharts highstock
     * @apioption yAxis.top
     */
    /**
     * The stack labels show the total value for each bar in a stacked
     * column or bar chart. The label will be placed on top of positive
     * columns and below negative columns. In case of an inverted column
     * chart or a bar chart the label is placed to the right of positive
     * bars and to the left of negative bars.
     *
     * @product highcharts
     */
    stackLabels: {
      /**
       * Enable or disable the initial animation when a series is
       * displayed for the `stackLabels`. The animation can also be set as
       * a configuration object. Please note that this option only
       * applies to the initial animation.
       * For other animations, see [chart.animation](#chart.animation)
       * and the animation parameter under the API methods.
       * The following properties are supported:
       *
       * - `defer`: The animation delay time in milliseconds.
       *
       * @sample {highcharts} highcharts/plotoptions/animation-defer/
       *          Animation defer settings
       * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
       * @since 8.2.0
       * @apioption yAxis.stackLabels.animation
       */
      animation: {},
      /**
       * The animation delay time in milliseconds.
       * Set to `0` renders stackLabel immediately.
       * As `undefined` inherits defer time from the [series.animation.defer](#plotOptions.series.animation.defer).
       *
       * @type      {number}
       * @since 8.2.0
       * @apioption yAxis.stackLabels.animation.defer
       */
      /**
       * Allow the stack labels to overlap.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/
       *         Default false
       *
       * @since   5.0.13
       * @product highcharts
       */
      allowOverlap: false,
      /**
       * The background color or gradient for the stack label.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-box/
       *          Stack labels box options
       * @type      {Highcharts.ColorType}
       * @since 8.1.0
       * @apioption yAxis.stackLabels.backgroundColor
       */
      /**
       * The border color for the stack label. Defaults to `undefined`.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-box/
       *          Stack labels box options
       * @type      {Highcharts.ColorType}
       * @since 8.1.0
       * @apioption yAxis.stackLabels.borderColor
       */
      /**
       * The border radius in pixels for the stack label.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-box/
       *          Stack labels box options
       * @type      {number}
       * @default   0
       * @since 8.1.0
       * @apioption yAxis.stackLabels.borderRadius
       */
      /**
       * The border width in pixels for the stack label.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-box/
       *          Stack labels box options
       * @type      {number}
       * @default   0
       * @since 8.1.0
       * @apioption yAxis.stackLabels.borderWidth
       */
      /**
       * Enable or disable the stack total labels.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/
       *         Enabled stack total labels
       * @sample {highcharts} highcharts/yaxis/stacklabels-enabled-waterfall/
       *         Enabled stack labels in waterfall chart
       *
       * @since   2.1.5
       * @product highcharts
       */
      enabled: false,
      /**
       * Whether to hide stack labels that are outside the plot area.
       * By default, the stack label is moved
       * inside the plot area according to the
       * [overflow](/highcharts/#yAxis/stackLabels/overflow)
       * option.
       *
       * @type  {boolean}
       * @since 7.1.3
       */
      crop: true,
      /**
       * How to handle stack total labels that flow outside the plot area.
       * The default is set to `"justify"`,
       * which aligns them inside the plot area.
       * For columns and bars, this means it will be moved inside the bar.
       * To display stack labels outside the plot area,
       * set `crop` to `false` and `overflow` to `"allow"`.
       *
       * @sample highcharts/yaxis/stacklabels-overflow/
       *         Stack labels flows outside the plot area.
       *
       * @type  {Highcharts.DataLabelsOverflowValue}
       * @since 7.1.3
       */
      overflow: "justify",
      /* eslint-disable valid-jsdoc */
      /**
       * Callback JavaScript function to format the label. The value is
       * given by `this.total`.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/
       *         Added units to stack total value
       *
       * @type    {Highcharts.FormatterCallbackFunction<Highcharts.StackItemObject>}
       * @since   2.1.5
       * @product highcharts
       */
      formatter: function() {
        const { numberFormatter } = this.axis.chart;
        return numberFormatter(this.total || 0, -1);
      },
      /**
       * CSS styles for the label.
       *
       * In styled mode, the styles are set in the
       * `.highcharts-stack-label` class.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-style/
       *         Red stack total labels
       *
       * @type    {Highcharts.CSSObject}
       * @since   2.1.5
       * @product highcharts
       */
      style: {
        /** @internal */
        color: "#000000",
        /**
         * @type {number|string}
         */
        fontSize: "0.7em",
        /** @internal */
        fontWeight: "bold",
        /** @internal */
        textOutline: "1px contrast"
      }
    },
    gridLineWidth: 1,
    lineWidth: 0
  };
})(AxisDefaults || (AxisDefaults = {}));
var AxisDefaults_default = AxisDefaults;

// node_modules/highcharts/es-modules/Core/Foundation.js
var { addEvent: addEvent4, isFunction: isFunction4, objectEach: objectEach8, removeEvent: removeEvent3 } = Utilities_default;
var Foundation;
(function(Foundation2) {
  function registerEventOptions5(component, options2) {
    component.eventOptions = component.eventOptions || {};
    objectEach8(options2.events, function(event, eventType) {
      if (component.eventOptions[eventType] !== event) {
        if (component.eventOptions[eventType]) {
          removeEvent3(component, eventType, component.eventOptions[eventType]);
          delete component.eventOptions[eventType];
        }
        if (isFunction4(event)) {
          component.eventOptions[eventType] = event;
          addEvent4(component, eventType, event, {
            order: 0
            // #14080 fire those events as firsts
          });
        }
      }
    });
  }
  Foundation2.registerEventOptions = registerEventOptions5;
})(Foundation || (Foundation = {}));
var Foundation_default = Foundation;

// node_modules/highcharts/es-modules/Core/Axis/Tick.js
var { deg2rad: deg2rad3 } = Globals_default;
var { clamp: clamp3, correctFloat: correctFloat2, defined: defined11, destroyObjectProperties: destroyObjectProperties3, extend: extend10, fireEvent: fireEvent5, getAlignFactor: getAlignFactor5, isNumber: isNumber12, merge: merge9, objectEach: objectEach9, pick: pick10 } = Utilities_default;
var Tick = class {
  /* *
   *
   *  Constructors
   *
   * */
  constructor(axis, pos, type, noLabel, parameters) {
    this.isNew = true;
    this.isNewLabel = true;
    this.axis = axis;
    this.pos = pos;
    this.type = type || "";
    this.parameters = parameters || {};
    this.tickmarkOffset = this.parameters.tickmarkOffset;
    this.options = this.parameters.options;
    fireEvent5(this, "init");
    if (!type && !noLabel) {
      this.addLabel();
    }
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Write the tick label.
   *
   * @private
   * @function Highcharts.Tick#addLabel
   */
  addLabel() {
    const tick = this, axis = tick.axis, options2 = axis.options, chart = axis.chart, categories = axis.categories, log = axis.logarithmic, names = axis.names, pos = tick.pos, labelOptions = pick10(tick.options?.labels, options2.labels), tickPositions = axis.tickPositions, isFirst = pos === tickPositions[0], isLast = pos === tickPositions[tickPositions.length - 1], animateLabels = (!labelOptions.step || labelOptions.step === 1) && axis.tickInterval === 1, tickPositionInfo = tickPositions.info;
    let label = tick.label, dateTimeLabelFormat, dateTimeLabelFormats, i;
    let value = this.parameters.category || (categories ? pick10(categories[pos], names[pos], pos) : pos);
    if (log && isNumber12(value)) {
      value = correctFloat2(log.lin2log(value));
    }
    if (axis.dateTime) {
      if (tickPositionInfo) {
        dateTimeLabelFormats = chart.time.resolveDTLFormat(options2.dateTimeLabelFormats[!options2.grid && tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName]);
        dateTimeLabelFormat = dateTimeLabelFormats.main;
      } else if (isNumber12(value)) {
        dateTimeLabelFormat = axis.dateTime.getXDateFormat(value, options2.dateTimeLabelFormats || {});
      }
    }
    tick.isFirst = isFirst;
    tick.isLast = isLast;
    const ctx = {
      axis,
      chart,
      dateTimeLabelFormat,
      isFirst,
      isLast,
      pos,
      tick,
      tickPositionInfo,
      value
    };
    fireEvent5(this, "labelFormat", ctx);
    const labelFormatter = (ctx2) => {
      if (labelOptions.formatter) {
        return labelOptions.formatter.call(ctx2, ctx2);
      }
      if (labelOptions.format) {
        ctx2.text = axis.defaultLabelFormatter.call(ctx2);
        return Templating_default.format(labelOptions.format, ctx2, chart);
      }
      return axis.defaultLabelFormatter.call(ctx2);
    };
    const str = labelFormatter.call(ctx, ctx);
    const list = dateTimeLabelFormats?.list;
    if (list) {
      tick.shortenLabel = function() {
        for (i = 0; i < list.length; i++) {
          extend10(ctx, { dateTimeLabelFormat: list[i] });
          label.attr({
            text: labelFormatter.call(ctx, ctx)
          });
          if (label.getBBox().width < axis.getSlotWidth(tick) - 2 * (labelOptions.padding || 0)) {
            return;
          }
        }
        label.attr({
          text: ""
        });
      };
    } else {
      tick.shortenLabel = void 0;
    }
    if (animateLabels && axis._addedPlotLB) {
      tick.moveLabel(str, labelOptions);
    }
    if (!defined11(label) && !tick.movedLabel) {
      tick.label = label = tick.createLabel(str, labelOptions);
      tick.rotation = 0;
    } else if (label && label.textStr !== str && !animateLabels) {
      if (label.textWidth && !labelOptions.style.width && !label.styles.width) {
        label.css({ width: null });
      }
      label.attr({ text: str });
      label.textPxLength = label.getBBox().width;
    }
  }
  /**
   * Render and return the label of the tick.
   *
   * @private
   * @function Highcharts.Tick#createLabel
   */
  createLabel(str, labelOptions, xy) {
    const axis = this.axis, { renderer, styledMode } = axis.chart, whiteSpace = labelOptions.style.whiteSpace, label = defined11(str) && labelOptions.enabled ? renderer.text(str, xy?.x, xy?.y, labelOptions.useHTML).add(axis.labelGroup) : void 0;
    if (label) {
      if (!styledMode) {
        label.css(merge9(labelOptions.style));
      }
      label.textPxLength = label.getBBox().width;
      if (!styledMode && whiteSpace) {
        label.css({ whiteSpace });
      }
    }
    return label;
  }
  /**
   * Destructor for the tick prototype
   *
   * @private
   * @function Highcharts.Tick#destroy
   */
  destroy() {
    destroyObjectProperties3(this, this.axis);
  }
  /**
   * Gets the x and y positions for ticks in terms of pixels.
   *
   * @private
   * @function Highcharts.Tick#getPosition
   *
   * @param {boolean} horiz
   * Whether the tick is on an horizontal axis or not.
   *
   * @param {number} tickPos
   * Position of the tick.
   *
   * @param {number} tickmarkOffset
   * Tickmark offset for all ticks.
   *
   * @param {boolean} [old]
   * Whether the axis has changed or not.
   *
   * @return {Highcharts.PositionObject}
   * The tick position.
   *
   * @emits Highcharts.Tick#event:afterGetPosition
   */
  getPosition(horiz, tickPos, tickmarkOffset, old) {
    const axis = this.axis, chart = axis.chart, cHeight = old && chart.oldChartHeight || chart.chartHeight, pos = {
      x: horiz ? correctFloat2(axis.translate(tickPos + tickmarkOffset, void 0, void 0, old) + axis.transB) : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),
      y: horiz ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : correctFloat2(cHeight - axis.translate(tickPos + tickmarkOffset, void 0, void 0, old) - axis.transB)
    };
    pos.y = clamp3(pos.y, -1e9, 1e9);
    fireEvent5(this, "afterGetPosition", { pos });
    return pos;
  }
  /**
   * Get the x, y position of the tick label
   * @private
   */
  getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
    const axis = this.axis, transA = axis.transA, reversed = (
      // #7911
      axis.isLinked && axis.linkedParent ? axis.linkedParent.reversed : axis.reversed
    ), staggerLines = axis.staggerLines, rotCorr = axis.tickRotCorr || { x: 0, y: 0 }, labelOffsetCorrection = !horiz && !axis.reserveSpaceDefault ? -axis.labelOffset * (axis.labelAlign === "center" ? 0.5 : 1) : 0, distance = labelOptions.distance, pos = {};
    let yOffset, line2;
    if (axis.side === 0) {
      yOffset = label.rotation ? -distance : -label.getBBox().height;
    } else if (axis.side === 2) {
      yOffset = rotCorr.y + distance;
    } else {
      yOffset = Math.cos(label.rotation * deg2rad3) * (rotCorr.y - label.getBBox(false, 0).height / 2);
    }
    if (defined11(labelOptions.y)) {
      yOffset = axis.side === 0 && axis.horiz ? labelOptions.y + yOffset : labelOptions.y;
    }
    x = x + pick10(labelOptions.x, [0, 1, 0, -1][axis.side] * distance) + labelOffsetCorrection + rotCorr.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
    y = y + yOffset - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
    if (staggerLines) {
      line2 = index / (step || 1) % staggerLines;
      if (axis.opposite) {
        line2 = staggerLines - line2 - 1;
      }
      y += line2 * (axis.labelOffset / staggerLines);
    }
    pos.x = x;
    pos.y = Math.round(y);
    fireEvent5(this, "afterGetLabelPosition", { pos, tickmarkOffset, index });
    return pos;
  }
  /**
   * Get the offset height or width of the label
   *
   * @private
   * @function Highcharts.Tick#getLabelSize
   */
  getLabelSize() {
    return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
  }
  /**
   * Extendible method to return the path of the marker
   * @private
   */
  getMarkPath(x, y, tickLength, tickWidth, horiz = false, renderer) {
    return renderer.crispLine([[
      "M",
      x,
      y
    ], [
      "L",
      x + (horiz ? 0 : -tickLength),
      y + (horiz ? tickLength : 0)
    ]], tickWidth);
  }
  /**
   * Handle the label overflow by adjusting the labels to the left and right
   * edge, or hide them if they collide into the neighbour label.
   *
   * @private
   * @function Highcharts.Tick#handleOverflow
   */
  handleOverflow(xy) {
    const tick = this, axis = this.axis, labelOptions = axis.options.labels, pxPos = xy.x, chartWidth = axis.chart.chartWidth, spacing = axis.chart.spacing, leftBound = pick10(axis.labelLeft, Math.min(axis.pos, spacing[3])), rightBound = pick10(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1])), label = this.label, rotation = this.rotation, factor = getAlignFactor5(axis.labelAlign || label.attr("align")), labelWidth = label.getBBox().width, slotWidth = axis.getSlotWidth(tick), xCorrection = factor, css19 = {};
    let modifiedSlotWidth = slotWidth, goRight = 1, leftPos, rightPos, textWidth;
    if (!rotation && labelOptions.overflow === "justify") {
      leftPos = pxPos - factor * labelWidth;
      rightPos = pxPos + (1 - factor) * labelWidth;
      if (leftPos < leftBound) {
        modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
      } else if (rightPos > rightBound) {
        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
        goRight = -1;
      }
      modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth);
      if (modifiedSlotWidth < slotWidth && axis.labelAlign === "center") {
        xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));
      }
      if (labelWidth > modifiedSlotWidth || axis.autoRotation && label?.styles?.width) {
        textWidth = modifiedSlotWidth;
      }
    } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
      textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad3) - leftBound);
    } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
      textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad3));
    }
    if (textWidth && label) {
      if (tick.shortenLabel) {
        tick.shortenLabel();
      } else {
        label.css(extend10(css19, {
          width: Math.floor(textWidth) + "px",
          lineClamp: axis.isRadial ? 0 : 1
        }));
      }
    }
  }
  /**
   * Try to replace the label if the same one already exists.
   *
   * @private
   * @function Highcharts.Tick#moveLabel
   */
  moveLabel(str, labelOptions) {
    const tick = this, label = tick.label, axis = tick.axis;
    let moved = false, labelPos;
    if (label && label.textStr === str) {
      tick.movedLabel = label;
      moved = true;
      delete tick.label;
    } else {
      objectEach9(axis.ticks, function(currentTick) {
        if (!moved && !currentTick.isNew && currentTick !== tick && currentTick.label && currentTick.label.textStr === str) {
          tick.movedLabel = currentTick.label;
          moved = true;
          currentTick.labelPos = tick.movedLabel.xy;
          delete currentTick.label;
        }
      });
    }
    if (!moved && (tick.labelPos || label)) {
      labelPos = tick.labelPos || label.xy;
      tick.movedLabel = tick.createLabel(str, labelOptions, labelPos);
      if (tick.movedLabel) {
        tick.movedLabel.attr({ opacity: 0 });
      }
    }
  }
  /**
   * Put everything in place
   *
   * @private
   * @param {number} index
   *
   * @param {boolean} [old]
   * Use old coordinates to prepare an animation into new position
   *
   * @param {number} [opacity]
   */
  render(index, old, opacity) {
    const tick = this, axis = tick.axis, horiz = axis.horiz, pos = tick.pos, tickmarkOffset = pick10(tick.tickmarkOffset, axis.tickmarkOffset), xy = tick.getPosition(horiz, pos, tickmarkOffset, old), x = xy.x, y = xy.y, axisStart = axis.pos, axisEnd = axisStart + axis.len, pxPos = horiz ? x : y;
    const labelOpacity = pick10(
      opacity,
      tick.label?.newOpacity,
      // #15528
      1
    );
    if (!axis.chart.polar && (correctFloat2(pxPos) < axisStart || pxPos > axisEnd)) {
      opacity = 0;
    }
    opacity ?? (opacity = 1);
    this.isActive = true;
    this.renderGridLine(old, opacity);
    this.renderMark(xy, opacity);
    this.renderLabel(xy, old, labelOpacity, index);
    tick.isNew = false;
    fireEvent5(this, "afterRender");
  }
  /**
   * Renders the gridLine.
   *
   * @private
   * @function Highcharts.Tick#renderGridLine
   * @param {boolean} old  Whether or not the tick is old
   * @param {number} opacity  The opacity of the grid line
   */
  renderGridLine(old, opacity) {
    const tick = this, axis = tick.axis, options2 = axis.options, attribs = {}, pos = tick.pos, type = tick.type, tickmarkOffset = pick10(tick.tickmarkOffset, axis.tickmarkOffset), renderer = axis.chart.renderer;
    let gridLine = tick.gridLine, gridLinePath, gridLineWidth = options2.gridLineWidth, gridLineColor = options2.gridLineColor, dashStyle = options2.gridLineDashStyle;
    if (tick.type === "minor") {
      gridLineWidth = options2.minorGridLineWidth;
      gridLineColor = options2.minorGridLineColor;
      dashStyle = options2.minorGridLineDashStyle;
    }
    if (!gridLine) {
      if (!axis.chart.styledMode) {
        attribs.stroke = gridLineColor;
        attribs["stroke-width"] = gridLineWidth || 0;
        attribs.dashstyle = dashStyle;
      }
      if (!type) {
        attribs.zIndex = 1;
      }
      if (old) {
        opacity = 0;
      }
      tick.gridLine = gridLine = renderer.path().attr(attribs).addClass("highcharts-" + (type ? type + "-" : "") + "grid-line").add(axis.gridGroup);
    }
    if (gridLine) {
      gridLinePath = axis.getPlotLinePath({
        value: pos + tickmarkOffset,
        lineWidth: gridLine.strokeWidth(),
        force: "pass",
        old,
        acrossPanes: false
        // #18025
      });
      if (gridLinePath) {
        gridLine[old || tick.isNew ? "attr" : "animate"]({
          d: gridLinePath,
          opacity
        });
      }
    }
  }
  /**
   * Renders the tick mark.
   *
   * @private
   * @function Highcharts.Tick#renderMark
   * @param {Highcharts.PositionObject} xy  The position vector of the mark
   * @param {number} opacity  The opacity of the mark
   */
  renderMark(xy, opacity) {
    const tick = this, axis = tick.axis, options2 = axis.options, renderer = axis.chart.renderer, type = tick.type, tickSize = axis.tickSize(type ? type + "Tick" : "tick"), x = xy.x, y = xy.y, tickWidth = pick10(options2[type !== "minor" ? "tickWidth" : "minorTickWidth"], !type && axis.isXAxis ? 1 : 0), tickColor = options2[type !== "minor" ? "tickColor" : "minorTickColor"];
    let mark = tick.mark;
    const isNewMark = !mark;
    if (tickSize) {
      if (axis.opposite) {
        tickSize[0] = -tickSize[0];
      }
      if (!mark) {
        tick.mark = mark = renderer.path().addClass("highcharts-" + (type ? type + "-" : "") + "tick").add(axis.axisGroup);
        if (!axis.chart.styledMode) {
          mark.attr({
            stroke: tickColor,
            "stroke-width": tickWidth
          });
        }
      }
      mark[isNewMark ? "attr" : "animate"]({
        d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth(), axis.horiz, renderer),
        opacity
      });
    }
  }
  /**
   * Renders the tick label.
   * Note: The label should already be created in init(), so it should only
   * have to be moved into place.
   *
   * @private
   * @function Highcharts.Tick#renderLabel
   * @param {Highcharts.PositionObject} xy  The position vector of the label
   * @param {boolean} old  Whether or not the tick is old
   * @param {number} opacity  The opacity of the label
   * @param {number} index  The index of the tick
   */
  renderLabel(xy, old, opacity, index) {
    const tick = this, axis = tick.axis, horiz = axis.horiz, options2 = axis.options, label = tick.label, labelOptions = options2.labels, step = labelOptions.step, tickmarkOffset = pick10(tick.tickmarkOffset, axis.tickmarkOffset), x = xy.x, y = xy.y;
    let show = true;
    if (label && isNumber12(x)) {
      label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
      if (tick.isFirst && !tick.isLast && !options2.showFirstLabel || tick.isLast && !tick.isFirst && !options2.showLastLabel) {
        show = false;
      } else if (horiz && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
        tick.handleOverflow(xy);
      }
      if (step && index % step) {
        show = false;
      }
      if (show && isNumber12(xy.y)) {
        xy.opacity = opacity;
        label[tick.isNewLabel ? "attr" : "animate"](xy).show(true);
        tick.isNewLabel = false;
      } else {
        label.hide();
        tick.isNewLabel = true;
      }
    }
  }
  /**
   * Replace labels with the moved ones to perform animation. Additionally
   * destroy unused labels.
   *
   * @private
   * @function Highcharts.Tick#replaceMovedLabel
   */
  replaceMovedLabel() {
    const tick = this, label = tick.label, axis = tick.axis;
    if (label && !tick.isNew) {
      label.animate({ opacity: 0 }, void 0, label.destroy);
      delete tick.label;
    }
    axis.isDirty = true;
    tick.label = tick.movedLabel;
    delete tick.movedLabel;
  }
};
var Tick_default = Tick;

// node_modules/highcharts/es-modules/Core/Axis/Axis.js
var { animObject: animObject3 } = AnimationUtilities_default;
var { xAxis, yAxis } = AxisDefaults_default;
var { defaultOptions: defaultOptions4 } = Defaults_default;
var { registerEventOptions } = Foundation_default;
var { deg2rad: deg2rad4 } = Globals_default;
var { arrayMax: arrayMax2, arrayMin: arrayMin2, clamp: clamp4, correctFloat: correctFloat3, defined: defined12, destroyObjectProperties: destroyObjectProperties4, erase: erase3, error: error4, extend: extend11, fireEvent: fireEvent6, getClosestDistance: getClosestDistance2, insertItem: insertItem2, isArray: isArray6, isNumber: isNumber13, isString: isString9, merge: merge10, normalizeTickInterval: normalizeTickInterval2, objectEach: objectEach10, pick: pick11, relativeLength: relativeLength2, removeEvent: removeEvent4, splat: splat4, syncTimeout: syncTimeout3 } = Utilities_default;
var getNormalizedTickInterval = (axis, tickInterval) => normalizeTickInterval2(tickInterval, void 0, void 0, pick11(
  axis.options.allowDecimals,
  // If the tick interval is greater than 0.5, avoid decimals, as
  // linear axes are often used to render discrete values (#3363). If
  // a tick amount is set, allow decimals by default, as it increases
  // the chances for a good fit.
  tickInterval < 0.5 || axis.tickAmount !== void 0
), !!axis.tickAmount);
extend11(defaultOptions4, { xAxis, yAxis: merge10(xAxis, yAxis) });
var Axis = class _Axis {
  /* *
   *
   *  Constructors
   *
   * */
  constructor(chart, userOptions, coll) {
    this.init(chart, userOptions, coll);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Overrideable function to initialize the axis.
   *
   * @see {@link Axis}
   *
   * @function Highcharts.Axis#init
   *
   * @param {Highcharts.Chart} chart
   * The Chart instance to apply the axis on.
   *
   * @param {AxisOptions} userOptions
   * Axis options.
   *
   * @emits Highcharts.Axis#event:afterInit
   * @emits Highcharts.Axis#event:init
   */
  init(chart, userOptions, coll = this.coll) {
    const isXAxis = coll === "xAxis", axis = this, horiz = axis.isZAxis || (chart.inverted ? !isXAxis : isXAxis);
    axis.chart = chart;
    axis.horiz = horiz;
    axis.isXAxis = isXAxis;
    axis.coll = coll;
    fireEvent6(this, "init", { userOptions });
    axis.opposite = pick11(userOptions.opposite, axis.opposite);
    axis.side = pick11(
      userOptions.side,
      axis.side,
      horiz ? axis.opposite ? 0 : 2 : (
        // Top : bottom
        axis.opposite ? 1 : 3
      )
      // Right : left
    );
    axis.setOptions(userOptions);
    const options2 = axis.options, labelsOptions = options2.labels;
    axis.type ?? (axis.type = options2.type || "linear");
    axis.uniqueNames ?? (axis.uniqueNames = options2.uniqueNames ?? true);
    fireEvent6(axis, "afterSetType");
    axis.userOptions = userOptions;
    axis.minPixelPadding = 0;
    axis.reversed = pick11(options2.reversed, axis.reversed);
    axis.visible = options2.visible;
    axis.zoomEnabled = options2.zoomEnabled;
    axis.hasNames = this.type === "category" || options2.categories === true;
    axis.categories = isArray6(options2.categories) && options2.categories || (axis.hasNames ? [] : void 0);
    if (!axis.names) {
      axis.names = [];
      axis.names.keys = {};
    }
    axis.plotLinesAndBandsGroups = {};
    axis.positiveValuesOnly = !!axis.logarithmic;
    axis.isLinked = defined12(options2.linkedTo);
    axis.ticks = {};
    axis.labelEdge = [];
    axis.minorTicks = {};
    axis.plotLinesAndBands = [];
    axis.alternateBands = {};
    axis.len ?? (axis.len = 0);
    axis.minRange = axis.userMinRange = options2.minRange || options2.maxZoom;
    axis.range = options2.range;
    axis.offset = options2.offset || 0;
    axis.max = void 0;
    axis.min = void 0;
    const crosshair = pick11(options2.crosshair, splat4(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1]);
    axis.crosshair = crosshair === true ? {} : crosshair;
    if (chart.axes.indexOf(axis) === -1) {
      if (isXAxis) {
        chart.axes.splice(chart.xAxis.length, 0, axis);
      } else {
        chart.axes.push(axis);
      }
      insertItem2(this, chart[this.coll]);
    }
    chart.orderItems(axis.coll);
    axis.series = axis.series || [];
    if (chart.inverted && !axis.isZAxis && isXAxis && !defined12(axis.reversed)) {
      axis.reversed = true;
    }
    axis.labelRotation = isNumber13(labelsOptions.rotation) ? labelsOptions.rotation : void 0;
    registerEventOptions(axis, options2);
    fireEvent6(this, "afterInit");
  }
  /**
   * Merge and set options.
   *
   * @private
   * @function Highcharts.Axis#setOptions
   *
   * @param {Highcharts.AxisOptions} userOptions
   * Axis options.
   *
   * @emits Highcharts.Axis#event:afterSetOptions
   */
  setOptions(userOptions) {
    const sideSpecific = this.horiz ? (
      // Top and bottom axis defaults
      {
        labels: {
          autoRotation: [-45],
          padding: 3
        },
        margin: 15
      }
    ) : (
      // Left and right axis, title rotated 90 or 270 degrees
      // respectively
      {
        labels: {
          padding: 1
        },
        title: {
          rotation: 90 * this.side
        }
      }
    );
    this.options = merge10(
      sideSpecific,
      // Merge in the default title for y-axis, which changes with
      // language settings
      this.coll === "yAxis" ? {
        title: {
          text: this.chart.options.lang.yAxisTitle
        }
      } : {},
      defaultOptions4[this.coll],
      userOptions
    );
    fireEvent6(this, "afterSetOptions", { userOptions });
  }
  /**
   * The default label formatter. The context is a special config object for
   * the label. In apps, use the
   * [labels.formatter](https://api.highcharts.com/highcharts/xAxis.labels.formatter)
   * instead, except when a modification is needed.
   *
   * @function Highcharts.Axis#defaultLabelFormatter
   *
   * @param {Highcharts.AxisLabelsFormatterContextObject} this
   * Formatter context of axis label.
   *
   * @param {Highcharts.AxisLabelsFormatterContextObject} [ctx]
   * Formatter context of axis label.
   *
   * @return {string}
   * The formatted label content.
   */
  defaultLabelFormatter() {
    const axis = this.axis, chart = this.chart, { numberFormatter } = chart, value = isNumber13(this.value) ? this.value : NaN, time = axis.chart.time, categories = axis.categories, dateTimeLabelFormat = this.dateTimeLabelFormat, lang6 = defaultOptions4.lang, numericSymbols = lang6.numericSymbols, numSymMagnitude = lang6.numericSymbolMagnitude || 1e3, numericSymbolDetector = axis.logarithmic ? Math.abs(value) : axis.tickInterval;
    let i = numericSymbols?.length, multi, ret;
    if (categories) {
      ret = `${this.value}`;
    } else if (dateTimeLabelFormat) {
      ret = time.dateFormat(dateTimeLabelFormat, value, true);
    } else if (i && numericSymbols && numericSymbolDetector >= 1e3) {
      while (i-- && typeof ret === "undefined") {
        multi = Math.pow(numSymMagnitude, i + 1);
        if (
          // Only accept a numeric symbol when the distance is more
          // than a full unit. So for example if the symbol is k, we
          // don't accept numbers like 0.5k.
          numericSymbolDetector >= multi && // Accept one decimal before the symbol. Accepts 0.5k but
          // not 0.25k. How does this work with the previous?
          value * 10 % multi === 0 && numericSymbols[i] !== null && value !== 0
        ) {
          ret = numberFormatter(value / multi, -1) + numericSymbols[i];
        }
      }
    }
    if (typeof ret === "undefined") {
      if (Math.abs(value) >= 1e4) {
        ret = numberFormatter(value, -1);
      } else {
        ret = numberFormatter(value, -1, void 0, "");
      }
    }
    return ret;
  }
  /**
   * Get the minimum and maximum for the series of each axis. The function
   * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.
   *
   * @private
   * @function Highcharts.Axis#getSeriesExtremes
   *
   * @emits Highcharts.Axis#event:afterGetSeriesExtremes
   * @emits Highcharts.Axis#event:getSeriesExtremes
   */
  getSeriesExtremes() {
    const axis = this;
    let xExtremes;
    fireEvent6(this, "getSeriesExtremes", null, function() {
      axis.hasVisibleSeries = false;
      axis.dataMin = axis.dataMax = axis.threshold = void 0;
      axis.softThreshold = !axis.isXAxis;
      axis.series.forEach((series) => {
        if (series.reserveSpace()) {
          const seriesOptions = series.options;
          let xData, threshold = seriesOptions.threshold, seriesDataMin, seriesDataMax;
          axis.hasVisibleSeries = true;
          if (axis.positiveValuesOnly && (threshold || 0) <= 0) {
            threshold = void 0;
          }
          if (axis.isXAxis) {
            xData = series.getColumn("x");
            if (xData.length) {
              xData = axis.logarithmic ? xData.filter((x) => x > 0) : xData;
              xExtremes = series.getXExtremes(xData);
              seriesDataMin = xExtremes.min;
              seriesDataMax = xExtremes.max;
              if (!isNumber13(seriesDataMin) && // #5010:
              !(seriesDataMin instanceof Date)) {
                xData = xData.filter(isNumber13);
                xExtremes = series.getXExtremes(xData);
                seriesDataMin = xExtremes.min;
                seriesDataMax = xExtremes.max;
              }
              if (xData.length) {
                axis.dataMin = Math.min(pick11(axis.dataMin, seriesDataMin), seriesDataMin);
                axis.dataMax = Math.max(pick11(axis.dataMax, seriesDataMax), seriesDataMax);
              }
            }
          } else {
            const dataExtremes = series.applyExtremes();
            if (isNumber13(dataExtremes.dataMin)) {
              seriesDataMin = dataExtremes.dataMin;
              axis.dataMin = Math.min(pick11(axis.dataMin, seriesDataMin), seriesDataMin);
            }
            if (isNumber13(dataExtremes.dataMax)) {
              seriesDataMax = dataExtremes.dataMax;
              axis.dataMax = Math.max(pick11(axis.dataMax, seriesDataMax), seriesDataMax);
            }
            if (defined12(threshold)) {
              axis.threshold = threshold;
            }
            if (!seriesOptions.softThreshold || axis.positiveValuesOnly) {
              axis.softThreshold = false;
            }
          }
        }
      });
    });
    fireEvent6(this, "afterGetSeriesExtremes");
  }
  /**
   * Translate from axis value to pixel position on the chart, or back. Use
   * the `toPixels` and `toValue` functions in applications.
   *
   * @private
   * @function Highcharts.Axis#translate
   */
  translate(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
    const axis = this.linkedParent || this, localMin = old && axis.old ? axis.old.min : axis.min;
    if (!isNumber13(localMin)) {
      return NaN;
    }
    const minPixelPadding = axis.minPixelPadding, doPostTranslate = (axis.isOrdinal || axis.brokenAxis?.hasBreaks || axis.logarithmic && handleLog) && axis.lin2val;
    let sign = 1, cvsOffset = 0, localA = old && axis.old ? axis.old.transA : axis.transA, returnValue = 0;
    if (!localA) {
      localA = axis.transA;
    }
    if (cvsCoord) {
      sign *= -1;
      cvsOffset = axis.len;
    }
    if (axis.reversed) {
      sign *= -1;
      cvsOffset -= sign * (axis.sector || axis.len);
    }
    if (backwards) {
      val = val * sign + cvsOffset;
      val -= minPixelPadding;
      returnValue = val / localA + localMin;
      if (doPostTranslate) {
        returnValue = axis.lin2val(returnValue);
      }
    } else {
      if (doPostTranslate) {
        val = axis.val2lin(val);
      }
      const value = sign * (val - localMin) * localA;
      returnValue = value + cvsOffset + sign * minPixelPadding + (isNumber13(pointPlacement) ? localA * pointPlacement : 0);
      if (!axis.isRadial) {
        returnValue = correctFloat3(returnValue);
      }
    }
    return returnValue;
  }
  /**
   * Translate a value in terms of axis units into pixels within the chart.
   *
   * @function Highcharts.Axis#toPixels
   *
   * @param {number|string} value
   * A value in terms of axis units. For datetime axes, a timestamp or
   * date/time string is accepted.
   *
   * @param {boolean} [paneCoordinates=false]
   * Whether to return the pixel coordinate relative to the chart or just the
   * axis/pane itself.
   *
   * @return {number}
   * Pixel position of the value on the chart or axis.
   */
  toPixels(value, paneCoordinates) {
    return this.translate(this.chart?.time.parse(value) ?? NaN, false, !this.horiz, void 0, true) + (paneCoordinates ? 0 : this.pos);
  }
  /**
   * Translate a pixel position along the axis to a value in terms of axis
   * units.
   *
   * @function Highcharts.Axis#toValue
   *
   * @param {number} pixel
   * The pixel value coordinate.
   *
   * @param {boolean} [paneCoordinates=false]
   * Whether the input pixel is relative to the chart or just the axis/pane
   * itself.
   *
   * @return {number}
   * The axis value.
   */
  toValue(pixel, paneCoordinates) {
    return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, void 0, true);
  }
  /**
   * Create the path for a plot line that goes from the given value on
   * this axis, across the plot to the opposite side. Also used internally for
   * grid lines and crosshairs.
   *
   * @function Highcharts.Axis#getPlotLinePath
   *
   * @param {Highcharts.AxisPlotLinePathOptionsObject} options
   * Options for the path.
   *
   * @return {Highcharts.SVGPathArray|null}
   * The SVG path definition for the plot line.
   */
  getPlotLinePath(options2) {
    const axis = this, chart = axis.chart, axisLeft = axis.left, axisTop = axis.top, old = options2.old, value = options2.value, lineWidth = options2.lineWidth, cHeight = old && chart.oldChartHeight || chart.chartHeight, cWidth = old && chart.oldChartWidth || chart.chartWidth, transB = axis.transB;
    let translatedValue = options2.translatedValue, force = options2.force, x1, y1, x2, y2, skip;
    function between(x, a, b) {
      if (force !== "pass" && (x < a || x > b)) {
        if (force) {
          x = clamp4(x, a, b);
        } else {
          skip = true;
        }
      }
      return x;
    }
    const evt = {
      value,
      lineWidth,
      old,
      force,
      acrossPanes: options2.acrossPanes,
      translatedValue
    };
    fireEvent6(this, "getPlotLinePath", evt, function(e) {
      translatedValue = pick11(translatedValue, axis.translate(value, void 0, void 0, old));
      translatedValue = clamp4(translatedValue, -1e9, 1e9);
      x1 = x2 = translatedValue + transB;
      y1 = y2 = cHeight - translatedValue - transB;
      if (!isNumber13(translatedValue)) {
        skip = true;
        force = false;
      } else if (axis.horiz) {
        y1 = axisTop;
        y2 = cHeight - axis.bottom + (axis.options.isInternal ? 0 : chart.scrollablePixelsY || 0);
        x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
      } else {
        x1 = axisLeft;
        x2 = cWidth - axis.right + (chart.scrollablePixelsX || 0);
        y1 = y2 = between(y1, axisTop, axisTop + axis.height);
      }
      e.path = skip && !force ? void 0 : chart.renderer.crispLine([["M", x1, y1], ["L", x2, y2]], lineWidth || 1);
    });
    return evt.path;
  }
  /**
   * Internal function to get the tick positions of a linear axis to round
   * values like whole tens or every five.
   *
   * @function Highcharts.Axis#getLinearTickPositions
   *
   * @param {number} tickInterval
   * The normalized tick interval.
   *
   * @param {number} min
   * Axis minimum.
   *
   * @param {number} max
   * Axis maximum.
   *
   * @return {Array<number>}
   * An array of axis values where ticks should be placed.
   */
  getLinearTickPositions(tickInterval, min4, max4) {
    const roundedMin = correctFloat3(Math.floor(min4 / tickInterval) * tickInterval), roundedMax = correctFloat3(Math.ceil(max4 / tickInterval) * tickInterval), tickPositions = [];
    let pos, lastPos, precision;
    if (correctFloat3(roundedMin + tickInterval) === roundedMin) {
      precision = 20;
    }
    if (this.single) {
      return [min4];
    }
    pos = roundedMin;
    while (pos <= roundedMax) {
      tickPositions.push(pos);
      pos = correctFloat3(pos + tickInterval, precision);
      if (pos === lastPos) {
        break;
      }
      lastPos = pos;
    }
    return tickPositions;
  }
  /**
   * Resolve the new minorTicks/minorTickInterval options into the legacy
   * loosely typed minorTickInterval option.
   *
   * @function Highcharts.Axis#getMinorTickInterval
   *
   * @return {number|"auto"|null}
   * Legacy option
   */
  getMinorTickInterval() {
    const { minorTicks, minorTickInterval } = this.options;
    if (minorTicks === true) {
      return pick11(minorTickInterval, "auto");
    }
    if (minorTicks === false) {
      return;
    }
    return minorTickInterval;
  }
  /**
   * Internal function to return the minor tick positions. For logarithmic
   * axes, the same logic as for major ticks is reused.
   *
   * @function Highcharts.Axis#getMinorTickPositions
   *
   * @return {Array<number>}
   * An array of axis values where ticks should be placed.
   */
  getMinorTickPositions() {
    const axis = this, options2 = axis.options, tickPositions = axis.tickPositions, minorTickInterval = axis.minorTickInterval, pointRangePadding = axis.pointRangePadding || 0, min4 = (axis.min || 0) - pointRangePadding, max4 = (axis.max || 0) + pointRangePadding, range2 = axis.brokenAxis?.hasBreaks ? axis.brokenAxis.unitLength : max4 - min4;
    let minorTickPositions = [], pos;
    if (range2 && range2 / minorTickInterval < axis.len / 3) {
      const logarithmic = axis.logarithmic;
      if (logarithmic) {
        this.paddedTicks.forEach(function(_pos, i, paddedTicks) {
          if (i) {
            minorTickPositions.push.apply(minorTickPositions, logarithmic.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));
          }
        });
      } else if (axis.dateTime && this.getMinorTickInterval() === "auto") {
        minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval), min4, max4, options2.startOfWeek));
      } else {
        for (pos = min4 + (tickPositions[0] - min4) % minorTickInterval; pos <= max4; pos += minorTickInterval) {
          if (pos === minorTickPositions[0]) {
            break;
          }
          minorTickPositions.push(pos);
        }
      }
    }
    if (minorTickPositions.length !== 0) {
      axis.trimTicks(minorTickPositions);
    }
    return minorTickPositions;
  }
  /**
   * Adjust the min and max for the minimum range. Keep in mind that the
   * series data is not yet processed, so we don't have information on data
   * cropping and grouping, or updated `axis.pointRange` or
   * `series.pointRange`. The data can't be processed until we have finally
   * established min and max.
   *
   * @private
   * @function Highcharts.Axis#adjustForMinRange
   */
  adjustForMinRange() {
    const axis = this, options2 = axis.options, logarithmic = axis.logarithmic, time = axis.chart.time;
    let { max: max4, min: min4, minRange } = axis, zoomOffset, spaceAvailable, closestDataRange, minArgs, maxArgs;
    if (axis.isXAxis && typeof minRange === "undefined" && !logarithmic) {
      if (defined12(options2.min) || defined12(options2.max) || defined12(options2.floor) || defined12(options2.ceiling)) {
        minRange = null;
      } else {
        closestDataRange = getClosestDistance2(axis.series.map((s) => {
          const xData = s.getColumn("x");
          return s.xIncrement ? xData.slice(0, 2) : xData;
        })) || 0;
        minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);
      }
    }
    if (isNumber13(max4) && isNumber13(min4) && isNumber13(minRange) && max4 - min4 < minRange) {
      spaceAvailable = axis.dataMax - axis.dataMin >= minRange;
      zoomOffset = (minRange - max4 + min4) / 2;
      minArgs = [
        min4 - zoomOffset,
        time.parse(options2.min) ?? min4 - zoomOffset
      ];
      if (spaceAvailable) {
        minArgs[2] = logarithmic ? logarithmic.log2lin(axis.dataMin) : axis.dataMin;
      }
      min4 = arrayMax2(minArgs);
      maxArgs = [
        min4 + minRange,
        time.parse(options2.max) ?? min4 + minRange
      ];
      if (spaceAvailable) {
        maxArgs[2] = logarithmic ? logarithmic.log2lin(axis.dataMax) : axis.dataMax;
      }
      max4 = arrayMin2(maxArgs);
      if (max4 - min4 < minRange) {
        minArgs[0] = max4 - minRange;
        minArgs[1] = time.parse(options2.min) ?? max4 - minRange;
        min4 = arrayMax2(minArgs);
      }
    }
    axis.minRange = minRange;
    axis.min = min4;
    axis.max = max4;
  }
  /**
   * Find the closestPointRange across all series, including the single data
   * series.
   *
   * @private
   * @function Highcharts.Axis#getClosest
   */
  getClosest() {
    let closestSingleDistance, closestDistance;
    if (this.categories) {
      closestDistance = 1;
    } else {
      const singleXs = [];
      this.series.forEach(function(series) {
        const seriesClosest = series.closestPointRange, xData = series.getColumn("x");
        if (xData.length === 1) {
          singleXs.push(xData[0]);
        } else if (series.sorted && defined12(seriesClosest) && series.reserveSpace()) {
          closestDistance = defined12(closestDistance) ? Math.min(closestDistance, seriesClosest) : seriesClosest;
        }
      });
      if (singleXs.length) {
        singleXs.sort((a, b) => a - b);
        closestSingleDistance = getClosestDistance2([singleXs]);
      }
    }
    if (closestSingleDistance && closestDistance) {
      return Math.min(closestSingleDistance, closestDistance);
    }
    return closestSingleDistance || closestDistance;
  }
  /**
   * When a point name is given and no x, search for the name in the existing
   * categories, or if categories aren't provided, search names or create a
   * new category (#2522).
   *
   * @private
   * @function Highcharts.Axis#nameToX
   *
   * @param {Highcharts.Point} point
   * The point to inspect.
   *
   * @return {number}
   * The X value that the point is given.
   */
  nameToX(point) {
    const explicitCategories = isArray6(this.options.categories), names = explicitCategories ? this.categories : this.names;
    let nameX = point.options.x, x;
    point.series.requireSorting = false;
    if (!defined12(nameX)) {
      nameX = this.uniqueNames && names ? explicitCategories ? names.indexOf(point.name) : pick11(names.keys[point.name], -1) : point.series.autoIncrement();
    }
    if (nameX === -1) {
      if (!explicitCategories && names) {
        x = names.length;
      }
    } else if (isNumber13(nameX)) {
      x = nameX;
    }
    if (typeof x !== "undefined") {
      this.names[x] = point.name;
      this.names.keys[point.name] = x;
    } else if (point.x) {
      x = point.x;
    }
    return x;
  }
  /**
   * When changes have been done to series data, update the axis.names.
   *
   * @private
   * @function Highcharts.Axis#updateNames
   */
  updateNames() {
    const axis = this, names = this.names, i = names.length;
    if (i > 0) {
      Object.keys(names.keys).forEach(function(key) {
        delete names.keys[key];
      });
      names.length = 0;
      this.minRange = this.userMinRange;
      (this.series || []).forEach((series) => {
        series.xIncrement = null;
        if (!series.points || series.isDirtyData) {
          axis.max = Math.max(axis.max || 0, series.dataTable.rowCount - 1);
          series.processData();
          series.generatePoints();
        }
        const xData = series.getColumn("x").slice();
        series.data.forEach((point, i2) => {
          let x = xData[i2];
          if (point?.options && typeof point.name !== "undefined") {
            x = axis.nameToX(point);
            if (typeof x !== "undefined" && x !== point.x) {
              xData[i2] = point.x = x;
            }
          }
        });
        series.dataTable.setColumn("x", xData);
      });
    }
  }
  /**
   * Update translation information.
   *
   * @private
   * @function Highcharts.Axis#setAxisTranslation
   *
   * @emits Highcharts.Axis#event:afterSetAxisTranslation
   */
  setAxisTranslation() {
    const axis = this, range2 = axis.max - axis.min, linkedParent = axis.linkedParent, hasCategories = !!axis.categories, isXAxis = axis.isXAxis;
    let pointRange = axis.axisPointRange || 0, closestPointRange, minPointOffset = 0, pointRangePadding = 0, ordinalCorrection, transA = axis.transA;
    if (isXAxis || hasCategories || pointRange) {
      closestPointRange = axis.getClosest();
      if (linkedParent) {
        minPointOffset = linkedParent.minPointOffset;
        pointRangePadding = linkedParent.pointRangePadding;
      } else {
        axis.series.forEach(function(series) {
          const seriesPointRange = hasCategories ? 1 : isXAxis ? pick11(series.options.pointRange, closestPointRange, 0) : axis.axisPointRange || 0, pointPlacement = series.options.pointPlacement;
          pointRange = Math.max(pointRange, seriesPointRange);
          if (!axis.single || hasCategories) {
            const isPointPlacementAxis = series.is("xrange") ? !isXAxis : isXAxis;
            minPointOffset = Math.max(minPointOffset, isPointPlacementAxis && isString9(pointPlacement) ? 0 : seriesPointRange / 2);
            pointRangePadding = Math.max(pointRangePadding, isPointPlacementAxis && pointPlacement === "on" ? 0 : seriesPointRange);
          }
        });
      }
      ordinalCorrection = axis.ordinal?.slope && closestPointRange ? axis.ordinal.slope / closestPointRange : 1;
      axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
      axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;
      axis.pointRange = Math.min(pointRange, axis.single && hasCategories ? 1 : range2);
      if (isXAxis) {
        axis.closestPointRange = closestPointRange;
      }
    }
    axis.translationSlope = axis.transA = transA = axis.staticScale || axis.len / (range2 + pointRangePadding || 1);
    axis.transB = axis.horiz ? axis.left : axis.bottom;
    axis.minPixelPadding = transA * minPointOffset;
    fireEvent6(this, "afterSetAxisTranslation");
  }
  /**
   * @private
   * @function Highcharts.Axis#minFromRange
   */
  minFromRange() {
    const { max: max4, min: min4 } = this;
    return isNumber13(max4) && isNumber13(min4) && max4 - min4 || void 0;
  }
  /**
   * Set the tick positions to round values and optionally extend the extremes
   * to the nearest tick.
   *
   * @private
   * @function Highcharts.Axis#setTickInterval
   *
   * @param {boolean} secondPass
   * TO-DO: parameter description
   *
   * @emits Highcharts.Axis#event:foundExtremes
   */
  setTickInterval(secondPass) {
    const axis = this, { categories, chart, dataMax, dataMin, dateTime, isXAxis, logarithmic, options: options2, softThreshold } = axis, time = chart.time, threshold = isNumber13(axis.threshold) ? axis.threshold : void 0, minRange = axis.minRange || 0, { ceiling, floor, linkedTo, softMax, softMin } = options2, linkedParent = isNumber13(linkedTo) && chart[axis.coll]?.[linkedTo], tickPixelIntervalOption = options2.tickPixelInterval;
    let maxPadding = options2.maxPadding, minPadding = options2.minPadding, range2 = 0, linkedParentExtremes, tickIntervalOption = isNumber13(options2.tickInterval) && options2.tickInterval >= 0 ? options2.tickInterval : void 0, thresholdMin, thresholdMax, hardMin, hardMax;
    if (!dateTime && !categories && !linkedParent) {
      this.getTickAmount();
    }
    hardMin = pick11(axis.userMin, time.parse(options2.min));
    hardMax = pick11(axis.userMax, time.parse(options2.max));
    if (linkedParent) {
      axis.linkedParent = linkedParent;
      linkedParentExtremes = linkedParent.getExtremes();
      axis.min = pick11(linkedParentExtremes.min, linkedParentExtremes.dataMin);
      axis.max = pick11(linkedParentExtremes.max, linkedParentExtremes.dataMax);
      if (this.type !== linkedParent.type) {
        error4(11, true, chart);
      }
    } else {
      if (softThreshold && defined12(threshold) && isNumber13(dataMax) && isNumber13(dataMin)) {
        if (dataMin >= threshold) {
          thresholdMin = threshold;
          minPadding = 0;
        } else if (dataMax <= threshold) {
          thresholdMax = threshold;
          maxPadding = 0;
        }
      }
      axis.min = pick11(hardMin, thresholdMin, dataMin);
      axis.max = pick11(hardMax, thresholdMax, dataMax);
    }
    if (isNumber13(axis.max) && isNumber13(axis.min)) {
      if (logarithmic) {
        if (axis.positiveValuesOnly && !secondPass && Math.min(axis.min, pick11(dataMin, axis.min)) <= 0) {
          error4(10, true, chart);
        }
        axis.min = correctFloat3(logarithmic.log2lin(axis.min), 16);
        axis.max = correctFloat3(logarithmic.log2lin(axis.max), 16);
      }
      if (axis.range && isNumber13(dataMin)) {
        axis.userMin = axis.min = hardMin = Math.max(dataMin, axis.minFromRange() || 0);
        axis.userMax = hardMax = axis.max;
        axis.range = void 0;
      }
    }
    fireEvent6(axis, "foundExtremes");
    axis.adjustForMinRange();
    if (isNumber13(axis.min) && isNumber13(axis.max)) {
      if (!isNumber13(axis.userMin) && isNumber13(softMin) && softMin < axis.min) {
        axis.min = hardMin = softMin;
      }
      if (!isNumber13(axis.userMax) && isNumber13(softMax) && softMax > axis.max) {
        axis.max = hardMax = softMax;
      }
      if (!categories && !axis.axisPointRange && !axis.stacking?.usePercentage && !linkedParent) {
        range2 = axis.max - axis.min;
        if (range2) {
          if (!defined12(hardMin) && minPadding) {
            axis.min -= range2 * minPadding;
          }
          if (!defined12(hardMax) && maxPadding) {
            axis.max += range2 * maxPadding;
          }
        }
      }
      if (!isNumber13(axis.userMin) && isNumber13(floor)) {
        axis.min = Math.max(axis.min, floor);
      }
      if (!isNumber13(axis.userMax) && isNumber13(ceiling)) {
        axis.max = Math.min(axis.max, ceiling);
      }
      if (softThreshold && isNumber13(dataMin) && isNumber13(dataMax)) {
        const numThreshold = threshold || 0;
        if (!defined12(hardMin) && axis.min < numThreshold && dataMin >= numThreshold) {
          axis.min = options2.minRange ? Math.min(numThreshold, axis.max - minRange) : numThreshold;
        } else if (!defined12(hardMax) && axis.max > numThreshold && dataMax <= numThreshold) {
          axis.max = options2.minRange ? Math.max(numThreshold, axis.min + minRange) : numThreshold;
        }
      }
      if (!chart.polar && axis.min > axis.max) {
        if (defined12(options2.min)) {
          axis.max = axis.min;
        } else if (defined12(options2.max)) {
          axis.min = axis.max;
        }
      }
      range2 = axis.max - axis.min;
    }
    if (axis.min === axis.max || !isNumber13(axis.min) || !isNumber13(axis.max)) {
      axis.tickInterval = 1;
    } else if (linkedParent && !tickIntervalOption && tickPixelIntervalOption === linkedParent.options.tickPixelInterval) {
      axis.tickInterval = tickIntervalOption = linkedParent.tickInterval;
    } else {
      axis.tickInterval = pick11(
        tickIntervalOption,
        this.tickAmount ? range2 / Math.max(this.tickAmount - 1, 1) : void 0,
        // For categorized axis, 1 is default, for linear axis use
        // tickPix
        categories ? 1 : (
          // Don't let it be more than the data range
          range2 * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption)
        )
      );
    }
    if (isXAxis && !secondPass) {
      const hasExtremesChanged = axis.min !== axis.old?.min || axis.max !== axis.old?.max;
      axis.series.forEach(function(series) {
        series.forceCrop = series.forceCropping?.();
        series.processData(hasExtremesChanged);
      });
      fireEvent6(this, "postProcessData", { hasExtremesChanged });
    }
    axis.setAxisTranslation();
    fireEvent6(this, "initialAxisTranslation");
    if (axis.pointRange && !tickIntervalOption) {
      axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
    }
    const minTickInterval = pick11(
      options2.minTickInterval,
      // In datetime axes, don't go below the data interval, except when
      // there are scatter-like series involved (#13369).
      dateTime && !axis.series.some((s) => !s.sorted) ? axis.closestPointRange : 0
    );
    if (!tickIntervalOption && minTickInterval && axis.tickInterval < minTickInterval) {
      axis.tickInterval = minTickInterval;
    }
    if (!dateTime && !logarithmic && !tickIntervalOption) {
      axis.tickInterval = getNormalizedTickInterval(axis, axis.tickInterval);
    }
    if (!this.tickAmount) {
      axis.tickInterval = axis.unsquish();
    }
    this.setTickPositions();
  }
  /**
   * Now we have computed the normalized tickInterval, get the tick positions.
   *
   * @private
   * @function Highcharts.Axis#setTickPositions
   *
   * @emits Highcharts.Axis#event:afterSetTickPositions
   */
  setTickPositions() {
    const axis = this, options2 = this.options, tickPositionsOption = options2.tickPositions, tickPositioner = options2.tickPositioner, minorTickIntervalOption = this.getMinorTickInterval(), allowEndOnTick = !this.isPanning, startOnTick = allowEndOnTick && options2.startOnTick, endOnTick = allowEndOnTick && options2.endOnTick;
    let tickPositions = [], tickPositionerResult;
    this.tickmarkOffset = this.categories && options2.tickmarkPlacement === "between" && this.tickInterval === 1 ? 0.5 : 0;
    this.single = this.min === this.max && defined12(this.min) && !this.tickAmount && // Data is on integer (#6563)
    (this.min % 1 === 0 || // Between integers and decimals are not allowed (#6274)
    options2.allowDecimals !== false);
    if (tickPositionsOption) {
      tickPositions = tickPositionsOption.slice();
    } else if (isNumber13(this.min) && isNumber13(this.max)) {
      if (!axis.ordinal?.positions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) {
        tickPositions = [this.min, this.max];
        error4(19, false, this.chart);
      } else if (axis.dateTime) {
        tickPositions = axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval, options2.units), this.min, this.max, options2.startOfWeek, axis.ordinal?.positions, this.closestPointRange, true);
      } else if (axis.logarithmic) {
        tickPositions = axis.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
      } else {
        const startingTickInterval = this.tickInterval;
        let adjustedTickInterval = startingTickInterval;
        while (adjustedTickInterval <= startingTickInterval * 2) {
          tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
          if (this.tickAmount && tickPositions.length > this.tickAmount) {
            this.tickInterval = getNormalizedTickInterval(this, adjustedTickInterval *= 1.1);
          } else {
            break;
          }
        }
      }
      if (tickPositions.length > this.len) {
        tickPositions = [
          tickPositions[0],
          tickPositions[tickPositions.length - 1]
        ];
        if (tickPositions[0] === tickPositions[1]) {
          tickPositions.length = 1;
        }
      }
      if (tickPositioner) {
        this.tickPositions = tickPositions;
        tickPositionerResult = tickPositioner.apply(axis, [this.min, this.max]);
        if (tickPositionerResult) {
          tickPositions = tickPositionerResult;
        }
      }
    }
    this.tickPositions = tickPositions;
    this.minorTickInterval = minorTickIntervalOption === "auto" && this.tickInterval ? this.tickInterval / options2.minorTicksPerMajor : minorTickIntervalOption;
    this.paddedTicks = tickPositions.slice(0);
    this.trimTicks(tickPositions, startOnTick, endOnTick);
    if (!this.isLinked && isNumber13(this.min) && isNumber13(this.max)) {
      if (this.single && tickPositions.length < 2 && !this.categories && !this.series.some((s) => s.is("heatmap") && s.options.pointPlacement === "between")) {
        this.min -= 0.5;
        this.max += 0.5;
      }
      if (!tickPositionsOption && !tickPositionerResult) {
        this.adjustTickAmount();
      }
    }
    fireEvent6(this, "afterSetTickPositions");
  }
  /**
   * Handle startOnTick and endOnTick by either adapting to padding min/max or
   * rounded min/max. Also handle single data points.
   *
   * @private
   * @function Highcharts.Axis#trimTicks
   *
   * @param {Array<number>} tickPositions
   * TO-DO: parameter description
   *
   * @param {boolean} [startOnTick]
   * TO-DO: parameter description
   *
   * @param {boolean} [endOnTick]
   * TO-DO: parameter description
   */
  trimTicks(tickPositions, startOnTick, endOnTick) {
    const roundedMin = tickPositions[0], roundedMax = tickPositions[tickPositions.length - 1], minPointOffset = !this.isOrdinal && this.minPointOffset || 0;
    fireEvent6(this, "trimTicks");
    if (!this.isLinked || // Linked non-grid axes should trim ticks, #21743.
    // Grid axis has custom handling of ticks.
    !this.grid) {
      if (startOnTick && roundedMin !== -Infinity) {
        this.min = roundedMin;
      } else {
        while (this.min - minPointOffset > tickPositions[0]) {
          tickPositions.shift();
        }
      }
      if (endOnTick) {
        this.max = roundedMax;
      } else {
        while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
          tickPositions.pop();
        }
      }
      if (tickPositions.length === 0 && defined12(roundedMin) && !this.options.tickPositions) {
        tickPositions.push((roundedMax + roundedMin) / 2);
      }
    }
  }
  /**
   * Check if there are multiple axes in the same pane.
   *
   * @private
   * @function Highcharts.Axis#alignToOthers
   *
   * @return {boolean|undefined}
   * True if there are other axes.
   */
  alignToOthers() {
    const axis = this, chart = axis.chart, alignedAxes = [this], options2 = axis.options, chartOptions = chart.options.chart, alignThresholds = this.coll === "yAxis" && chartOptions.alignThresholds, thresholdAlignments = [];
    let hasOther;
    axis.thresholdAlignment = void 0;
    if (
      // Only if alignTicks or alignThresholds is true
      (chartOptions.alignTicks !== false && options2.alignTicks || alignThresholds) && // Disabled when startOnTick or endOnTick are false (#7604)
      options2.startOnTick !== false && options2.endOnTick !== false && // Don't try to align ticks on a log axis, they are not evenly
      // spaced (#6021)
      !axis.logarithmic
    ) {
      const getKey = (axis2) => {
        const { horiz, options: options3 } = axis2;
        return [
          horiz ? options3.left : options3.top,
          options3.width,
          options3.height,
          options3.pane
        ].join(",");
      };
      const thisKey = getKey(this);
      chart[this.coll].forEach(function(otherAxis) {
        const { series } = otherAxis;
        if (
          // #4442
          series.length && series.some((s) => s.visible) && otherAxis !== axis && getKey(otherAxis) === thisKey
        ) {
          hasOther = true;
          alignedAxes.push(otherAxis);
        }
      });
    }
    if (hasOther && alignThresholds) {
      alignedAxes.forEach((otherAxis) => {
        const threshAlign = otherAxis.getThresholdAlignment(axis);
        if (isNumber13(threshAlign)) {
          thresholdAlignments.push(threshAlign);
        }
      });
      const thresholdAlignment = thresholdAlignments.length > 1 ? thresholdAlignments.reduce((sum2, n) => sum2 += n, 0) / thresholdAlignments.length : void 0;
      alignedAxes.forEach((axis2) => {
        axis2.thresholdAlignment = thresholdAlignment;
      });
    }
    return hasOther;
  }
  /**
   * Where the axis wants its threshold, from 0 which is on `axis.min`, to 1 which
   * is on `axis.max`.
   *
   * @private
   * @function Highcharts.Axis#getThresholdAlignment
   */
  getThresholdAlignment(callerAxis) {
    if (!isNumber13(this.dataMin) || this !== callerAxis && this.series.some((s) => s.isDirty || s.isDirtyData)) {
      this.getSeriesExtremes();
    }
    if (isNumber13(this.threshold)) {
      let thresholdAlignment = clamp4((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
      if (this.options.reversed) {
        thresholdAlignment = 1 - thresholdAlignment;
      }
      return thresholdAlignment;
    }
  }
  /**
   * Find the max ticks of either the x and y axis collection, and record it
   * in `this.tickAmount`.
   *
   * @private
   * @function Highcharts.Axis#getTickAmount
   */
  getTickAmount() {
    const axis = this, options2 = this.options, tickPixelInterval = options2.tickPixelInterval;
    let tickAmount = options2.tickAmount;
    if (!defined12(options2.tickInterval) && !tickAmount && this.len < tickPixelInterval && !this.isRadial && !axis.logarithmic && options2.startOnTick && options2.endOnTick) {
      tickAmount = 2;
    }
    if (!tickAmount && this.alignToOthers()) {
      tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
    }
    if (tickAmount < 4) {
      this.finalTickAmt = tickAmount;
      tickAmount = 5;
    }
    this.tickAmount = tickAmount;
  }
  /**
   * When using multiple axes, adjust the number of ticks to match the highest
   * number of ticks in that group.
   *
   * @private
   * @function Highcharts.Axis#adjustTickAmount
   */
  adjustTickAmount() {
    const axis = this, { finalTickAmt, max: max4, min: min4, options: options2, tickPositions, tickAmount, thresholdAlignment } = axis, currentTickAmount = tickPositions?.length, threshold = pick11(axis.threshold, axis.softThreshold ? 0 : null);
    let len, i, tickInterval = axis.tickInterval, thresholdTickIndex;
    const append = () => tickPositions.push(correctFloat3(tickPositions[tickPositions.length - 1] + tickInterval)), prepend = () => tickPositions.unshift(correctFloat3(tickPositions[0] - tickInterval));
    if (isNumber13(thresholdAlignment)) {
      thresholdTickIndex = thresholdAlignment < 0.5 ? Math.ceil(thresholdAlignment * (tickAmount - 1)) : Math.floor(thresholdAlignment * (tickAmount - 1));
      if (options2.reversed) {
        thresholdTickIndex = tickAmount - 1 - thresholdTickIndex;
      }
    }
    if (axis.hasData() && isNumber13(min4) && isNumber13(max4)) {
      const adjustExtremes2 = () => {
        axis.transA *= (currentTickAmount - 1) / (tickAmount - 1);
        axis.min = options2.startOnTick ? tickPositions[0] : Math.min(min4, tickPositions[0]);
        axis.max = options2.endOnTick ? tickPositions[tickPositions.length - 1] : Math.max(max4, tickPositions[tickPositions.length - 1]);
      };
      if (isNumber13(thresholdTickIndex) && isNumber13(axis.threshold)) {
        while (tickPositions[thresholdTickIndex] !== threshold || tickPositions.length !== tickAmount || tickPositions[0] > min4 || tickPositions[tickPositions.length - 1] < max4) {
          tickPositions.length = 0;
          tickPositions.push(axis.threshold);
          while (tickPositions.length < tickAmount) {
            if (
              // Start by prepending positions until the threshold
              // is at the required index...
              tickPositions[thresholdTickIndex] === void 0 || tickPositions[thresholdTickIndex] > axis.threshold
            ) {
              prepend();
            } else {
              append();
            }
          }
          if (tickInterval > axis.tickInterval * 8) {
            break;
          }
          tickInterval *= 2;
        }
        adjustExtremes2();
      } else if (currentTickAmount < tickAmount) {
        while (tickPositions.length < tickAmount) {
          if (tickPositions.length % 2 || min4 === threshold) {
            append();
          } else {
            prepend();
          }
        }
        adjustExtremes2();
      }
      if (defined12(finalTickAmt)) {
        i = len = tickPositions.length;
        while (i--) {
          if (
            // Remove every other tick
            finalTickAmt === 3 && i % 2 === 1 || // Remove all but first and last
            finalTickAmt <= 2 && i > 0 && i < len - 1
          ) {
            tickPositions.splice(i, 1);
          }
        }
        axis.finalTickAmt = void 0;
      }
    }
  }
  /**
   * Set the scale based on data min and max, user set min and max or options.
   *
   * @private
   * @function Highcharts.Axis#setScale
   *
   * @emits Highcharts.Axis#event:afterSetScale
   */
  setScale() {
    const axis = this, { coll, stacking } = axis;
    let isDirtyData = false, isXAxisDirty = false;
    axis.series.forEach((series) => {
      isDirtyData = isDirtyData || series.isDirtyData || series.isDirty;
      isXAxisDirty = isXAxisDirty || series.xAxis?.isDirty || false;
    });
    axis.setAxisSize();
    const isDirtyAxisLength = axis.len !== axis.old?.len;
    if (isDirtyAxisLength || isDirtyData || isXAxisDirty || axis.isLinked || axis.forceRedraw || axis.userMin !== axis.old?.userMin || axis.userMax !== axis.old?.userMax || axis.alignToOthers()) {
      if (stacking && coll === "yAxis") {
        stacking.buildStacks();
      }
      axis.forceRedraw = false;
      if (!axis.userMinRange) {
        axis.minRange = void 0;
      }
      axis.getSeriesExtremes();
      axis.setTickInterval();
      if (stacking && coll === "xAxis") {
        stacking.buildStacks();
      }
      if (!axis.isDirty) {
        axis.isDirty = isDirtyAxisLength || axis.min !== axis.old?.min || axis.max !== axis.old?.max;
      }
    } else if (stacking) {
      stacking.cleanStacks();
    }
    if (isDirtyData) {
      delete axis.allExtremes;
    }
    fireEvent6(this, "afterSetScale");
  }
  /**
   * Set the minimum and maximum of the axes after render time. If the
   * `startOnTick` and `endOnTick` options are true, the minimum and maximum
   * values are rounded off to the nearest tick. To prevent this, these
   * options can be set to false before calling setExtremes. Also, setExtremes
   * will not allow a range lower than the `minRange` option, which by default
   * is the range of five points.
   *
   * @sample highcharts/members/axis-setextremes/
   *         Set extremes from a button
   * @sample highcharts/members/axis-setextremes-datetime/
   *         Set extremes on a datetime axis
   * @sample highcharts/members/axis-setextremes-off-ticks/
   *         Set extremes off ticks
   * @sample stock/members/axis-setextremes/
   *         Set extremes in Highcharts Stock
   *
   * @function Highcharts.Axis#setExtremes
   *
   * @param {number|string} [newMin]
   * The new minimum value. For datetime axes, date strings are accepted.
   *
   * @param {number|string} [newMax]
   * The new maximum value. For datetime axes, date strings are accepted.
   *
   * @param {boolean} [redraw=true]
   * Whether to redraw the chart or wait for an explicit call to
   * {@link Highcharts.Chart#redraw}
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=true]
   * Enable or modify animations.
   *
   * @param {*} [eventArguments]
   * Arguments to be accessed in event handler.
   *
   * @emits Highcharts.Axis#event:setExtremes
   */
  setExtremes(min4, max4, redraw = true, animation, eventArguments) {
    const chart = this.chart;
    this.series.forEach((serie) => {
      delete serie.kdTree;
    });
    min4 = chart.time.parse(min4);
    max4 = chart.time.parse(max4);
    eventArguments = extend11(eventArguments, { min: min4, max: max4 });
    fireEvent6(this, "setExtremes", eventArguments, (e) => {
      this.userMin = e.min;
      this.userMax = e.max;
      this.eventArgs = e;
      if (redraw) {
        chart.redraw(animation);
      }
    });
  }
  /**
   * Update the axis metrics.
   *
   * @private
   * @function Highcharts.Axis#setAxisSize
   */
  setAxisSize() {
    const chart = this.chart, options2 = this.options, offsets = options2.offsets || [0, 0, 0, 0], horiz = this.horiz, width = this.width = Math.round(relativeLength2(pick11(options2.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth)), height = this.height = Math.round(relativeLength2(pick11(options2.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight)), top = this.top = Math.round(relativeLength2(pick11(options2.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop)), left = this.left = Math.round(relativeLength2(pick11(options2.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft));
    this.bottom = chart.chartHeight - height - top;
    this.right = chart.chartWidth - width - left;
    this.len = Math.max(horiz ? width : height, 0);
    this.pos = horiz ? left : top;
  }
  /**
   * Get the current extremes for the axis.
   *
   * @sample highcharts/members/axis-getextremes/
   *         Report extremes by click on a button
   *
   * @function Highcharts.Axis#getExtremes
   *
   * @return {Highcharts.ExtremesObject}
   * An object containing extremes information.
   */
  getExtremes() {
    const axis = this, log = axis.logarithmic;
    return {
      min: log ? correctFloat3(log.lin2log(axis.min)) : axis.min,
      max: log ? correctFloat3(log.lin2log(axis.max)) : axis.max,
      dataMin: axis.dataMin,
      dataMax: axis.dataMax,
      userMin: axis.userMin,
      userMax: axis.userMax
    };
  }
  /**
   * Get the zero plane either based on zero or on the min or max value.
   * Used in bar and area plots.
   *
   * @function Highcharts.Axis#getThreshold
   *
   * @param {number} threshold
   * The threshold in axis values.
   *
   * @return {number}
   * The translated threshold position in terms of pixels, and corrected to
   * stay within the axis bounds.
   */
  getThreshold(threshold) {
    const axis = this, log = axis.logarithmic, realMin = log ? log.lin2log(axis.min) : axis.min, realMax = log ? log.lin2log(axis.max) : axis.max;
    if (threshold === null || threshold === -Infinity) {
      threshold = realMin;
    } else if (threshold === Infinity) {
      threshold = realMax;
    } else if (realMin > threshold) {
      threshold = realMin;
    } else if (realMax < threshold) {
      threshold = realMax;
    }
    return axis.translate(threshold, 0, 1, 0, 1);
  }
  /**
   * Compute auto alignment for the axis label based on which side the axis is
   * on and the given rotation for the label.
   *
   * @private
   * @function Highcharts.Axis#autoLabelAlign
   *
   * @param {number} rotation
   * The rotation in degrees as set by either the `rotation` or `autoRotation`
   * options.
   *
   * @return {Highcharts.AlignValue}
   * Can be `"center"`, `"left"` or `"right"`.
   */
  autoLabelAlign(rotation) {
    const angle = (pick11(rotation, 0) - this.side * 90 + 720) % 360, evt = { align: "center" };
    fireEvent6(this, "autoLabelAlign", evt, function(e) {
      if (angle > 15 && angle < 165) {
        e.align = "right";
      } else if (angle > 195 && angle < 345) {
        e.align = "left";
      }
    });
    return evt.align;
  }
  /**
   * Get the tick length and width for the axis based on axis options.
   *
   * @private
   * @function Highcharts.Axis#tickSize
   *
   * @param {string} [prefix]
   * 'tick' or 'minorTick'
   *
   * @return {Array<number,number>|undefined}
   * An array of tickLength and tickWidth
   */
  tickSize(prefix) {
    const options2 = this.options, tickWidth = pick11(
      options2[prefix === "tick" ? "tickWidth" : "minorTickWidth"],
      // Default to 1 on linear and datetime X axes
      prefix === "tick" && this.isXAxis && !this.categories ? 1 : 0
    );
    let tickLength = options2[prefix === "tick" ? "tickLength" : "minorTickLength"], tickSize;
    if (tickWidth && tickLength) {
      if (options2[prefix + "Position"] === "inside") {
        tickLength = -tickLength;
      }
      tickSize = [tickLength, tickWidth];
    }
    const e = { tickSize };
    fireEvent6(this, "afterTickSize", e);
    return e.tickSize;
  }
  /**
   * Return the size of the labels.
   *
   * @private
   * @function Highcharts.Axis#labelMetrics
   */
  labelMetrics() {
    const renderer = this.chart.renderer, ticks = this.ticks, tick = ticks[Object.keys(ticks)[0]] || {};
    return this.chart.renderer.fontMetrics(tick.label || tick.movedLabel || renderer.box);
  }
  /**
   * Prevent the ticks from getting so close we can't draw the labels. On a
   * horizontal axis, this is handled by rotating the labels, removing ticks
   * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.
   *
   * @private
   * @function Highcharts.Axis#unsquish
   */
  unsquish() {
    const labelOptions = this.options.labels, padding = labelOptions.padding || 0, horiz = this.horiz, tickInterval = this.tickInterval, slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval), rotationOption = labelOptions.rotation, lineHeight = correctFloat3(this.labelMetrics().h * 0.8), range2 = Math.max(this.max - this.min, 0), getStep = function(spaceNeeded) {
      let step = (spaceNeeded + 2 * padding) / (slotSize || 1);
      step = step > 1 ? Math.ceil(step) : 1;
      if (step * tickInterval > range2 && spaceNeeded !== Infinity && slotSize !== Infinity && range2) {
        step = Math.ceil(range2 / tickInterval);
      }
      return correctFloat3(step * tickInterval);
    };
    let newTickInterval = tickInterval, rotation, bestScore = Number.MAX_VALUE, autoRotation;
    if (horiz) {
      if (!labelOptions.staggerLines) {
        if (isNumber13(rotationOption)) {
          autoRotation = [rotationOption];
        } else if (slotSize < labelOptions.autoRotationLimit) {
          autoRotation = labelOptions.autoRotation;
        }
      }
      if (autoRotation) {
        let step, score;
        for (const rot of autoRotation) {
          if (rot === rotationOption || rot && rot >= -90 && rot <= 90) {
            step = getStep(Math.abs(lineHeight / Math.sin(deg2rad4 * rot)));
            score = step + Math.abs(rot / 360);
            if (score < bestScore) {
              bestScore = score;
              rotation = rot;
              newTickInterval = step;
            }
          }
        }
      }
    } else {
      newTickInterval = getStep(lineHeight * 0.75);
    }
    this.autoRotation = autoRotation;
    this.labelRotation = pick11(rotation, isNumber13(rotationOption) ? rotationOption : 0);
    return labelOptions.step ? tickInterval : newTickInterval;
  }
  /**
   * Get the general slot width for labels/categories on this axis. This may
   * change between the pre-render (from Axis.getOffset) and the final tick
   * rendering and placement.
   *
   * @private
   * @function Highcharts.Axis#getSlotWidth
   *
   * @param {Highcharts.Tick} [tick] Optionally, calculate the slot width
   * basing on tick label. It is used in highcharts-3d module, where the slots
   * has different widths depending on perspective angles.
   *
   * @return {number}
   * The pixel width allocated to each axis label.
   */
  getSlotWidth(tick) {
    const chart = this.chart, horiz = this.horiz, labelOptions = this.options.labels, slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), marginLeft = chart.margin[3];
    if (tick && isNumber13(tick.slotWidth)) {
      return tick.slotWidth;
    }
    if (horiz && labelOptions.step < 2 && !this.isRadial) {
      if (labelOptions.rotation) {
        return 0;
      }
      return (this.staggerLines || 1) * this.len / slotCount;
    }
    if (!horiz) {
      const cssWidth = labelOptions.style.width;
      if (cssWidth !== void 0) {
        return parseInt(String(cssWidth), 10);
      }
      if (marginLeft) {
        return marginLeft - chart.spacing[3];
      }
    }
    return chart.chartWidth * 0.33;
  }
  /**
   * Render the axis labels and determine whether ellipsis or rotation need to
   * be applied.
   *
   * @private
   * @function Highcharts.Axis#renderUnsquish
   */
  renderUnsquish() {
    const chart = this.chart, renderer = chart.renderer, tickPositions = this.tickPositions, ticks = this.ticks, labelOptions = this.options.labels, labelStyleOptions = labelOptions.style, horiz = this.horiz, slotWidth = this.getSlotWidth(), innerWidth = Math.max(1, Math.round(slotWidth - (horiz ? 2 * (labelOptions.padding || 0) : labelOptions.distance || 0))), attr18 = {}, labelMetrics = this.labelMetrics(), lineClampOption = labelStyleOptions.lineClamp;
    let commonWidth, lineClamp = lineClampOption ?? (Math.floor(this.len / (tickPositions.length * labelMetrics.h)) || 1), maxLabelLength = 0;
    if (!isString9(labelOptions.rotation)) {
      attr18.rotation = labelOptions.rotation || 0;
    }
    tickPositions.forEach(function(tickPosition) {
      const tick = ticks[tickPosition];
      if (tick.movedLabel) {
        tick.replaceMovedLabel();
      }
      const textPxLength = tick.label?.textPxLength || 0;
      if (textPxLength > maxLabelLength) {
        maxLabelLength = textPxLength;
      }
    });
    this.maxLabelLength = maxLabelLength;
    if (this.autoRotation) {
      if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {
        attr18.rotation = this.labelRotation;
      } else {
        this.labelRotation = 0;
      }
    } else if (slotWidth) {
      commonWidth = innerWidth;
    }
    if (attr18.rotation) {
      commonWidth = maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : maxLabelLength;
      if (!lineClampOption) {
        lineClamp = 1;
      }
    }
    this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);
    if (this.labelAlign) {
      attr18.align = this.labelAlign;
    }
    tickPositions.forEach(function(pos) {
      const tick = ticks[pos], label = tick?.label, widthOption = labelStyleOptions.width, css19 = {};
      if (label) {
        label.attr(attr18);
        if (tick.shortenLabel) {
          tick.shortenLabel();
        } else if (commonWidth && !widthOption && // Setting width in this case messes with the bounding box
        // (#7975)
        labelStyleOptions.whiteSpace !== "nowrap" && // Speed optimizing, #7656
        (commonWidth < (label.textPxLength || 0) || // Resetting CSS, #4928
        label.element.tagName === "SPAN")) {
          label.css(extend11(css19, {
            width: `${commonWidth}px`,
            lineClamp
          }));
        } else if (label.styles.width && !css19.width && !widthOption) {
          label.css({ width: "auto" });
        }
        tick.rotation = attr18.rotation;
      }
    }, this);
    this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
  }
  /**
   * Return true if the axis has associated data.
   *
   * @function Highcharts.Axis#hasData
   *
   * @return {boolean}
   * True if the axis has associated visible series and those series have
   * either valid data points or explicit `min` and `max` settings.
   */
  hasData() {
    return this.series.some(function(s) {
      return s.hasData();
    }) || this.options.showEmpty && defined12(this.min) && defined12(this.max);
  }
  /**
   * Adds the title defined in axis.options.title.
   *
   * @function Highcharts.Axis#addTitle
   *
   * @param {boolean} [display]
   * Whether or not to display the title.
   */
  addTitle(display) {
    const axis = this, renderer = axis.chart.renderer, horiz = axis.horiz, opposite = axis.opposite, options2 = axis.options, axisTitleOptions = options2.title, styledMode = axis.chart.styledMode;
    let textAlign;
    if (!axis.axisTitle) {
      textAlign = axisTitleOptions.textAlign;
      if (!textAlign) {
        textAlign = (horiz ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: opposite ? "right" : "left",
          middle: "center",
          high: opposite ? "left" : "right"
        })[axisTitleOptions.align];
      }
      axis.axisTitle = renderer.text(axisTitleOptions.text || "", 0, 0, axisTitleOptions.useHTML).attr({
        zIndex: 7,
        rotation: axisTitleOptions.rotation || 0,
        align: textAlign
      }).addClass("highcharts-axis-title");
      if (!styledMode) {
        axis.axisTitle.css(merge10(axisTitleOptions.style));
      }
      axis.axisTitle.add(axis.axisGroup);
      axis.axisTitle.isNew = true;
    }
    if (!styledMode && !axisTitleOptions.style.width && !axis.isRadial) {
      axis.axisTitle.css({
        width: axis.len + "px"
      });
    }
    axis.axisTitle[display ? "show" : "hide"](display);
  }
  /**
   * Generates a tick for initial positioning.
   *
   * @private
   * @function Highcharts.Axis#generateTick
   *
   * @param {number} pos
   * The tick position in axis values.
   *
   * @param {number} [i]
   * The index of the tick in {@link Axis.tickPositions}.
   */
  generateTick(pos) {
    const axis = this, ticks = axis.ticks;
    if (!ticks[pos]) {
      ticks[pos] = new Tick_default(axis, pos);
    } else {
      ticks[pos].addLabel();
    }
  }
  /**
   * Create the axisGroup and gridGroup elements on first iteration.
   *
   * @private
   * @function Highcharts.Axis#getOffset
   *
   * @emits Highcharts.Axis#event:afterGetOffset
   */
  createGroups() {
    const {
      axisParent,
      // Used in color axis
      chart,
      coll,
      options: options2
    } = this, renderer = chart.renderer;
    const createGroup = (name, suffix, zIndex) => renderer.g(name).attr({ zIndex }).addClass(`highcharts-${coll.toLowerCase()}${suffix} ` + (this.isRadial ? `highcharts-radial-axis${suffix} ` : "") + (options2.className || "")).add(axisParent);
    if (!this.axisGroup) {
      this.gridGroup = createGroup("grid", "-grid", options2.gridZIndex);
      this.axisGroup = createGroup("axis", "", options2.zIndex);
      this.labelGroup = createGroup("axis-labels", "-labels", options2.labels.zIndex);
    }
  }
  /**
   * Render the tick labels to a preliminary position to get their sizes
   *
   * @private
   * @function Highcharts.Axis#getOffset
   *
   * @emits Highcharts.Axis#event:afterGetOffset
   */
  getOffset() {
    const axis = this, { chart, horiz, options: options2, side, ticks, tickPositions, coll } = axis, invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side, hasData = axis.hasData(), axisTitleOptions = options2.title, labelOptions = options2.labels, hasCrossing = isNumber13(options2.crossing), axisOffset = chart.axisOffset, clipOffset = chart.clipOffset, directionFactor = [-1, 1, 1, -1][side];
    let showAxis, titleOffset = 0, titleOffsetOption, titleMargin = 0, labelOffset = 0, labelOffsetPadded, lineHeightCorrection;
    axis.showAxis = showAxis = hasData || options2.showEmpty;
    axis.staggerLines = axis.horiz && labelOptions.staggerLines || void 0;
    axis.createGroups();
    if (hasData || axis.isLinked) {
      tickPositions.forEach(function(pos) {
        axis.generateTick(pos);
      });
      axis.renderUnsquish();
      axis.reserveSpaceDefault = side === 0 || side === 2 || { 1: "left", 3: "right" }[side] === axis.labelAlign;
      if (pick11(labelOptions.reserveSpace, hasCrossing ? false : null, axis.labelAlign === "center" ? true : null, axis.reserveSpaceDefault)) {
        tickPositions.forEach(function(pos) {
          labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);
        });
      }
      if (axis.staggerLines) {
        labelOffset *= axis.staggerLines;
      }
      axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
    } else {
      objectEach10(ticks, function(tick, n) {
        tick.destroy();
        delete ticks[n];
      });
    }
    if (axisTitleOptions?.text && axisTitleOptions.enabled !== false) {
      axis.addTitle(showAxis);
      if (showAxis && !hasCrossing && axisTitleOptions.reserveSpace !== false) {
        axis.titleOffset = titleOffset = axis.axisTitle.getBBox()[horiz ? "height" : "width"];
        titleOffsetOption = axisTitleOptions.offset;
        titleMargin = defined12(titleOffsetOption) ? 0 : pick11(axisTitleOptions.margin, horiz ? 5 : 10);
      }
    }
    axis.renderLine();
    axis.offset = directionFactor * pick11(options2.offset, axisOffset[side] ? axisOffset[side] + (options2.margin || 0) : 0);
    axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 };
    if (side === 0) {
      lineHeightCorrection = -axis.labelMetrics().h;
    } else if (side === 2) {
      lineHeightCorrection = axis.tickRotCorr.y;
    } else {
      lineHeightCorrection = 0;
    }
    labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
    if (labelOffset) {
      labelOffsetPadded -= lineHeightCorrection;
      labelOffsetPadded += directionFactor * (horiz ? pick11(labelOptions.y, axis.tickRotCorr.y + directionFactor * labelOptions.distance) : pick11(labelOptions.x, directionFactor * labelOptions.distance));
    }
    axis.axisTitleMargin = pick11(titleOffsetOption, labelOffsetPadded);
    if (axis.getMaxLabelDimensions) {
      axis.maxLabelDimensions = axis.getMaxLabelDimensions(ticks, tickPositions);
    }
    if (coll !== "colorAxis" && clipOffset) {
      const tickSize = this.tickSize("tick");
      axisOffset[side] = Math.max(
        axisOffset[side],
        (axis.axisTitleMargin || 0) + titleOffset + directionFactor * axis.offset,
        labelOffsetPadded,
        // #3027
        tickPositions?.length && tickSize ? tickSize[0] + directionFactor * axis.offset : 0
        // #4866
      );
      const clip = !axis.axisLine || options2.offset ? 0 : (
        // #4308, #4371
        axis.axisLine.strokeWidth() / 2
      );
      clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);
    }
    fireEvent6(this, "afterGetOffset");
  }
  /**
   * Internal function to get the path for the axis line. Extended for polar
   * charts.
   *
   * @function Highcharts.Axis#getLinePath
   *
   * @param {number} lineWidth
   * The line width in pixels.
   *
   * @return {Highcharts.SVGPathArray}
   * The SVG path definition in array form.
   */
  getLinePath(lineWidth) {
    const chart = this.chart, opposite = this.opposite, offset3 = this.offset, horiz = this.horiz, lineLeft = this.left + (opposite ? this.width : 0) + offset3, lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset3;
    if (opposite) {
      lineWidth *= -1;
    }
    return chart.renderer.crispLine([
      [
        "M",
        horiz ? this.left : lineLeft,
        horiz ? lineTop : this.top
      ],
      [
        "L",
        horiz ? chart.chartWidth - this.right : lineLeft,
        horiz ? lineTop : chart.chartHeight - this.bottom
      ]
    ], lineWidth);
  }
  /**
   * Render the axis line. Called internally when rendering and redrawing the
   * axis.
   *
   * @function Highcharts.Axis#renderLine
   */
  renderLine() {
    if (!this.axisLine) {
      this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup);
      if (!this.chart.styledMode) {
        this.axisLine.attr({
          stroke: this.options.lineColor,
          "stroke-width": this.options.lineWidth,
          zIndex: 7
        });
      }
    }
  }
  /**
   * Position the axis title.
   *
   * @private
   * @function Highcharts.Axis#getTitlePosition
   *
   * @return {Highcharts.PositionObject}
   * X and Y positions for the title.
   */
  getTitlePosition(axisTitle) {
    const horiz = this.horiz, axisLeft = this.left, axisTop = this.top, axisLength = this.len, axisTitleOptions = this.options.title, margin = horiz ? axisLeft : axisTop, opposite = this.opposite, offset3 = this.offset, xOption = axisTitleOptions.x, yOption = axisTitleOptions.y, fontMetrics = this.chart.renderer.fontMetrics(axisTitle), textHeightOvershoot = axisTitle ? Math.max(axisTitle.getBBox(false, 0).height - fontMetrics.h - 1, 0) : 0, alongAxis = {
      low: margin + (horiz ? 0 : axisLength),
      middle: margin + axisLength / 2,
      high: margin + (horiz ? axisLength : 0)
    }[axisTitleOptions.align], offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * // Horizontal axis reverses the margin
    (opposite ? -1 : 1) * // So does opposite axes
    (this.axisTitleMargin || 0) + [
      -textHeightOvershoot,
      // Top
      textHeightOvershoot,
      // Right
      fontMetrics.f,
      // Bottom
      -textHeightOvershoot
      // Left
    ][this.side], titlePosition = {
      x: horiz ? alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset3 + xOption,
      y: horiz ? offAxis + yOption - (opposite ? this.height : 0) + offset3 : alongAxis + yOption
    };
    fireEvent6(this, "afterGetTitlePosition", { titlePosition });
    return titlePosition;
  }
  /**
   * Render a minor tick into the given position. If a minor tick already
   * exists in this position, move it.
   *
   * @function Highcharts.Axis#renderMinorTick
   *
   * @param {number} pos
   * The position in axis values.
   *
   * @param {boolean} slideIn
   * Whether the tick should animate in from last computed position
   */
  renderMinorTick(pos, slideIn) {
    const axis = this;
    const minorTicks = axis.minorTicks;
    if (!minorTicks[pos]) {
      minorTicks[pos] = new Tick_default(axis, pos, "minor");
    }
    if (slideIn && minorTicks[pos].isNew) {
      minorTicks[pos].render(null, true);
    }
    minorTicks[pos].render(null, false, 1);
  }
  /**
   * Render a major tick into the given position. If a tick already exists
   * in this position, move it.
   *
   * @function Highcharts.Axis#renderTick
   *
   * @param {number} pos
   * The position in axis values.
   *
   * @param {number} i
   * The tick index.
   *
   * @param {boolean} slideIn
   * Whether the tick should animate in from last computed position
   */
  renderTick(pos, i, slideIn) {
    const axis = this, isLinked = axis.isLinked, ticks = axis.ticks;
    if (!isLinked || pos >= axis.min && pos <= axis.max || axis.grid?.isColumn) {
      if (!ticks[pos]) {
        ticks[pos] = new Tick_default(axis, pos);
      }
      if (slideIn && ticks[pos].isNew) {
        ticks[pos].render(i, true, -1);
      }
      ticks[pos].render(i);
    }
  }
  /**
   * Render the axis.
   *
   * @private
   * @function Highcharts.Axis#render
   *
   * @emits Highcharts.Axis#event:afterRender
   */
  render() {
    const axis = this, chart = axis.chart, log = axis.logarithmic, renderer = chart.renderer, options2 = axis.options, isLinked = axis.isLinked, tickPositions = axis.tickPositions, axisTitle = axis.axisTitle, ticks = axis.ticks, minorTicks = axis.minorTicks, alternateBands = axis.alternateBands, stackLabelOptions = options2.stackLabels, alternateGridColor = options2.alternateGridColor, crossing = options2.crossing, tickmarkOffset = axis.tickmarkOffset, axisLine = axis.axisLine, showAxis = axis.showAxis, animation = animObject3(renderer.globalAnimation);
    let from, to;
    axis.labelEdge.length = 0;
    axis.overlap = false;
    [ticks, minorTicks, alternateBands].forEach(function(coll) {
      objectEach10(coll, function(tick) {
        tick.isActive = false;
      });
    });
    if (isNumber13(crossing)) {
      const otherAxis = this.isXAxis ? chart.yAxis[0] : chart.xAxis[0], directionFactor = [1, -1, -1, 1][this.side];
      if (otherAxis) {
        let px = otherAxis.toPixels(crossing, true);
        if (axis.horiz) {
          px = otherAxis.len - px;
        }
        axis.offset = directionFactor * px;
      }
    }
    if (axis.hasData() || isLinked) {
      const slideInTicks = axis.chart.hasRendered && axis.old && isNumber13(axis.old.min);
      if (axis.minorTickInterval && !axis.categories) {
        axis.getMinorTickPositions().forEach(function(pos) {
          axis.renderMinorTick(pos, slideInTicks);
        });
      }
      if (tickPositions.length) {
        tickPositions.forEach(function(pos, i) {
          axis.renderTick(pos, i, slideInTicks);
        });
        if (tickmarkOffset && (axis.min === 0 || axis.single)) {
          if (!ticks[-1]) {
            ticks[-1] = new Tick_default(axis, -1, null, true);
          }
          ticks[-1].render(-1);
        }
      }
      if (alternateGridColor) {
        tickPositions.forEach(function(pos, i) {
          to = typeof tickPositions[i + 1] !== "undefined" ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;
          if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {
            if (!alternateBands[pos]) {
              alternateBands[pos] = new Globals_default.PlotLineOrBand(axis, {});
            }
            from = pos + tickmarkOffset;
            alternateBands[pos].options = {
              from: log ? log.lin2log(from) : from,
              to: log ? log.lin2log(to) : to,
              color: alternateGridColor,
              className: "highcharts-alternate-grid"
            };
            alternateBands[pos].render();
            alternateBands[pos].isActive = true;
          }
        });
      }
      if (!axis._addedPlotLB) {
        axis._addedPlotLB = true;
        (options2.plotLines || []).concat(options2.plotBands || []).forEach(function(plotLineOptions) {
          axis.addPlotBandOrLine(plotLineOptions);
        });
      }
    }
    [ticks, minorTicks, alternateBands].forEach(function(coll) {
      const forDestruction = [], delay = animation.duration, destroyInactiveItems = function() {
        let i = forDestruction.length;
        while (i--) {
          if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
            coll[forDestruction[i]].destroy();
            delete coll[forDestruction[i]];
          }
        }
      };
      objectEach10(coll, function(tick, pos) {
        if (!tick.isActive) {
          tick.render(pos, false, 0);
          tick.isActive = false;
          forDestruction.push(pos);
        }
      });
      syncTimeout3(destroyInactiveItems, coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay);
    });
    if (axisLine) {
      axisLine[axisLine.isPlaced ? "animate" : "attr"]({
        d: this.getLinePath(axisLine.strokeWidth())
      });
      axisLine.isPlaced = true;
      axisLine[showAxis ? "show" : "hide"](showAxis);
    }
    if (axisTitle && showAxis) {
      axisTitle[axisTitle.isNew ? "attr" : "animate"](axis.getTitlePosition(axisTitle));
      axisTitle.isNew = false;
    }
    if (stackLabelOptions?.enabled && axis.stacking) {
      axis.stacking.renderStackTotals();
    }
    axis.old = {
      len: axis.len,
      max: axis.max,
      min: axis.min,
      transA: axis.transA,
      userMax: axis.userMax,
      userMin: axis.userMin
    };
    axis.isDirty = false;
    fireEvent6(this, "afterRender");
  }
  /**
   * Redraw the axis to reflect changes in the data or axis extremes. Called
   * internally from Highcharts.Chart#redraw.
   *
   * @private
   * @function Highcharts.Axis#redraw
   */
  redraw() {
    if (this.visible) {
      this.render();
      this.plotLinesAndBands.forEach(function(plotLine) {
        plotLine.render();
      });
    }
    this.series.forEach(function(series) {
      series.isDirty = true;
    });
  }
  /**
   * Returns an array of axis properties, that should be untouched during
   * reinitialization.
   *
   * @private
   * @function Highcharts.Axis#getKeepProps
   */
  getKeepProps() {
    return this.keepProps || _Axis.keepProps;
  }
  /**
   * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint
   * to fully remove the axis.
   *
   * @private
   * @function Highcharts.Axis#destroy
   *
   * @param {boolean} [keepEvents]
   * Whether to preserve events, used internally in Axis.update.
   */
  destroy(keepEvents) {
    const axis = this, plotLinesAndBands = axis.plotLinesAndBands, eventOptions = this.eventOptions;
    fireEvent6(this, "destroy", { keepEvents });
    if (!keepEvents) {
      removeEvent4(axis);
    }
    [axis.ticks, axis.minorTicks, axis.alternateBands].forEach(function(coll) {
      destroyObjectProperties4(coll);
    });
    if (plotLinesAndBands) {
      let i = plotLinesAndBands.length;
      while (i--) {
        plotLinesAndBands[i].destroy();
      }
    }
    [
      "axisLine",
      "axisTitle",
      "axisGroup",
      "gridGroup",
      "labelGroup",
      "cross",
      "scrollbar"
    ].forEach(function(prop) {
      if (axis[prop]) {
        axis[prop] = axis[prop].destroy();
      }
    });
    for (const plotGroup in axis.plotLinesAndBandsGroups) {
      axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();
    }
    objectEach10(axis, function(val, key) {
      if (axis.getKeepProps().indexOf(key) === -1) {
        delete axis[key];
      }
    });
    this.eventOptions = eventOptions;
  }
  /**
   * Internal function to draw a crosshair.
   *
   * @function Highcharts.Axis#drawCrosshair
   *
   * @param {Highcharts.PointerEventObject} [e]
   * The event arguments from the modified pointer event, extended with
   * `chartX` and `chartY`
   *
   * @param {Highcharts.Point} [point]
   * The Point object if the crosshair snaps to points.
   *
   * @emits Highcharts.Axis#event:afterDrawCrosshair
   * @emits Highcharts.Axis#event:drawCrosshair
   */
  drawCrosshair(e, point) {
    const options2 = this.crosshair, snap = options2?.snap ?? true, chart = this.chart;
    let path, pos, categorized, graphic = this.cross, crossOptions;
    fireEvent6(this, "drawCrosshair", { e, point });
    if (!e) {
      e = this.cross?.e;
    }
    if (
      // Disabled in options
      !options2 || // Snap
      (defined12(point) || !snap) === false
    ) {
      this.hideCrosshair();
    } else {
      if (!snap) {
        pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
      } else if (defined12(point)) {
        pos = pick11(this.coll !== "colorAxis" ? point.crosshairPos : (
          // 3D axis extension
          null
        ), this.isXAxis ? point.plotX : this.len - point.plotY);
      }
      if (defined12(pos)) {
        crossOptions = {
          // Value, only used on radial
          value: point && (this.isXAxis ? point.x : pick11(point.stackY, point.y)),
          translatedValue: pos
        };
        if (chart.polar) {
          extend11(crossOptions, {
            isCrosshair: true,
            chartX: e?.chartX,
            chartY: e?.chartY,
            point
          });
        }
        path = this.getPlotLinePath(crossOptions) || null;
      }
      if (!defined12(path)) {
        this.hideCrosshair();
        return;
      }
      categorized = this.categories && !this.isRadial;
      if (!graphic) {
        this.cross = graphic = chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (categorized ? "category " : "thin ") + (options2.className || "")).attr({
          zIndex: pick11(options2.zIndex, 2)
        }).add();
        if (!chart.styledMode) {
          graphic.attr({
            stroke: options2.color || (categorized ? Color_default.parse(
              "#ccd3ff"
              /* Palette.highlightColor20 */
            ).setOpacity(0.25).get() : "#cccccc"),
            "stroke-width": pick11(options2.width, 1)
          }).css({
            "pointer-events": "none"
          });
          if (options2.dashStyle) {
            graphic.attr({
              dashstyle: options2.dashStyle
            });
          }
        }
      }
      graphic.show().attr({
        d: path
      });
      if (categorized && !options2.width) {
        graphic.attr({
          "stroke-width": this.transA
        });
      }
      this.cross.e = e;
    }
    fireEvent6(this, "afterDrawCrosshair", { e, point });
  }
  /**
   * Hide the crosshair if visible.
   *
   * @function Highcharts.Axis#hideCrosshair
   */
  hideCrosshair() {
    if (this.cross) {
      this.cross.hide();
    }
    fireEvent6(this, "afterHideCrosshair");
  }
  /**
   * Update an axis object with a new set of options. The options are merged
   * with the existing options, so only new or altered options need to be
   * specified.
   *
   * @sample highcharts/members/axis-update/
   *         Axis update demo
   *
   * @function Highcharts.Axis#update
   *
   * @param {Highcharts.AxisOptions} options
   * The new options that will be merged in with existing options on the axis.
   *
   * @param {boolean} [redraw=true]
   * Whether to redraw the chart after the axis is altered. If doing more
   * operations on the chart, it is a good idea to set redraw to false and
   * call {@link Chart#redraw} after.
   */
  update(options2, redraw) {
    const chart = this.chart;
    options2 = merge10(this.userOptions, options2);
    this.destroy(true);
    this.init(chart, options2);
    chart.isDirtyBox = true;
    if (pick11(redraw, true)) {
      chart.redraw();
    }
  }
  /**
   * Remove the axis from the chart.
   *
   * @sample highcharts/members/chart-addaxis/
   *         Add and remove axes
   *
   * @function Highcharts.Axis#remove
   *
   * @param {boolean} [redraw=true]
   * Whether to redraw the chart following the remove.
   */
  remove(redraw) {
    const chart = this.chart, coll = this.coll, axisSeries = this.series;
    let i = axisSeries.length;
    while (i--) {
      if (axisSeries[i]) {
        axisSeries[i].remove(false);
      }
    }
    erase3(chart.axes, this);
    erase3(chart[coll] || [], this);
    chart.orderItems(coll);
    this.destroy();
    chart.isDirtyBox = true;
    if (pick11(redraw, true)) {
      chart.redraw();
    }
  }
  /**
   * Update the axis title by options after render time.
   *
   * @sample highcharts/members/axis-settitle/
   *         Set a new Y axis title
   *
   * @function Highcharts.Axis#setTitle
   *
   * @param {Highcharts.AxisTitleOptions} titleOptions
   * The additional title options.
   *
   * @param {boolean} [redraw=true]
   * Whether to redraw the chart after setting the title.
   */
  setTitle(titleOptions, redraw) {
    this.update({ title: titleOptions }, redraw);
  }
  /**
   * Set new axis categories and optionally redraw.
   *
   * @sample highcharts/members/axis-setcategories/
   *         Set categories by click on a button
   *
   * @function Highcharts.Axis#setCategories
   *
   * @param {Array<string>} categories
   * The new categories.
   *
   * @param {boolean} [redraw=true]
   * Whether to redraw the chart.
   */
  setCategories(categories, redraw) {
    this.update({ categories }, redraw);
  }
};
Axis.keepProps = [
  "coll",
  "extKey",
  "hcEvents",
  "len",
  "names",
  "series",
  "userMax",
  "userMin"
];
var Axis_default = Axis;

// node_modules/highcharts/es-modules/Core/Axis/DateTimeAxis.js
var { addEvent: addEvent5, getMagnitude: getMagnitude2, normalizeTickInterval: normalizeTickInterval3, timeUnits: timeUnits4 } = Utilities_default;
var DateTimeAxis;
(function(DateTimeAxis2) {
  function compose27(AxisClass) {
    if (!AxisClass.keepProps.includes("dateTime")) {
      AxisClass.keepProps.push("dateTime");
      const axisProto = AxisClass.prototype;
      axisProto.getTimeTicks = getTimeTicks;
      addEvent5(AxisClass, "afterSetType", onAfterSetType);
    }
    return AxisClass;
  }
  DateTimeAxis2.compose = compose27;
  function getTimeTicks() {
    return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
  }
  function onAfterSetType() {
    if (this.type !== "datetime") {
      this.dateTime = void 0;
      return;
    }
    if (!this.dateTime) {
      this.dateTime = new Additions(this);
    }
  }
  class Additions {
    /* *
     *
     *  Constructors
     *
     * */
    constructor(axis) {
      this.axis = axis;
    }
    /* *
     *
     *  Functions
     *
     * */
    /**
     * Get a normalized tick interval for dates. Returns a configuration
     * object with unit range (interval), count and name. Used to prepare
     * data for `getTimeTicks`. Previously this logic was part of
     * getTimeTicks, but as `getTimeTicks` now runs of segments in stock
     * charts, the normalizing logic was extracted in order to prevent it
     * for running over again for each segment having the same interval.
     * #662, #697.
     * @private
     */
    normalizeTimeTickInterval(tickInterval, unitsOption) {
      const units2 = unitsOption || [[
        // Unit name
        "millisecond",
        // Allowed multiples
        [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]
      ], [
        "second",
        [1, 2, 5, 10, 15, 30]
      ], [
        "minute",
        [1, 2, 5, 10, 15, 30]
      ], [
        "hour",
        [1, 2, 3, 4, 6, 8, 12]
      ], [
        "day",
        [1, 2]
      ], [
        "week",
        [1, 2]
      ], [
        "month",
        [1, 2, 3, 4, 6]
      ], [
        "year",
        null
      ]];
      let unit = units2[units2.length - 1], interval = timeUnits4[unit[0]], multiples = unit[1], i;
      for (i = 0; i < units2.length; i++) {
        unit = units2[i];
        interval = timeUnits4[unit[0]];
        multiples = unit[1];
        if (units2[i + 1]) {
          const lessThan = (interval * multiples[multiples.length - 1] + timeUnits4[units2[i + 1][0]]) / 2;
          if (tickInterval <= lessThan) {
            break;
          }
        }
      }
      if (interval === timeUnits4.year && tickInterval < 5 * interval) {
        multiples = [1, 2, 5];
      }
      const count = normalizeTickInterval3(tickInterval / interval, multiples, unit[0] === "year" ? (
        // #1913, #2360
        Math.max(getMagnitude2(tickInterval / interval), 1)
      ) : 1);
      return {
        unitRange: interval,
        count,
        unitName: unit[0]
      };
    }
    /**
     * Get the best date format for a specific X value based on the closest
     * point range on the axis.
     *
     * @private
     */
    getXDateFormat(x, dateTimeLabelFormats) {
      const { axis } = this, time = axis.chart.time;
      return axis.closestPointRange ? time.getDateFormat(axis.closestPointRange, x, axis.options.startOfWeek, dateTimeLabelFormats) || // #2546, 2581
      time.resolveDTLFormat(dateTimeLabelFormats.year).main : time.resolveDTLFormat(dateTimeLabelFormats.day).main;
    }
  }
  DateTimeAxis2.Additions = Additions;
})(DateTimeAxis || (DateTimeAxis = {}));
var DateTimeAxis_default = DateTimeAxis;

// node_modules/highcharts/es-modules/Core/Axis/LogarithmicAxis.js
var { addEvent: addEvent6, normalizeTickInterval: normalizeTickInterval4, pick: pick12 } = Utilities_default;
var LogarithmicAxis;
(function(LogarithmicAxis2) {
  function compose27(AxisClass) {
    if (!AxisClass.keepProps.includes("logarithmic")) {
      AxisClass.keepProps.push("logarithmic");
      addEvent6(AxisClass, "afterSetType", onAfterSetType);
      addEvent6(AxisClass, "afterInit", onAfterInit2);
    }
    return AxisClass;
  }
  LogarithmicAxis2.compose = compose27;
  function onAfterSetType() {
    if (this.type !== "logarithmic") {
      this.logarithmic = void 0;
    } else {
      this.logarithmic ?? (this.logarithmic = new Additions(this));
    }
  }
  function onAfterInit2() {
    const axis = this;
    const log = axis.logarithmic;
    if (log) {
      axis.lin2val = function(num) {
        return log.lin2log(num);
      };
      axis.val2lin = function(num) {
        return log.log2lin(num);
      };
    }
  }
  class Additions {
    /* *
    *
    *  Constructors
    *
    * */
    constructor(axis) {
      this.axis = axis;
    }
    /* *
    *
    *  Functions
    *
    * */
    /**
     * Set the tick positions of a logarithmic axis.
     */
    getLogTickPositions(interval, min4, max4, minor) {
      const log = this;
      const axis = log.axis;
      const axisLength = axis.len;
      const options2 = axis.options;
      let positions = [];
      if (!minor) {
        log.minorAutoInterval = void 0;
      }
      if (interval >= 0.5) {
        interval = Math.round(interval);
        positions = axis.getLinearTickPositions(interval, min4, max4);
      } else if (interval >= 0.08) {
        const roundedMin = Math.floor(min4);
        let intermediate, i, j, len, pos, lastPos, break2;
        if (interval > 0.3) {
          intermediate = [1, 2, 4];
        } else if (interval > 0.15) {
          intermediate = [1, 2, 4, 6, 8];
        } else {
          intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        }
        for (i = roundedMin; i < max4 + 1 && !break2; i++) {
          len = intermediate.length;
          for (j = 0; j < len && !break2; j++) {
            pos = log.log2lin(log.lin2log(i) * intermediate[j]);
            if (pos > min4 && (!minor || lastPos <= max4) && typeof lastPos !== "undefined") {
              positions.push(lastPos);
            }
            if (lastPos > max4) {
              break2 = true;
            }
            lastPos = pos;
          }
        }
      } else {
        const realMin = log.lin2log(min4), realMax = log.lin2log(max4), tickIntervalOption = minor ? axis.getMinorTickInterval() : options2.tickInterval, filteredTickIntervalOption = tickIntervalOption === "auto" ? null : tickIntervalOption, tickPixelIntervalOption = options2.tickPixelInterval / (minor ? 5 : 1), totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
        interval = pick12(filteredTickIntervalOption, log.minorAutoInterval, (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1));
        interval = normalizeTickInterval4(interval);
        positions = axis.getLinearTickPositions(interval, realMin, realMax).map(log.log2lin);
        if (!minor) {
          log.minorAutoInterval = interval / 5;
        }
      }
      if (!minor) {
        axis.tickInterval = interval;
      }
      return positions;
    }
    lin2log(num) {
      return Math.pow(10, num);
    }
    log2lin(num) {
      return Math.log(num) / Math.LN10;
    }
  }
  LogarithmicAxis2.Additions = Additions;
})(LogarithmicAxis || (LogarithmicAxis = {}));
var LogarithmicAxis_default = LogarithmicAxis;

// node_modules/highcharts/es-modules/Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js
var { erase: erase4, extend: extend12, isNumber: isNumber14 } = Utilities_default;
var PlotLineOrBandAxis;
(function(PlotLineOrBandAxis2) {
  let PlotLineOrBandClass;
  function addPlotBand(options2) {
    return this.addPlotBandOrLine(options2, "plotBands");
  }
  function addPlotBandOrLine(options2, coll) {
    const userOptions = this.userOptions;
    let obj = new PlotLineOrBandClass(this, options2);
    if (this.visible) {
      obj = obj.render();
    }
    if (obj) {
      if (!this._addedPlotLB) {
        this._addedPlotLB = true;
        (userOptions.plotLines || []).concat(userOptions.plotBands || []).forEach((plotLineOptions) => {
          this.addPlotBandOrLine(plotLineOptions);
        });
      }
      if (coll) {
        const updatedOptions = userOptions[coll] || [];
        updatedOptions.push(options2);
        userOptions[coll] = updatedOptions;
      }
      this.plotLinesAndBands.push(obj);
    }
    return obj;
  }
  function addPlotLine(options2) {
    return this.addPlotBandOrLine(options2, "plotLines");
  }
  function compose27(PlotLineOrBandType, AxisClass) {
    const axisProto = AxisClass.prototype;
    if (!axisProto.addPlotBand) {
      PlotLineOrBandClass = PlotLineOrBandType;
      extend12(axisProto, {
        addPlotBand,
        addPlotLine,
        addPlotBandOrLine,
        getPlotBandPath,
        removePlotBand,
        removePlotLine,
        removePlotBandOrLine
      });
    }
    return AxisClass;
  }
  PlotLineOrBandAxis2.compose = compose27;
  function getPlotBandPath(from, to, options2) {
    options2 = options2 || this.options;
    const toPath = this.getPlotLinePath({
      value: to,
      force: true,
      acrossPanes: options2.acrossPanes
    }), result = [], horiz = this.horiz, outside = !isNumber14(this.min) || !isNumber14(this.max) || from < this.min && to < this.min || from > this.max && to > this.max, path = this.getPlotLinePath({
      value: from,
      force: true,
      acrossPanes: options2.acrossPanes
    });
    let i, plus = 1, isFlat;
    if (path && toPath) {
      if (outside) {
        isFlat = path.toString() === toPath.toString();
        plus = 0;
      }
      for (i = 0; i < path.length; i += 2) {
        const pathStart = path[i], pathEnd = path[i + 1], toPathStart = toPath[i], toPathEnd = toPath[i + 1];
        if ((pathStart[0] === "M" || pathStart[0] === "L") && (pathEnd[0] === "M" || pathEnd[0] === "L") && (toPathStart[0] === "M" || toPathStart[0] === "L") && (toPathEnd[0] === "M" || toPathEnd[0] === "L")) {
          if (horiz && toPathStart[1] === pathStart[1]) {
            toPathStart[1] += plus;
            toPathEnd[1] += plus;
          } else if (!horiz && toPathStart[2] === pathStart[2]) {
            toPathStart[2] += plus;
            toPathEnd[2] += plus;
          }
          result.push(["M", pathStart[1], pathStart[2]], ["L", pathEnd[1], pathEnd[2]], ["L", toPathEnd[1], toPathEnd[2]], ["L", toPathStart[1], toPathStart[2]], ["Z"]);
        }
        result.isFlat = isFlat;
      }
    }
    return result;
  }
  function removePlotBand(id) {
    this.removePlotBandOrLine(id);
  }
  function removePlotBandOrLine(id) {
    const plotLinesAndBands = this.plotLinesAndBands, options2 = this.options, userOptions = this.userOptions;
    if (plotLinesAndBands) {
      let i = plotLinesAndBands.length;
      while (i--) {
        if (plotLinesAndBands[i].id === id) {
          plotLinesAndBands[i].destroy();
        }
      }
      [
        options2.plotLines || [],
        userOptions.plotLines || [],
        options2.plotBands || [],
        userOptions.plotBands || []
      ].forEach(function(arr) {
        i = arr.length;
        while (i--) {
          if (arr[i]?.id === id) {
            erase4(arr, arr[i]);
          }
        }
      });
    }
  }
  function removePlotLine(id) {
    this.removePlotBandOrLine(id);
  }
})(PlotLineOrBandAxis || (PlotLineOrBandAxis = {}));
var PlotLineOrBandAxis_default = PlotLineOrBandAxis;

// node_modules/highcharts/es-modules/Core/Axis/PlotLineOrBand/PlotLineOrBand.js
var { addEvent: addEvent7, arrayMax: arrayMax3, arrayMin: arrayMin3, defined: defined13, destroyObjectProperties: destroyObjectProperties5, erase: erase5, fireEvent: fireEvent7, merge: merge11, objectEach: objectEach11, pick: pick13 } = Utilities_default;
var PlotLineOrBand = class _PlotLineOrBand {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(ChartClass, AxisClass) {
    addEvent7(ChartClass, "afterInit", function() {
      this.labelCollectors.push(() => {
        const labels = [];
        for (const axis of this.axes) {
          for (const { label, options: options2 } of axis.plotLinesAndBands) {
            if (label && !options2?.label?.allowOverlap) {
              labels.push(label);
            }
          }
        }
        return labels;
      });
    });
    return PlotLineOrBandAxis_default.compose(_PlotLineOrBand, AxisClass);
  }
  /* *
   *
   *  Constructor
   *
   * */
  constructor(axis, options2) {
    this.axis = axis;
    this.options = options2;
    this.id = options2.id;
  }
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable no-invalid-this, valid-jsdoc */
  /**
   * Render the plot line or plot band. If it is already existing,
   * move it.
   * @private
   * @function Highcharts.PlotLineOrBand#render
   */
  render() {
    fireEvent7(this, "render");
    const { axis, options: options2 } = this, { horiz, logarithmic } = axis, { color: color14, events, zIndex = 0 } = options2, { renderer, time } = axis.chart, groupAttribs = {}, to = time.parse(options2.to), from = time.parse(options2.from), value = time.parse(options2.value), borderWidth = options2.borderWidth;
    let optionsLabel = options2.label, { label, svgElem } = this, path = [], group;
    const isBand = defined13(from) && defined13(to), isLine = defined13(value), isNew = !svgElem, attribs = {
      "class": "highcharts-plot-" + (isBand ? "band " : "line ") + (options2.className || "")
    };
    let groupName = isBand ? "bands" : "lines";
    if (!axis.chart.styledMode) {
      if (isLine) {
        attribs.stroke = color14 || "#999999";
        attribs["stroke-width"] = pick13(options2.width, 1);
        if (options2.dashStyle) {
          attribs.dashstyle = options2.dashStyle;
        }
      } else if (isBand) {
        attribs.fill = color14 || "#e6e9ff";
        if (borderWidth) {
          attribs.stroke = options2.borderColor;
          attribs["stroke-width"] = borderWidth;
        }
      }
    }
    groupAttribs.zIndex = zIndex;
    groupName += "-" + zIndex;
    group = axis.plotLinesAndBandsGroups[groupName];
    if (!group) {
      axis.plotLinesAndBandsGroups[groupName] = group = renderer.g("plot-" + groupName).attr(groupAttribs).add();
    }
    if (!svgElem) {
      this.svgElem = svgElem = renderer.path().attr(attribs).add(group);
    }
    if (defined13(value)) {
      path = axis.getPlotLinePath({
        value: logarithmic?.log2lin(value) ?? value,
        lineWidth: svgElem.strokeWidth(),
        acrossPanes: options2.acrossPanes
      });
    } else if (defined13(from) && defined13(to)) {
      path = axis.getPlotBandPath(logarithmic?.log2lin(from) ?? from, logarithmic?.log2lin(to) ?? to, options2);
    } else {
      return;
    }
    if (!this.eventsAdded && events) {
      objectEach11(events, (event, eventType) => {
        svgElem?.on(eventType, (e) => {
          events[eventType].apply(this, [e]);
        });
      });
      this.eventsAdded = true;
    }
    if ((isNew || !svgElem.d) && path?.length) {
      svgElem.attr({ d: path });
    } else if (svgElem) {
      if (path) {
        svgElem.show();
        svgElem.animate({ d: path });
      } else if (svgElem.d) {
        svgElem.hide();
        if (label) {
          this.label = label = label.destroy();
        }
      }
    }
    if (optionsLabel && (defined13(optionsLabel.text) || defined13(optionsLabel.formatter)) && path?.length && axis.width > 0 && axis.height > 0 && !path.isFlat) {
      optionsLabel = merge11({
        align: horiz && isBand ? "center" : void 0,
        x: horiz ? !isBand && 4 : 10,
        verticalAlign: !horiz && isBand ? "middle" : void 0,
        y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
        rotation: horiz && !isBand ? 90 : 0,
        ...isBand ? { inside: true } : {}
      }, optionsLabel);
      this.renderLabel(optionsLabel, path, isBand, zIndex);
    } else if (label) {
      label.hide();
    }
    return this;
  }
  /**
   * Render and align label for plot line or band.
   * @private
   * @function Highcharts.PlotLineOrBand#renderLabel
   */
  renderLabel(optionsLabel, path, isBand, zIndex) {
    const plotLine = this, axis = plotLine.axis, renderer = axis.chart.renderer, inside = optionsLabel.inside;
    let label = plotLine.label;
    if (!label) {
      plotLine.label = label = renderer.text(this.getLabelText(optionsLabel), 0, 0, optionsLabel.useHTML).attr({
        align: optionsLabel.textAlign || optionsLabel.align,
        rotation: optionsLabel.rotation,
        "class": "highcharts-plot-" + (isBand ? "band" : "line") + "-label " + (optionsLabel.className || ""),
        zIndex
      });
      if (!axis.chart.styledMode) {
        label.css(merge11({
          fontSize: "0.8em",
          textOverflow: isBand && !inside ? "" : "ellipsis"
        }, optionsLabel.style));
      }
      label.add();
    }
    const xBounds = path.xBounds || [path[0][1], path[1][1], isBand ? path[2][1] : path[0][1]], yBounds = path.yBounds || [path[0][2], path[1][2], isBand ? path[2][2] : path[0][2]], x = arrayMin3(xBounds), y = arrayMin3(yBounds), bBoxWidth = arrayMax3(xBounds) - x;
    label.align(optionsLabel, false, {
      x,
      y,
      width: bBoxWidth,
      height: arrayMax3(yBounds) - y
    });
    label.alignAttr.y -= renderer.fontMetrics(label).b;
    if (!label.alignValue || label.alignValue === "left" || defined13(inside)) {
      label.css({
        width: (optionsLabel.style?.width || (!isBand || !inside ? label.rotation === 90 ? axis.height - (label.alignAttr.y - axis.top) : (optionsLabel.clip ? axis.width : axis.chart.chartWidth) - (label.alignAttr.x - axis.left) : bBoxWidth)) + "px"
      });
    }
    label.show(true);
  }
  /**
   * Get label's text content.
   * @private
   * @function Highcharts.PlotLineOrBand#getLabelText
   */
  getLabelText(optionsLabel) {
    return defined13(optionsLabel.formatter) ? optionsLabel.formatter.call(this) : optionsLabel.text;
  }
  /**
   * Remove the plot line or band.
   *
   * @function Highcharts.PlotLineOrBand#destroy
   */
  destroy() {
    erase5(this.axis.plotLinesAndBands, this);
    delete this.axis;
    destroyObjectProperties5(this);
  }
};
var PlotLineOrBand_default = PlotLineOrBand;

// node_modules/highcharts/es-modules/Core/Tooltip.js
var { animObject: animObject4 } = AnimationUtilities_default;
var { format: format2 } = Templating_default;
var { composed: composed2, dateFormats, doc: doc5, isSafari } = Globals_default;
var { distribute } = RendererUtilities_default;
var { addEvent: addEvent8, clamp: clamp5, css: css7, discardElement: discardElement2, extend: extend13, fireEvent: fireEvent8, getAlignFactor: getAlignFactor6, isArray: isArray7, isNumber: isNumber15, isObject: isObject7, isString: isString10, merge: merge12, pick: pick14, pushUnique: pushUnique5, splat: splat5, syncTimeout: syncTimeout4 } = Utilities_default;
var Tooltip = class {
  /* *
   *
   *  Constructors
   *
   * */
  constructor(chart, options2, pointer) {
    this.allowShared = true;
    this.crosshairs = [];
    this.distance = 0;
    this.isHidden = true;
    this.isSticky = false;
    this.options = {};
    this.outside = false;
    this.chart = chart;
    this.init(chart, options2);
    this.pointer = pointer;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Build the body (lines) of the tooltip by iterating over the items and
   * returning one entry for each item, abstracting this functionality allows
   * to easily overwrite and extend it.
   *
   * @private
   * @function Highcharts.Tooltip#bodyFormatter
   */
  bodyFormatter(points) {
    return points.map((point) => {
      const tooltipOptions = point.series.tooltipOptions, formatPrefix = point.formatPrefix || "point";
      return (tooltipOptions[formatPrefix + "Formatter"] || point.tooltipFormatter).call(point, tooltipOptions[formatPrefix + "Format"] || "");
    });
  }
  /**
   * Destroy the single tooltips in a split tooltip.
   * If the tooltip is active then it is not destroyed, unless forced to.
   *
   * @private
   * @function Highcharts.Tooltip#cleanSplit
   *
   * @param {boolean} [force]
   * Force destroy all tooltips.
   */
  cleanSplit(force) {
    this.chart.series.forEach(function(series) {
      const tt = series?.tt;
      if (tt) {
        if (!tt.isActive || force) {
          series.tt = tt.destroy();
        } else {
          tt.isActive = false;
        }
      }
    });
  }
  /**
   * In case no user defined formatter is given, this will be used. Note that
   * the context here is an object holding point, series, x, y etc.
   *
   * @function Highcharts.Tooltip#defaultFormatter
   *
   * @param {Highcharts.Tooltip} tooltip
   *
   * @return {string|Array<string>}
   * Returns a string (single tooltip and shared)
   * or an array of strings (split tooltip)
   */
  defaultFormatter(tooltip) {
    const hoverPoints = this.points || splat5(this);
    let s;
    s = [tooltip.headerFooterFormatter(hoverPoints[0])];
    s = s.concat(tooltip.bodyFormatter(hoverPoints));
    s.push(tooltip.headerFooterFormatter(hoverPoints[0], true));
    return s;
  }
  /**
   * Removes and destroys the tooltip and its elements.
   *
   * @function Highcharts.Tooltip#destroy
   */
  destroy() {
    if (this.label) {
      this.label = this.label.destroy();
    }
    if (this.split) {
      this.cleanSplit(true);
      if (this.tt) {
        this.tt = this.tt.destroy();
      }
    }
    if (this.renderer) {
      this.renderer = this.renderer.destroy();
      discardElement2(this.container);
    }
    Utilities_default.clearTimeout(this.hideTimer);
  }
  /**
   * Extendable method to get the anchor position of the tooltip
   * from a point or set of points
   *
   * @private
   * @function Highcharts.Tooltip#getAnchor
   */
  getAnchor(points, mouseEvent) {
    const { chart, pointer } = this, inverted = chart.inverted, plotTop = chart.plotTop, plotLeft = chart.plotLeft;
    let ret;
    points = splat5(points);
    if (points[0].series?.yAxis && !points[0].series.yAxis.options.reversedStacks) {
      points = points.slice().reverse();
    }
    if (this.followPointer && mouseEvent) {
      if (typeof mouseEvent.chartX === "undefined") {
        mouseEvent = pointer.normalize(mouseEvent);
      }
      ret = [
        mouseEvent.chartX - plotLeft,
        mouseEvent.chartY - plotTop
      ];
    } else if (points[0].tooltipPos) {
      ret = points[0].tooltipPos;
    } else {
      let chartX = 0, chartY = 0;
      points.forEach(function(point) {
        const pos = point.pos(true);
        if (pos) {
          chartX += pos[0];
          chartY += pos[1];
        }
      });
      chartX /= points.length;
      chartY /= points.length;
      if (this.shared && points.length > 1 && mouseEvent) {
        if (inverted) {
          chartX = mouseEvent.chartX;
        } else {
          chartY = mouseEvent.chartY;
        }
      }
      ret = [chartX - plotLeft, chartY - plotTop];
    }
    return ret.map(Math.round);
  }
  /**
   * Get the CSS class names for the tooltip's label. Styles the label
   * by `colorIndex` or user-defined CSS.
   *
   * @function Highcharts.Tooltip#getClassName
   *
   * @return {string}
   *         The class names.
   */
  getClassName(point, isSplit, isHeader) {
    const options2 = this.options, series = point.series, seriesOptions = series.options;
    return [
      options2.className,
      "highcharts-label",
      isHeader && "highcharts-tooltip-header",
      isSplit ? "highcharts-tooltip-box" : "highcharts-tooltip",
      !isHeader && "highcharts-color-" + pick14(point.colorIndex, series.colorIndex),
      seriesOptions?.className
    ].filter(isString10).join(" ");
  }
  /**
   * Creates the Tooltip label element if it does not exist, then returns it.
   *
   * @function Highcharts.Tooltip#getLabel
   *
   * @return {Highcharts.SVGElement}
   * Tooltip label
   */
  getLabel({ anchorX, anchorY } = { anchorX: 0, anchorY: 0 }) {
    const tooltip = this, styledMode = this.chart.styledMode, options2 = this.options, doSplit = this.split && this.allowShared;
    let container = this.container, renderer = this.chart.renderer;
    if (this.label) {
      const wasSplit = !this.label.hasClass("highcharts-label");
      if (!doSplit && wasSplit || doSplit && !wasSplit) {
        this.destroy();
      }
    }
    if (!this.label) {
      if (this.outside) {
        const chart = this.chart, chartStyle = chart.options.chart.style, Renderer = RendererRegistry_default.getRendererType();
        this.container = container = Globals_default.doc.createElement("div");
        container.className = "highcharts-tooltip-container " + (chart.renderTo.className.match(/(highcharts[a-zA-Z0-9-]+)\s?/gm) || [].join(" "));
        css7(container, {
          position: "absolute",
          top: "1px",
          pointerEvents: "none",
          zIndex: Math.max(this.options.style.zIndex || 0, (chartStyle?.zIndex || 0) + 3)
        });
        this.renderer = renderer = new Renderer(container, 0, 0, chartStyle, void 0, void 0, renderer.styledMode);
      }
      if (doSplit) {
        this.label = renderer.g("tooltip");
      } else {
        this.label = renderer.label("", anchorX, anchorY, options2.shape || "callout", void 0, void 0, options2.useHTML, void 0, "tooltip").attr({
          padding: options2.padding,
          r: options2.borderRadius
        });
        if (!styledMode) {
          this.label.attr({
            fill: options2.backgroundColor,
            "stroke-width": options2.borderWidth || 0
          }).css(options2.style).css({
            pointerEvents: options2.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none")
          });
        }
      }
      if (tooltip.outside) {
        const label = this.label;
        [label.xSetter, label.ySetter].forEach((setter, i) => {
          label[i ? "ySetter" : "xSetter"] = (value) => {
            setter.call(label, tooltip.distance);
            label[i ? "y" : "x"] = value;
            if (container) {
              container.style[i ? "top" : "left"] = `${value}px`;
            }
          };
        });
      }
      this.label.attr({ zIndex: 8 }).shadow(options2.shadow ?? !options2.fixed).add();
    }
    if (container && !container.parentElement) {
      Globals_default.doc.body.appendChild(container);
    }
    return this.label;
  }
  /**
   * Get the total area available area to place the tooltip
   *
   * @private
   */
  getPlayingField() {
    const { body, documentElement } = doc5, { chart, distance, outside } = this;
    return {
      width: outside ? (
        // Subtract distance to prevent scrollbars
        Math.max(body.scrollWidth, documentElement.scrollWidth, body.offsetWidth, documentElement.offsetWidth, documentElement.clientWidth) - 2 * distance - 2
      ) : chart.chartWidth,
      height: outside ? Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, documentElement.clientHeight) : chart.chartHeight
    };
  }
  /**
   * Place the tooltip in a chart without spilling over and not covering the
   * point itself.
   *
   * @function Highcharts.Tooltip#getPosition
   *
   * @param {number} boxWidth
   *        Width of the tooltip box.
   *
   * @param {number} boxHeight
   *        Height of the tooltip box.
   *
   * @param {Highcharts.Point} point
   *        Tooltip related point.
   *
   * @return {Highcharts.PositionObject}
   *         Recommended position of the tooltip.
   */
  getPosition(boxWidth, boxHeight, point) {
    const { distance, chart, outside, pointer } = this, { inverted, plotLeft, plotTop, polar } = chart, { plotX = 0, plotY = 0 } = point, ret = {}, h = inverted && point.h || 0, { height: outerHeight, width: outerWidth } = this.getPlayingField(), chartPosition = pointer.getChartPosition(), scaleX = (val) => val * chartPosition.scaleX, scaleY = (val) => val * chartPosition.scaleY, buildDimensionArray = (dim) => {
      const isX = dim === "x";
      return [
        dim,
        // Dimension - x or y
        isX ? outerWidth : outerHeight,
        isX ? boxWidth : boxHeight
      ].concat(outside ? [
        // If we are using tooltip.outside, we need to scale the
        // position to match scaling of the container in case there
        // is a transform/zoom on the container. #11329
        isX ? scaleX(boxWidth) : scaleY(boxHeight),
        isX ? chartPosition.left - distance + scaleX(plotX + plotLeft) : chartPosition.top - distance + scaleY(plotY + plotTop),
        0,
        isX ? outerWidth : outerHeight
      ] : [
        // Not outside, no scaling is needed
        isX ? boxWidth : boxHeight,
        isX ? plotX + plotLeft : plotY + plotTop,
        isX ? plotLeft : plotTop,
        isX ? plotLeft + chart.plotWidth : plotTop + chart.plotHeight
      ]);
    };
    let first = buildDimensionArray("y"), second = buildDimensionArray("x"), swapped;
    let flipped = !!point.negative;
    if (!polar && chart.hoverSeries?.yAxis?.reversed) {
      flipped = !flipped;
    }
    const preferFarSide = !this.followPointer && pick14(point.ttBelow, polar ? false : !inverted === flipped), firstDimension = function(dim, outerSize, innerSize, scaledInnerSize, point2, min4, max4) {
      const scaledDist = outside ? dim === "y" ? scaleY(distance) : scaleX(distance) : distance, scaleDiff = (innerSize - scaledInnerSize) / 2, roomLeft = scaledInnerSize < point2 - distance, roomRight = point2 + distance + scaledInnerSize < outerSize, alignedLeft = point2 - scaledDist - innerSize + scaleDiff, alignedRight = point2 + scaledDist - scaleDiff;
      if (preferFarSide && roomRight) {
        ret[dim] = alignedRight;
      } else if (!preferFarSide && roomLeft) {
        ret[dim] = alignedLeft;
      } else if (roomLeft) {
        ret[dim] = Math.min(max4 - scaledInnerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);
      } else if (roomRight) {
        ret[dim] = Math.max(min4, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);
      } else {
        ret[dim] = 0;
        return false;
      }
    }, secondDimension = function(dim, outerSize, innerSize, scaledInnerSize, point2) {
      if (point2 < distance || point2 > outerSize - distance) {
        return false;
      }
      if (point2 < innerSize / 2) {
        ret[dim] = 1;
      } else if (point2 > outerSize - scaledInnerSize / 2) {
        ret[dim] = outerSize - scaledInnerSize - 2;
      } else {
        ret[dim] = point2 - innerSize / 2;
      }
    }, swap = function(count) {
      [first, second] = [second, first];
      swapped = count;
    }, run = () => {
      if (firstDimension.apply(0, first) !== false) {
        if (secondDimension.apply(0, second) === false && !swapped) {
          swap(true);
          run();
        }
      } else if (!swapped) {
        swap(true);
        run();
      } else {
        ret.x = ret.y = 0;
      }
    };
    if (inverted && !polar || this.len > 1) {
      swap();
    }
    run();
    return ret;
  }
  /**
   * Place the tooltip when `position.fixed` is true. This is called both for
   * single tooltips, and for partial tooltips when `split`.
   *
   * @private
   */
  getFixedPosition(boxWidth, boxHeight, point) {
    const series = point.series, { chart, options: options2, split } = this, position = options2.position, relativeToOption = position.relativeTo, noPane = options2.shared || series?.yAxis?.isRadial && (relativeToOption === "pane" || !relativeToOption), relativeTo = noPane ? "plotBox" : relativeToOption, bounds = relativeTo === "chart" ? chart.renderer : chart[relativeTo] || chart.getClipBox(series, true);
    return {
      x: bounds.x + (bounds.width - boxWidth) * getAlignFactor6(position.align) + position.x,
      y: bounds.y + (bounds.height - boxHeight) * getAlignFactor6(position.verticalAlign) + (!split && position.y || 0)
    };
  }
  /**
   * Hides the tooltip with a fade out animation.
   *
   * @function Highcharts.Tooltip#hide
   *
   * @param {number} [delay]
   *        The fade out in milliseconds. If no value is provided the value
   *        of the tooltip.hideDelay option is used. A value of 0 disables
   *        the fade out animation.
   */
  hide(delay) {
    const tooltip = this;
    Utilities_default.clearTimeout(this.hideTimer);
    delay = pick14(delay, this.options.hideDelay);
    if (!this.isHidden) {
      this.hideTimer = syncTimeout4(function() {
        const label = tooltip.getLabel();
        tooltip.getLabel().animate({
          opacity: 0
        }, {
          duration: delay ? 150 : delay,
          complete: () => {
            label.hide();
            if (tooltip.container) {
              tooltip.container.remove();
            }
          }
        });
        tooltip.isHidden = true;
      }, delay);
    }
  }
  /**
   * Initialize tooltip.
   *
   * @private
   * @function Highcharts.Tooltip#init
   *
   * @param {Highcharts.Chart} chart
   *        The chart instance.
   *
   * @param {Highcharts.TooltipOptions} options
   *        Tooltip options.
   */
  init(chart, options2) {
    this.chart = chart;
    this.options = options2;
    this.crosshairs = [];
    this.isHidden = true;
    this.split = options2.split && !chart.inverted && !chart.polar;
    this.shared = options2.shared || this.split;
    this.outside = pick14(options2.outside, Boolean(chart.scrollablePixelsX || chart.scrollablePixelsY));
  }
  shouldStickOnContact(pointerEvent) {
    return !!(!this.followPointer && this.options.stickOnContact && (!pointerEvent || this.pointer.inClass(pointerEvent.target, "highcharts-tooltip")));
  }
  /**
   * Moves the tooltip with a soft animation to a new position.
   *
   * @private
   * @function Highcharts.Tooltip#move
   *
   * @param {number} x
   *
   * @param {number} y
   *
   * @param {number} anchorX
   *
   * @param {number} anchorY
   */
  move(x, y, anchorX, anchorY) {
    const { followPointer, options: options2 } = this, animation = animObject4(!followPointer && !this.isHidden && !options2.fixed && options2.animation), skipAnchor = followPointer || (this.len || 0) > 1, attr18 = { x, y };
    if (!skipAnchor) {
      attr18.anchorX = anchorX;
      attr18.anchorY = anchorY;
    } else {
      attr18.anchorX = attr18.anchorY = NaN;
    }
    animation.step = () => this.drawTracker();
    this.getLabel().animate(attr18, animation);
  }
  /**
   * Refresh the tooltip's text and position.
   *
   * @function Highcharts.Tooltip#refresh
   *
   * @param {Highcharts.Point|Array<Highcharts.Point>} pointOrPoints
   *        Either a point or an array of points.
   *
   * @param {Highcharts.PointerEventObject} [mouseEvent]
   *        Mouse event, that is responsible for the refresh and should be
   *        used for the tooltip update.
   */
  refresh(pointOrPoints, mouseEvent) {
    const tooltip = this, { chart, options: options2, pointer, shared } = this, points = splat5(pointOrPoints), point = points[0], formatString = options2.format, formatter = options2.formatter || tooltip.defaultFormatter, styledMode = chart.styledMode;
    let wasShared = tooltip.allowShared;
    if (!options2.enabled || !point.series) {
      return;
    }
    Utilities_default.clearTimeout(this.hideTimer);
    tooltip.allowShared = !(!isArray7(pointOrPoints) && pointOrPoints.series && pointOrPoints.series.noSharedTooltip);
    wasShared = wasShared && !tooltip.allowShared;
    tooltip.followPointer = !tooltip.split && point.series.tooltipOptions.followPointer;
    const anchor = tooltip.getAnchor(pointOrPoints, mouseEvent), x = anchor[0], y = anchor[1];
    if (shared && tooltip.allowShared) {
      pointer.applyInactiveState(points);
      points.forEach((item) => item.setState("hover"));
      point.points = points;
    }
    this.len = points.length;
    const text = isString10(formatString) ? format2(formatString, point, chart) : formatter.call(point, tooltip);
    point.points = void 0;
    const currentSeries = point.series;
    this.distance = pick14(currentSeries.tooltipOptions.distance, 16);
    if (text === false) {
      this.hide();
    } else {
      if (tooltip.split && tooltip.allowShared) {
        this.renderSplit(text, points);
      } else {
        let checkX = x;
        let checkY = y;
        if (mouseEvent && pointer.isDirectTouch) {
          checkX = mouseEvent.chartX - chart.plotLeft;
          checkY = mouseEvent.chartY - chart.plotTop;
        }
        if (chart.polar || currentSeries.options.clip === false || points.some((p) => (
          // #16004
          pointer.isDirectTouch || // ##17929
          p.series.shouldShowTooltip(checkX, checkY)
        ))) {
          const label = tooltip.getLabel(wasShared && tooltip.tt || {});
          if (!options2.style.width || styledMode) {
            label.css({
              width: (this.outside ? this.getPlayingField() : chart.spacingBox).width + "px"
            });
          }
          label.attr({
            // Add class before the label BBox calculation (#21035)
            "class": tooltip.getClassName(point),
            text: text && text.join ? text.join("") : text
          });
          if (this.outside) {
            label.attr({
              x: clamp5(label.x || 0, 0, this.getPlayingField().width - (label.width || 0) - 1)
            });
          }
          if (!styledMode) {
            label.attr({
              stroke: options2.borderColor || point.color || currentSeries.color || "#666666"
            });
          }
          tooltip.updatePosition({
            plotX: x,
            plotY: y,
            negative: point.negative,
            ttBelow: point.ttBelow,
            series: currentSeries,
            h: anchor[2] || 0
          });
        } else {
          tooltip.hide();
          return;
        }
      }
      if (tooltip.isHidden && tooltip.label) {
        tooltip.label.attr({
          opacity: 1
        }).show();
      }
      tooltip.isHidden = false;
    }
    fireEvent8(this, "refresh");
  }
  /**
   * Render the split tooltip. Loops over each point's text and adds
   * a label next to the point, then uses the distribute function to
   * find best non-overlapping positions.
   *
   * @private
   * @function Highcharts.Tooltip#renderSplit
   *
   * @param {string|Array<(boolean|string)>} labels
   *
   * @param {Array<Highcharts.Point>} points
   */
  renderSplit(labels, points) {
    const tooltip = this;
    const { chart, chart: { chartWidth, chartHeight, plotHeight, plotLeft, plotTop, scrollablePixelsY = 0, scrollablePixelsX, styledMode }, distance, options: options2, options: { fixed, position, positioner }, pointer } = tooltip;
    const { scrollLeft = 0, scrollTop = 0 } = chart.scrollablePlotArea?.scrollingContainer || {};
    const bounds = tooltip.outside && typeof scrollablePixelsX !== "number" ? doc5.documentElement.getBoundingClientRect() : {
      left: scrollLeft,
      right: scrollLeft + chartWidth,
      top: scrollTop,
      bottom: scrollTop + chartHeight
    };
    const tooltipLabel = tooltip.getLabel();
    const ren = this.renderer || chart.renderer;
    const headerTop = Boolean(chart.xAxis[0]?.opposite);
    const { left: chartLeft, top: chartTop } = pointer.getChartPosition();
    const hasFixedPosition = positioner || fixed;
    let distributionBoxTop = plotTop + scrollTop;
    let headerHeight = 0;
    let adjustedPlotHeight = plotHeight - scrollablePixelsY;
    function getAnchor(point) {
      const { isHeader, plotX = 0, plotY = 0, series } = point;
      let anchorX;
      let anchorY;
      if (isHeader) {
        anchorX = Math.max(plotLeft + plotX, plotLeft);
        anchorY = plotTop + plotHeight / 2;
      } else {
        const { xAxis: xAxis2, yAxis: yAxis2 } = series;
        anchorX = xAxis2.pos + clamp5(plotX, -distance, xAxis2.len + distance);
        if (series.shouldShowTooltip(0, yAxis2.pos - plotTop + plotY, {
          ignoreX: true
        })) {
          anchorY = yAxis2.pos + plotY;
        }
      }
      anchorX = clamp5(anchorX, bounds.left - distance, bounds.right + distance);
      return { anchorX, anchorY };
    }
    const defaultPositioner = function(boxWidth, boxHeight, point, anchor = [0, 0], alignedLeft = true) {
      let x, y;
      if (point.isHeader) {
        y = headerTop ? 0 : adjustedPlotHeight;
        x = clamp5(anchor[0] - boxWidth / 2, bounds.left, bounds.right - boxWidth - (tooltip.outside ? chartLeft : 0));
      } else if (fixed && point) {
        const pos = tooltip.getFixedPosition(boxWidth, boxHeight, point);
        x = pos.x;
        y = pos.y - distributionBoxTop;
      } else {
        y = anchor[1] - distributionBoxTop;
        x = alignedLeft ? anchor[0] - boxWidth - distance : anchor[0] + distance;
        x = clamp5(x, alignedLeft ? x : bounds.left, bounds.right);
      }
      return { x, y };
    };
    function updatePartialTooltip(partialTooltip, point, str) {
      let tt = partialTooltip;
      const { isHeader, series } = point, ttOptions = series.tooltipOptions || options2;
      if (!tt) {
        const attribs = {
          padding: ttOptions.padding,
          r: ttOptions.borderRadius
        };
        if (!styledMode) {
          attribs.fill = ttOptions.backgroundColor;
          attribs["stroke-width"] = ttOptions.borderWidth ?? (fixed && !isHeader ? 0 : 1);
        }
        tt = ren.label("", 0, 0, ttOptions[isHeader ? "headerShape" : "shape"] || (fixed && !isHeader ? "rect" : "callout"), void 0, void 0, ttOptions.useHTML).addClass(tooltip.getClassName(point, true, isHeader)).attr(attribs).add(tooltipLabel);
      }
      tt.isActive = true;
      tt.attr({
        text: str
      });
      if (!styledMode) {
        tt.css(ttOptions.style).attr({
          stroke: ttOptions.borderColor || point.color || series.color || "#333333"
        });
      }
      return tt;
    }
    if (isString10(labels)) {
      labels = [false, labels];
    }
    let boxes = labels.slice(0, points.length + 1).reduce(function(boxes2, str, i) {
      if (str !== false && str !== "") {
        const point = points[i - 1] || {
          // Item 0 is the header. Instead of this, we could also
          // use the crosshair label
          isHeader: true,
          plotX: points[0].plotX,
          plotY: plotHeight,
          series: {}
        };
        const isHeader = point.isHeader;
        const owner = isHeader ? tooltip : point.series;
        const tt = owner.tt = updatePartialTooltip(owner.tt, point, str.toString());
        const bBox = tt.getBBox();
        const boxWidth = bBox.width + tt.strokeWidth();
        if (isHeader) {
          headerHeight = bBox.height;
          adjustedPlotHeight += headerHeight;
          if (headerTop) {
            distributionBoxTop -= headerHeight;
          }
        }
        const { anchorX, anchorY } = getAnchor(point);
        if (typeof anchorY === "number") {
          const size = bBox.height + 1, boxPosition = (positioner || defaultPositioner).call(tooltip, boxWidth, size, point, [anchorX, anchorY]);
          boxes2.push({
            // 0-align to the top, 1-align to the bottom
            align: hasFixedPosition ? 0 : void 0,
            anchorX,
            anchorY,
            boxWidth,
            point,
            rank: pick14(boxPosition.rank, isHeader ? 1 : 0),
            size,
            target: boxPosition.y,
            tt,
            x: boxPosition.x
          });
        } else {
          tt.isActive = false;
        }
      }
      return boxes2;
    }, []);
    if (!hasFixedPosition && boxes.some((box) => {
      const { outside: outside2 } = tooltip;
      const boxStart = (outside2 ? chartLeft : 0) + box.anchorX;
      if (boxStart < bounds.left && boxStart + box.boxWidth < bounds.right) {
        return true;
      }
      return boxStart < chartLeft - bounds.left + box.boxWidth && bounds.right - boxStart > boxStart;
    })) {
      boxes = boxes.map((box) => {
        const { x, y } = defaultPositioner.call(this, box.boxWidth, box.size, box.point, [box.anchorX, box.anchorY], false);
        return extend13(box, {
          target: y,
          x
        });
      });
    }
    tooltip.cleanSplit();
    distribute(boxes, adjustedPlotHeight);
    const boxExtremes = {
      left: chartLeft,
      right: chartLeft
    };
    boxes.forEach(function(box) {
      const { x, boxWidth, isHeader } = box;
      if (!isHeader) {
        if (tooltip.outside && chartLeft + x < boxExtremes.left) {
          boxExtremes.left = chartLeft + x;
        }
        if (!isHeader && tooltip.outside && boxExtremes.left + boxWidth > boxExtremes.right) {
          boxExtremes.right = chartLeft + x;
        }
      }
    });
    boxes.forEach(function(box) {
      const { x, anchorX, anchorY, pos, point: { isHeader } } = box;
      const attributes = {
        visibility: typeof pos === "undefined" ? "hidden" : "inherit",
        x,
        /* NOTE: y should equal pos to be consistent with !split
         * tooltip, but is currently relative to plotTop. Is left as is
         * to avoid breaking change. Remove distributionBoxTop to make
         * it consistent.
         */
        y: (pos || 0) + distributionBoxTop + (fixed && position.y || 0),
        anchorX,
        anchorY
      };
      if (tooltip.outside && x < anchorX) {
        const offset3 = chartLeft - boxExtremes.left;
        if (offset3 > 0) {
          if (!isHeader) {
            attributes.x = x + offset3;
            attributes.anchorX = anchorX + offset3;
          }
          if (isHeader) {
            attributes.x = (boxExtremes.right - boxExtremes.left) / 2;
            attributes.anchorX = anchorX + offset3;
          }
        }
      }
      box.tt.attr(attributes);
    });
    const { container, outside, renderer } = tooltip;
    if (outside && container && renderer) {
      const { width, height, x, y } = tooltipLabel.getBBox();
      renderer.setSize(width + x, height + y, false);
      container.style.left = boxExtremes.left + "px";
      container.style.top = chartTop + "px";
    }
    if (isSafari) {
      tooltipLabel.attr({
        // Force a redraw of the whole group by chaining the opacity
        // slightly
        opacity: tooltipLabel.opacity === 1 ? 0.999 : 1
      });
    }
  }
  /**
   * If the `stickOnContact` option is active, this will add a tracker shape.
   *
   * @private
   * @function Highcharts.Tooltip#drawTracker
   */
  drawTracker() {
    const tooltip = this;
    if (!this.shouldStickOnContact()) {
      if (tooltip.tracker) {
        tooltip.tracker = tooltip.tracker.destroy();
      }
      return;
    }
    const chart = tooltip.chart;
    const label = tooltip.label;
    const points = tooltip.shared ? chart.hoverPoints : chart.hoverPoint;
    if (!label || !points) {
      return;
    }
    const box = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    const anchorPos = this.getAnchor(points);
    const labelBBox = label.getBBox();
    anchorPos[0] += chart.plotLeft - (label.translateX || 0);
    anchorPos[1] += chart.plotTop - (label.translateY || 0);
    box.x = Math.min(0, anchorPos[0]);
    box.y = Math.min(0, anchorPos[1]);
    box.width = anchorPos[0] < 0 ? Math.max(Math.abs(anchorPos[0]), labelBBox.width - anchorPos[0]) : Math.max(Math.abs(anchorPos[0]), labelBBox.width);
    box.height = anchorPos[1] < 0 ? Math.max(Math.abs(anchorPos[1]), labelBBox.height - Math.abs(anchorPos[1])) : Math.max(Math.abs(anchorPos[1]), labelBBox.height);
    if (tooltip.tracker) {
      tooltip.tracker.attr(box);
    } else {
      tooltip.tracker = label.renderer.rect(box).addClass("highcharts-tracker").add(label);
      if (!chart.styledMode) {
        tooltip.tracker.attr({
          fill: "rgba(0,0,0,0)"
        });
      }
    }
  }
  /**
   * @private
   */
  styledModeFormat(formatString) {
    return formatString.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
  }
  /**
   * Format the footer/header of the tooltip
   * #3397: abstraction to enable formatting of footer and header
   *
   * @private
   * @function Highcharts.Tooltip#headerFooterFormatter
   */
  headerFooterFormatter(point, isFooter) {
    const series = point.series, tooltipOptions = series.tooltipOptions, xAxis2 = series.xAxis, dateTime = xAxis2?.dateTime, e = {
      isFooter,
      point
    };
    let xDateFormat = tooltipOptions.xDateFormat || "", formatString = tooltipOptions[isFooter ? "footerFormat" : "headerFormat"];
    fireEvent8(this, "headerFormatter", e, function(e2) {
      if (dateTime && !xDateFormat && isNumber15(point.key)) {
        xDateFormat = dateTime.getXDateFormat(point.key, tooltipOptions.dateTimeLabelFormats);
      }
      if (dateTime && xDateFormat) {
        if (isObject7(xDateFormat)) {
          const format18 = xDateFormat;
          dateFormats[0] = (timestamp) => series.chart.time.dateFormat(format18, timestamp);
          xDateFormat = "%0";
        }
        (point.tooltipDateKeys || ["key"]).forEach((key) => {
          formatString = formatString.replace(new RegExp("point\\." + key + "([ \\)}])"), `(point.${key}:${xDateFormat})$1`);
        });
      }
      if (series.chart.styledMode) {
        formatString = this.styledModeFormat(formatString);
      }
      e2.text = format2(formatString, point, this.chart);
    });
    return e.text || "";
  }
  /**
   * Updates the tooltip with the provided tooltip options.
   *
   * @function Highcharts.Tooltip#update
   *
   * @param {Highcharts.TooltipOptions} options
   *        The tooltip options to update.
   */
  update(options2) {
    this.destroy();
    this.init(this.chart, merge12(true, this.options, options2));
  }
  /**
   * Find the new position and perform the move
   *
   * @private
   * @function Highcharts.Tooltip#updatePosition
   *
   * @param {Highcharts.Point} point
   */
  updatePosition(point) {
    const { chart, container, distance, options: options2, pointer, renderer } = this, label = this.getLabel(), { height = 0, width = 0 } = label, { fixed, positioner } = options2, { left, top, scaleX, scaleY } = pointer.getChartPosition(), pos = (positioner || fixed && this.getFixedPosition || this.getPosition).call(this, width, height, point), doc30 = Globals_default.doc;
    let anchorX = (point.plotX || 0) + chart.plotLeft, anchorY = (point.plotY || 0) + chart.plotTop, pad3;
    if (renderer && container) {
      if (positioner || fixed) {
        const { scrollLeft = 0, scrollTop = 0 } = chart.scrollablePlotArea?.scrollingContainer || {};
        pos.x += scrollLeft + left - distance;
        pos.y += scrollTop + top - distance;
      }
      pad3 = (options2.borderWidth || 0) + 2 * distance + 2;
      renderer.setSize(
        // Clamp width to keep tooltip in viewport (#21698)
        // and subtract one since tooltip container has 'left: 1px;'
        clamp5(width + pad3, 0, doc30.documentElement.clientWidth) - 1,
        height + pad3,
        false
      );
      if (scaleX !== 1 || scaleY !== 1) {
        css7(container, {
          transform: `scale(${scaleX}, ${scaleY})`
        });
        anchorX *= scaleX;
        anchorY *= scaleY;
      }
      anchorX += left - pos.x;
      anchorY += top - pos.y;
    }
    this.move(
      Math.round(pos.x),
      Math.round(pos.y || 0),
      // Can be undefined (#3977)
      anchorX,
      anchorY
    );
  }
};
(function(Tooltip2) {
  function compose27(PointerClass) {
    if (pushUnique5(composed2, "Core.Tooltip")) {
      addEvent8(PointerClass, "afterInit", function() {
        const chart = this.chart;
        if (chart.options.tooltip) {
          chart.tooltip = new Tooltip2(chart, chart.options.tooltip, this);
        }
      });
    }
  }
  Tooltip2.compose = compose27;
})(Tooltip || (Tooltip = {}));
var Tooltip_default = Tooltip;

// node_modules/highcharts/es-modules/Core/Series/Point.js
var { animObject: animObject5 } = AnimationUtilities_default;
var { defaultOptions: defaultOptions5 } = Defaults_default;
var { format: format3 } = Templating_default;
var { addEvent: addEvent9, crisp: crisp4, erase: erase6, extend: extend14, fireEvent: fireEvent9, getNestedProperty: getNestedProperty3, isArray: isArray8, isFunction: isFunction5, isNumber: isNumber16, isObject: isObject8, merge: merge13, pick: pick15, syncTimeout: syncTimeout5, removeEvent: removeEvent5, uniqueKey: uniqueKey4 } = Utilities_default;
var Point = class _Point {
  /**
   * For categorized axes this property holds the category name for the
   * point. For other axes it holds the X value.
   *
   * @name Highcharts.Point#category
   * @type {number|string}
   */
  /**
   * The name of the point. The name can be given as the first position of the
   * point configuration array, or as a `name` property in the configuration:
   *
   * @example
   * // Array config
   * data: [
   *     ['John', 1],
   *     ['Jane', 2]
   * ]
   *
   * // Object config
   * data: [{
   *        name: 'John',
   *        y: 1
   * }, {
   *     name: 'Jane',
   *     y: 2
   * }]
   *
   * @name Highcharts.Point#name
   * @type {string}
   */
  /**
   * The point's name if it is defined, or its category in case of a category,
   * otherwise the x value. Convenient for tooltip and data label formatting.
   *
   * @name Highcharts.Point#key
   * @type {number|string}
   */
  /**
   * The point's options as applied in the initial configuration, or
   * extended through `Point.update`.
   *
   * In TypeScript you have to extend `PointOptionsObject` via an
   * additional interface to allow custom data options:
   *
   * ```
   * declare interface PointOptionsObject {
   *     customProperty: string;
   * }
   * ```
   *
   * @name Highcharts.Point#options
   * @type {Highcharts.PointOptionsObject}
   */
  /**
   * The percentage for points in a stacked series, pies or gauges.
   *
   * @name Highcharts.Point#percentage
   * @type {number|undefined}
   */
  /**
   * Array of all hovered points when using shared tooltips.
   *
   * @name Highcharts.Point#points
   * @type {Array<Highcharts.Point>|undefined}
   */
  /**
   * The series object associated with the point.
   *
   * @name Highcharts.Point#series
   * @type {Highcharts.Series}
   */
  /**
   * The attributes of the rendered SVG shape like in `column` or `pie`
   * series.
   *
   * @readonly
   * @name Highcharts.Point#shapeArgs
   * @type {Readonly<Highcharts.SVGAttributes>|undefined}
   */
  /**
   * The total of values in either a stack for stacked series, or a pie in a
   * pie series.
   *
   * @name Highcharts.Point#total
   * @type {number|undefined}
   */
  /**
   * For certain series types, like pie charts, where individual points can
   * be shown or hidden.
   *
   * @name Highcharts.Point#visible
   * @type {boolean}
   * @default true
   */
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Animate SVG elements associated with the point.
   *
   * @private
   * @function Highcharts.Point#animateBeforeDestroy
   */
  animateBeforeDestroy() {
    const point = this, animateParams = { x: point.startXPos, opacity: 0 }, graphicalProps = point.getGraphicalProps();
    graphicalProps.singular.forEach(function(prop) {
      const isDataLabel = prop === "dataLabel";
      point[prop] = point[prop].animate(isDataLabel ? {
        x: point[prop].startXPos,
        y: point[prop].startYPos,
        opacity: 0
      } : animateParams);
    });
    graphicalProps.plural.forEach(function(plural) {
      point[plural].forEach(function(item) {
        if (item.element) {
          item.animate(extend14({ x: point.startXPos }, item.startYPos ? {
            x: item.startXPos,
            y: item.startYPos
          } : {}));
        }
      });
    });
  }
  /**
   * Apply the options containing the x and y data and possible some extra
   * properties. Called on point init or from point.update.
   *
   * @private
   * @function Highcharts.Point#applyOptions
   *
   * @param {Highcharts.PointOptionsType} options
   *        The point options as defined in series.data.
   *
   * @param {number} [x]
   *        Optionally, the x value.
   *
   * @return {Highcharts.Point}
   *         The Point instance.
   */
  applyOptions(options2, x) {
    const point = this, series = point.series, pointValKey = series.options.pointValKey || series.pointValKey;
    options2 = _Point.prototype.optionsToObject.call(this, options2);
    extend14(point, options2);
    point.options = point.options ? extend14(point.options, options2) : options2;
    if (options2.group) {
      delete point.group;
    }
    if (options2.dataLabels) {
      delete point.dataLabels;
    }
    if (pointValKey) {
      point.y = _Point.prototype.getNestedProperty.call(point, pointValKey);
    }
    if (point.selected) {
      point.state = "select";
    }
    if ("name" in point && typeof x === "undefined" && series.xAxis && series.xAxis.hasNames) {
      point.x = series.xAxis.nameToX(point);
    }
    if (typeof point.x === "undefined" && series) {
      point.x = x ?? series.autoIncrement();
    } else if (isNumber16(options2.x) && series.options.relativeXValue) {
      point.x = series.autoIncrement(options2.x);
    } else if (typeof point.x === "string") {
      x ?? (x = series.chart.time.parse(point.x));
      if (isNumber16(x)) {
        point.x = x;
      }
    }
    point.isNull = this.isValid && !this.isValid();
    point.formatPrefix = point.isNull ? "null" : "point";
    return point;
  }
  /**
   * Destroy a point to clear memory. Its reference still stays in
   * `series.data`.
   *
   * @private
   * @function Highcharts.Point#destroy
   */
  destroy() {
    if (!this.destroyed) {
      const point = this, series = point.series, chart = series.chart, dataSorting = series.options.dataSorting, hoverPoints = chart.hoverPoints, globalAnimation = point.series.chart.renderer.globalAnimation, animation = animObject5(globalAnimation);
      const destroyPoint = () => {
        if (point.graphic || point.graphics || point.dataLabel || point.dataLabels) {
          removeEvent5(point);
          point.destroyElements();
        }
        for (const prop in point) {
          delete point[prop];
        }
      };
      if (point.legendItem) {
        chart.legend.destroyItem(point);
      }
      if (hoverPoints) {
        point.setState();
        erase6(hoverPoints, point);
        if (!hoverPoints.length) {
          chart.hoverPoints = null;
        }
      }
      if (point === chart.hoverPoint) {
        point.onMouseOut();
      }
      if (!dataSorting?.enabled) {
        destroyPoint();
      } else {
        this.animateBeforeDestroy();
        syncTimeout5(destroyPoint, animation.duration);
      }
      chart.pointCount--;
    }
    this.destroyed = true;
  }
  /**
   * Destroy SVG elements associated with the point.
   *
   * @private
   * @function Highcharts.Point#destroyElements
   * @param {Highcharts.Dictionary<number>} [kinds]
   */
  destroyElements(kinds) {
    const point = this, props = point.getGraphicalProps(kinds);
    props.singular.forEach(function(prop) {
      point[prop] = point[prop].destroy();
    });
    props.plural.forEach(function(plural) {
      point[plural].forEach(function(item) {
        if (item?.element) {
          item.destroy();
        }
      });
      delete point[plural];
    });
  }
  /**
   * Fire an event on the Point object.
   *
   * @private
   * @function Highcharts.Point#firePointEvent
   *
   * @param {string} eventType
   *        Type of the event.
   *
   * @param {Highcharts.Dictionary<any>|Event} [eventArgs]
   *        Additional event arguments.
   *
   * @param {Highcharts.EventCallbackFunction<Highcharts.Point>|Function} [defaultFunction]
   *        Default event handler.
   *
   * @emits Highcharts.Point#event:*
   */
  firePointEvent(eventType, eventArgs, defaultFunction) {
    const point = this, series = this.series, seriesOptions = series.options;
    point.manageEvent(eventType);
    if (eventType === "click" && seriesOptions.allowPointSelect) {
      defaultFunction = function(event) {
        if (!point.destroyed && point.select) {
          point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
        }
      };
    }
    fireEvent9(point, eventType, eventArgs, defaultFunction);
  }
  /**
   * Get the CSS class names for individual points. Used internally where the
   * returned value is set on every point.
   *
   * @function Highcharts.Point#getClassName
   *
   * @return {string}
   *         The class names.
   */
  getClassName() {
    const point = this;
    return "highcharts-point" + (point.selected ? " highcharts-point-select" : "") + (point.negative ? " highcharts-negative" : "") + (point.isNull ? " highcharts-null-point" : "") + (typeof point.colorIndex !== "undefined" ? " highcharts-color-" + point.colorIndex : "") + (point.options.className ? " " + point.options.className : "") + (point.zone?.className ? " " + point.zone.className.replace("highcharts-negative", "") : "");
  }
  /**
   * Get props of all existing graphical point elements.
   *
   * @private
   * @function Highcharts.Point#getGraphicalProps
   */
  getGraphicalProps(kinds) {
    const point = this, props = [], graphicalProps = { singular: [], plural: [] };
    let prop, i;
    kinds = kinds || { graphic: 1, dataLabel: 1 };
    if (kinds.graphic) {
      props.push(
        "graphic",
        "connector"
        // Used by dumbbell
      );
    }
    if (kinds.dataLabel) {
      props.push("dataLabel", "dataLabelPath", "dataLabelUpper");
    }
    i = props.length;
    while (i--) {
      prop = props[i];
      if (point[prop]) {
        graphicalProps.singular.push(prop);
      }
    }
    [
      "graphic",
      "dataLabel"
    ].forEach(function(prop2) {
      const plural = prop2 + "s";
      if (kinds[prop2] && point[plural]) {
        graphicalProps.plural.push(plural);
      }
    });
    return graphicalProps;
  }
  /**
   * Returns the value of the point property for a given value.
   * @private
   */
  getNestedProperty(key) {
    if (!key) {
      return;
    }
    if (key.indexOf("custom.") === 0) {
      return getNestedProperty3(key, this.options);
    }
    return this[key];
  }
  /**
   * In a series with `zones`, return the zone that the point belongs to.
   *
   * @function Highcharts.Point#getZone
   *
   * @return {Highcharts.SeriesZonesOptionsObject}
   *         The zone item.
   */
  getZone() {
    const series = this.series, zones = series.zones, zoneAxis = series.zoneAxis || "y";
    let zone, i = 0;
    zone = zones[i];
    while (this[zoneAxis] >= zone.value) {
      zone = zones[++i];
    }
    if (!this.nonZonedColor) {
      this.nonZonedColor = this.color;
    }
    if (zone?.color && !this.options.color) {
      this.color = zone.color;
    } else {
      this.color = this.nonZonedColor;
    }
    return zone;
  }
  /**
   * Utility to check if point has new shape type. Used in column series and
   * all others that are based on column series.
   * @private
   */
  hasNewShapeType() {
    const point = this;
    const oldShapeType = point.graphic && (point.graphic.symbolName || point.graphic.element.nodeName);
    return oldShapeType !== this.shapeType;
  }
  /**
   * Initialize the point. Called internally based on the `series.data`
   * option.
   *
   * @function Highcharts.Point#init
   *
   * @param {Highcharts.Series} series
   *        The series object containing this point.
   *
   * @param {Highcharts.PointOptionsType} options
   *        The data in either number, array or object format.
   *
   * @param {number} [x]
   *        Optionally, the X value of the point.
   *
   * @return {Highcharts.Point}
   *         The Point instance.
   *
   * @emits Highcharts.Point#event:afterInit
   */
  constructor(series, options2, x) {
    this.formatPrefix = "point";
    this.visible = true;
    this.point = this;
    this.series = series;
    this.applyOptions(options2, x);
    this.id ?? (this.id = uniqueKey4());
    this.resolveColor();
    this.dataLabelOnNull ?? (this.dataLabelOnNull = series.options.nullInteraction);
    series.chart.pointCount++;
    fireEvent9(this, "afterInit");
  }
  /**
   * Determine if point is valid.
   * @private
   * @function Highcharts.Point#isValid
   */
  isValid() {
    return (isNumber16(this.x) || this.x instanceof Date) && isNumber16(this.y);
  }
  /**
   * Transform number or array configs into objects. Also called for object
   * configs. Used internally to unify the different configuration formats for
   * points. For example, a simple number `10` in a line series will be
   * transformed to `{ y: 10 }`, and an array config like `[1, 10]` in a
   * scatter series will be transformed to `{ x: 1, y: 10 }`.
   *
   * @function Highcharts.Point#optionsToObject
   *
   * @param {Highcharts.PointOptionsType} options
   * Series data options.
   *
   * @return {Highcharts.Dictionary<*>}
   * Transformed point options.
   */
  optionsToObject(options2) {
    const series = this.series, keys = series.options.keys, pointArrayMap = keys || series.pointArrayMap || ["y"], valueCount = pointArrayMap.length;
    let ret = {}, firstItemType, i = 0, j = 0;
    if (isNumber16(options2) || options2 === null) {
      ret[pointArrayMap[0]] = options2;
    } else if (isArray8(options2)) {
      if (!keys && options2.length > valueCount) {
        firstItemType = typeof options2[0];
        if (firstItemType === "string") {
          if (series.xAxis?.dateTime) {
            ret.x = series.chart.time.parse(options2[0]);
          } else {
            ret.name = options2[0];
          }
        } else if (firstItemType === "number") {
          ret.x = options2[0];
        }
        i++;
      }
      while (j < valueCount) {
        if (!keys || typeof options2[i] !== "undefined") {
          if (pointArrayMap[j].indexOf(".") > 0) {
            _Point.prototype.setNestedProperty(ret, options2[i], pointArrayMap[j]);
          } else {
            ret[pointArrayMap[j]] = options2[i];
          }
        }
        i++;
        j++;
      }
    } else if (typeof options2 === "object") {
      ret = options2;
      if (options2.dataLabels) {
        series.hasDataLabels = () => true;
      }
      if (options2.marker) {
        series._hasPointMarkers = true;
      }
    }
    return ret;
  }
  /**
   * Get the pixel position of the point relative to the plot area.
   * @function Highcharts.Point#pos
   *
   * @sample highcharts/point/position
   *         Get point's position in pixels.
   *
   * @param {boolean} chartCoordinates
   * If true, the returned position is relative to the full chart area.
   * If false, it is relative to the plot area determined by the axes.
   *
   * @param {number|undefined} plotY
   * A custom plot y position to be computed. Used internally for some
   * series types that have multiple `y` positions, like area range (low
   * and high values).
   *
   * @return {Array<number>|undefined}
   * Coordinates of the point if the point exists.
   */
  pos(chartCoordinates, plotY = this.plotY) {
    if (!this.destroyed) {
      const { plotX, series } = this, { chart, xAxis: xAxis2, yAxis: yAxis2 } = series;
      let posX = 0, posY = 0;
      if (isNumber16(plotX) && isNumber16(plotY)) {
        if (chartCoordinates) {
          posX = xAxis2 ? xAxis2.pos : chart.plotLeft;
          posY = yAxis2 ? yAxis2.pos : chart.plotTop;
        }
        return chart.inverted && xAxis2 && yAxis2 ? [yAxis2.len - plotY + posY, xAxis2.len - plotX + posX] : [plotX + posX, plotY + posY];
      }
    }
  }
  /**
   * @private
   * @function Highcharts.Point#resolveColor
   */
  resolveColor() {
    const series = this.series, optionsChart = series.chart.options.chart, styledMode = series.chart.styledMode;
    let color14, colors, colorCount = optionsChart.colorCount, colorIndex;
    delete this.nonZonedColor;
    if (series.options.colorByPoint) {
      if (!styledMode) {
        colors = series.options.colors || series.chart.options.colors;
        color14 = colors[series.colorCounter];
        colorCount = colors.length;
      }
      colorIndex = series.colorCounter;
      series.colorCounter++;
      if (series.colorCounter === colorCount) {
        series.colorCounter = 0;
      }
    } else {
      if (!styledMode) {
        color14 = series.color;
      }
      colorIndex = series.colorIndex;
    }
    this.colorIndex = pick15(this.options.colorIndex, colorIndex);
    this.color = pick15(this.options.color, color14);
  }
  /**
   * Set a value in an object, on the property defined by key. The key
   * supports nested properties using dot notation. The function modifies the
   * input object and does not make a copy.
   *
   * @function Highcharts.Point#setNestedProperty<T>
   *
   * @param {T} object
   *        The object to set the value on.
   *
   * @param {*} value
   *        The value to set.
   *
   * @param {string} key
   *        Key to the property to set.
   *
   * @return {T}
   *         The modified object.
   */
  setNestedProperty(object, value, key) {
    const nestedKeys = key.split(".");
    nestedKeys.reduce(function(result, key2, i, arr) {
      const isLastKey = arr.length - 1 === i;
      result[key2] = isLastKey ? value : isObject8(result[key2], true) ? result[key2] : {};
      return result[key2];
    }, object);
    return object;
  }
  shouldDraw() {
    return !this.isNull;
  }
  /**
   * Extendable method for formatting each point's tooltip line.
   *
   * @function Highcharts.Point#tooltipFormatter
   *
   * @param {string} pointFormat
   *        The point format.
   *
   * @return {string}
   *         A string to be concatenated in to the common tooltip text.
   */
  tooltipFormatter(pointFormat) {
    const { chart, pointArrayMap = ["y"], tooltipOptions } = this.series, { valueDecimals = "", valuePrefix = "", valueSuffix = "" } = tooltipOptions;
    if (chart.styledMode) {
      pointFormat = chart.tooltip?.styledModeFormat(pointFormat) || pointFormat;
    }
    pointArrayMap.forEach((key) => {
      key = "{point." + key;
      if (valuePrefix || valueSuffix) {
        pointFormat = pointFormat.replace(RegExp(key + "}", "g"), valuePrefix + key + "}" + valueSuffix);
      }
      pointFormat = pointFormat.replace(RegExp(key + "}", "g"), key + ":,." + valueDecimals + "f}");
    });
    return format3(pointFormat, this, chart);
  }
  /**
   * Update point with new options (typically x/y data) and optionally redraw
   * the series.
   *
   * @sample highcharts/members/point-update-column/
   *         Update column value
   * @sample highcharts/members/point-update-pie/
   *         Update pie slice
   * @sample maps/members/point-update/
   *         Update map area value in Highmaps
   *
   * @function Highcharts.Point#update
   *
   * @param {Highcharts.PointOptionsType} options
   *        The point options. Point options are handled as described under
   *        the `series.type.data` item for each series type. For example
   *        for a line series, if options is a single number, the point will
   *        be given that number as the marin y value. If it is an array, it
   *        will be interpreted as x and y values respectively. If it is an
   *        object, advanced options are applied.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after the point is updated. If doing
   *        more operations on the chart, it is best practice to set
   *        `redraw` to false and call `chart.redraw()` after.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=true]
   *        Whether to apply animation, and optionally animation
   *        configuration.
   *
   * @emits Highcharts.Point#event:update
   */
  update(options2, redraw, animation, runEvent) {
    const point = this, series = point.series, graphic = point.graphic, chart = series.chart, seriesOptions = series.options;
    let i;
    redraw = pick15(redraw, true);
    function update() {
      point.applyOptions(options2);
      const hasMockGraphic = graphic && point.hasMockGraphic;
      const shouldDestroyGraphic = point.y === null ? !hasMockGraphic : hasMockGraphic;
      if (graphic && shouldDestroyGraphic) {
        point.graphic = graphic.destroy();
        delete point.hasMockGraphic;
      }
      if (isObject8(options2, true)) {
        if (graphic?.element) {
          if (options2 && options2.marker && typeof options2.marker.symbol !== "undefined") {
            point.graphic = graphic.destroy();
          }
        }
        if (options2?.dataLabels && point.dataLabel) {
          point.dataLabel = point.dataLabel.destroy();
        }
      }
      i = point.index;
      const row = {};
      for (const key of series.dataColumnKeys()) {
        row[key] = point[key];
      }
      series.dataTable.setRow(row, i);
      seriesOptions.data[i] = isObject8(seriesOptions.data[i], true) || isObject8(options2, true) ? point.options : pick15(options2, seriesOptions.data[i]);
      series.isDirty = series.isDirtyData = true;
      if (!series.fixedBox && series.hasCartesianSeries) {
        chart.isDirtyBox = true;
      }
      if (seriesOptions.legendType === "point") {
        chart.isDirtyLegend = true;
      }
      if (redraw) {
        chart.redraw(animation);
      }
    }
    if (runEvent === false) {
      update();
    } else {
      point.firePointEvent("update", { options: options2 }, update);
    }
  }
  /**
   * Remove a point and optionally redraw the series and if necessary the axes
   *
   * @sample highcharts/plotoptions/series-point-events-remove/
   *         Remove point and confirm
   * @sample highcharts/members/point-remove/
   *         Remove pie slice
   * @sample maps/members/point-remove/
   *         Remove selected points in Highmaps
   *
   * @function Highcharts.Point#remove
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart or wait for an explicit call. When
   *        doing more operations on the chart, for example running
   *        `point.remove()` in a loop, it is best practice to set `redraw`
   *        to false and call `chart.redraw()` after.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=false]
   *        Whether to apply animation, and optionally animation
   *        configuration.
   */
  remove(redraw, animation) {
    this.series.removePoint(this.series.data.indexOf(this), redraw, animation);
  }
  /**
   * Toggle the selection status of a point.
   *
   * @see Highcharts.Chart#getSelectedPoints
   *
   * @sample highcharts/members/point-select/
   *         Select a point from a button
   * @sample highcharts/members/point-select-lasso/
   *         Lasso selection
   * @sample highcharts/chart/events-selection-points/
   *         Rectangle selection
   * @sample maps/series/data-id/
   *         Select a point in Highmaps
   *
   * @function Highcharts.Point#select
   *
   * @param {boolean} [selected]
   * When `true`, the point is selected. When `false`, the point is
   * unselected. When `null` or `undefined`, the selection state is toggled.
   *
   * @param {boolean} [accumulate=false]
   * When `true`, the selection is added to other selected points.
   * When `false`, other selected points are deselected. Internally in
   * Highcharts, when
   * [allowPointSelect](https://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect)
   * is `true`, selected points are accumulated on Control, Shift or Cmd
   * clicking the point.
   *
   * @emits Highcharts.Point#event:select
   * @emits Highcharts.Point#event:unselect
   */
  select(selected, accumulate) {
    const point = this, series = point.series, chart = series.chart;
    selected = pick15(selected, !point.selected);
    this.selectedStaging = selected;
    point.firePointEvent(selected ? "select" : "unselect", { accumulate }, function() {
      point.selected = point.options.selected = selected;
      series.options.data[series.data.indexOf(point)] = point.options;
      point.setState(selected && "select");
      if (!accumulate) {
        chart.getSelectedPoints().forEach(function(loopPoint) {
          const loopSeries = loopPoint.series;
          if (loopPoint.selected && loopPoint !== point) {
            loopPoint.selected = loopPoint.options.selected = false;
            loopSeries.options.data[loopSeries.data.indexOf(loopPoint)] = loopPoint.options;
            loopPoint.setState(chart.hoverPoints && loopSeries.options.inactiveOtherPoints ? "inactive" : "");
            loopPoint.firePointEvent("unselect");
          }
        });
      }
    });
    delete this.selectedStaging;
  }
  /**
   * Runs on mouse over the point. Called internally from mouse and touch
   * events.
   *
   * @function Highcharts.Point#onMouseOver
   *
   * @param {Highcharts.PointerEventObject} [e]
   *        The event arguments.
   */
  onMouseOver(e) {
    const point = this, series = point.series, { inverted, pointer } = series.chart;
    if (pointer) {
      e = e ? pointer.normalize(e) : (
        // In cases where onMouseOver is called directly without an
        // event
        pointer.getChartCoordinatesFromPoint(point, inverted)
      );
      pointer.runPointActions(e, point);
    }
  }
  /**
   * Runs on mouse out from the point. Called internally from mouse and touch
   * events.
   *
   * @function Highcharts.Point#onMouseOut
   * @emits Highcharts.Point#event:mouseOut
   */
  onMouseOut() {
    const point = this, chart = point.series.chart;
    point.firePointEvent("mouseOut");
    if (!point.series.options.inactiveOtherPoints) {
      (chart.hoverPoints || []).forEach(function(p) {
        p.setState();
      });
    }
    chart.hoverPoints = chart.hoverPoint = null;
  }
  /**
   * Manage specific event from the series' and point's options. Only do it on
   * demand, to save processing time on hovering.
   *
   * @private
   * @function Highcharts.Point#importEvents
   */
  manageEvent(eventType) {
    const point = this, options2 = merge13(point.series.options.point, point.options), userEvent = options2.events?.[eventType];
    if (isFunction5(userEvent) && (!point.hcEvents?.[eventType] || // Some HC modules, like marker-clusters, draggable-poins etc.
    // use events in their logic, so we need to be sure, that
    // callback function is different
    point.hcEvents?.[eventType]?.map((el) => el.fn).indexOf(userEvent) === -1)) {
      point.importedUserEvent?.();
      point.importedUserEvent = addEvent9(point, eventType, userEvent);
      if (point.hcEvents) {
        point.hcEvents[eventType].userEvent = true;
      }
    } else if (point.importedUserEvent && !userEvent && point.hcEvents?.[eventType] && point.hcEvents?.[eventType].userEvent) {
      removeEvent5(point, eventType);
      delete point.hcEvents[eventType];
      if (!Object.keys(point.hcEvents)) {
        delete point.importedUserEvent;
      }
    }
  }
  /**
   * Set the point's state.
   *
   * @function Highcharts.Point#setState
   *
   * @param {Highcharts.PointStateValue|""} [state]
   *        The new state, can be one of `'hover'`, `'select'`, `'inactive'`,
   *        or `''` (an empty string), `'normal'` or `undefined` to set to
   *        normal state.
   * @param {boolean} [move]
   *        State for animation.
   *
   * @emits Highcharts.Point#event:afterSetState
   */
  setState(state, move) {
    const point = this, series = point.series, previousState = point.state, stateOptions = series.options.states[state || "normal"] || {}, markerOptions = defaultOptions5.plotOptions[series.type].marker && series.options.marker, normalDisabled = markerOptions && markerOptions.enabled === false, markerStateOptions = markerOptions?.states?.[state || "normal"] || {}, stateDisabled = markerStateOptions.enabled === false, pointMarker = point.marker || {}, chart = series.chart, hasMarkers = markerOptions && series.markerAttribs;
    let halo = series.halo, markerAttribs, pointAttribs, pointAttribsAnimation, stateMarkerGraphic = series.stateMarkerGraphic, newSymbol;
    state = state || "";
    if (
      // Already has this state
      state === point.state && !move || // Selected points don't respond to hover
      point.selected && state !== "select" || // Series' state options is disabled
      stateOptions.enabled === false || // General point marker's state options is disabled
      state && (stateDisabled || normalDisabled && markerStateOptions.enabled === false) || // Individual point marker's state options is disabled
      state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false
    ) {
      return;
    }
    point.state = state;
    if (hasMarkers) {
      markerAttribs = series.markerAttribs(point, state);
    }
    if (point.graphic && !point.hasMockGraphic) {
      if (previousState) {
        point.graphic.removeClass("highcharts-point-" + previousState);
      }
      if (state) {
        point.graphic.addClass("highcharts-point-" + state);
      }
      if (!chart.styledMode) {
        pointAttribs = series.pointAttribs(point, state);
        pointAttribsAnimation = pick15(chart.options.chart.animation, stateOptions.animation);
        const opacity = pointAttribs.opacity;
        if (series.options.inactiveOtherPoints && isNumber16(opacity)) {
          (point.dataLabels || []).forEach(function(label) {
            if (label && !label.hasClass("highcharts-data-label-hidden")) {
              label.animate({ opacity }, pointAttribsAnimation);
              if (label.connector) {
                label.connector.animate({ opacity }, pointAttribsAnimation);
              }
            }
          });
        }
        point.graphic.animate(pointAttribs, pointAttribsAnimation);
      }
      if (markerAttribs) {
        point.graphic.animate(markerAttribs, pick15(
          // Turn off globally:
          chart.options.chart.animation,
          markerStateOptions.animation,
          markerOptions.animation
        ));
      }
      if (stateMarkerGraphic) {
        stateMarkerGraphic.hide();
      }
    } else {
      if (state && markerStateOptions) {
        newSymbol = pointMarker.symbol || series.symbol;
        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
          stateMarkerGraphic = stateMarkerGraphic.destroy();
        }
        if (markerAttribs) {
          if (!stateMarkerGraphic) {
            if (newSymbol) {
              series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, merge13(markerOptions, markerStateOptions)).add(series.markerGroup);
              stateMarkerGraphic.currentSymbol = newSymbol;
            }
          } else {
            stateMarkerGraphic[move ? "animate" : "attr"]({
              x: markerAttribs.x,
              y: markerAttribs.y
            });
          }
        }
        if (!chart.styledMode && stateMarkerGraphic && point.state !== "inactive") {
          stateMarkerGraphic.attr(series.pointAttribs(point, state));
        }
      }
      if (stateMarkerGraphic) {
        stateMarkerGraphic[state && point.isInside ? "show" : "hide"]();
        stateMarkerGraphic.element.point = point;
        stateMarkerGraphic.addClass(point.getClassName(), true);
      }
    }
    const haloOptions = stateOptions.halo;
    const markerGraphic = point.graphic || stateMarkerGraphic;
    const markerVisibility = markerGraphic?.visibility || "inherit";
    if (haloOptions?.size && markerGraphic && markerVisibility !== "hidden" && !point.isCluster) {
      if (!halo) {
        series.halo = halo = chart.renderer.path().add(markerGraphic.parentGroup);
      }
      halo.show()[move ? "animate" : "attr"]({
        d: point.haloPath(haloOptions.size)
      });
      halo.attr({
        "class": "highcharts-halo highcharts-color-" + pick15(point.colorIndex, series.colorIndex) + (point.className ? " " + point.className : ""),
        "visibility": markerVisibility,
        "zIndex": -1
        // #4929, #8276
      });
      halo.point = point;
      if (!chart.styledMode) {
        halo.attr(extend14({
          "fill": point.color || series.color,
          "fill-opacity": haloOptions.opacity
        }, AST_default.filterUserAttributes(haloOptions.attributes || {})));
      }
    } else if (halo?.point?.haloPath && !halo.point.destroyed) {
      halo.animate(
        { d: halo.point.haloPath(0) },
        null,
        // Hide after unhovering. The `complete` callback runs in the
        // halo's context (#7681).
        halo.hide
      );
    }
    fireEvent9(point, "afterSetState", { state });
  }
  /**
   * Get the path definition for the halo, which is usually a shadow-like
   * circle around the currently hovered point.
   *
   * @function Highcharts.Point#haloPath
   *
   * @param {number} size
   *        The radius of the circular halo.
   *
   * @return {Highcharts.SVGPathArray}
   *         The path definition.
   */
  haloPath(size) {
    const pos = this.pos();
    return pos ? this.series.chart.renderer.symbols.circle(crisp4(pos[0], 1) - size, pos[1] - size, size * 2, size * 2) : [];
  }
};
var Point_default = Point;

// node_modules/highcharts/es-modules/Core/Pointer.js
var { parse: color2 } = Color_default;
var { charts: charts3, composed: composed3, isTouchDevice: isTouchDevice2 } = Globals_default;
var { addEvent: addEvent10, attr: attr8, css: css8, extend: extend15, find: find2, fireEvent: fireEvent10, isNumber: isNumber17, isObject: isObject9, objectEach: objectEach12, offset: offset2, pick: pick16, pushUnique: pushUnique6, splat: splat6 } = Utilities_default;
var Pointer = class _Pointer {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Set inactive state to all series that are not currently hovered,
   * or, if `inactiveOtherPoints` is set to true, set inactive state to
   * all points within that series.
   *
   * @private
   * @function Highcharts.Pointer#applyInactiveState
   *
   * @param {Array<Highcharts.Point>} points
   * Currently hovered points
   */
  applyInactiveState(points = []) {
    const activeSeries = [];
    points.forEach((item) => {
      const series = item.series;
      activeSeries.push(series);
      if (series.linkedParent) {
        activeSeries.push(series.linkedParent);
      }
      if (series.linkedSeries) {
        activeSeries.push.apply(activeSeries, series.linkedSeries);
      }
      if (series.navigatorSeries) {
        activeSeries.push(series.navigatorSeries);
      }
      if (series.boosted && series.markerGroup) {
        activeSeries.push.apply(activeSeries, this.chart.series.filter((otherSeries) => otherSeries.markerGroup === series.markerGroup));
      }
    });
    this.chart.series.forEach((series) => {
      if (activeSeries.indexOf(series) === -1) {
        series.setState("inactive", true);
      } else if (series.options.inactiveOtherPoints) {
        series.setAllPointsToState("inactive");
      }
    });
  }
  /**
   * Destroys the Pointer object and disconnects DOM events.
   *
   * @function Highcharts.Pointer#destroy
   */
  destroy() {
    const pointer = this;
    this.eventsToUnbind.forEach((unbind) => unbind());
    this.eventsToUnbind = [];
    if (!Globals_default.chartCount) {
      _Pointer.unbindDocumentMouseUp.forEach((el) => el.unbind());
      _Pointer.unbindDocumentMouseUp.length = 0;
      if (_Pointer.unbindDocumentTouchEnd) {
        _Pointer.unbindDocumentTouchEnd = _Pointer.unbindDocumentTouchEnd();
      }
    }
    clearInterval(pointer.tooltipTimeout);
    objectEach12(pointer, function(_val, prop) {
      pointer[prop] = void 0;
    });
  }
  /**
   * Calculate attrs for selection marker.
   * @private
   * @function Highcharts.Pointer#getSelectionMarkerAttrs
   * @emits getSelectionMarkerAttrs
   */
  getSelectionMarkerAttrs(chartX, chartY) {
    const e = {
      args: { chartX, chartY },
      attrs: {},
      shapeType: "rect"
    };
    fireEvent10(this, "getSelectionMarkerAttrs", e, (e2) => {
      const { chart, zoomHor, zoomVert } = this, { mouseDownX = 0, mouseDownY = 0 } = chart, attrs = e2.attrs;
      let size;
      attrs.x = chart.plotLeft;
      attrs.y = chart.plotTop;
      attrs.width = zoomHor ? 1 : chart.plotWidth;
      attrs.height = zoomVert ? 1 : chart.plotHeight;
      if (zoomHor) {
        size = chartX - mouseDownX;
        attrs.width = Math.max(1, Math.abs(size));
        attrs.x = (size > 0 ? 0 : size) + mouseDownX;
      }
      if (zoomVert) {
        size = chartY - mouseDownY;
        attrs.height = Math.max(1, Math.abs(size));
        attrs.y = (size > 0 ? 0 : size) + mouseDownY;
      }
    });
    return e;
  }
  /**
   * Perform a drag operation in response to a mousemove event while the mouse
   * is down.
   * @private
   * @function Highcharts.Pointer#drag
   */
  drag(e) {
    const { chart } = this, { mouseDownX = 0, mouseDownY = 0 } = chart, { panning, panKey, selectionMarkerFill } = chart.options.chart, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, panningEnabled = isObject9(panning) ? panning.enabled : panning, panKeyPressed = panKey && e[`${panKey}Key`];
    let chartX = e.chartX, chartY = e.chartY, clickedInside, selectionMarker = this.selectionMarker;
    if (selectionMarker && selectionMarker.touch) {
      return;
    }
    if (chartX < plotLeft) {
      chartX = plotLeft;
    } else if (chartX > plotLeft + plotWidth) {
      chartX = plotLeft + plotWidth;
    }
    if (chartY < plotTop) {
      chartY = plotTop;
    } else if (chartY > plotTop + plotHeight) {
      chartY = plotTop + plotHeight;
    }
    this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));
    if (this.hasDragged > 10) {
      clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop, {
        visiblePlotOnly: true
      });
      const { shapeType, attrs } = this.getSelectionMarkerAttrs(chartX, chartY);
      if ((chart.hasCartesianSeries || chart.mapView) && this.hasZoom && clickedInside && !panKeyPressed) {
        if (!selectionMarker) {
          this.selectionMarker = selectionMarker = chart.renderer[shapeType]();
          selectionMarker.attr({
            "class": "highcharts-selection-marker",
            zIndex: 7
          }).add();
          if (!chart.styledMode) {
            selectionMarker.attr({
              fill: selectionMarkerFill || color2(
                "#334eff"
                /* Palette.highlightColor80 */
              ).setOpacity(0.25).get()
            });
          }
        }
      }
      if (selectionMarker) {
        selectionMarker.attr(attrs);
      }
      if (clickedInside && !selectionMarker && panningEnabled) {
        chart.pan(e, panning);
      }
    }
  }
  /**
   * Start a drag operation.
   * @private
   * @function Highcharts.Pointer#dragStart
   */
  dragStart(e) {
    const chart = this.chart;
    chart.mouseIsDown = e.type;
    chart.cancelClick = false;
    chart.mouseDownX = e.chartX;
    chart.mouseDownY = e.chartY;
  }
  /**
   * Get selection box to calculate extremes
   * @private
   * @function Highcharts.Pointer#getSelectionBox
   * @emits getSelectionBox
   */
  getSelectionBox(marker) {
    const e = {
      args: { marker },
      result: marker.getBBox()
    };
    fireEvent10(this, "getSelectionBox", e);
    return e.result;
  }
  /**
   * On mouse up or touch end across the entire document, drop the selection.
   * @private
   * @function Highcharts.Pointer#drop
   */
  drop(e) {
    const { chart, selectionMarker } = this;
    let redraw;
    for (const axis of chart.axes) {
      if (axis.isPanning) {
        axis.isPanning = false;
        if (axis.options.startOnTick || axis.options.endOnTick || axis.series.some((s) => s.boosted)) {
          axis.forceRedraw = true;
          axis.setExtremes(axis.userMin, axis.userMax, false);
          redraw = true;
        }
      }
    }
    if (redraw) {
      chart.redraw();
    }
    if (selectionMarker && e) {
      if (this.hasDragged) {
        const from = this.getSelectionBox(selectionMarker);
        chart.transform({
          axes: chart.axes.filter((a) => a.zoomEnabled && (a.coll === "xAxis" && this.zoomX || a.coll === "yAxis" && this.zoomY)),
          selection: {
            originalEvent: e,
            // #4890
            xAxis: [],
            yAxis: [],
            ...from
          },
          from
        });
      }
      if (isNumber17(chart.index)) {
        this.selectionMarker = selectionMarker.destroy();
      }
    }
    if (chart && isNumber17(chart.index)) {
      css8(chart.container, { cursor: chart._cursor });
      chart.cancelClick = this.hasDragged > 10;
      chart.mouseIsDown = false;
      this.hasDragged = 0;
      this.pinchDown = [];
    }
  }
  /**
   * Finds the closest point to a set of coordinates, using the k-d-tree
   * algorithm.
   *
   * @function Highcharts.Pointer#findNearestKDPoint
   *
   * @param {Array<Highcharts.Series>} series
   * All the series to search in.
   *
   * @param {boolean|undefined} shared
   * Whether it is a shared tooltip or not.
   *
   * @param {Highcharts.PointerEventObject} e
   * The pointer event object, containing chart coordinates of the pointer.
   *
   * @return {Highcharts.Point|undefined}
   * The point closest to given coordinates.
   */
  findNearestKDPoint(series, shared, e) {
    let closest;
    function sort(p1, p2) {
      const isCloserX = p1.distX - p2.distX, isCloser = p1.dist - p2.dist, isAbove = p2.series.group?.zIndex - p1.series.group?.zIndex;
      let result;
      if (isCloserX !== 0 && shared) {
        result = isCloserX;
      } else if (isCloser !== 0) {
        result = isCloser;
      } else if (isAbove !== 0) {
        result = isAbove;
      } else {
        result = p1.series.index > p2.series.index ? -1 : 1;
      }
      return result;
    }
    series.forEach(function(s) {
      const noSharedTooltip = s.noSharedTooltip && shared, compareX = !noSharedTooltip && s.options.findNearestPointBy.indexOf("y") < 0, point = s.searchPoint(e, compareX);
      if (
        // Check that we actually found a point on the series.
        isObject9(point, true) && point.series && // Use the new point if it is closer.
        (!isObject9(closest, true) || sort(closest, point) > 0)
      ) {
        closest = point;
      }
    });
    return closest;
  }
  /**
   * @private
   * @function Highcharts.Pointer#getChartCoordinatesFromPoint
   */
  getChartCoordinatesFromPoint(point, inverted) {
    const { xAxis: xAxis2, yAxis: yAxis2 } = point.series, shapeArgs = point.shapeArgs;
    if (xAxis2 && yAxis2) {
      let x = point.clientX ?? point.plotX ?? 0, y = point.plotY || 0;
      if (point.isNode && shapeArgs && isNumber17(shapeArgs.x) && isNumber17(shapeArgs.y)) {
        x = shapeArgs.x;
        y = shapeArgs.y;
      }
      return inverted ? {
        chartX: yAxis2.len + yAxis2.pos - y,
        chartY: xAxis2.len + xAxis2.pos - x
      } : {
        chartX: x + xAxis2.pos,
        chartY: y + yAxis2.pos
      };
    }
    if (shapeArgs?.x && shapeArgs.y) {
      return {
        chartX: shapeArgs.x,
        chartY: shapeArgs.y
      };
    }
  }
  /**
   * Return the cached chartPosition if it is available on the Pointer,
   * otherwise find it. Running offset is quite expensive, so it should be
   * avoided when we know the chart hasn't moved.
   *
   * @function Highcharts.Pointer#getChartPosition
   *
   * @return {Highcharts.ChartPositionObject}
   * The offset of the chart container within the page
   */
  getChartPosition() {
    if (this.chartPosition) {
      return this.chartPosition;
    }
    const { container } = this.chart;
    const pos = offset2(container);
    this.chartPosition = {
      left: pos.left,
      top: pos.top,
      scaleX: 1,
      scaleY: 1
    };
    const { offsetHeight, offsetWidth } = container;
    if (offsetWidth > 2 && // #13342
    offsetHeight > 2) {
      this.chartPosition.scaleX = pos.width / offsetWidth;
      this.chartPosition.scaleY = pos.height / offsetHeight;
    }
    return this.chartPosition;
  }
  /**
   * Get the click position in terms of axis values.
   *
   * @function Highcharts.Pointer#getCoordinates
   *
   * @param {Highcharts.PointerEventObject} e
   * Pointer event, extended with `chartX` and `chartY` properties.
   *
   * @return {Highcharts.PointerAxisCoordinatesObject}
   * Axis coordinates.
   */
  getCoordinates(e) {
    const coordinates = {
      xAxis: [],
      yAxis: []
    };
    for (const axis of this.chart.axes) {
      coordinates[axis.isXAxis ? "xAxis" : "yAxis"].push({
        axis,
        value: axis.toValue(e[axis.horiz ? "chartX" : "chartY"])
      });
    }
    return coordinates;
  }
  /**
   * Calculates what is the current hovered point/points and series.
   *
   * @private
   * @function Highcharts.Pointer#getHoverData
   *
   * @param {Highcharts.Point|undefined} existingHoverPoint
   * The point currently being hovered.
   *
   * @param {Highcharts.Series|undefined} existingHoverSeries
   * The series currently being hovered.
   *
   * @param {Array<Highcharts.Series>} series
   * All the series in the chart.
   *
   * @param {boolean} isDirectTouch
   * Is the pointer directly hovering the point.
   *
   * @param {boolean|undefined} shared
   * Whether it is a shared tooltip or not.
   *
   * @param {Highcharts.PointerEventObject} [e]
   * The triggering event, containing chart coordinates of the pointer.
   *
   * @return {Object}
   * Object containing resulting hover data: hoverPoint, hoverSeries, and
   * hoverPoints.
   */
  getHoverData(existingHoverPoint, existingHoverSeries, series, isDirectTouch, shared, e) {
    const hoverPoints = [], useExisting = !!(isDirectTouch && existingHoverPoint), filter = function(s) {
      return s.visible && !(!shared && s.directTouch) && // #3821
      pick16(s.options.enableMouseTracking, true);
    };
    let hoverSeries = existingHoverSeries, searchSeries, eventArgs = {
      chartX: e ? e.chartX : void 0,
      chartY: e ? e.chartY : void 0,
      shared
    };
    fireEvent10(this, "beforeGetHoverData", eventArgs);
    const notSticky = hoverSeries && !hoverSeries.stickyTracking;
    searchSeries = notSticky ? (
      // Only search on hovered series if it has stickyTracking false
      [hoverSeries]
    ) : (
      // Filter what series to look in.
      series.filter((s) => s.stickyTracking && (eventArgs.filter || filter)(s))
    );
    const hoverPoint = useExisting || !e ? existingHoverPoint : this.findNearestKDPoint(searchSeries, shared, e);
    hoverSeries = hoverPoint?.series;
    if (hoverPoint) {
      if (shared && !hoverSeries.noSharedTooltip) {
        searchSeries = series.filter(function(s) {
          return eventArgs.filter ? eventArgs.filter(s) : filter(s) && !s.noSharedTooltip;
        });
        searchSeries.forEach(function(s) {
          const nullInteraction = s.options?.nullInteraction;
          let point = find2(s.points, function(p) {
            return p.x === hoverPoint.x && (!p.isNull || !!nullInteraction);
          });
          if (isObject9(point)) {
            if (s.boosted && s.boost) {
              point = s.boost.getPoint(point);
            }
            hoverPoints.push(point);
          }
        });
      } else {
        hoverPoints.push(hoverPoint);
      }
    }
    eventArgs = { hoverPoint };
    fireEvent10(this, "afterGetHoverData", eventArgs);
    return {
      hoverPoint: eventArgs.hoverPoint,
      hoverSeries,
      hoverPoints
    };
  }
  /**
   * @private
   * @function Highcharts.Pointer#getPointFromEvent
   */
  getPointFromEvent(e) {
    let target = e.target, point;
    while (target && !point) {
      point = target.point;
      target = target.parentNode;
    }
    return point;
  }
  /**
   * @private
   * @function Highcharts.Pointer#onTrackerMouseOut
   */
  onTrackerMouseOut(e) {
    const chart = this.chart;
    const relatedTarget = e.relatedTarget;
    const series = chart.hoverSeries;
    this.isDirectTouch = false;
    if (series && relatedTarget && !series.stickyTracking && !this.inClass(relatedTarget, "highcharts-tooltip") && (!this.inClass(relatedTarget, "highcharts-series-" + series.index) || // #2499, #4465, #5553
    !this.inClass(relatedTarget, "highcharts-tracker"))) {
      series.onMouseOut();
    }
  }
  /**
   * Utility to detect whether an element has, or has a parent with, a
   * specific class name. Used on detection of tracker objects and on deciding
   * whether hovering the tooltip should cause the active series to mouse out.
   *
   * @function Highcharts.Pointer#inClass
   *
   * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element
   * The element to investigate.
   *
   * @param {string} className
   * The class name to look for.
   *
   * @return {boolean|undefined}
   * True if either the element or one of its parents has the given class
   * name.
   */
  inClass(element, className) {
    let elem = element, elemClassName;
    while (elem) {
      elemClassName = attr8(elem, "class");
      if (elemClassName) {
        if (elemClassName.indexOf(className) !== -1) {
          return true;
        }
        if (elemClassName.indexOf("highcharts-container") !== -1) {
          return false;
        }
      }
      elem = elem.parentElement;
    }
  }
  /**
   * Initialize the Pointer.
   *
   * @private
   * @function Highcharts.Pointer#init
   *
   * @param {Highcharts.Chart} chart
   * The Chart instance.
   *
   * @param {Highcharts.Options} options
   * The root options object. The pointer uses options from the chart and
   * tooltip structures.
   */
  constructor(chart, options2) {
    this.hasDragged = 0;
    this.pointerCaptureEventsToUnbind = [];
    this.eventsToUnbind = [];
    this.options = options2;
    this.chart = chart;
    this.runChartClick = Boolean(options2.chart.events?.click);
    this.pinchDown = [];
    this.setDOMEvents();
    fireEvent10(this, "afterInit");
  }
  /**
   * Takes a browser event object and extends it with custom Highcharts
   * properties `chartX` and `chartY` in order to work on the internal
   * coordinate system.
   *
   * On map charts, the properties `lon` and `lat` are added to the event
   * object given that the chart has projection information.
   *
   * @function Highcharts.Pointer#normalize
   *
   * @param {global.MouseEvent|global.PointerEvent|global.TouchEvent} e
   * Event object in standard browsers.
   *
   * @param {Highcharts.OffsetObject} [chartPosition]
   * Additional chart offset.
   *
   * @return {Highcharts.PointerEventObject}
   * A browser event with extended properties `chartX` and `chartY`.
   */
  normalize(e, chartPosition) {
    const touches = e.touches;
    const ePos = touches ? touches.length ? touches.item(0) : pick16(
      // #13534
      touches.changedTouches,
      e.changedTouches
    )[0] : e;
    if (!chartPosition) {
      chartPosition = this.getChartPosition();
    }
    let chartX = ePos.pageX - chartPosition.left, chartY = ePos.pageY - chartPosition.top;
    chartX /= chartPosition.scaleX;
    chartY /= chartPosition.scaleY;
    return extend15(e, {
      chartX: Math.round(chartX),
      chartY: Math.round(chartY)
    });
  }
  /**
   * @private
   * @function Highcharts.Pointer#onContainerClick
   */
  onContainerClick(e) {
    const chart = this.chart;
    const hoverPoint = chart.hoverPoint;
    const pEvt = this.normalize(e);
    const plotLeft = chart.plotLeft;
    const plotTop = chart.plotTop;
    if (!chart.cancelClick) {
      if (hoverPoint && this.inClass(pEvt.target, "highcharts-tracker")) {
        fireEvent10(hoverPoint.series, "click", extend15(pEvt, {
          point: hoverPoint
        }));
        if (chart.hoverPoint) {
          hoverPoint.firePointEvent("click", pEvt);
        }
      } else {
        extend15(pEvt, this.getCoordinates(pEvt));
        if (chart.isInsidePlot(pEvt.chartX - plotLeft, pEvt.chartY - plotTop, {
          visiblePlotOnly: true
        })) {
          fireEvent10(chart, "click", pEvt);
        }
      }
    }
  }
  /**
   * @private
   * @function Highcharts.Pointer#onContainerMouseDown
   */
  onContainerMouseDown(e) {
    const isPrimaryButton = ((e.buttons || e.button) & 1) === 1;
    e = this.normalize(e);
    if (Globals_default.isFirefox && e.button !== 0) {
      this.onContainerMouseMove(e);
    }
    if (typeof e.button === "undefined" || isPrimaryButton) {
      this.zoomOption(e);
      if (isPrimaryButton) {
        e.preventDefault?.();
      }
      this.dragStart(e);
    }
  }
  /**
   * When mouse leaves the container, hide the tooltip.
   * @private
   * @function Highcharts.Pointer#onContainerMouseLeave
   */
  onContainerMouseLeave(e) {
    const { pointer } = charts3[pick16(_Pointer.hoverChartIndex, -1)] || {};
    e = this.normalize(e);
    this.onContainerMouseMove(e);
    if (pointer && !this.inClass(e.relatedTarget, "highcharts-tooltip")) {
      pointer.reset();
      pointer.chartPosition = void 0;
    }
  }
  /**
   * When mouse enters the container, delete pointer's chartPosition.
   * @private
   * @function Highcharts.Pointer#onContainerMouseEnter
   */
  onContainerMouseEnter() {
    delete this.chartPosition;
  }
  /**
   * The mousemove, touchmove and touchstart event handler
   * @private
   * @function Highcharts.Pointer#onContainerMouseMove
   */
  onContainerMouseMove(e) {
    const chart = this.chart, tooltip = chart.tooltip, pEvt = this.normalize(e);
    this.setHoverChartIndex(e);
    if (chart.mouseIsDown === "mousedown" || this.touchSelect(pEvt)) {
      this.drag(pEvt);
    }
    if (!chart.openMenu && (this.inClass(pEvt.target, "highcharts-tracker") || chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
      visiblePlotOnly: true
    })) && // If the tooltip has stickOnContact enabled, do nothing. This
    // applies regardless of any combinations of the `split` and
    // `useHTML` options.
    !tooltip?.shouldStickOnContact(pEvt)) {
      if (this.inClass(pEvt.target, "highcharts-no-tooltip")) {
        this.reset(false, 0);
      } else {
        this.runPointActions(pEvt);
      }
    }
  }
  /**
   * @private
   * @function Highcharts.Pointer#onDocumentTouchEnd
   */
  onDocumentTouchEnd(e) {
    this.onDocumentMouseUp(e);
  }
  /**
   * @private
   * @function Highcharts.Pointer#onContainerTouchMove
   */
  onContainerTouchMove(e) {
    if (this.touchSelect(e)) {
      this.onContainerMouseMove(e);
    } else {
      this.touch(e);
    }
  }
  /**
   * @private
   * @function Highcharts.Pointer#onContainerTouchStart
   */
  onContainerTouchStart(e) {
    if (this.touchSelect(e)) {
      this.onContainerMouseDown(e);
    } else {
      this.zoomOption(e);
      this.touch(e, true);
    }
  }
  /**
   * Special handler for mouse move that will hide the tooltip when the mouse
   * leaves the plotarea. Issue #149 workaround. The mouseleave event does not
   * always fire.
   * @private
   * @function Highcharts.Pointer#onDocumentMouseMove
   */
  onDocumentMouseMove(e) {
    const chart = this.chart;
    const tooltip = chart.tooltip;
    const chartPosition = this.chartPosition;
    const pEvt = this.normalize(e, chartPosition);
    if (chartPosition && !chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
      visiblePlotOnly: true
    }) && !tooltip?.shouldStickOnContact(pEvt) && (pEvt.target === chart.container.ownerDocument || !this.inClass(pEvt.target, "highcharts-tracker"))) {
      this.reset();
    }
  }
  /**
   * @private
   * @function Highcharts.Pointer#onDocumentMouseUp
   */
  onDocumentMouseUp(e) {
    charts3[pick16(_Pointer.hoverChartIndex, -1)]?.pointer?.drop(e);
  }
  /**
   * Handle touch events with two touches
   * @private
   * @function Highcharts.Pointer#pinch
   */
  pinch(e) {
    const pointer = this, { chart, hasZoom, lastTouches } = pointer, touches = [].map.call(
      e.touches || [],
      // Normalize each touch
      (touch) => pointer.normalize(touch)
    ), touchesLength = touches.length, fireClickEvent = touchesLength === 1 && (pointer.inClass(e.target, "highcharts-tracker") && chart.runTrackerClick || pointer.runChartClick), tooltip = chart.tooltip, followTouchMove = touchesLength === 1 && pick16(tooltip?.options.followTouchMove, true);
    if (touchesLength > 1) {
      pointer.initiated = true;
    } else if (followTouchMove) {
      pointer.initiated = false;
    }
    if (hasZoom && pointer.initiated && !fireClickEvent && e.cancelable !== false) {
      e.preventDefault();
    }
    if (e.type === "touchstart") {
      pointer.pinchDown = touches;
      pointer.res = true;
      chart.mouseDownX = e.chartX;
    } else if (followTouchMove) {
      this.runPointActions(pointer.normalize(e));
    } else if (lastTouches) {
      fireEvent10(chart, "touchpan", {
        originalEvent: e,
        touches
      }, () => {
        const boxFromTouches = (touches2) => {
          const finger0 = touches2[0], finger1 = touches2[1] || finger0;
          return {
            x: finger0.chartX,
            y: finger0.chartY,
            width: finger1.chartX - finger0.chartX,
            height: finger1.chartY - finger0.chartY
          };
        };
        chart.transform({
          axes: chart.axes.filter((axis) => axis.zoomEnabled && (this.zoomHor && axis.horiz || this.zoomVert && !axis.horiz)),
          to: boxFromTouches(touches),
          from: boxFromTouches(lastTouches),
          trigger: e.type
        });
      });
      if (pointer.res) {
        pointer.res = false;
        this.reset(false, 0);
      }
    }
    pointer.lastTouches = touches;
  }
  /**
   * Run translation operations
   * @private
   * @function Highcharts.Pointer#pinchTranslate
   * /
  public pinchTranslate(
      pinchDown: Array<any>,
      touches: Array<PointerEvent>,
      transform: any,
      selectionMarker: any,
      clip: any,
      lastValidTouch: any
  ): void {
      if (this.zoomHor) {
          this.pinchTranslateDirection(
              true,
              pinchDown,
              touches,
              transform,
              selectionMarker,
              clip,
              lastValidTouch
          );
      }
      if (this.zoomVert) {
          this.pinchTranslateDirection(
              false,
              pinchDown,
              touches,
              transform,
              selectionMarker,
              clip,
              lastValidTouch
          );
      }
  }
  */
  /**
       * Run translation operations for each direction (horizontal and vertical)
       * independently.
       * @private
       * @function Highcharts.Pointer#pinchTranslateDirection
       * /
      public pinchTranslateDirection(
          horiz: boolean,
          pinchDown: Array<any>,
          touches: Array<PointerEvent>,
          transform: any,
          selectionMarker: any,
          clip: any,
          lastValidTouch: any,
          forcedScale?: number
      ): void {
          const chart = this.chart,
              xy: ('x'|'y') = horiz ? 'x' : 'y',
              XY: ('X'|'Y') = horiz ? 'X' : 'Y',
              sChartXY: ('chartX'|'chartY') = ('chart' + XY) as any,
              wh = horiz ? 'width' : 'height',
              plotLeftTop = (chart as any)['plot' + (horiz ? 'Left' : 'Top')],
              inverted = chart.inverted,
              bounds = chart.bounds[horiz ? 'h' : 'v'],
              singleTouch = pinchDown.length === 1,
              touch0Start = pinchDown[0][sChartXY],
              touch1Start = !singleTouch && pinchDown[1][sChartXY],
              setScale = function (): void {
                  // Don't zoom if fingers are too close on this axis
                  if (
                      typeof touch1Now === 'number' &&
                      Math.abs(touch0Start - touch1Start) > 20
                  ) {
                      scale = forcedScale ||
                          Math.abs(touch0Now - touch1Now) /
                          Math.abs(touch0Start - touch1Start);
                  }
  
                  clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
                  selectionWH = (chart as any)[
                      'plot' + (horiz ? 'Width' : 'Height')
                  ] / scale;
              };
  
          let selectionWH: any,
              selectionXY,
              clipXY: any,
              scale = forcedScale || 1,
              touch0Now = touches[0][sChartXY],
              touch1Now = !singleTouch && touches[1][sChartXY],
              outOfBounds;
  
          // Set the scale, first pass
          setScale();
  
          // The clip position (x or y) is altered if out of bounds, the selection
          // position is not
          selectionXY = clipXY;
  
          // Out of bounds
          if (selectionXY < bounds.min) {
              selectionXY = bounds.min;
              outOfBounds = true;
          } else if (selectionXY + selectionWH > bounds.max) {
              selectionXY = bounds.max - selectionWH;
              outOfBounds = true;
          }
  
          // Is the chart dragged off its bounds, determined by dataMin and
          // dataMax?
          if (outOfBounds) {
  
              // Modify the touchNow position in order to create an elastic drag
              // movement. This indicates to the user that the chart is responsive
              // but can't be dragged further.
              touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
              if (typeof touch1Now === 'number') {
                  touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
              }
  
              // Set the scale, second pass to adapt to the modified touchNow
              // positions
              setScale();
  
          } else {
              lastValidTouch[xy] = [touch0Now, touch1Now];
          }
  
          // Set geometry for clipping, selection and transformation
          if (!inverted) {
              clip[xy] = clipXY - plotLeftTop;
              clip[wh] = selectionWH;
          }
          const scaleKey = inverted ?
              (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
          const transformScale = inverted ? 1 / scale : scale;
  
          selectionMarker[wh] = selectionWH;
          selectionMarker[xy] = selectionXY;
          // Invert scale if needed (#19217)
          transform[scaleKey] = scale * (inverted && !horiz ? -1 : 1);
          transform['translate' + XY] = (transformScale * plotLeftTop) +
              (touch0Now - (transformScale * touch0Start));
      }
      */
  /**
   * Reset the tracking by hiding the tooltip, the hover series state and the
   * hover point.
   *
   * @function Highcharts.Pointer#reset
   *
   * @param {boolean} [allowMove]
   * Instead of destroying the tooltip altogether, allow moving it if
   * possible.
   *
   * @param {number} [delay]
   * The tooltip hide delay in ms.
   */
  reset(allowMove, delay) {
    const pointer = this, chart = pointer.chart, hoverSeries = chart.hoverSeries, hoverPoint = chart.hoverPoint, hoverPoints = chart.hoverPoints, tooltip = chart.tooltip, tooltipPoints = tooltip?.shared ? hoverPoints : hoverPoint;
    if (allowMove && tooltipPoints) {
      splat6(tooltipPoints).forEach(function(point) {
        if (point.series.isCartesian && typeof point.plotX === "undefined") {
          allowMove = false;
        }
      });
    }
    if (allowMove) {
      if (tooltip && tooltipPoints && splat6(tooltipPoints).length) {
        tooltip.refresh(tooltipPoints);
        if (tooltip.shared && hoverPoints) {
          hoverPoints.forEach(function(point) {
            point.setState(point.state, true);
            if (point.series.isCartesian) {
              if (point.series.xAxis.crosshair) {
                point.series.xAxis.drawCrosshair(null, point);
              }
              if (point.series.yAxis.crosshair) {
                point.series.yAxis.drawCrosshair(null, point);
              }
            }
          });
        } else if (hoverPoint) {
          hoverPoint.setState(hoverPoint.state, true);
          chart.axes.forEach(function(axis) {
            if (axis.crosshair && hoverPoint.series[axis.coll] === axis) {
              axis.drawCrosshair(null, hoverPoint);
            }
          });
        }
      }
    } else {
      if (hoverPoint) {
        hoverPoint.onMouseOut();
      }
      if (hoverPoints) {
        hoverPoints.forEach(function(point) {
          point.setState();
        });
      }
      if (hoverSeries) {
        hoverSeries.onMouseOut();
      }
      if (tooltip) {
        tooltip.hide(delay);
      }
      if (pointer.unDocMouseMove) {
        pointer.unDocMouseMove = pointer.unDocMouseMove();
      }
      chart.axes.forEach(function(axis) {
        axis.hideCrosshair();
      });
      chart.hoverPoints = chart.hoverPoint = void 0;
    }
  }
  /**
   * With line type charts with a single tracker, get the point closest to the
   * mouse. Run Point.onMouseOver and display tooltip for the point or points.
   *
   * @private
   * @function Highcharts.Pointer#runPointActions
   *
   * @emits Highcharts.Point#event:mouseOut
   * @emits Highcharts.Point#event:mouseOver
   */
  runPointActions(e, p, force) {
    const pointer = this, chart = pointer.chart, series = chart.series, tooltip = chart.tooltip?.options.enabled ? chart.tooltip : void 0, shared = tooltip ? tooltip.shared : false;
    let hoverPoint = p || chart.hoverPoint, hoverSeries = hoverPoint?.series || chart.hoverSeries;
    const isDirectTouch = (!e || e.type !== "touchmove") && (!!p || hoverSeries?.directTouch && pointer.isDirectTouch), hoverData = this.getHoverData(hoverPoint, hoverSeries, series, isDirectTouch, shared, e);
    hoverPoint = hoverData.hoverPoint;
    hoverSeries = hoverData.hoverSeries;
    const points = hoverData.hoverPoints, followPointer = hoverSeries?.tooltipOptions.followPointer && !hoverSeries.tooltipOptions.split, useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip;
    if (hoverPoint && (force || hoverPoint !== chart.hoverPoint || tooltip?.isHidden)) {
      (chart.hoverPoints || []).forEach(function(p2) {
        if (points.indexOf(p2) === -1) {
          p2.setState();
        }
      });
      if (chart.hoverSeries !== hoverSeries) {
        hoverSeries.onMouseOver();
      }
      pointer.applyInactiveState(points);
      (points || []).forEach(function(p2) {
        p2.setState("hover");
      });
      if (chart.hoverPoint) {
        chart.hoverPoint.firePointEvent("mouseOut");
      }
      if (!hoverPoint.series) {
        return;
      }
      chart.hoverPoints = points;
      chart.hoverPoint = hoverPoint;
      hoverPoint.firePointEvent("mouseOver", void 0, () => {
        if (tooltip && hoverPoint) {
          tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);
        }
      });
    } else if (followPointer && tooltip && !tooltip.isHidden) {
      const anchor = tooltip.getAnchor([{}], e);
      if (chart.isInsidePlot(anchor[0], anchor[1], {
        visiblePlotOnly: true
      })) {
        tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
      }
    }
    if (!pointer.unDocMouseMove) {
      pointer.unDocMouseMove = addEvent10(chart.container.ownerDocument, "mousemove", (e2) => charts3[_Pointer.hoverChartIndex ?? -1]?.pointer?.onDocumentMouseMove(e2));
      pointer.eventsToUnbind.push(pointer.unDocMouseMove);
    }
    chart.axes.forEach(function drawAxisCrosshair(axis) {
      const snap = axis.crosshair?.snap ?? true;
      let point;
      if (snap) {
        point = chart.hoverPoint;
        if (!point || point.series[axis.coll] !== axis) {
          point = find2(points, (p2) => p2.series?.[axis.coll] === axis);
        }
      }
      if (point || !snap) {
        axis.drawCrosshair(e, point);
      } else {
        axis.hideCrosshair();
      }
    });
  }
  /**
   * Set the JS DOM events on the container and document. This method should
   * contain a one-to-one assignment between methods and their handlers. Any
   * advanced logic should be moved to the handler reflecting the event's
   * name.
   * @private
   * @function Highcharts.Pointer#setDOMEvents
   */
  setDOMEvents() {
    const container = this.chart.container, ownerDoc = container.ownerDocument;
    container.onmousedown = this.onContainerMouseDown.bind(this);
    container.onmousemove = this.onContainerMouseMove.bind(this);
    container.onclick = this.onContainerClick.bind(this);
    this.eventsToUnbind.push(addEvent10(container, "mouseenter", this.onContainerMouseEnter.bind(this)), addEvent10(container, "mouseleave", this.onContainerMouseLeave.bind(this)));
    if (!_Pointer.unbindDocumentMouseUp.some((el) => el.doc === ownerDoc)) {
      _Pointer.unbindDocumentMouseUp.push({
        doc: ownerDoc,
        unbind: addEvent10(ownerDoc, "mouseup", this.onDocumentMouseUp.bind(this))
      });
    }
    let parent = this.chart.renderTo.parentElement;
    while (parent && parent.tagName !== "BODY") {
      this.eventsToUnbind.push(addEvent10(parent, "scroll", () => {
        delete this.chartPosition;
      }));
      parent = parent.parentElement;
    }
    this.eventsToUnbind.push(addEvent10(container, "touchstart", this.onContainerTouchStart.bind(this), { passive: false }), addEvent10(container, "touchmove", this.onContainerTouchMove.bind(this), { passive: false }));
    if (!_Pointer.unbindDocumentTouchEnd) {
      _Pointer.unbindDocumentTouchEnd = addEvent10(ownerDoc, "touchend", this.onDocumentTouchEnd.bind(this), { passive: false });
    }
    this.setPointerCapture();
    addEvent10(this.chart, "redraw", this.setPointerCapture.bind(this));
  }
  /**
   * Sets, or removes on update, pointer events using pointer capture for
   * tooltip.followTouchMove if any series has findNearestPointBy that
   * includes the y dimension.
   * @private
   * @function Highcharts.Pointer#setPointerCapture
  */
  setPointerCapture() {
    if (!isTouchDevice2) {
      return;
    }
    const pointer = this, events = pointer.pointerCaptureEventsToUnbind, chart = pointer.chart, container = chart.container, followTouchMove = pick16(chart.options.tooltip?.followTouchMove, true), shouldHave = followTouchMove && chart.series.some((series) => series.options.findNearestPointBy.indexOf("y") > -1);
    if (!pointer.hasPointerCapture && shouldHave) {
      events.push(addEvent10(container, "pointerdown", (e) => {
        if (e.target?.hasPointerCapture(e.pointerId)) {
          e.target?.releasePointerCapture(e.pointerId);
        }
      }), addEvent10(container, "pointermove", (e) => {
        chart.pointer?.getPointFromEvent(e)?.onMouseOver(e);
      }));
      if (!chart.styledMode) {
        css8(container, { "touch-action": "none" });
      }
      container.className += " highcharts-no-touch-action";
      pointer.hasPointerCapture = true;
    } else if (pointer.hasPointerCapture && !shouldHave) {
      events.forEach((e) => e());
      events.length = 0;
      if (!chart.styledMode) {
        css8(container, {
          "touch-action": pick16(chart.options.chart.style?.["touch-action"], "manipulation")
        });
      }
      container.className = container.className.replace(" highcharts-no-touch-action", "");
      pointer.hasPointerCapture = false;
    }
  }
  /**
   * Sets the index of the hovered chart and leaves the previous hovered
   * chart, to reset states like tooltip.
   * @private
   * @function Highcharts.Pointer#setHoverChartIndex
   */
  setHoverChartIndex(e) {
    const chart = this.chart;
    const hoverChart = Globals_default.charts[pick16(_Pointer.hoverChartIndex, -1)];
    if (hoverChart && hoverChart !== chart) {
      const relatedTargetObj = { relatedTarget: chart.container };
      if (e && !e?.relatedTarget) {
        Object.assign({}, e, relatedTargetObj);
      }
      hoverChart.pointer?.onContainerMouseLeave(e || relatedTargetObj);
    }
    if (!hoverChart?.mouseIsDown) {
      _Pointer.hoverChartIndex = chart.index;
    }
  }
  /**
   * General touch handler shared by touchstart and touchmove.
   * @private
   * @function Highcharts.Pointer#touch
   */
  touch(e, start) {
    const { chart, pinchDown = [] } = this;
    let hasMoved, isInside;
    this.setHoverChartIndex();
    e = this.normalize(e);
    if (e.touches.length === 1) {
      isInside = chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop, {
        visiblePlotOnly: true
      });
      if (isInside && !chart.openMenu) {
        if (start) {
          this.runPointActions(e);
        }
        if (e.type === "touchmove") {
          hasMoved = pinchDown[0] ? (
            // #5266
            Math.pow(pinchDown[0].chartX - e.chartX, 2) + Math.pow(pinchDown[0].chartY - e.chartY, 2) >= 16
          ) : false;
        }
        if (pick16(hasMoved, true)) {
          this.pinch(e);
        }
      } else if (start) {
        this.reset();
      }
    } else if (e.touches.length === 2) {
      this.pinch(e);
    }
  }
  /**
   * Returns true if the chart is set up for zooming by single touch and the
   * event is capable
   * @private
   * @function Highcharts.Pointer#touchSelect
   */
  touchSelect(e) {
    return Boolean(this.chart.zooming.singleTouch && e.touches && e.touches.length === 1);
  }
  /**
   * Resolve the zoomType option, this is reset on all touch start and mouse
   * down events.
   * @private
   * @function Highcharts.Pointer#zoomOption
   */
  zoomOption(e) {
    const chart = this.chart, inverted = chart.inverted;
    let zoomType = chart.zooming.type || "", zoomX, zoomY;
    if (/touch/.test(e.type)) {
      zoomType = pick16(chart.zooming.pinchType, zoomType);
    }
    this.zoomX = zoomX = /x/.test(zoomType);
    this.zoomY = zoomY = /y/.test(zoomType);
    this.zoomHor = zoomX && !inverted || zoomY && inverted;
    this.zoomVert = zoomY && !inverted || zoomX && inverted;
    this.hasZoom = zoomX || zoomY;
  }
};
Pointer.unbindDocumentMouseUp = [];
(function(Pointer2) {
  function compose27(ChartClass) {
    if (pushUnique6(composed3, "Core.Pointer")) {
      addEvent10(ChartClass, "beforeRender", function() {
        this.pointer = new Pointer2(this, this.options);
      });
    }
  }
  Pointer2.compose = compose27;
})(Pointer || (Pointer = {}));
var Pointer_default = Pointer;

// node_modules/highcharts/es-modules/Data/ColumnUtils.js
var ColumnUtils;
(function(ColumnUtils2) {
  function setLength2(column2, length, asSubarray) {
    if (Array.isArray(column2)) {
      column2.length = length;
      return column2;
    }
    return column2[asSubarray ? "subarray" : "slice"](0, length);
  }
  ColumnUtils2.setLength = setLength2;
  function splice2(column2, start, deleteCount, removedAsSubarray, items = []) {
    if (Array.isArray(column2)) {
      if (!Array.isArray(items)) {
        items = Array.from(items);
      }
      return {
        removed: column2.splice(start, deleteCount, ...items),
        array: column2
      };
    }
    const Constructor = Object.getPrototypeOf(column2).constructor;
    const removed = column2[removedAsSubarray ? "subarray" : "slice"](start, start + deleteCount);
    const newLength = column2.length - deleteCount + items.length;
    const result = new Constructor(newLength);
    result.set(column2.subarray(0, start), 0);
    result.set(items, start);
    result.set(column2.subarray(start + deleteCount), start + items.length);
    return {
      removed,
      array: result
    };
  }
  ColumnUtils2.splice = splice2;
})(ColumnUtils || (ColumnUtils = {}));
var ColumnUtils_default = ColumnUtils;

// node_modules/highcharts/es-modules/Data/DataTableCore.js
var { setLength, splice } = ColumnUtils_default;
var { fireEvent: fireEvent11, objectEach: objectEach13, uniqueKey: uniqueKey5 } = Utilities_default;
var DataTableCore = class {
  /**
       * Constructs an instance of the DataTable class.
       *
       * @example
       * const dataTable = new Highcharts.DataTableCore({
       *   columns: {
       *     year: [2020, 2021, 2022, 2023],
       *     cost: [11, 13, 12, 14],
       *     revenue: [12, 15, 14, 18]
       *   }
       * });
  
       *
       * @param {Highcharts.DataTableOptions} [options]
       * Options to initialize the new DataTable instance.
       */
  constructor(options2 = {}) {
    this.autoId = !options2.id;
    this.columns = {};
    this.id = options2.id || uniqueKey5();
    this.modified = this;
    this.rowCount = 0;
    this.versionTag = uniqueKey5();
    let rowCount = 0;
    objectEach13(options2.columns || {}, (column2, columnName) => {
      this.columns[columnName] = column2.slice();
      rowCount = Math.max(rowCount, column2.length);
    });
    this.applyRowCount(rowCount);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Applies a row count to the table by setting the `rowCount` property and
   * adjusting the length of all columns.
   *
   * @private
   * @param {number} rowCount The new row count.
   */
  applyRowCount(rowCount) {
    this.rowCount = rowCount;
    objectEach13(this.columns, (column2, columnName) => {
      if (column2.length !== rowCount) {
        this.columns[columnName] = setLength(column2, rowCount);
      }
    });
  }
  /**
   * Delete rows. Simplified version of the full
   * `DataTable.deleteRows` method.
   *
   * @param {number} rowIndex
   * The start row index
   *
   * @param {number} [rowCount=1]
   * The number of rows to delete
   *
   * @return {void}
   *
   * @emits #afterDeleteRows
   */
  deleteRows(rowIndex, rowCount = 1) {
    if (rowCount > 0 && rowIndex < this.rowCount) {
      let length = 0;
      objectEach13(this.columns, (column2, columnName) => {
        this.columns[columnName] = splice(column2, rowIndex, rowCount).array;
        length = column2.length;
      });
      this.rowCount = length;
    }
    fireEvent11(this, "afterDeleteRows", { rowIndex, rowCount });
    this.versionTag = uniqueKey5();
  }
  /**
   * Fetches the given column by the canonical column name. Simplified version
   * of the full `DataTable.getRow` method, always returning by reference.
   *
   * @param {string} columnName
   * Name of the column to get.
   *
   * @return {Highcharts.DataTableColumn|undefined}
   * A copy of the column, or `undefined` if not found.
   */
  getColumn(columnName, asReference) {
    return this.columns[columnName];
  }
  /**
   * Retrieves all or the given columns. Simplified version of the full
   * `DataTable.getColumns` method, always returning by reference.
   *
   * @param {Array<string>} [columnNames]
   * Column names to retrieve.
   *
   * @return {Highcharts.DataTableColumnCollection}
   * Collection of columns. If a requested column was not found, it is
   * `undefined`.
   */
  getColumns(columnNames, asReference) {
    return (columnNames || Object.keys(this.columns)).reduce((columns, columnName) => {
      columns[columnName] = this.columns[columnName];
      return columns;
    }, {});
  }
  /**
   * Retrieves the row at a given index.
   *
   * @param {number} rowIndex
   * Row index to retrieve. First row has index 0.
   *
   * @param {Array<string>} [columnNames]
   * Column names to retrieve.
   *
   * @return {Record<string, number|string|undefined>|undefined}
   * Returns the row values, or `undefined` if not found.
   */
  getRow(rowIndex, columnNames) {
    return (columnNames || Object.keys(this.columns)).map((key) => this.columns[key]?.[rowIndex]);
  }
  /**
   * Sets cell values for a column. Will insert a new column, if not found.
   *
   * @param {string} columnName
   * Column name to set.
   *
   * @param {Highcharts.DataTableColumn} [column]
   * Values to set in the column.
   *
   * @param {number} [rowIndex]
   * Index of the first row to change. (Default: 0)
   *
   * @param {Record<string, (boolean|number|string|null|undefined)>} [eventDetail]
   * Custom information for pending events.
   *
   * @emits #setColumns
   * @emits #afterSetColumns
   */
  setColumn(columnName, column2 = [], rowIndex = 0, eventDetail) {
    this.setColumns({ [columnName]: column2 }, rowIndex, eventDetail);
  }
  /**
   * Sets cell values for multiple columns. Will insert new columns, if not
   * found. Simplified version of the full `DataTableCore.setColumns`, limited
   * to full replacement of the columns (undefined `rowIndex`).
   *
   * @param {Highcharts.DataTableColumnCollection} columns
   * Columns as a collection, where the keys are the column names.
   *
   * @param {number} [rowIndex]
   * Index of the first row to change. Ignored in the `DataTableCore`, as it
   * always replaces the full column.
   *
   * @param {Record<string, (boolean|number|string|null|undefined)>} [eventDetail]
   * Custom information for pending events.
   *
   * @emits #setColumns
   * @emits #afterSetColumns
   */
  setColumns(columns, rowIndex, eventDetail) {
    let rowCount = this.rowCount;
    objectEach13(columns, (column2, columnName) => {
      this.columns[columnName] = column2.slice();
      rowCount = column2.length;
    });
    this.applyRowCount(rowCount);
    if (!eventDetail?.silent) {
      fireEvent11(this, "afterSetColumns");
      this.versionTag = uniqueKey5();
    }
  }
  /**
   * Sets cell values of a row. Will insert a new row if no index was
   * provided, or if the index is higher than the total number of table rows.
   * A simplified version of the full `DateTable.setRow`, limited to objects.
   *
   * @param {Record<string, number|string|undefined>} row
   * Cell values to set.
   *
   * @param {number} [rowIndex]
   * Index of the row to set. Leave `undefined` to add as a new row.
   *
   * @param {boolean} [insert]
   * Whether to insert the row at the given index, or to overwrite the row.
   *
   * @param {Record<string, (boolean|number|string|null|undefined)>} [eventDetail]
   * Custom information for pending events.
   *
   * @emits #afterSetRows
   */
  setRow(row, rowIndex = this.rowCount, insert, eventDetail) {
    const { columns } = this, indexRowCount = insert ? this.rowCount + 1 : rowIndex + 1;
    objectEach13(row, (cellValue, columnName) => {
      let column2 = columns[columnName] || eventDetail?.addColumns !== false && new Array(indexRowCount);
      if (column2) {
        if (insert) {
          column2 = splice(column2, rowIndex, 0, true, [cellValue]).array;
        } else {
          column2[rowIndex] = cellValue;
        }
        columns[columnName] = column2;
      }
    });
    if (indexRowCount > this.rowCount) {
      this.applyRowCount(indexRowCount);
    }
    if (!eventDetail?.silent) {
      fireEvent11(this, "afterSetRows");
      this.versionTag = uniqueKey5();
    }
  }
};
var DataTableCore_default = DataTableCore;

// node_modules/highcharts/es-modules/Core/Legend/LegendSymbol.js
var { extend: extend16, merge: merge14, pick: pick17 } = Utilities_default;
var LegendSymbol;
(function(LegendSymbol2) {
  function areaMarker(legend, item) {
    lineMarker.call(this, legend, item, true);
  }
  LegendSymbol2.areaMarker = areaMarker;
  function lineMarker(legend, item, hasArea) {
    const legendItem = this.legendItem = this.legendItem || {}, { chart, options: options2 } = this, { baseline = 0, symbolWidth, symbolHeight } = legend, symbol = this.symbol || "circle", generalRadius = symbolHeight / 2, renderer = chart.renderer, legendItemGroup = legendItem.group, verticalCenter = baseline - Math.round((legend.fontMetrics?.b || symbolHeight) * // Render line and marker slightly higher to make room for the
    // area
    (hasArea ? 0.4 : 0.3)), attr18 = {};
    let legendSymbol, markerOptions = options2.marker, lineSizer = 0;
    if (!chart.styledMode) {
      attr18["stroke-width"] = Math.min(options2.lineWidth || 0, 24);
      if (options2.dashStyle) {
        attr18.dashstyle = options2.dashStyle;
      } else if (options2.linecap !== "square") {
        attr18["stroke-linecap"] = "round";
      }
    }
    legendItem.line = renderer.path().addClass("highcharts-graph").attr(attr18).add(legendItemGroup);
    if (hasArea) {
      legendItem.area = renderer.path().addClass("highcharts-area").add(legendItemGroup);
    }
    if (attr18["stroke-linecap"]) {
      lineSizer = Math.min(legendItem.line.strokeWidth(), symbolWidth) / 2;
    }
    if (symbolWidth) {
      const d = [
        ["M", lineSizer, verticalCenter],
        ["L", symbolWidth - lineSizer, verticalCenter]
      ];
      legendItem.line.attr({ d });
      legendItem.area?.attr({
        d: [
          ...d,
          ["L", symbolWidth - lineSizer, baseline],
          ["L", lineSizer, baseline]
        ]
      });
    }
    if (markerOptions && markerOptions.enabled !== false && symbolWidth) {
      let radius = Math.min(pick17(markerOptions.radius, generalRadius), generalRadius);
      if (symbol.indexOf("url") === 0) {
        markerOptions = merge14(markerOptions, {
          width: symbolHeight,
          height: symbolHeight
        });
        radius = 0;
      }
      legendItem.symbol = legendSymbol = renderer.symbol(symbol, symbolWidth / 2 - radius, verticalCenter - radius, 2 * radius, 2 * radius, extend16({ context: "legend" }, markerOptions)).addClass("highcharts-point").add(legendItemGroup);
      legendSymbol.isMarker = true;
    }
  }
  LegendSymbol2.lineMarker = lineMarker;
  function rectangle(legend, item) {
    const legendItem = item.legendItem || {}, options2 = legend.options, symbolHeight = legend.symbolHeight, square = options2.squareSymbol, symbolWidth = square ? symbolHeight : legend.symbolWidth;
    legendItem.symbol = this.chart.renderer.rect(
      square ? (legend.symbolWidth - symbolHeight) / 2 : 0,
      legend.baseline - symbolHeight + 1,
      // #3988
      symbolWidth,
      symbolHeight,
      pick17(legend.options.symbolRadius, symbolHeight / 2)
    ).addClass("highcharts-point").attr({
      zIndex: 3
    }).add(legendItem.group);
  }
  LegendSymbol2.rectangle = rectangle;
})(LegendSymbol || (LegendSymbol = {}));
var LegendSymbol_default = LegendSymbol;

// node_modules/highcharts/es-modules/Core/Series/SeriesDefaults.js
var seriesDefaults = {
  // Base series options
  /**
   * The SVG value used for the `stroke-linecap` and `stroke-linejoin`
   * of a line graph. Round means that lines are rounded in the ends and
   * bends.
   *
   * @type       {Highcharts.SeriesLinecapValue}
   * @default    round
   * @since      3.0.7
   * @apioption  plotOptions.line.linecap
   */
  /**
   * Pixel width of the graph line.
   *
   * @see In styled mode, the line stroke-width can be set with the
   *      `.highcharts-graph` class name.
   *
   * @sample {highcharts} highcharts/plotoptions/series-linewidth-general/
   *         On all series
   * @sample {highcharts} highcharts/plotoptions/series-linewidth-specific/
   *         On one single series
   *
   * @product highcharts highstock
   */
  lineWidth: 2,
  /**
   * For some series, there is a limit that shuts down animation
   * by default when the total number of points in the chart is too high.
   * For example, for a column chart and its derivatives, animation does
   * not run if there is more than 250 points totally. To disable this
   * cap, set `animationLimit` to `Infinity`. This option works if animation
   * is fired on individual points, not on a group of points like e.g. during
   * the initial animation.
   *
   * @sample {highcharts} highcharts/plotoptions/series-animationlimit/
   *         Animation limit on updating individual points
   *
   * @type      {number}
   * @apioption plotOptions.series.animationLimit
   */
  /**
   * Allow this series' points to be selected by clicking on the graphic
   * (columns, point markers, pie slices, map areas etc).
   *
   * The selected points can be handled by point select and unselect
   * events, or collectively by the [getSelectedPoints
   * ](/class-reference/Highcharts.Chart#getSelectedPoints) function.
   *
   * And alternative way of selecting points is through dragging.
   *
   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/
   *         Line
   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/
   *         Column
   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/
   *         Pie
   * @sample {highcharts} highcharts/chart/events-selection-points/
   *         Select a range of points through a drag selection
   * @sample {highmaps} maps/plotoptions/series-allowpointselect/
   *         Map area
   * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
   *         Map bubble
   *
   * @since 1.2.0
   *
   * @private
   */
  allowPointSelect: false,
  /**
   * When true, each point or column edge is rounded to its nearest pixel
   * in order to render sharp on screen. In some cases, when there are a
   * lot of densely packed columns, this leads to visible difference
   * in column widths or distance between columns. In these cases,
   * setting `crisp` to `false` may look better, even though each column
   * is rendered blurry.
   *
   * @sample {highcharts} highcharts/plotoptions/column-crisp-false/
   *         Crisp is false
   *
   * @since   5.0.10
   * @product highcharts highstock gantt
   *
   * @private
   */
  crisp: true,
  /**
   * If true, a checkbox is displayed next to the legend item to allow
   * selecting the series. The state of the checkbox is determined by
   * the `selected` option.
   *
   * @productdesc {highmaps}
   * Note that if a `colorAxis` is defined, the color axis is represented
   * in the legend, not the series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/
   *         Show select box
   *
   * @since 1.2.0
   *
   * @private
   */
  showCheckbox: false,
  /**
   * Enable or disable the initial animation when a series is displayed.
   * The animation can also be set as a configuration object. Please
   * note that this option only applies to the initial animation of the
   * series itself. For other animations, see [chart.animation](
   * #chart.animation) and the animation parameter under the API methods.
   * The following properties are supported:
   *
   * - `defer`: The animation delay time in milliseconds.
   *
   * - `duration`: The duration of the animation in milliseconds. (Defaults to
   *   `1000`)
   *
   * - `easing`: Can be a string reference to an easing function set on
   *   the `Math` object or a function. See the _Custom easing function_
   *   demo below. (Defaults to `easeInOutSine`)
   *
   * Due to poor performance, animation is disabled in old IE browsers
   * for several chart types.
   *
   * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/
   *         Animation disabled
   * @sample {highcharts} highcharts/plotoptions/series-animation-slower/
   *         Slower animation
   * @sample {highcharts} highcharts/plotoptions/series-animation-easing/
   *         Custom easing function
   * @sample {highstock} stock/plotoptions/animation-slower/
   *         Slower animation
   * @sample {highstock} stock/plotoptions/animation-easing/
   *         Custom easing function
   * @sample {highmaps} maps/plotoptions/series-animation-true/
   *         Animation enabled on map series
   * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/
   *         Disabled on mapbubble series
   *
   * @type    {boolean|Highcharts.AnimationOptionsObject}
   * @default {highcharts} true
   * @default {highstock} true
   * @default {highmaps} false
   *
   * @private
   */
  animation: {
    /** @ignore-option */
    duration: 1e3
  },
  /**
   * An additional class name to apply to the series' graphical elements.
   * This option does not replace default class names of the graphical
   * element. Changes to the series' color will also be reflected in a
   * chart's legend and tooltip.
   *
   * @sample {highcharts} highcharts/css/point-series-classname
   *         Series and point class name
   *
   * @type      {string}
   * @since     5.0.0
   * @apioption plotOptions.series.className
   */
  /**
   * Disable this option to allow series rendering in the whole plotting
   * area.
   *
   * **Note:** Clipping should be always enabled when
   * [chart.zoomType](#chart.zoomType) is set
   *
   * @sample {highcharts} highcharts/plotoptions/series-clip/
   *         Disabled clipping
   *
   * @default   true
   * @type      {boolean}
   * @since     3.0.0
   * @apioption plotOptions.series.clip
   */
  /**
   * The main color of the series. In line type series it applies to the
   * line and the point markers unless otherwise specified. In bar type
   * series it applies to the bars unless a color is specified per point.
   * The default value is pulled from the `options.colors` array.
   *
   * In styled mode, the color can be defined by the
   * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
   * color can be set with the `.highcharts-series`,
   * `.highcharts-color-{n}`, `.highcharts-{type}-series` or
   * `.highcharts-series-{n}` class, or individual classes given by the
   * `className` option.
   *
   * @productdesc {highmaps}
   * In maps, the series color is rarely used, as most choropleth maps use
   * the color to denote the value of each point. The series color can
   * however be used in a map with multiple series holding categorized
   * data.
   *
   * @sample {highcharts} highcharts/plotoptions/series-color-general/
   *         General plot option
   * @sample {highcharts} highcharts/plotoptions/series-color-specific/
   *         One specific series
   * @sample {highcharts} highcharts/plotoptions/series-color-area/
   *         Area color
   * @sample {highcharts} highcharts/series/infographic/
   *         Pattern fill
   * @sample {highmaps} maps/demo/category-map/
   *         Category map by multiple series
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @apioption plotOptions.series.color
   */
  /**
   * Styled mode only. A specific color index to use for the series, so its
   * graphic representations are given the class name `highcharts-color-{n}`.
   *
   * Since v11, CSS variables on the form `--highcharts-color-{n}` make
   * changing the color scheme very convenient.
   *
   * @sample    {highcharts} highcharts/css/colorindex/ Series and point color
   *            index
   *
   * @type      {number}
   * @since     5.0.0
   * @apioption plotOptions.series.colorIndex
   */
  /**
   * Whether to connect a graph line across null points, or render a gap
   * between the two points on either side of the null.
   *
   * In stacked area chart, if `connectNulls` is set to true,
   * null points are interpreted as 0.
   *
   * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/
   *         False by default
   * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/
   *         True
   *
   * @type      {boolean}
   * @default   false
   * @product   highcharts highstock
   * @apioption plotOptions.series.connectNulls
   */
  /**
   * You can set the cursor to "pointer" if you have click events attached
   * to the series, to signal to the user that the points and lines can
   * be clicked.
   *
   * In styled mode, the series cursor can be set with the same classes
   * as listed under [series.color](#plotOptions.series.color).
   *
   * @sample {highcharts} highcharts/plotoptions/series-cursor-line/
   *         On line graph
   * @sample {highcharts} highcharts/plotoptions/series-cursor-column/
   *         On columns
   * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/
   *         On scatter markers
   * @sample {highstock} stock/plotoptions/cursor/
   *         Pointer on a line graph
   * @sample {highmaps} maps/plotoptions/series-allowpointselect/
   *         Map area
   * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
   *         Map bubble
   *
   * @type      {string|Highcharts.CursorValue}
   * @apioption plotOptions.series.cursor
   */
  /**
   * A reserved subspace to store options and values for customized
   * functionality. Here you can add additional data for your own event
   * callbacks and formatter callbacks.
   *
   * @sample {highcharts} highcharts/point/custom/
   *         Point and series with custom data
   *
   * @type      {Highcharts.Dictionary<*>}
   * @apioption plotOptions.series.custom
   */
  /**
   * Name of the dash style to use for the graph, or for some series types
   * the outline of each shape.
   *
   * In styled mode, the
   * [stroke dash-array](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-dashstyle/)
   * can be set with the same classes as listed under
   * [series.color](#plotOptions.series.color).
   *
   * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
   *         Possible values demonstrated
   * @sample {highcharts} highcharts/plotoptions/series-dashstyle/
   *         Chart suitable for printing in black and white
   * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/
   *         Possible values demonstrated
   * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/
   *         Possible values demonstrated
   * @sample {highmaps} maps/plotoptions/series-dashstyle/
   *         Dotted borders on a map
   *
   * @type      {Highcharts.DashStyleValue}
   * @default   Solid
   * @since     2.1
   * @apioption plotOptions.series.dashStyle
   */
  /**
   * A description of the series to add to the screen reader information
   * about the series.
   *
   * @type      {string}
   * @since     5.0.0
   * @requires  modules/accessibility
   * @apioption plotOptions.series.description
   */
  /**
   * Options for the series data sorting.
   *
   * @type      {Highcharts.DataSortingOptionsObject}
   * @since     8.0.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.dataSorting
   */
  /**
   * Enable or disable data sorting for the series. Use [xAxis.reversed](
   * #xAxis.reversed) to change the sorting order.
   *
   * @sample {highcharts} highcharts/datasorting/animation/
   *         Data sorting in scatter-3d
   * @sample {highcharts} highcharts/datasorting/labels-animation/
   *         Axis labels animation
   * @sample {highcharts} highcharts/datasorting/dependent-sorting/
   *         Dependent series sorting
   * @sample {highcharts} highcharts/datasorting/independent-sorting/
   *         Independent series sorting
   *
   * @type      {boolean}
   * @since     8.0.0
   * @apioption plotOptions.series.dataSorting.enabled
   */
  /**
   * Whether to allow matching points by name in an update. If this option
   * is disabled, points will be matched by order.
   *
   * @sample {highcharts} highcharts/datasorting/match-by-name/
   *         Enabled match by name
   *
   * @type      {boolean}
   * @since     8.0.0
   * @apioption plotOptions.series.dataSorting.matchByName
   */
  /**
   * Determines what data value should be used to sort by.
   *
   * @sample {highcharts} highcharts/datasorting/sort-key/
   *         Sort key as `z` value
   *
   * @type      {string}
   * @since     8.0.0
   * @default   y
   * @apioption plotOptions.series.dataSorting.sortKey
   */
  /**
   * Enable or disable the mouse tracking for a specific series. This
   * includes point tooltips and click events on graphs and points. For
   * large datasets it improves performance.
   *
   * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/
   *         No mouse tracking
   * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/
   *         No mouse tracking
   *
   * @type      {boolean}
   * @default   true
   * @apioption plotOptions.series.enableMouseTracking
   */
  enableMouseTracking: true,
  /**
   * Whether to use the Y extremes of the total chart width or only the
   * zoomed area when zooming in on parts of the X axis. By default, the
   * Y axis adjusts to the min and max of the visible data. Cartesian
   * series only.
   *
   * @type      {boolean}
   * @default   false
   * @since     4.1.6
   * @product   highcharts highstock gantt
   * @apioption plotOptions.series.getExtremesFromAll
   */
  /**
   * Highlight only the hovered point and fade the remaining points.
   *
   * Scatter-type series require enabling the 'inactive' marker state and
   * adjusting opacity. Note that this approach could affect performance
   * with large datasets.
   *
   * @sample {highcharts} highcharts/plotoptions/series-inactiveotherpoints-enabled/
   *         Chart with inactiveOtherPoints option enabled.
   *
   * @type      {boolean}
   * @default   false
   * @apioption plotOptions.series.inactiveOtherPoints
   */
  /**
   * An array specifying which option maps to which key in the data point
   * array. This makes it convenient to work with unstructured data arrays
   * from different sources.
   *
   * @see [series.data](#series.line.data)
   *
   * @sample {highcharts|highstock} highcharts/series/data-keys/
   *         An extended data array with keys
   * @sample {highcharts|highstock} highcharts/series/data-nested-keys/
   *         Nested keys used to access object properties
   *
   * @type      {Array<string>}
   * @since     4.1.6
   * @apioption plotOptions.series.keys
   */
  /**
   * The line cap used for line ends and line joins on the graph.
   *
   * @sample highcharts/series-line/linecap/
   *         Line cap comparison
   *
   * @type       {Highcharts.SeriesLinecapValue}
   * @default    round
   * @product    highcharts highstock
   * @apioption  plotOptions.series.linecap
   */
  /**
   * The [id](#series.id) of another series to link to. Additionally,
   * the value can be ":previous" to link to the previous series. When
   * two series are linked, only the first one appears in the legend.
   * Toggling the visibility of this also toggles the linked series.
   *
   * If master series uses data sorting and linked series does not have
   * its own sorting definition, the linked series will be sorted in the
   * same order as the master one.
   *
   * @sample {highcharts|highstock} highcharts/demo/arearange-line/
   *         Linked series
   *
   * @type      {string}
   * @since     3.0
   * @product   highcharts highstock gantt
   * @apioption plotOptions.series.linkedTo
   */
  /**
   * Options for the corresponding navigator series if `showInNavigator`
   * is `true` for this series. Available options are the same as any
   * series, documented at [plotOptions](#plotOptions.series) and
   * [series](#series).
   *
   * These options are merged with options in [navigator.series](
   * #navigator.series), and will take precedence if the same option is
   * defined both places.
   *
   * @see [navigator.series](#navigator.series)
   *
   * @type      {Highcharts.PlotSeriesOptions}
   * @since     5.0.0
   * @product   highstock
   * @apioption plotOptions.series.navigatorOptions
   */
  /**
   * The color for the parts of the graph or points that are below the
   * [threshold](#plotOptions.series.threshold). Note that `zones` takes
   * precedence over the negative color. Using `negativeColor` is
   * equivalent to applying a zone with value of 0.
   *
   * @see In styled mode, a negative color is applied by setting this option
   *      to `true` combined with the `.highcharts-negative` class name.
   *
   * @sample {highcharts} highcharts/plotoptions/series-negative-color/
   *         Spline, area and column
   * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/
   *         Arearange
   * @sample {highcharts} highcharts/css/series-negative-color/
   *         Styled mode
   * @sample {highstock} highcharts/plotoptions/series-negative-color/
   *         Spline, area and column
   * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/
   *         Arearange
   * @sample {highmaps} highcharts/plotoptions/series-negative-color/
   *         Spline, area and column
   * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/
   *         Arearange
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     3.0
   * @apioption plotOptions.series.negativeColor
   */
  /**
   * Whether or not data-points with the value of `null` should be interactive.
   * When this is set to `true`, tooltips may highlight these points, and this
   * option also enables keyboard navigation for such points. Format options
   * for such points include [`nullFormat`](#tooltip.nullFormat) and [`nullFormater`](#tooltip.nullFormatter).
   * Works for these series: `line`, `spline`, `area`, `area-spline`,
   * `column`, `bar`, and* `timeline`.
   *
   * @sample {highcharts} highcharts/series/null-interaction/
   *         Chart with interactive `null` points
   *
   * @sample {highcharts} highcharts/series-timeline/null-interaction/
   *         Timeline series with `null` points
   *
   * @type      {boolean|undefined}
   * @product   highcharts highstock
   * @apioption plotOptions.series.nullInteraction
   */
  /**
   * Same as
   * [accessibility.point.descriptionFormat](#accessibility.point.descriptionFormat),
   * but for an individual series. Overrides the chart wide configuration.
   *
   * @type      {Function}
   * @since 11.1.0
   * @apioption plotOptions.series.pointDescriptionFormat
   */
  /**
   * Same as
   * [accessibility.series.descriptionFormatter](#accessibility.series.descriptionFormatter),
   * but for an individual series. Overrides the chart wide configuration.
   *
   * @type      {Function}
   * @since     5.0.12
   * @apioption plotOptions.series.pointDescriptionFormatter
   */
  /**
   * If no x values are given for the points in a series, `pointInterval`
   * defines the interval of the x values. For example, if a series
   * contains one value every decade starting from year 0, set
   * `pointInterval` to `10`. In true `datetime` axes, the `pointInterval`
   * is set in milliseconds.
   *
   * It can be also be combined with `pointIntervalUnit` to draw irregular
   * time intervals.
   *
   * If combined with `relativeXValue`, an x value can be set on each
   * point, and the `pointInterval` is added x times to the `pointStart`
   * setting.
   *
   * Please note that this options applies to the _series data_, not the
   * interval of the axis ticks, which is independent.
   *
   * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
   *         Datetime X axis
   * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
   *         Relative x value
   * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
   *         Using pointStart and pointInterval
   * @sample {highstock} stock/plotoptions/relativexvalue/
   *         Relative x value
   *
   * @type      {number}
   * @default   1
   * @product   highcharts highstock gantt
   * @apioption plotOptions.series.pointInterval
   */
  /**
   * On datetime series, this allows for setting the
   * [pointInterval](#plotOptions.series.pointInterval) to irregular time
   * units, `day`, `month` and `year`. A day is usually the same as 24
   * hours, but `pointIntervalUnit` also takes the DST crossover into
   * consideration when dealing with local time. Combine this option with
   * `pointInterval` to draw weeks, quarters, 6 months, 10 years etc.
   *
   * Please note that this options applies to the _series data_, not the
   * interval of the axis ticks, which is independent.
   *
   * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/
   *         One point a month
   * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/
   *         One point a month
   *
   * @type       {string}
   * @since      4.1.0
   * @product    highcharts highstock gantt
   * @validvalue ["day", "month", "year"]
   * @apioption  plotOptions.series.pointIntervalUnit
   */
  /**
   * Possible values: `"on"`, `"between"`, `number`.
   *
   * In a column chart, when pointPlacement is `"on"`, the point will not
   * create any padding of the X axis. In a polar column chart this means
   * that the first column points directly north. If the pointPlacement is
   * `"between"`, the columns will be laid out between ticks. This is
   * useful for example for visualising an amount between two points in
   * time or in a certain sector of a polar chart.
   *
   * Since Highcharts 3.0.2, the point placement can also be numeric,
   * where 0 is on the axis value, -0.5 is between this value and the
   * previous, and 0.5 is between this value and the next. Unlike the
   * textual options, numeric point placement options won't affect axis
   * padding.
   *
   * Note that pointPlacement needs a [pointRange](
   * #plotOptions.series.pointRange) to work. For column series this is
   * computed, but for line-type series it needs to be set.
   *
   * For the `xrange` series type and gantt charts, if the Y axis is a
   * category axis, the `pointPlacement` applies to the Y axis rather than
   * the (typically datetime) X axis.
   *
   * Defaults to `undefined` in cartesian charts, `"between"` in polar
   * charts.
   *
   * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)
   *
   * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-between/
   *         Between in a column chart
   * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-numeric/
   *         Numeric placement for custom layout
   * @sample {highcharts|highstock} maps/plotoptions/heatmap-pointplacement/
   *         Placement in heatmap
   *
   * @type      {string|number}
   * @since     2.3.0
   * @product   highcharts highstock gantt
   * @apioption plotOptions.series.pointPlacement
   */
  /**
   * If no x values are given for the points in a series, `pointStart`
   * defines on what value to start. For example, if a series contains one
   * yearly value starting from 1945, set `pointStart` to 1945.
   *
   * The `pointStart` setting can be a number, or a datetime string that is
   * parsed according to the `time.timezone` setting.
   *
   * If combined with `relativeXValue`, an x value can be set on each
   * point. The x value from the point options is multiplied by
   * `pointInterval` and added to `pointStart` to produce a modified x
   * value.
   *
   * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/
   *         Linear
   * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
   *         Datetime
   * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
   *         Relative x value
   * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
   *         Using pointStart and pointInterval
   * @sample {highstock} stock/plotoptions/relativexvalue/
   *         Relative x value
   *
   * @type      {number|string}
   * @default   0
   * @product   highcharts highstock gantt
   * @apioption plotOptions.series.pointStart
   */
  /**
   * When true, X values in the data set are relative to the current
   * `pointStart`, `pointInterval` and `pointIntervalUnit` settings. This
   * allows compression of the data for datasets with irregular X values.
   *
   * The real X values are computed on the formula `f(x) = ax + b`, where
   * `a` is the `pointInterval` (optionally with a time unit given by
   * `pointIntervalUnit`), and `b` is the `pointStart`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
   *         Relative X value
   * @sample {highstock} stock/plotoptions/relativexvalue/
   *         Relative X value
   *
   * @type      {boolean}
   * @default   false
   * @product   highcharts highstock
   * @apioption plotOptions.series.relativeXValue
   */
  /**
   * Whether to select the series initially. If `showCheckbox` is true,
   * the checkbox next to the series name in the legend will be checked
   * for a selected series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-selected/
   *         One out of two series selected
   *
   * @type      {boolean}
   * @default   false
   * @since     1.2.0
   * @apioption plotOptions.series.selected
   */
  /**
   * Whether to apply a drop shadow to the graph line. Since 2.3 the
   * shadow can be an object configuration containing `color`, `offsetX`,
   * `offsetY`, `opacity` and `width`.
   *
   * Note that in some cases, like stacked columns or other dense layouts, the
   * series may cast shadows on each other. In that case, the
   * `chart.seriesGroupShadow` allows applying a common drop shadow to the
   * whole series group.
   *
   * @sample {highcharts} highcharts/plotoptions/series-shadow/
   *         Shadow enabled
   *
   * @type      {boolean|Highcharts.ShadowOptionsObject}
   * @default   false
   * @apioption plotOptions.series.shadow
   */
  /**
   * Whether to display this particular series or series type in the
   * legend. Standalone series are shown in legend by default, and linked
   * series are not. Since v7.2.0 it is possible to show series that use
   * colorAxis by setting this option to `true`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
   *         One series in the legend, one hidden
   *
   * @type      {boolean}
   * @apioption plotOptions.series.showInLegend
   */
  /**
   * Whether or not to show the series in the navigator. Takes precedence
   * over [navigator.baseSeries](#navigator.baseSeries) if defined.
   *
   * @type      {boolean}
   * @since     5.0.0
   * @product   highstock
   * @apioption plotOptions.series.showInNavigator
   */
  /**
   * If set to `true`, the accessibility module will skip past the points
   * in this series for keyboard navigation.
   *
   * @type      {boolean}
   * @since     5.0.12
   * @apioption plotOptions.series.skipKeyboardNavigation
   */
  /**
   * Whether to stack the values of each series on top of each other.
   * Possible values are `undefined` to disable, `"normal"` to stack by
   * value or `"percent"`.
   *
   * When stacking is enabled, data must be sorted
   * in ascending X order.
   *
   * Some stacking options are related to specific series types. In the
   * streamgraph series type, the stacking option is set to `"stream"`.
   * The second one is `"overlap"`, which only applies to waterfall
   * series.
   *
   * @see [yAxis.reversedStacks](#yAxis.reversedStacks)
   *
   * @sample {highcharts} highcharts/plotoptions/series-stacking-line/
   *         Line
   * @sample {highcharts} highcharts/plotoptions/series-stacking-column/
   *         Column
   * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/
   *         Bar
   * @sample {highcharts} highcharts/plotoptions/series-stacking-area/
   *         Area
   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/
   *         Line
   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/
   *         Column
   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/
   *         Bar
   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/
   *         Area
   * @sample {highcharts} highcharts/plotoptions/series-waterfall-with-normal-stacking
   *         Waterfall with normal stacking
   * @sample {highcharts} highcharts/plotoptions/series-waterfall-with-overlap-stacking
   *         Waterfall with overlap stacking
   * @sample {highstock} stock/plotoptions/stacking/
   *         Area
   *
   * @type       {string}
   * @product    highcharts highstock
   * @validvalue ["normal", "overlap", "percent", "stream"]
   * @apioption  plotOptions.series.stacking
   */
  /**
   * Whether to apply steps to the line. Possible values are `left`,
   * `center` and `right`.
   *
   * @sample {highcharts} highcharts/plotoptions/line-step/
   *         Different step line options
   * @sample {highcharts} highcharts/plotoptions/area-step/
   *         Stepped, stacked area
   * @sample {highstock} stock/plotoptions/line-step/
   *         Step line
   *
   * @type       {string}
   * @since      1.2.5
   * @product    highcharts highstock
   * @validvalue ["left", "center", "right"]
   * @apioption  plotOptions.series.step
   */
  /**
   * The threshold, also called zero level or base level. For line type
   * series this is only used in conjunction with
   * [negativeColor](#plotOptions.series.negativeColor).
   *
   * @see [softThreshold](#plotOptions.series.softThreshold).
   *
   * @type      {number|null}
   * @default   0
   * @since     3.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.threshold
   */
  /**
   * Set the initial visibility of the series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-visible/
   *         Two series, one hidden and one visible
   * @sample {highstock} stock/plotoptions/series-visibility/
   *         Hidden series
   *
   * @type      {boolean}
   * @default   true
   * @apioption plotOptions.series.visible
   */
  /**
   * Defines the Axis on which the zones are applied.
   *
   * @see [zones](#plotOptions.series.zones)
   *
   * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/
   *         Zones on the X-Axis
   * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/
   *         Zones on the X-Axis
   *
   * @type      {string}
   * @default   y
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zoneAxis
   */
  /**
   * General event handlers for the series items. These event hooks can
   * also be attached to the series at run time using the
   * `Highcharts.addEvent` function.
   *
   * @declare Highcharts.SeriesEventsOptionsObject
   *
   * @private
   */
  events: {},
  /**
   * Fires after the series has finished its initial animation, or in case
   * animation is disabled, immediately as the series is displayed.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-afteranimate/
   *         Show label after animate
   * @sample {highstock} highcharts/plotoptions/series-events-afteranimate/
   *         Show label after animate
   *
   * @type      {Highcharts.SeriesAfterAnimateCallbackFunction}
   * @since     4.0
   * @product   highcharts highstock gantt
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.afterAnimate
   */
  /**
   * Fires when the checkbox next to the series' name in the legend is
   * clicked. One parameter, `event`, is passed to the function. The state
   * of the checkbox is found by `event.checked`. The checked item is
   * found by `event.item`. Return `false` to prevent the default action
   * which is to toggle the select state of the series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
   *         Alert checkbox status
   *
   * @type      {Highcharts.SeriesCheckboxClickCallbackFunction}
   * @since     1.2.0
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.checkboxClick
   */
  /**
   * Fires when the series is clicked. One parameter, `event`, is passed
   * to the function, containing common event information. Additionally,
   * `event.point` holds a pointer to the nearest point on the graph.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-click/
   *         Alert click info
   * @sample {highstock} stock/plotoptions/series-events-click/
   *         Alert click info
   * @sample {highmaps} maps/plotoptions/series-events-click/
   *         Display click info in subtitle
   *
   * @type      {Highcharts.SeriesClickCallbackFunction}
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.click
   */
  /**
   * Fires when the series is hidden after chart generation time, either
   * by clicking the legend item or by calling `.hide()`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-hide/
   *         Alert when the series is hidden by clicking the legend item
   *
   * @type      {Highcharts.SeriesHideCallbackFunction}
   * @since     1.2.0
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.hide
   */
  /**
   * Fires when the legend item belonging to the series is clicked. One
   * parameter, `event`, is passed to the function. The default action
   * is to toggle the visibility of the series. This can be prevented
   * by returning `false` or calling `event.preventDefault()`.
   *
   * **Note:** This option is deprecated in favor of
   * [legend.events.itemClick](#legend.events.itemClick).
   *
   * @type       {Highcharts.SeriesLegendItemClickCallbackFunction}
   * @deprecated 11.4.4
   * @context    Highcharts.Series
   * @apioption  plotOptions.series.events.legendItemClick
   */
  /**
   * Fires when the mouse leaves the graph. One parameter, `event`, is
   * passed to the function, containing common event information. If the
   * [stickyTracking](#plotOptions.series) option is true, `mouseOut`
   * doesn't happen before the mouse enters another graph or leaves the
   * plot area.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
   *         With sticky tracking by default
   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
   *         Without sticky tracking
   *
   * @type      {Highcharts.SeriesMouseOutCallbackFunction}
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.mouseOut
   */
  /**
   * Fires when the mouse enters the graph. One parameter, `event`, is
   * passed to the function, containing common event information.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
   *         With sticky tracking by default
   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
   *         Without sticky tracking
   *
   * @type      {Highcharts.SeriesMouseOverCallbackFunction}
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.mouseOver
   */
  /**
   * Fires when the series is shown after chart generation time, either
   * by clicking the legend item or by calling `.show()`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-show/
   *         Alert when the series is shown by clicking the legend item.
   *
   * @type      {Highcharts.SeriesShowCallbackFunction}
   * @since     1.2.0
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.show
   */
  /**
   * Options for the point markers of line and scatter-like series. Properties
   * like `fillColor`, `lineColor` and `lineWidth` define the visual
   * appearance of the markers. The `symbol` option defines the shape. Other
   * series types, like column series, don't have markers, but have visual
   * options on the series level instead.
   *
   * In styled mode, the markers can be styled with the `.highcharts-point`,
   * `.highcharts-point-hover` and `.highcharts-point-select` class names.
   *
   * @declare Highcharts.PointMarkerOptionsObject
   *
   * @sample {highmaps} maps/demo/mappoint-mapmarker
   *         Using the mapmarker symbol for points
   *
   * @private
   */
  marker: {
    /**
     * Enable or disable the point marker. If `undefined`, the markers
     * are hidden when the data is dense, and shown for more widespread
     * data points.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-enabled/
     *         Disabled markers
     * @sample {highcharts} highcharts/plotoptions/series-marker-enabled-false/
     *         Disabled in normal state but enabled on hover
     * @sample {highstock} stock/plotoptions/series-marker/
     *         Enabled markers
     *
     * @type      {boolean}
     * @default   {highcharts} undefined
     * @default   {highstock} false
     * @apioption plotOptions.series.marker.enabled
     */
    /**
     * The threshold for how dense the point markers should be before
     * they are hidden, given that `enabled` is not defined. The number
     * indicates the horizontal distance between the two closest points
     * in the series, as multiples of the `marker.radius`. In other
     * words, the default value of 2 means points are hidden if
     * overlapping horizontally.
     *
     * @sample highcharts/plotoptions/series-marker-enabledthreshold
     *         A higher threshold
     *
     * @since 6.0.5
     */
    enabledThreshold: 2,
    /**
     * The fill color of the point marker. When `undefined`, the series'
     * or point's color is used.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
     *         White fill
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @apioption plotOptions.series.marker.fillColor
     */
    /**
     * Image markers only. Set the image width explicitly. When using
     * this option, a `width` must also be set.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
     *         Fixed width and height
     * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
     *         Fixed width and height
     *
     * @type      {number}
     * @since     4.0.4
     * @apioption plotOptions.series.marker.height
     */
    /**
     * The color of the point marker's outline. When `undefined`, the
     * series' or point's color is used.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
     *         Inherit from series color (undefined)
     *
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    lineColor: "#ffffff",
    /**
     * The width of the point marker's outline.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
     *         2px blue marker
     */
    lineWidth: 0,
    /**
     * The radius of the point marker.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-radius/
     *         Bigger markers
     *
     * @default {highstock} 2
     * @default {highcharts} 4
     *
     */
    radius: 4,
    /**
     * A predefined shape or symbol for the marker. When undefined, the
     * symbol is pulled from options.symbols. Other possible values are
     * `'circle'`, `'square'`,`'diamond'`, `'triangle'` and
     * `'triangle-down'`.
     *
     * Additionally, the URL to a graphic can be given on this form:
     * `'url(graphic.png)'`. Note that for the image to be applied to
     * exported charts, its URL needs to be accessible by the export
     * server.
     *
     * Custom callbacks for symbol path generation can also be added to
     * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
     * used by its method name, as shown in the demo.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
     *         Predefined, graphic and custom markers
     * @sample {highstock} highcharts/plotoptions/series-marker-symbol/
     *         Predefined, graphic and custom markers
     * @sample {highmaps} maps/demo/mappoint-mapmarker
     *         Using the mapmarker symbol for points
     *
     * @type      {string}
     * @apioption plotOptions.series.marker.symbol
     */
    /**
     * Image markers only. Set the image width explicitly. When using
     * this option, a `height` must also be set.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
     *         Fixed width and height
     * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
     *         Fixed width and height
     *
     * @type      {number}
     * @since     4.0.4
     * @apioption plotOptions.series.marker.width
     */
    /**
     * States for a single point marker.
     *
     * @declare Highcharts.PointStatesOptionsObject
     */
    states: {
      /**
       * The normal state of a single point marker. Currently only
       * used for setting animation when returning to normal state
       * from hover.
       *
       * @declare Highcharts.PointStatesNormalOptionsObject
       */
      normal: {
        /**
         * Animation when returning to normal state after hovering.
         *
         * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
         */
        animation: true
      },
      /**
       * The hover state for a single point marker.
       *
       * @declare Highcharts.PointStatesHoverOptionsObject
       */
      hover: {
        /**
         * Animation when hovering over the marker.
         *
         * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
         */
        animation: {
          /** @internal */
          duration: 150
        },
        /**
         * Enable or disable the point marker.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/
         *         Disabled hover state
         */
        enabled: true,
        /**
         * The fill color of the marker in hover state. When
         * `undefined`, the series' or point's fillColor for normal
         * state is used.
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption plotOptions.series.marker.states.hover.fillColor
         */
        /**
         * The color of the point marker's outline. When
         * `undefined`, the series' or point's lineColor for normal
         * state is used.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linecolor/
         *         White fill color, black line color
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption plotOptions.series.marker.states.hover.lineColor
         */
        /**
         * The width of the point marker's outline. When
         * `undefined`, the series' or point's lineWidth for normal
         * state is used.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linewidth/
         *         3px line width
         *
         * @type      {number}
         * @apioption plotOptions.series.marker.states.hover.lineWidth
         */
        /**
         * The radius of the point marker. In hover state, it
         * defaults to the normal state's radius + 2 as per the
         * [radiusPlus](#plotOptions.series.marker.states.hover.radiusPlus)
         * option.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-radius/
         *         10px radius
         *
         * @type      {number}
         * @apioption plotOptions.series.marker.states.hover.radius
         */
        /**
         * The number of pixels to increase the radius of the
         * hovered point.
         *
         * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
         *         5 pixels greater radius on hover
         * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
         *         5 pixels greater radius on hover
         *
         * @since 4.0.3
         */
        radiusPlus: 2,
        /**
         * The additional line width for a hovered point.
         *
         * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
         *         2 pixels wider on hover
         * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
         *         2 pixels wider on hover
         *
         * @since 4.0.3
         */
        lineWidthPlus: 1
      },
      /**
       * The appearance of the point marker when selected. In order to
       * allow a point to be selected, set the
       * `series.allowPointSelect` option to true.
       *
       * @declare Highcharts.PointStatesSelectOptionsObject
       */
      select: {
        /**
         * Enable or disable visible feedback for selection.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-enabled/
         *         Disabled select state
         *
         * @type      {boolean}
         * @default   true
         * @apioption plotOptions.series.marker.states.select.enabled
         */
        /**
         * The radius of the point marker. In hover state, it
         * defaults to the normal state's radius + 2.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-radius/
         *         10px radius for selected points
         *
         * @type      {number}
         * @apioption plotOptions.series.marker.states.select.radius
         */
        /**
         * The fill color of the point marker.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-fillcolor/
         *         Solid red discs for selected points
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        fillColor: "#cccccc",
        /**
         * The color of the point marker's outline. When
         * `undefined`, the series' or point's color is used.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linecolor/
         *         Red line color for selected points
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        lineColor: "#000000",
        /**
         * The width of the point marker's outline.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linewidth/
         *         3px line width for selected points
         */
        lineWidth: 2
      }
    }
  },
  /**
   * Properties for each single point.
   *
   * @declare Highcharts.PlotSeriesPointOptions
   *
   * @private
   */
  point: {
    /**
     * Fires when a point is clicked. One parameter, `event`, is passed
     * to the function, containing common event information.
     *
     * If the `series.allowPointSelect` option is true, the default
     * action for the point's click event is to toggle the point's
     * select state. Returning `false` cancels this action.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-click/
     *         Click marker to alert values
     * @sample {highcharts} highcharts/plotoptions/series-point-events-click-column/
     *         Click column
     * @sample {highcharts} highcharts/plotoptions/series-point-events-click-url/
     *         Go to URL
     * @sample {highmaps} maps/plotoptions/series-point-events-click/
     *         Click marker to display values
     * @sample {highmaps} maps/plotoptions/series-point-events-click-url/
     *         Go to URL
     *
     * @type      {Highcharts.PointClickCallbackFunction}
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.click
     */
    /**
     * Fires when the mouse leaves the area close to the point. One
     * parameter, `event`, is passed to the function, containing common
     * event information.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
     *         Show values in the chart's corner on mouse over
     *
     * @type      {Highcharts.PointMouseOutCallbackFunction}
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.mouseOut
     */
    /**
     * Fires when the mouse enters the area close to the point. One
     * parameter, `event`, is passed to the function, containing common
     * event information.
     *
     * Returning `false` cancels the default behavior, which is to show a
     * tooltip for the point.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
     *         Show values in the chart's corner on mouse over
     *
     * @type      {Highcharts.PointMouseOverCallbackFunction}
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.mouseOver
     */
    /**
     * Fires when the point is removed using the `.remove()` method. One
     * parameter, `event`, is passed to the function. Returning `false`
     * cancels the operation.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-remove/
     *         Remove point and confirm
     *
     * @type      {Highcharts.PointRemoveCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.remove
     */
    /**
     * Fires when the point is selected either programmatically or
     * following a click on the point. One parameter, `event`, is passed
     * to the function. Returning `false` cancels the operation.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-select/
     *         Report the last selected point
     * @sample {highmaps} maps/plotoptions/series-allowpointselect/
     *         Report select and unselect
     *
     * @type      {Highcharts.PointSelectCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.select
     */
    /**
     * Fires when the point is unselected either programmatically or
     * following a click on the point. One parameter, `event`, is passed
     * to the function.
     *  Returning `false` cancels the operation.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-unselect/
     *         Report the last unselected point
     * @sample {highmaps} maps/plotoptions/series-allowpointselect/
     *         Report select and unselect
     *
     * @type      {Highcharts.PointUnselectCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.unselect
     */
    /**
     * Fires when the point is updated programmatically through the
     * `.update()` method. One parameter, `event`, is passed to the
     * function. The new point options can be accessed through
     * `event.options`. Returning `false` cancels the operation.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-update/
     *         Confirm point updating
     *
     * @type      {Highcharts.PointUpdateCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.update
     */
    /**
     * Events for each single point.
     *
     * @declare Highcharts.PointEventsOptionsObject
     */
    events: {}
  },
  /**
   * Options for the series data labels, appearing next to each data
   * point.
   *
   * Since v6.2.0, multiple data labels can be applied to each single
   * point by defining them as an array of configs.
   *
   * In styled mode, the data labels can be styled with the
   * `.highcharts-data-label-box` and `.highcharts-data-label` class names
   * ([see example](https://www.highcharts.com/samples/highcharts/css/series-datalabels)).
   *
   * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled
   *         Data labels enabled
   * @sample {highcharts} highcharts/plotoptions/series-datalabels-multiple
   *         Multiple data labels on a bar series
   * @sample {highcharts} highcharts/css/series-datalabels
   *         Styled mode example
   * @sample {highmaps} maps/demo/color-axis
   *         Choropleth map with data labels
   * @sample {highmaps} maps/demo/mappoint-datalabels-mapmarker
   *         Using data labels as map markers
   *
   * @type    {*|Array<*>}
   * @product highcharts highstock highmaps gantt
   *
   * @private
   */
  dataLabels: {
    /**
     * Enable or disable the initial animation when a series is displayed
     * for the `dataLabels`. The animation can also be set as a
     * configuration object. Please note that this option only applies to
     * the initial animation.
     *
     * For other animations, see [chart.animation](#chart.animation) and the
     * animation parameter under the API methods. The following properties
     * are supported:
     *
     * - `defer`: The animation delay time in milliseconds.
     *
     * @sample {highcharts} highcharts/plotoptions/animation-defer/
     *          Animation defer settings
     *
     * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
     * @since     8.2.0
     * @apioption plotOptions.series.dataLabels.animation
     */
    animation: {},
    /**
     * The animation delay time in milliseconds. Set to `0` to render the
     * data labels immediately. As `undefined` inherits defer time from the
     * [series.animation.defer](#plotOptions.series.animation.defer).
     *
     * @type      {number}
     * @since     8.2.0
     * @apioption plotOptions.series.dataLabels.animation.defer
     */
    /**
     * The alignment of the data label compared to the point. If `right`,
     * the right side of the label should be touching the point. For points
     * with an extent, like columns, the alignments also dictates how to
     * align it inside the box, as given with the
     * [inside](#plotOptions.column.dataLabels.inside) option. Can be one of
     * `left`, `center` or `right`.
     *
     * @sample {highcharts}
     *         highcharts/plotoptions/series-datalabels-align-left/ Left
     *         aligned
     * @sample {highcharts}
     *         highcharts/plotoptions/bar-datalabels-align-inside-bar/ Data
     *         labels inside the bar
     *
     * @type {Highcharts.AlignValue|null}
     */
    align: "center",
    /**
     * Alignment method for data labels. If set to `plotEdges`, the labels
     * are aligned within the plot area in the direction of the y-axis. So
     * in a regular column chart, the labels are aligned vertically
     * according to the `verticalAlign` setting. In a bar chart, which is
     * inverted, the labels are aligned horizontally according to the
     * `align` setting. Applies to cartesian series only.
     *
     * @sample {highcharts} highcharts/series-bar/datalabels-alignto/
     *         Align to plot edges
     *
     * @type      {string}
     * @since 11.4.2
     * @apioption plotOptions.series.dataLabels.alignTo
     */
    /**
     * Whether to allow data labels to overlap. To make the labels less
     * sensitive for overlapping, the
     * [dataLabels.padding](#plotOptions.series.dataLabels.padding)
     * can be set to 0.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-allowoverlap-false/
     *         Don't allow overlap
     *
     * @type      {boolean}
     * @default   false
     * @since     4.1.0
     * @apioption plotOptions.series.dataLabels.allowOverlap
     */
    /**
     * The background color or gradient for the data label. Setting it to
     * `auto` will use the point's color.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     * @sample {highmaps} maps/plotoptions/series-datalabels-box/
     *         Data labels box options
     * @sample {highmaps} maps/demo/mappoint-datalabels-mapmarker
     *         Data labels as map markers
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @since     2.2.1
     * @apioption plotOptions.series.dataLabels.backgroundColor
     */
    /**
     * The border color for the data label. Setting it to `auto` will use
     * the point's color. Defaults to `undefined`.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @since     2.2.1
     * @apioption plotOptions.series.dataLabels.borderColor
     */
    /**
     * The border radius in pixels for the data label.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     * @sample {highmaps} maps/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @type      {number}
     * @default   0
     * @since     2.2.1
     * @apioption plotOptions.series.dataLabels.borderRadius
     */
    /**
     * The border width in pixels for the data label.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @type      {number}
     * @default   0
     * @since     2.2.1
     * @apioption plotOptions.series.dataLabels.borderWidth
     */
    borderWidth: 0,
    /**
     * A class name for the data label. Particularly in styled mode,
     * this can be used to give each series' or point's data label
     * unique styling. In addition to this option, a default color class
     * name is added so that we can give the labels a contrast text
     * shadow.
     *
     * @sample {highcharts} highcharts/css/data-label-contrast/
     *         Contrast text shadow
     * @sample {highcharts} highcharts/css/series-datalabels/
     *         Styling by CSS
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption plotOptions.series.dataLabels.className
     */
    /**
     * This options is deprecated.
     * Use [style.color](#plotOptions.series.dataLabels.style) instead.
     *
     * The text color for the data labels. Defaults to `undefined`. For
     * certain series types, like column or map, the data labels can be
     * drawn inside the points. In this case the data label will be
     * drawn with maximum contrast by default. Additionally, it will be
     * given a `text-outline` style with the opposite color, to further
     * increase the contrast. This can be overridden by setting the
     * `text-outline` style to `none` in the `dataLabels.style` option.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/
     *         Red data labels
     * @sample {highmaps} maps/demo/color-axis/
     *         White data labels
     *
     * @see [style.color](#plotOptions.series.dataLabels.style)
     *
     * @type       {Highcharts.ColorType}
     * @deprecated 10.3
     * @apioption  plotOptions.series.dataLabels.color
     */
    /**
     * Whether to hide data labels that are outside the plot area. By
     * default, the data label is moved inside the plot area according
     * to the
     * [overflow](#plotOptions.series.dataLabels.overflow)
     * option.
     *
     * @type      {boolean}
     * @default   true
     * @since     2.3.3
     * @apioption plotOptions.series.dataLabels.crop
     */
    /**
     * Whether to defer displaying the data labels until the initial
     * series animation has finished. Setting to `false` renders the
     * data label immediately. If set to `true` inherits the defer
     * time set in [plotOptions.series.animation](#plotOptions.series.animation).
     *
     * @since     4.0.0
     * @type      {boolean}
     * @product   highcharts highstock gantt
     */
    defer: true,
    /**
     * Enable or disable the data labels.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/
     *         Data labels enabled
     * @sample {highmaps} maps/demo/color-axis/
     *         Data labels enabled
     *
     * @type      {boolean}
     * @default   false
     * @apioption plotOptions.series.dataLabels.enabled
     */
    /**
     * A declarative filter to control of which data labels to display.
     * The declarative filter is designed for use when callback
     * functions are not available, like when the chart options require
     * a pure JSON structure or for use with graphical editors. For
     * programmatic control, use the `formatter` instead, and return
     * `undefined` to disable a single data label.
     *
     * @example
     * filter: {
     *     property: 'percentage',
     *     operator: '>',
     *     value: 4
     * }
     *
     * @sample {highcharts} highcharts/demo/pie-monochrome
     *         Data labels filtered by percentage
     *
     * @declare   Highcharts.DataLabelsFilterOptionsObject
     * @since     6.0.3
     * @apioption plotOptions.series.dataLabels.filter
     */
    /**
     * The operator to compare by. Can be one of `>`, `<`, `>=`, `<=`,
     * `==`, `===`, `!=` and `!==`.
     *
     * @type       {string}
     * @validvalue [">", "<", ">=", "<=", "==", "===", "!=", "!=="]
     * @apioption  plotOptions.series.dataLabels.filter.operator
     */
    /**
     * The point property to filter by. Point options are passed
     * directly to properties, additionally there are `y` value,
     * `percentage` and others listed under {@link Highcharts.Point}
     * members.
     *
     * @type      {string}
     * @apioption plotOptions.series.dataLabels.filter.property
     */
    /**
     * The value to compare against.
     *
     * @type      {number}
     * @apioption plotOptions.series.dataLabels.filter.value
     */
    /**
     * A
     * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
     * for the data label. Available variables are the same as for
     * `formatter`.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
     *         Add a unit
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-format-subexpression/
     *         Complex logic in the format string
     * @sample {highmaps} maps/plotoptions/series-datalabels-format/
     *         Formatted value in the data label
     *
     * @type      {string}
     * @default   y
     * @default   point.value
     * @since     3.0
     * @apioption plotOptions.series.dataLabels.format
     */
    // eslint-disable-next-line valid-jsdoc
    /**
     * Callback JavaScript function to format the data label. Note that if a
     * `format` is defined, the format takes precedence and the formatter is
     * ignored.
     *
     * @sample {highmaps} maps/plotoptions/series-datalabels-format/
     *         Formatted value
     *
     * @type {Highcharts.DataLabelsFormatterCallbackFunction}
     */
    formatter: function() {
      const { numberFormatter } = this.series.chart;
      return typeof this.y !== "number" ? "" : numberFormatter(this.y, -1);
    },
    /**
     * For points with an extent, like columns or map areas, whether to
     * align the data label inside the box or to the actual value point.
     * Defaults to `false` in most cases, `true` in stacked columns.
     *
     * @type      {boolean}
     * @since     3.0
     * @apioption plotOptions.series.dataLabels.inside
     */
    /**
     * Format for points with the value of null. Works analogously to
     * [format](#plotOptions.series.dataLabels.format). `nullFormat` can
     * be applied only to series which support displaying null points.
     * `heatmap` and `tilemap` supports `nullFormat` by default while the
     * following series requires [#series.nullInteraction] set to `true`:
     * `line`, `spline`, `area`, `area-spline`, `column`, `bar`, and
     * `timeline`. Does not work with series that don't display null
     * points, like `pie`.
     *
     * @sample {highcharts} highcharts/series/null-interaction/
     *         Line chart with null interaction
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-nullformat/
     *         Heatmap with null interaction
     *
     * @type      {boolean|string}
     * @since     7.1.0
     * @apioption plotOptions.series.dataLabels.nullFormat
     */
    /**
             * Callback JavaScript function that defines formatting for points
             * with the value of null. Works analogously to [formatter](#plotOptions.series.dataLabels.formatter).
             * `nullFormatter` can be applied only to series which support
             * displaying null points. `heatmap` and `tilemap` supports
             * `nullFormatter` by default while the following series requires [#series.nullInteraction]
             * set to `true`: `line`, `spline`, `area`, `area-spline`, `column`,
             * `bar`, and `timeline`. Does not work with series that don't display
             * null points, like `pie`.
    
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-nullformat/
             *         Format data label for null points in heat map
             *
             * @type      {Highcharts.DataLabelsFormatterCallbackFunction}
             * @since     7.1.0
             * @apioption plotOptions.series.dataLabels.nullFormatter
             */
    /**
     * How to handle data labels that flow outside the plot area. The
     * default is `"justify"`, which aligns them inside the plot area.
     * For columns and bars, this means it will be moved inside the bar.
     * To display data labels outside the plot area, set `crop` to
     * `false` and `overflow` to `"allow"`.
     *
     * @type       {Highcharts.DataLabelsOverflowValue}
     * @default    justify
     * @since      3.0.6
     * @apioption  plotOptions.series.dataLabels.overflow
     */
    /**
     * When either the `borderWidth` or the `backgroundColor` is set,
     * this is the padding within the box.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     * @sample {highmaps} maps/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @since 2.2.1
     */
    padding: 5,
    /**
     * Aligns data labels relative to points. If `center` alignment is
     * not possible, it defaults to `right`.
     *
     * @type      {Highcharts.AlignValue}
     * @default   center
     * @apioption plotOptions.series.dataLabels.position
     */
    /**
     * Text rotation in degrees. Note that due to a more complex
     * structure, backgrounds, borders and padding will be lost on a
     * rotated data label.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
     *         Vertical labels
     *
     * @type      {number}
     * @default   0
     * @apioption plotOptions.series.dataLabels.rotation
     */
    /**
     * The shadow of the box. Works best with `borderWidth` or
     * `backgroundColor`. Since 2.3 the shadow can be an object
     * configuration containing `color`, `offsetX`, `offsetY`, `opacity`
     * and `width`.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @type      {boolean|Highcharts.ShadowOptionsObject}
     * @default   false
     * @since     2.2.1
     * @apioption plotOptions.series.dataLabels.shadow
     */
    /**
     * The name of a symbol to use for the border around the label.
     * Symbols are predefined functions on the Renderer object.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-shape/
     *         A callout for annotations
     *
     * @type      {string}
     * @default   square
     * @since     4.1.2
     * @apioption plotOptions.series.dataLabels.shape
     */
    /**
     * Styles for the label. The default `color` setting is
     * `"contrast"`, which is a pseudo color that Highcharts picks up
     * and applies the maximum contrast to the underlying point item,
     * for example the bar in a bar chart.
     *
     * The `textOutline` is a pseudo property that applies an outline of
     * the given width with the given color, which by default is the
     * maximum contrast to the text. So a bright text color will result
     * in a black text outline for maximum readability on a mixed
     * background. In some cases, especially with grayscale text, the
     * text outline doesn't work well, in which cases it can be disabled
     * by setting it to `"none"`. When `useHTML` is true, the
     * `textOutline` will not be picked up. In this, case, the same
     * effect can be acheived through the `text-shadow` CSS property.
     *
     * For some series types, where each point has an extent, like for
     * example tree maps, the data label may overflow the point. There
     * are two strategies for handling overflow. By default, the text
     * will wrap to multiple lines. The other strategy is to set
     * `style.textOverflow` to `ellipsis`, which will keep the text on
     * one line plus it will break inside long words.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-style/
     *         Bold labels
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow/
     *         Long labels truncated with an ellipsis in a pie
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow-wrap/
     *         Long labels are wrapped in a pie
     * @sample {highmaps} maps/demo/color-axis/
     *         Bold labels
     *
     * @type      {Highcharts.CSSObject}
     * @since     4.1.0
     * @apioption plotOptions.series.dataLabels.style
     */
    style: {
      /** @internal */
      fontSize: "0.7em",
      /** @internal */
      fontWeight: "bold",
      /** @internal */
      color: "contrast",
      /** @internal */
      textOutline: "1px contrast"
    },
    /**
     * Options for a label text which should follow marker's shape.
     * Border and background are disabled for a label that follows a
     * path.
     *
     * **Note:** Only SVG-based renderer supports this option. Setting
     * `useHTML` to true will disable this option.
     *
     * @declare   Highcharts.DataLabelsTextPathOptionsObject
     * @since     7.1.0
     * @apioption plotOptions.series.dataLabels.textPath
     */
    /**
     * Presentation attributes for the text path.
     *
     * @type      {Highcharts.SVGAttributes}
     * @since     7.1.0
     * @apioption plotOptions.series.dataLabels.textPath.attributes
     */
    /**
     * Enable or disable `textPath` option for link's or marker's data
     * labels.
     *
     * @type      {boolean}
     * @since     7.1.0
     * @apioption plotOptions.series.dataLabels.textPath.enabled
     */
    /**
     * Whether to
     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the labels.
     *
     * @type      {boolean}
     * @default   false
     * @apioption plotOptions.series.dataLabels.useHTML
     */
    /**
     * The vertical alignment of a data label. Can be one of `top`,
     * `middle` or `bottom`. The default value depends on the data, for
     * instance in a column chart, the label is above positive values
     * and below negative values.
     *
     * @type  {Highcharts.VerticalAlignValue|null}
     * @since 2.3.3
     */
    verticalAlign: "bottom",
    /**
     * The x position offset of the label relative to the point in
     * pixels.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
     *         Vertical and positioned
     * @sample {highcharts} highcharts/plotoptions/bar-datalabels-align-inside-bar/
     *         Data labels inside the bar
     */
    x: 0,
    /**
     * The z index of the data labels. Use a `zIndex` of 6 to display it above
     * the series, or use a `zIndex` of 2 to display it behind the series.
     *
     * @type      {number}
     * @default   6
     * @since     2.3.5
     * @apioption plotOptions.series.dataLabels.zIndex
     */
    /**
     * The y position offset of the label relative to the point in
     * pixels.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
     *         Vertical and positioned
     */
    y: 0
  },
  /**
   * When the series contains less points than the crop threshold, all
   * points are drawn, even if the points fall outside the visible plot
   * area at the current zoom. The advantage of drawing all points
   * (including markers and columns), is that animation is performed on
   * updates. On the other hand, when the series contains more points than
   * the crop threshold, the series data is cropped to only contain points
   * that fall within the plot area. The advantage of cropping away
   * invisible points is to increase performance on large series.
   *
   * @since   2.2
   * @product highcharts highstock
   *
   * @private
   */
  cropThreshold: 300,
  /**
   * Opacity of a series parts: line, fill (e.g. area) and dataLabels.
   *
   * @see [states.inactive.opacity](#plotOptions.series.states.inactive.opacity)
   *
   * @since 7.1.0
   *
   * @private
   */
  opacity: 1,
  /**
   * The width of each point on the x axis. For example in a column chart
   * with one value each day, the pointRange would be 1 day (= 24 * 3600
   * * 1000 milliseconds). This is normally computed automatically, but
   * this option can be used to override the automatic value.
   *
   * @product highstock
   *
   * @private
   */
  pointRange: 0,
  /**
   * When this is true, the series will not cause the Y axis to cross
   * the zero plane (or [threshold](#plotOptions.series.threshold) option)
   * unless the data actually crosses the plane.
   *
   * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
   * 3 will make the Y axis show negative values according to the
   * `minPadding` option. If `softThreshold` is `true`, the Y axis starts
   * at 0.
   *
   * @since   4.1.9
   * @product highcharts highstock
   *
   * @private
   */
  softThreshold: true,
  /**
   * @declare Highcharts.SeriesStatesOptionsObject
   *
   * @private
   */
  states: {
    /**
     * The normal state of a series, or for point items in column, pie
     * and similar series. Currently only used for setting animation
     * when returning to normal state from hover.
     *
     * @declare Highcharts.SeriesStatesNormalOptionsObject
     */
    normal: {
      /**
       * Animation when returning to normal state after hovering.
       *
           * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
       */
      animation: true
    },
    /**
     * Options for the hovered series. These settings override the
     * normal state options when a series is moused over or touched.
     *
     * @declare Highcharts.SeriesStatesHoverOptionsObject
     */
    hover: {
      /**
       * Enable separate styles for the hovered series to visualize
       * that the user hovers either the series itself or the legend.
       *
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled/
       *         Line
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-column/
       *         Column
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-pie/
       *         Pie
       *
       * @type      {boolean}
       * @default   true
       * @since     1.2
       * @apioption plotOptions.series.states.hover.enabled
       */
      /**
       * Animation setting for hovering the graph in line-type series.
       *
       * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
       * @since   5.0.8
       * @product highcharts highstock
       */
      animation: {
        /**
         * The duration of the hover animation in milliseconds. By
         * default the hover state animates quickly in, and slowly
         * back to normal.
         *
         * @internal
         */
        duration: 150
      },
      /**
       * Pixel width of the graph line. By default this property is
       * undefined, and the `lineWidthPlus` property dictates how much
       * to increase the linewidth from normal state.
       *
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidth/
       *         5px line on hover
       *
       * @type      {number}
       * @product   highcharts highstock
       * @apioption plotOptions.series.states.hover.lineWidth
       */
      /**
       * The additional line width for the graph of a hovered series.
       *
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
       *         5 pixels wider
       * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
       *         5 pixels wider
       *
       * @since   4.0.3
       * @product highcharts highstock
       */
      lineWidthPlus: 1,
      /**
       * In Highcharts 1.0, the appearance of all markers belonging
       * to the hovered series. For settings on the hover state of the
       * individual point, see
       * [marker.states.hover](#plotOptions.series.marker.states.hover).
       *
       * @deprecated
       *
       * @extends   plotOptions.series.marker
       * @excluding states, symbol
       * @product   highcharts highstock
       */
      marker: {
        // `lineWidth: base + 1`,
        // `radius: base + 1`
      },
      /**
       * Options for the halo appearing around the hovered point in
       * line-type series as well as outside the hovered slice in pie
       * charts. By default the halo is filled by the current point or
       * series color with an opacity of 0.25\. The halo can be
       * disabled by setting the `halo` option to `null`.
       *
       * In styled mode, the halo is styled with the
       * `.highcharts-halo` class, with colors inherited from
       * `.highcharts-color-{n}`.
       *
       * @sample {highcharts} highcharts/plotoptions/halo/
       *         Halo options
       * @sample {highstock} highcharts/plotoptions/halo/
       *         Halo options
       *
       * @declare Highcharts.SeriesStatesHoverHaloOptionsObject
       * @type    {null|*}
       * @since   4.0
       * @product highcharts highstock
       */
      halo: {
        /**
         * A collection of SVG attributes to override the appearance
         * of the halo, for example `fill`, `stroke` and
         * `stroke-width`.
         *
         * @type      {Highcharts.SVGAttributes}
         * @since     4.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.states.hover.halo.attributes
         */
        /**
         * The pixel size of the halo. For point markers this is the
         * radius of the halo. For pie slices it is the width of the
         * halo outside the slice. For bubbles it defaults to 5 and
         * is the width of the halo outside the bubble.
         *
         * @since   4.0
         * @product highcharts highstock
         */
        size: 10,
        /**
         * Opacity for the halo unless a specific fill is overridden
         * using the `attributes` setting. Note that Highcharts is
         * only able to apply opacity to colors of hex or rgb(a)
         * formats.
         *
         * @since   4.0
         * @product highcharts highstock
         */
        opacity: 0.25
      }
    },
    /**
     * Specific options for point in selected states, after being
     * selected by
     * [allowPointSelect](#plotOptions.series.allowPointSelect)
     * or programmatically.
     *
     * @sample maps/plotoptions/series-allowpointselect/
     *         Allow point select demo
     *
     * @declare   Highcharts.SeriesStatesSelectOptionsObject
     * @extends   plotOptions.series.states.hover
     * @excluding brightness
     */
    select: {
      animation: {
        /** @internal */
        duration: 0
      }
    },
    /**
     * The opposite state of a hover for series.
     *
     * @sample highcharts/plotoptions/series-states-inactive-disabled
     *         Disabled inactive state
     *
     * @declare Highcharts.SeriesStatesInactiveOptionsObject
     */
    inactive: {
      /**
       * Enable or disable the inactive state for a series
       *
       * @sample highcharts/plotoptions/series-states-inactive-disabled
       *         Disabled inactive state
       *
       * @type {boolean}
       * @default true
       * @apioption plotOptions.series.states.inactive.enabled
       */
      /**
       * The animation for entering the inactive state.
       *
       * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
       */
      animation: {
        /** @internal */
        duration: 150
      },
      /**
       * Opacity of series elements (dataLabels, line, area).
       *
       * @type {number}
       */
      opacity: 0.2
    }
  },
  /**
   * Sticky tracking of mouse events. When true, the `mouseOut` event on a
   * series isn't triggered until the mouse moves over another series, or
   * out of the plot area. When false, the `mouseOut` event on a series is
   * triggered when the mouse leaves the area around the series' graph or
   * markers. This also implies the tooltip when not shared. When
   * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
   * will be hidden when moving the mouse between series. Defaults to true
   * for line and area type series, but to false for columns, pies etc.
   *
   * **Note:** The boost module will force this option because of
   * technical limitations.
   *
   * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/
   *         True by default
   * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/
   *         False
   *
   * @default {highcharts} true
   * @default {highstock} true
   * @default {highmaps} false
   * @since   2.0
   *
   * @private
   */
  stickyTracking: true,
  /**
   * A configuration object for the tooltip rendering of each single
   * series. Properties are inherited from [tooltip](#tooltip), but only
   * the following properties can be defined on a series level.
   *
   * @declare   Highcharts.SeriesTooltipOptionsObject
   * @since     2.3
   * @extends   tooltip
   * @excluding animation, backgroundColor, borderColor, borderRadius,
   *            borderWidth, className, crosshairs, enabled, fixed, formatter,
   *            headerShape, hideDelay, outside, padding, positioner,
   *            shadow, shape, shared, snap, split, stickOnContact,
   *            style, useHTML
   * @apioption plotOptions.series.tooltip
   */
  /**
   * When a series contains a `data` array that is longer than this, the
   * Series class looks for data configurations of plain numbers or arrays of
   * numbers. The first and last valid points are checked. If found, the rest
   * of the data is assumed to be the same. This saves expensive data checking
   * and indexing in long series, and makes data-heavy charts render faster.
   *
   * Set it to `0` disable.
   *
   * Note:
   * - In boost mode turbo threshold is forced. Only array of numbers or two
   *   dimensional arrays are allowed.
   * - In version 11.4.3 and earlier, if object configurations were passed
   *   beyond the turbo threshold, a warning was logged in the console and the
   *   data series didn't render.
   *
   * @since   2.2
   * @product highcharts highstock gantt
   *
   * @private
   */
  turboThreshold: 1e3,
  /**
   * An array defining zones within a series. Zones can be applied to the
   * X axis, Y axis or Z axis for bubbles, according to the `zoneAxis`
   * option. The zone definitions have to be in ascending order regarding
   * to the value.
   *
   * In styled mode, the color zones are styled with the
   * `.highcharts-zone-{n}` class, or custom classed from the `className`
   * option
   * ([view live demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/color-zones/)).
   *
   * @see [zoneAxis](#plotOptions.series.zoneAxis)
   *
   * @sample {highcharts} highcharts/series/color-zones-simple/
   *         Color zones
   * @sample {highstock} highcharts/series/color-zones-simple/
   *         Color zones
   *
   * @declare   Highcharts.SeriesZonesOptionsObject
   * @type      {Array<*>}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones
   */
  /**
   * Styled mode only. A custom class name for the zone.
   *
   * @sample highcharts/css/color-zones/
   *         Zones styled by class name
   *
   * @type      {string}
   * @since     5.0.0
   * @apioption plotOptions.series.zones.className
   */
  /**
   * Defines the color of the series.
   *
   * @see [series color](#plotOptions.series.color)
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones.color
   */
  /**
   * A name for the dash style to use for the graph.
   *
   * @see [plotOptions.series.dashStyle](#plotOptions.series.dashStyle)
   *
   * @sample {highcharts|highstock} highcharts/series/color-zones-dashstyle-dot/
   *         Dashed line indicates prognosis
   *
   * @type      {Highcharts.DashStyleValue}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones.dashStyle
   */
  /**
   * Defines the fill color for the series (in area type series)
   *
   * @see [fillColor](#plotOptions.area.fillColor)
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones.fillColor
   */
  /**
   * The value up to where the zone extends, if undefined the zones
   * stretches to the last value in the series.
   *
   * @type      {number}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones.value
   */
  /**
   * When using dual or multiple color axes, this number defines which
   * colorAxis the particular series is connected to. It refers to
   * either the
   * {@link #colorAxis.id|axis id}
   * or the index of the axis in the colorAxis array, with 0 being the
   * first. Set this option to false to prevent a series from connecting
   * to the default color axis.
   *
   * Since v7.2.0 the option can also be an axis id or an axis index
   * instead of a boolean flag.
   *
   * @sample highcharts/coloraxis/coloraxis-with-pie/
   *         Color axis with pie series
   * @sample highcharts/coloraxis/multiple-coloraxis/
   *         Multiple color axis
   *
   * @type      {number|string|boolean}
   * @default   0
   * @product   highcharts highstock highmaps
   * @apioption plotOptions.series.colorAxis
   */
  /**
   * Determines what data value should be used to calculate point color
   * if `colorAxis` is used. Requires to set `min` and `max` if some
   * custom point property is used or if approximation for data grouping
   * is set to `'sum'`.
   *
   * @sample highcharts/coloraxis/custom-color-key/
   *         Custom color key
   * @sample highcharts/coloraxis/color-key-with-stops/
   *         Custom colorKey with color axis stops
   * @sample highcharts/coloraxis/changed-default-color-key/
   *         Changed default color key
   *
   * @type      {string}
   * @default   y
   * @since     7.2.0
   * @product   highcharts highstock highmaps
   * @apioption plotOptions.series.colorKey
   */
  /**
   * What type of legend symbol to render for this series. Can be one of
   * `areaMarker`, `lineMarker` or `rectangle`.
   *
   * @validvalue ["areaMarker", "lineMarker", "rectangle"]
   *
   * @sample {highcharts} highcharts/series/legend-symbol/
   *         Change the legend symbol
   *
   * @type      {string}
   * @default   rectangle
   * @since     11.0.1
   * @apioption plotOptions.series.legendSymbol
   */
  /**
   * Defines the color of the legend symbol for this series. Defaults to
   * undefined, in which case the series color is used. Does not work with
   * styled mode.
   *
   * @sample {highcharts|highstock} highcharts/series/legend-symbol-color/
   *         Change the legend symbol color
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default   undefined
   * @since 12.0.0
   * @product   highcharts highstock highmaps
   * @apioption plotOptions.series.legendSymbolColor
   */
  /**
   * Determines whether the series should look for the nearest point
   * in both dimensions or just the x-dimension when hovering the series.
   * Defaults to `'xy'` for scatter series and `'x'` for most other
   * series. If the data has duplicate x-values, it is recommended to
   * set this to `'xy'` to allow hovering over all points.
   *
   * Applies only to series types using nearest neighbor search (not
   * direct hover) for tooltip.
   *
   * @sample {highcharts} highcharts/series/findnearestpointby/
   *         Different hover behaviors
   * @sample {highstock} highcharts/series/findnearestpointby/
   *         Different hover behaviors
   * @sample {highmaps} highcharts/series/findnearestpointby/
   *         Different hover behaviors
   *
   * @since      5.0.10
   * @validvalue ["x", "xy"]
   *
   * @private
   */
  findNearestPointBy: "x"
};
var SeriesDefaults_default = seriesDefaults;

// node_modules/highcharts/es-modules/Core/Series/SeriesRegistry.js
var { defaultOptions: defaultOptions6 } = Defaults_default;
var { extend: extend17, extendClass: extendClass2, merge: merge15 } = Utilities_default;
var SeriesRegistry;
(function(SeriesRegistry2) {
  SeriesRegistry2.seriesTypes = Globals_default.seriesTypes;
  function registerSeriesType(seriesType2, SeriesClass) {
    const defaultPlotOptions = defaultOptions6.plotOptions || {}, seriesOptions = SeriesClass.defaultOptions, seriesProto7 = SeriesClass.prototype;
    seriesProto7.type = seriesType2;
    if (!seriesProto7.pointClass) {
      seriesProto7.pointClass = Point_default;
    }
    if (SeriesRegistry2.seriesTypes[seriesType2]) {
      return false;
    }
    if (seriesOptions) {
      defaultPlotOptions[seriesType2] = seriesOptions;
    }
    SeriesRegistry2.seriesTypes[seriesType2] = SeriesClass;
    return true;
  }
  SeriesRegistry2.registerSeriesType = registerSeriesType;
  function seriesType(type, parent, options2, seriesProto7, pointProto2) {
    const defaultPlotOptions = defaultOptions6.plotOptions || {};
    parent = parent || "";
    defaultPlotOptions[type] = merge15(defaultPlotOptions[parent], options2);
    delete SeriesRegistry2.seriesTypes[type];
    registerSeriesType(type, extendClass2(SeriesRegistry2.seriesTypes[parent] || function() {
    }, seriesProto7));
    SeriesRegistry2.seriesTypes[type].prototype.type = type;
    if (pointProto2) {
      class PointClass extends Point_default {
      }
      extend17(PointClass.prototype, pointProto2);
      SeriesRegistry2.seriesTypes[type].prototype.pointClass = PointClass;
    }
    return SeriesRegistry2.seriesTypes[type];
  }
  SeriesRegistry2.seriesType = seriesType;
})(SeriesRegistry || (SeriesRegistry = {}));
var SeriesRegistry_default = SeriesRegistry;

// node_modules/highcharts/es-modules/Core/Series/Series.js
var { animObject: animObject6, setAnimation: setAnimation2 } = AnimationUtilities_default;
var { defaultOptions: defaultOptions7 } = Defaults_default;
var { registerEventOptions: registerEventOptions2 } = Foundation_default;
var { svg: svg2, win: win9 } = Globals_default;
var { seriesTypes } = SeriesRegistry_default;
var { format: format4 } = Templating_default;
var { arrayMax: arrayMax4, arrayMin: arrayMin4, clamp: clamp6, correctFloat: correctFloat4, crisp: crisp5, defined: defined14, destroyObjectProperties: destroyObjectProperties6, diffObjects: diffObjects2, erase: erase7, error: error5, extend: extend18, find: find3, fireEvent: fireEvent12, getClosestDistance: getClosestDistance3, getNestedProperty: getNestedProperty4, insertItem: insertItem3, isArray: isArray9, isNumber: isNumber18, isString: isString11, merge: merge16, objectEach: objectEach14, pick: pick18, removeEvent: removeEvent6, syncTimeout: syncTimeout6 } = Utilities_default;
var Series = class _Series {
  constructor() {
    this.zoneAxis = "y";
  }
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  init(chart, userOptions) {
    fireEvent12(this, "init", { options: userOptions });
    this.dataTable ?? (this.dataTable = new DataTableCore_default());
    const series = this, chartSeries = chart.series;
    this.eventsToUnbind = [];
    series.chart = chart;
    series.options = series.setOptions(userOptions);
    const options2 = series.options, visible = options2.visible !== false;
    series.linkedSeries = [];
    series.bindAxes();
    extend18(series, {
      /**
       * The series name as given in the options. Defaults to
       * "Series {n}".
       *
       * @name Highcharts.Series#name
       * @type {string}
       */
      name: options2.name,
      state: "",
      /**
       * Read only. The series' visibility state as set by {@link
       * Series#show}, {@link Series#hide}, or in the initial
       * configuration.
       *
       * @name Highcharts.Series#visible
       * @type {boolean}
       */
      visible,
      // True by default
      /**
       * Read only. The series' selected state as set by {@link
       * Highcharts.Series#select}.
       *
       * @name Highcharts.Series#selected
       * @type {boolean}
       */
      selected: options2.selected === true
      // False by default
    });
    registerEventOptions2(this, options2);
    const events = options2.events;
    if (events?.click || options2.point?.events?.click || options2.allowPointSelect) {
      chart.runTrackerClick = true;
    }
    series.getColor();
    series.getSymbol();
    if (series.isCartesian) {
      chart.hasCartesianSeries = true;
    }
    let lastSeries;
    if (chartSeries.length) {
      lastSeries = chartSeries[chartSeries.length - 1];
    }
    series._i = pick18(lastSeries?._i, -1) + 1;
    series.opacity = series.options.opacity;
    chart.orderItems("series", insertItem3(this, chartSeries));
    if (options2.dataSorting?.enabled) {
      series.setDataSortingOptions();
    } else if (!series.points && !series.data) {
      series.setData(options2.data, false);
    }
    fireEvent12(this, "afterInit");
  }
  /**
   * Check whether the series item is itself or inherits from a certain
   * series type.
   *
   * @function Highcharts.Series#is
   * @param {string} type The type of series to check for, can be either
   *        featured or custom series types. For example `column`, `pie`,
   *        `ohlc` etc.
   *
   * @return {boolean}
   *        True if this item is or inherits from the given type.
   */
  is(type) {
    return seriesTypes[type] && this instanceof seriesTypes[type];
  }
  /**
   * Set the xAxis and yAxis properties of cartesian series, and register
   * the series in the `axis.series` array.
   *
   * @private
   * @function Highcharts.Series#bindAxes
   */
  bindAxes() {
    const series = this, seriesOptions = series.options, chart = series.chart;
    let axisOptions;
    fireEvent12(this, "bindAxes", null, function() {
      (series.axisTypes || []).forEach(function(coll) {
        (chart[coll] || []).forEach(function(axis) {
          axisOptions = axis.options;
          if (pick18(seriesOptions[coll], 0) === axis.index || typeof seriesOptions[coll] !== "undefined" && seriesOptions[coll] === axisOptions.id) {
            insertItem3(series, axis.series);
            series[coll] = axis;
            axis.isDirty = true;
          }
        });
        if (!series[coll] && series.optionalAxis !== coll) {
          error5(18, true, chart);
        }
      });
    });
    fireEvent12(this, "afterBindAxes");
  }
  /**
   * Define hasData functions for series. These return true if there
   * are data points on this series within the plot area.
   *
   * @private
   * @function Highcharts.Series#hasData
   */
  hasData() {
    return this.visible && typeof this.dataMax !== "undefined" && typeof this.dataMin !== "undefined" || // #3703
    this.visible && this.dataTable.rowCount > 0;
  }
  /**
   * Determine whether the marker in a series has changed.
   *
   * @private
   * @function Highcharts.Series#hasMarkerChanged
   */
  hasMarkerChanged(options2, oldOptions) {
    const marker = options2.marker, oldMarker = oldOptions.marker || {};
    return marker && (oldMarker.enabled && !marker.enabled || oldMarker.symbol !== marker.symbol || // #10870, #15946
    oldMarker.height !== marker.height || // #16274
    oldMarker.width !== marker.width);
  }
  /**
   * Return an auto incremented x value based on the pointStart and
   * pointInterval options. This is only used if an x value is not given
   * for the point that calls autoIncrement.
   *
   * @private
   * @function Highcharts.Series#autoIncrement
   */
  autoIncrement(x) {
    const options2 = this.options, { pointIntervalUnit, relativeXValue } = this.options, time = this.chart.time, xIncrement = this.xIncrement ?? time.parse(options2.pointStart) ?? 0;
    let pointInterval;
    this.pointInterval = pointInterval = pick18(this.pointInterval, options2.pointInterval, 1);
    if (relativeXValue && isNumber18(x)) {
      pointInterval *= x;
    }
    if (pointIntervalUnit) {
      const d = time.toParts(xIncrement);
      if (pointIntervalUnit === "day") {
        d[2] += pointInterval;
      } else if (pointIntervalUnit === "month") {
        d[1] += pointInterval;
      } else if (pointIntervalUnit === "year") {
        d[0] += pointInterval;
      }
      pointInterval = time.makeTime.apply(time, d) - xIncrement;
    }
    if (relativeXValue && isNumber18(x)) {
      return xIncrement + pointInterval;
    }
    this.xIncrement = xIncrement + pointInterval;
    return xIncrement;
  }
  /**
   * Internal function to set properties for series if data sorting is
   * enabled.
   *
   * @private
   * @function Highcharts.Series#setDataSortingOptions
   */
  setDataSortingOptions() {
    const options2 = this.options;
    extend18(this, {
      requireSorting: false,
      sorted: false,
      enabledDataSorting: true,
      allowDG: false
    });
    if (!defined14(options2.pointRange)) {
      options2.pointRange = 1;
    }
  }
  /**
   * Set the series options by merging from the options tree. Called
   * internally on initializing and updating series. This function will
   * not redraw the series. For API usage, use {@link Series#update}.
   * @private
   * @function Highcharts.Series#setOptions
   * @param {Highcharts.SeriesOptionsType} itemOptions
   * The series options.
   * @emits Highcharts.Series#event:afterSetOptions
   */
  setOptions(itemOptions) {
    const chart = this.chart, chartOptions = chart.options, plotOptions = chartOptions.plotOptions, userOptions = chart.userOptions || {}, seriesUserOptions = merge16(itemOptions), styledMode = chart.styledMode, e = {
      plotOptions,
      userOptions: seriesUserOptions
    };
    let zone;
    fireEvent12(this, "setOptions", e);
    const typeOptions = e.plotOptions[this.type], userPlotOptions = userOptions.plotOptions || {}, userPlotOptionsSeries = userPlotOptions.series || {}, defaultPlotOptionsType = defaultOptions7.plotOptions[this.type] || {}, userPlotOptionsType = userPlotOptions[this.type] || {};
    typeOptions.dataLabels = this.mergeArrays(defaultPlotOptionsType.dataLabels, typeOptions.dataLabels);
    this.userOptions = e.userOptions;
    const options2 = merge16(
      typeOptions,
      plotOptions.series,
      // #3881, chart instance plotOptions[type] should trump
      // plotOptions.series
      userPlotOptionsType,
      seriesUserOptions
    );
    this.tooltipOptions = merge16(
      defaultOptions7.tooltip,
      // 1
      defaultOptions7.plotOptions.series?.tooltip,
      // 2
      defaultPlotOptionsType?.tooltip,
      // 3
      chart.userOptions.tooltip,
      // 4
      userPlotOptions.series?.tooltip,
      // 5
      userPlotOptionsType.tooltip,
      // 6
      seriesUserOptions.tooltip
      // 7
    );
    this.stickyTracking = pick18(seriesUserOptions.stickyTracking, userPlotOptionsType.stickyTracking, userPlotOptionsSeries.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : options2.stickyTracking);
    if (typeOptions.marker === null) {
      delete options2.marker;
    }
    this.zoneAxis = options2.zoneAxis || "y";
    const zones = this.zones = // #20440, create deep copy of zones options
    (options2.zones || []).map((z) => ({ ...z }));
    if ((options2.negativeColor || options2.negativeFillColor) && !options2.zones) {
      zone = {
        value: options2[this.zoneAxis + "Threshold"] || options2.threshold || 0,
        className: "highcharts-negative"
      };
      if (!styledMode) {
        zone.color = options2.negativeColor;
        zone.fillColor = options2.negativeFillColor;
      }
      zones.push(zone);
    }
    if (zones.length && defined14(zones[zones.length - 1].value)) {
      zones.push(styledMode ? {} : {
        color: this.color,
        fillColor: this.fillColor
      });
    }
    fireEvent12(this, "afterSetOptions", { options: options2 });
    return options2;
  }
  /**
   * Return series name in "Series {Number}" format or the one defined by
   * a user. This method can be simply overridden as series name format
   * can vary (e.g. technical indicators).
   *
   * @function Highcharts.Series#getName
   *
   * @return {string}
   * The series name.
   */
  getName() {
    return this.options.name ?? format4(this.chart.options.lang.seriesName, this, this.chart);
  }
  /**
   * @private
   * @function Highcharts.Series#getCyclic
   */
  getCyclic(prop, value, defaults) {
    const chart = this.chart, indexName = `${prop}Index`, counterName = `${prop}Counter`, len = (
      // Symbol count
      defaults?.length || // Color count
      chart.options.chart.colorCount
    );
    let i, setting;
    if (!value) {
      setting = pick18(prop === "color" ? this.options.colorIndex : void 0, this[indexName]);
      if (defined14(setting)) {
        i = setting;
      } else {
        if (!chart.series.length) {
          chart[counterName] = 0;
        }
        i = chart[counterName] % len;
        chart[counterName] += 1;
      }
      if (defaults) {
        value = defaults[i];
      }
    }
    if (typeof i !== "undefined") {
      this[indexName] = i;
    }
    this[prop] = value;
  }
  /**
   * Get the series' color based on either the options or pulled from
   * global options.
   *
   * @private
   * @function Highcharts.Series#getColor
   */
  getColor() {
    if (this.chart.styledMode) {
      this.getCyclic("color");
    } else if (this.options.colorByPoint) {
      this.color = "#cccccc";
    } else {
      this.getCyclic("color", this.options.color || defaultOptions7.plotOptions[this.type].color, this.chart.options.colors);
    }
  }
  /**
   * Get all points' instances created for this series.
   *
   * @private
   * @function Highcharts.Series#getPointsCollection
   */
  getPointsCollection() {
    return (this.hasGroupedData ? this.points : this.data) || [];
  }
  /**
   * Get the series' symbol based on either the options or pulled from
   * global options.
   *
   * @private
   * @function Highcharts.Series#getSymbol
   */
  getSymbol() {
    const seriesMarkerOption = this.options.marker;
    this.getCyclic("symbol", seriesMarkerOption.symbol, this.chart.options.symbols);
  }
  /**
   * Shorthand to get one of the series' data columns from `Series.dataTable`.
   *
   * @private
   * @function Highcharts.Series#getColumn
   */
  getColumn(columnName, modified) {
    return (modified ? this.dataTable.modified : this.dataTable).getColumn(columnName, true) || [];
  }
  /**
   * Finds the index of an existing point that matches the given point
   * options.
   *
   * @private
   * @function Highcharts.Series#findPointIndex
   * @param {Highcharts.PointOptionsObject} optionsObject
   * The options of the point.
   * @param {number} fromIndex
   * The index to start searching from, used for optimizing series with
   * required sorting.
   * @return {number|undefined}
   * Returns the index of a matching point, or undefined if no match is found.
   */
  findPointIndex(optionsObject, fromIndex) {
    const { id, x } = optionsObject, oldData = this.points, dataSorting = this.options.dataSorting, cropStart = this.cropStart || 0;
    let matchingPoint, matchedById, pointIndex;
    if (id) {
      const item = this.chart.get(id);
      if (item instanceof Point_default) {
        matchingPoint = item;
      }
    } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
      let matcher = (oldPoint) => !oldPoint.touched && oldPoint.index === optionsObject.index;
      if (dataSorting?.matchByName) {
        matcher = (oldPoint) => !oldPoint.touched && oldPoint.name === optionsObject.name;
      } else if (this.options.relativeXValue) {
        matcher = (oldPoint) => !oldPoint.touched && oldPoint.options.x === optionsObject.x;
      }
      matchingPoint = find3(oldData, matcher);
      if (!matchingPoint) {
        return void 0;
      }
    }
    if (matchingPoint) {
      pointIndex = matchingPoint?.index;
      if (typeof pointIndex !== "undefined") {
        matchedById = true;
      }
    }
    if (typeof pointIndex === "undefined" && isNumber18(x)) {
      pointIndex = this.getColumn("x").indexOf(x, fromIndex);
    }
    if (pointIndex !== -1 && typeof pointIndex !== "undefined" && this.cropped) {
      pointIndex = pointIndex >= cropStart ? pointIndex - cropStart : pointIndex;
    }
    if (!matchedById && isNumber18(pointIndex) && oldData[pointIndex]?.touched) {
      pointIndex = void 0;
    }
    return pointIndex;
  }
  /**
   * Internal function called from setData. If the point count is the same
   * as it was, or if there are overlapping X values, just run
   * Point.update which is cheaper, allows animation, and keeps references
   * to points. This also allows adding or removing points if the X-es
   * don't match.
   *
   * @private
   * @function Highcharts.Series#updateData
   */
  updateData(data, animation) {
    const { options: options2, requireSorting } = this, dataSorting = options2.dataSorting, oldData = this.points, pointsToAdd = [], equalLength = data.length === oldData.length;
    let hasUpdatedByKey, i, point, lastIndex, succeeded = true;
    this.xIncrement = null;
    data.forEach((pointOptions, i2) => {
      const optionsObject = defined14(pointOptions) && this.pointClass.prototype.optionsToObject.call({ series: this }, pointOptions) || {}, { id, x } = optionsObject;
      let pointIndex;
      if (id || isNumber18(x)) {
        pointIndex = this.findPointIndex(optionsObject, lastIndex);
        if (pointIndex === -1 || typeof pointIndex === "undefined") {
          pointsToAdd.push(pointOptions);
        } else if (oldData[pointIndex] && pointOptions !== options2.data?.[pointIndex]) {
          oldData[pointIndex].update(pointOptions, false, void 0, false);
          oldData[pointIndex].touched = true;
          if (requireSorting) {
            lastIndex = pointIndex + 1;
          }
        } else if (oldData[pointIndex]) {
          oldData[pointIndex].touched = true;
        }
        if (!equalLength || i2 !== pointIndex || dataSorting?.enabled || this.hasDerivedData) {
          hasUpdatedByKey = true;
        }
      } else {
        pointsToAdd.push(pointOptions);
      }
    }, this);
    if (hasUpdatedByKey) {
      i = oldData.length;
      while (i--) {
        point = oldData[i];
        if (point && !point.touched) {
          point.remove?.(false, animation);
        }
      }
    } else if (equalLength && !dataSorting?.enabled) {
      data.forEach((point2, i2) => {
        if (point2 !== oldData[i2].y && !oldData[i2].destroyed) {
          oldData[i2].update(point2, false, void 0, false);
        }
      });
      pointsToAdd.length = 0;
    } else {
      succeeded = false;
    }
    oldData.forEach((point2) => {
      if (point2) {
        point2.touched = false;
      }
    });
    if (!succeeded) {
      return false;
    }
    pointsToAdd.forEach((point2) => {
      this.addPoint(point2, false, void 0, void 0, false);
    }, this);
    const xData = this.getColumn("x");
    if (this.xIncrement === null && xData.length) {
      this.xIncrement = arrayMax4(xData);
      this.autoIncrement();
    }
    return true;
  }
  dataColumnKeys() {
    return ["x", ...this.pointArrayMap || ["y"]];
  }
  /**
   * Apply a new set of data to the series and optionally redraw it. The
   * new data array is passed by reference (except in case of
   * `updatePoints`), and may later be mutated when updating the chart
   * data.
   *
   * Note the difference in behaviour when setting the same amount of
   * points, or a different amount of points, as handled by the
   * `updatePoints` parameter.
   *
   * @sample highcharts/members/series-setdata/
   *         Set new data from a button
   * @sample highcharts/members/series-setdata-pie/
   *         Set data in a pie
   * @sample stock/members/series-setdata/
   *         Set new data in Highcharts Stock
   * @sample maps/members/series-setdata/
   *         Set new data in Highmaps
   *
   * @function Highcharts.Series#setData
   *
   * @param {Array<Highcharts.PointOptionsType>} data
   *        Takes an array of data in the same format as described under
   *        `series.{type}.data` for the given series type, for example a
   *        line series would take data in the form described under
   *        [series.line.data](https://api.highcharts.com/highcharts/series.line.data).
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after the series is altered. If
   *        doing more operations on the chart, it is a good idea to set
   *        redraw to false and call {@link Chart#redraw} after.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
   *        When the updated data is the same length as the existing data,
   *        points will be updated by default, and animation visualizes
   *        how the points are changed. Set false to disable animation, or
   *        a configuration object to set duration or easing.
   *
   * @param {boolean} [updatePoints=true]
   *        When this is true, points will be updated instead of replaced
   *        whenever possible. This occurs a) when the updated data is the
   *        same length as the existing data, b) when points are matched
   *        by their id's, or c) when points can be matched by X values.
   *        This allows updating with animation and performs better. In
   *        this case, the original array is not passed by reference. Set
   *        `false` to prevent.
   */
  setData(data, redraw = true, animation, updatePoints2) {
    const series = this, oldData = series.points, oldDataLength = oldData?.length || 0, options2 = series.options, chart = series.chart, dataSorting = options2.dataSorting, xAxis2 = series.xAxis, turboThreshold = options2.turboThreshold, table = this.dataTable, dataColumnKeys = this.dataColumnKeys(), pointValKey = series.pointValKey || "y", pointArrayMap = series.pointArrayMap || [], valueCount = pointArrayMap.length, keys = options2.keys;
    let i, updatedData, indexOfX = 0, indexOfY = 1, copiedData;
    if (!chart.options.chart.allowMutatingData) {
      if (options2.data) {
        delete series.options.data;
      }
      if (series.userOptions.data) {
        delete series.userOptions.data;
      }
      copiedData = merge16(true, data);
    }
    data = copiedData || data || [];
    const dataLength = data.length;
    if (dataSorting?.enabled) {
      data = this.sortData(data);
    }
    if (chart.options.chart.allowMutatingData && updatePoints2 !== false && dataLength && oldDataLength && !series.cropped && !series.hasGroupedData && series.visible && // Soft updating has no benefit in boost, and causes JS error
    // (#8355)
    !series.boosted) {
      updatedData = this.updateData(data, animation);
    }
    if (!updatedData) {
      series.xIncrement = null;
      series.colorCounter = 0;
      let runTurbo = turboThreshold && dataLength > turboThreshold;
      if (runTurbo) {
        const firstPoint = series.getFirstValidPoint(data), lastPoint = series.getFirstValidPoint(data, dataLength - 1, -1), isShortArray = (a) => Boolean(isArray9(a) && (keys || isNumber18(a[0])));
        if (isNumber18(firstPoint) && isNumber18(lastPoint)) {
          const x = [], valueData = [];
          for (const value of data) {
            x.push(this.autoIncrement());
            valueData.push(value);
          }
          table.setColumns({
            x,
            [pointValKey]: valueData
          });
        } else if (isShortArray(firstPoint) && isShortArray(lastPoint)) {
          if (valueCount) {
            const autoX = firstPoint.length === valueCount ? 1 : 0, colArray = new Array(dataColumnKeys.length).fill(0).map(() => []);
            for (const pt of data) {
              if (autoX) {
                colArray[0].push(this.autoIncrement());
              }
              for (let j = autoX; j <= valueCount; j++) {
                colArray[j]?.push(pt[j - autoX]);
              }
            }
            table.setColumns(dataColumnKeys.reduce((columns, columnName, i2) => {
              columns[columnName] = colArray[i2];
              return columns;
            }, {}));
          } else {
            if (keys) {
              indexOfX = keys.indexOf("x");
              indexOfY = keys.indexOf("y");
              indexOfX = indexOfX >= 0 ? indexOfX : 0;
              indexOfY = indexOfY >= 0 ? indexOfY : 1;
            }
            if (firstPoint.length === 1) {
              indexOfY = 0;
            }
            const xData = [], valueData = [];
            if (indexOfX === indexOfY) {
              for (const pt of data) {
                xData.push(this.autoIncrement());
                valueData.push(pt[indexOfY]);
              }
            } else {
              for (const pt of data) {
                xData.push(pt[indexOfX]);
                valueData.push(pt[indexOfY]);
              }
            }
            table.setColumns({
              x: xData,
              [pointValKey]: valueData
            });
          }
        } else {
          runTurbo = false;
        }
      }
      if (!runTurbo) {
        const columns = dataColumnKeys.reduce((columns2, columnName) => {
          columns2[columnName] = [];
          return columns2;
        }, {});
        for (i = 0; i < dataLength; i++) {
          const pt = series.pointClass.prototype.applyOptions.apply({ series }, [data[i]]);
          for (const key of dataColumnKeys) {
            columns[key][i] = pt[key];
          }
        }
        table.setColumns(columns);
      }
      if (isString11(this.getColumn("y")[0])) {
        error5(14, true, chart);
      }
      series.data = [];
      series.options.data = series.userOptions.data = data;
      i = oldDataLength;
      while (i--) {
        oldData[i]?.destroy();
      }
      if (xAxis2) {
        xAxis2.minRange = xAxis2.userMinRange;
      }
      series.isDirty = chart.isDirtyBox = true;
      series.isDirtyData = !!oldData;
      animation = false;
    }
    if (options2.legendType === "point") {
      this.processData();
      this.generatePoints();
    }
    if (redraw) {
      chart.redraw(animation);
    }
  }
  /**
   * Internal function to sort series data
   *
   * @private
   * @function Highcharts.Series#sortData
   * @param {Array<Highcharts.PointOptionsType>} data
   * Force data grouping.
   */
  sortData(data) {
    const series = this, options2 = series.options, dataSorting = options2.dataSorting, sortKey = dataSorting.sortKey || "y", getPointOptionsObject = function(series2, pointOptions) {
      return defined14(pointOptions) && series2.pointClass.prototype.optionsToObject.call({
        series: series2
      }, pointOptions) || {};
    };
    data.forEach(function(pointOptions, i) {
      data[i] = getPointOptionsObject(series, pointOptions);
      data[i].index = i;
    }, this);
    const sortedData = data.concat().sort((a, b) => {
      const aValue = getNestedProperty4(sortKey, a);
      const bValue = getNestedProperty4(sortKey, b);
      return bValue < aValue ? -1 : bValue > aValue ? 1 : 0;
    });
    sortedData.forEach(function(point, i) {
      point.x = i;
    }, this);
    if (series.linkedSeries) {
      series.linkedSeries.forEach(function(linkedSeries) {
        const options3 = linkedSeries.options, seriesData = options3.data;
        if (!options3.dataSorting?.enabled && seriesData) {
          seriesData.forEach(function(pointOptions, i) {
            seriesData[i] = getPointOptionsObject(linkedSeries, pointOptions);
            if (data[i]) {
              seriesData[i].x = data[i].x;
              seriesData[i].index = i;
            }
          });
          linkedSeries.setData(seriesData, false);
        }
      });
    }
    return data;
  }
  /**
   * Internal function to process the data by cropping away unused data
   * points if the series is longer than the crop threshold. This saves
   * computing time for large series.
   *
   * @private
   * @function Highcharts.Series#getProcessedData
   * @param {boolean} [forceExtremesFromAll]
   * Force getting extremes of a total series data range.
   */
  getProcessedData(forceExtremesFromAll) {
    const series = this, { dataTable: table, isCartesian, options: options2, xAxis: xAxis2 } = series, cropThreshold = options2.cropThreshold, getExtremesFromAll = forceExtremesFromAll || // X-range series etc, #21003
    series.getExtremesFromAll, logarithmic = xAxis2?.logarithmic, dataLength = table.rowCount;
    let croppedData, cropped, cropStart = 0, xExtremes, min4, max4, xData = series.getColumn("x"), modified = table, updatingNames = false;
    if (xAxis2) {
      xExtremes = xAxis2.getExtremes();
      min4 = xExtremes.min;
      max4 = xExtremes.max;
      updatingNames = !!(xAxis2.categories && !xAxis2.names.length);
      if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
        if (xData[dataLength - 1] < min4 || xData[0] > max4) {
          modified = new DataTableCore_default();
        } else if (
          // Don't understand why this condition is needed
          series.getColumn(series.pointValKey || "y").length && (xData[0] < min4 || xData[dataLength - 1] > max4)
        ) {
          croppedData = this.cropData(table, min4, max4);
          modified = croppedData.modified;
          cropStart = croppedData.start;
          cropped = true;
        }
      }
    }
    xData = modified.getColumn("x") || [];
    const closestPointRange = getClosestDistance3(
      [
        logarithmic ? xData.map(logarithmic.log2lin) : xData
      ],
      // Unsorted data is not supported by the line tooltip, as well as
      // data grouping and navigation in Stock charts (#725) and width
      // calculation of columns (#1900). Avoid warning during the
      // premature processing pass in updateNames (#16104).
      () => series.requireSorting && !updatingNames && error5(15, false, series.chart)
    );
    return {
      modified,
      cropped,
      cropStart,
      closestPointRange
    };
  }
  /**
   * Internal function to apply processed data.
   * In Highcharts Stock, this function is extended to provide data grouping.
   *
   * @private
   * @function Highcharts.Series#processData
   * @param {boolean} [force]
   * Force data grouping.
   */
  processData(force) {
    const series = this, xAxis2 = series.xAxis, table = series.dataTable;
    if (series.isCartesian && !series.isDirty && !xAxis2.isDirty && !series.yAxis.isDirty && !force) {
      return false;
    }
    const processedData = series.getProcessedData();
    table.modified = processedData.modified;
    series.cropped = processedData.cropped;
    series.cropStart = processedData.cropStart;
    series.closestPointRange = series.basePointRange = processedData.closestPointRange;
    fireEvent12(series, "afterProcessData");
  }
  /**
   * Iterate over xData and crop values between min and max. Returns
   * object containing crop start/end cropped xData with corresponding
   * part of yData, dataMin and dataMax within the cropped range.
   *
   * @private
   * @function Highcharts.Series#cropData
   */
  cropData(table, min4, max4) {
    const xData = table.getColumn("x", true) || [], dataLength = xData.length, columns = {};
    let i, j, start = 0, end = dataLength;
    for (i = 0; i < dataLength; i++) {
      if (xData[i] >= min4) {
        start = Math.max(0, i - 1);
        break;
      }
    }
    for (j = i; j < dataLength; j++) {
      if (xData[j] > max4) {
        end = j + 1;
        break;
      }
    }
    for (const key of this.dataColumnKeys()) {
      const column2 = table.getColumn(key, true);
      if (column2) {
        columns[key] = column2.slice(start, end);
      }
    }
    return {
      modified: new DataTableCore_default({ columns }),
      start,
      end
    };
  }
  /**
   * Generate the data point after the data has been processed by cropping
   * away unused points and optionally grouped in Highcharts Stock.
   *
   * @private
   * @function Highcharts.Series#generatePoints
   */
  generatePoints() {
    const series = this, options2 = series.options, dataOptions = series.processedData || options2.data, table = series.dataTable.modified, xData = series.getColumn("x", true), PointClass = series.pointClass, processedDataLength = table.rowCount, cropStart = series.cropStart || 0, hasGroupedData = series.hasGroupedData, keys = options2.keys, points = [], groupCropStartIndex = options2.dataGrouping?.groupAll ? cropStart : 0, categories = series.xAxis?.categories, pointArrayMap = series.pointArrayMap || ["y"], dataColumnKeys = this.dataColumnKeys();
    let dataLength, cursor, point, i, data = series.data, pOptions;
    if (!data && !hasGroupedData) {
      const arr = [];
      arr.length = dataOptions?.length || 0;
      data = series.data = arr;
    }
    if (keys && hasGroupedData) {
      series.options.keys = false;
    }
    for (i = 0; i < processedDataLength; i++) {
      cursor = cropStart + i;
      if (!hasGroupedData) {
        point = data[cursor];
        pOptions = dataOptions ? dataOptions[cursor] : table.getRow(i, pointArrayMap);
        if (!point && pOptions !== void 0) {
          data[cursor] = point = new PointClass(series, pOptions, xData[i]);
        }
      } else {
        point = new PointClass(series, table.getRow(i, dataColumnKeys) || []);
        point.dataGroup = series.groupMap[groupCropStartIndex + i];
        if (point.dataGroup?.options) {
          point.options = point.dataGroup.options;
          extend18(point, point.dataGroup.options);
          delete point.dataLabels;
        }
      }
      if (point) {
        point.index = hasGroupedData ? groupCropStartIndex + i : cursor;
        points[i] = point;
        point.category = categories?.[point.x] ?? point.x;
        point.key = point.name ?? point.category;
      }
    }
    series.options.keys = keys;
    if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
      for (i = 0; i < dataLength; i++) {
        if (i === cropStart && !hasGroupedData) {
          i += processedDataLength;
        }
        if (data[i]) {
          data[i].destroyElements();
          data[i].plotX = void 0;
        }
      }
    }
    series.data = data;
    series.points = points;
    fireEvent12(this, "afterGeneratePoints");
  }
  /**
   * Get current X extremes for the visible data.
   *
   * @private
   * @function Highcharts.Series#getXExtremes
   * @param {Array<number>} xData
   * The data to inspect. Defaults to the current data within the visible
   * range.
   */
  getXExtremes(xData) {
    return {
      min: arrayMin4(xData),
      max: arrayMax4(xData)
    };
  }
  /**
   * Calculate Y extremes for the visible data. The result is returned
   * as an object with `dataMin` and `dataMax` properties.
   *
   * @private
   * @function Highcharts.Series#getExtremes
   * @param {Array<number>} [yData]
   * The data to inspect. Defaults to the current data within the visible
   * range.
   * @param {boolean} [forceExtremesFromAll]
   * Force getting extremes of a total series data range.
   */
  getExtremes(yData, forceExtremesFromAll) {
    const { xAxis: xAxis2, yAxis: yAxis2 } = this, getExtremesFromAll = forceExtremesFromAll || this.getExtremesFromAll || this.options.getExtremesFromAll, table = getExtremesFromAll && this.cropped ? this.dataTable : this.dataTable.modified, rowCount = table.rowCount, customData = yData || this.stackedYData, yAxisData = customData ? [customData] : (this.keysAffectYAxis || this.pointArrayMap || ["y"])?.map((key) => table.getColumn(key, true) || []) || [], xData = this.getColumn("x", true), activeYData = [], shoulder = this.requireSorting && !this.is("column") ? 1 : 0, positiveValuesOnly = yAxis2 ? yAxis2.positiveValuesOnly : false, doAll = getExtremesFromAll || this.cropped || !xAxis2;
    let xExtremes, x, i, xMin = 0, xMax = 0;
    if (xAxis2) {
      xExtremes = xAxis2.getExtremes();
      xMin = xExtremes.min;
      xMax = xExtremes.max;
    }
    for (i = 0; i < rowCount; i++) {
      x = xData[i];
      if (doAll || (xData[i + shoulder] || x) >= xMin && (xData[i - shoulder] || x) <= xMax) {
        for (const values of yAxisData) {
          const val = values[i];
          if (isNumber18(val) && (val > 0 || !positiveValuesOnly)) {
            activeYData.push(val);
          }
        }
      }
    }
    const dataExtremes = {
      activeYData,
      // Needed for Stock Cumulative Sum
      dataMin: arrayMin4(activeYData),
      dataMax: arrayMax4(activeYData)
    };
    fireEvent12(this, "afterGetExtremes", { dataExtremes });
    return dataExtremes;
  }
  /**
   * Set the current data extremes as `dataMin` and `dataMax` on the
   * Series item. Use this only when the series properties should be
   * updated.
   *
   * @private
   * @function Highcharts.Series#applyExtremes
   */
  applyExtremes() {
    const dataExtremes = this.getExtremes();
    this.dataMin = dataExtremes.dataMin;
    this.dataMax = dataExtremes.dataMax;
    return dataExtremes;
  }
  /**
   * Find and return the first non nullish point in the data
   *
   * @private
   * @function Highcharts.Series.getFirstValidPoint
   * @param {Array<Highcharts.PointOptionsType>} data
   *        Array of options for points
   * @param {number} [start=0]
   *        Index to start searching from
   * @param {number} [increment=1]
   *        Index increment, set -1 to search backwards
   */
  getFirstValidPoint(data, start = 0, increment = 1) {
    const dataLength = data.length;
    let i = start;
    while (i >= 0 && i < dataLength) {
      if (defined14(data[i])) {
        return data[i];
      }
      i += increment;
    }
  }
  /**
   * Translate data points from raw data values to chart specific
   * positioning data needed later in the `drawPoints` and `drawGraph`
   * functions. This function can be overridden in plugins and custom
   * series type implementations.
   *
   * @function Highcharts.Series#translate
   *
   * @emits Highcharts.Series#events:translate
   */
  translate() {
    this.generatePoints();
    const series = this, options2 = series.options, stacking = options2.stacking, xAxis2 = series.xAxis, enabledDataSorting = series.enabledDataSorting, yAxis2 = series.yAxis, points = series.points, dataLength = points.length, pointPlacement = series.pointPlacementToXValue(), dynamicallyPlaced = Boolean(pointPlacement), threshold = options2.threshold, stackThreshold = options2.startFromThreshold ? threshold : 0, nullYSubstitute = options2?.nullInteraction && yAxis2.len;
    let i, plotX, lastPlotX, stackIndicator, closestPointRangePx = Number.MAX_VALUE;
    function limitedRange(val) {
      return clamp6(val, -1e9, 1e9);
    }
    for (i = 0; i < dataLength; i++) {
      const point = points[i], xValue = point.x;
      let stackItem, stackValues, yValue = point.y, lowValue = point.low;
      const stacks = stacking && yAxis2.stacking?.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? "-" : "") + series.stackKey];
      plotX = xAxis2.translate(
        // #3923
        xValue,
        false,
        false,
        false,
        true,
        pointPlacement
      );
      point.plotX = isNumber18(plotX) ? correctFloat4(
        // #5236
        limitedRange(plotX)
        // #3923
      ) : void 0;
      if (stacking && series.visible && stacks && stacks[xValue]) {
        stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
        if (!point.isNull && stackIndicator.key) {
          stackItem = stacks[xValue];
          stackValues = stackItem.points[stackIndicator.key];
        }
        if (stackItem && isArray9(stackValues)) {
          lowValue = stackValues[0];
          yValue = stackValues[1];
          if (lowValue === stackThreshold && stackIndicator.key === stacks[xValue].base) {
            lowValue = pick18(isNumber18(threshold) ? threshold : yAxis2.min);
          }
          if (yAxis2.positiveValuesOnly && defined14(lowValue) && lowValue <= 0) {
            lowValue = void 0;
          }
          point.total = point.stackTotal = pick18(stackItem.total);
          point.percentage = defined14(point.y) && stackItem.total ? point.y / stackItem.total * 100 : void 0;
          point.stackY = yValue;
          if (!series.irregularWidths) {
            stackItem.setOffset(series.pointXOffset || 0, series.barW || 0, void 0, void 0, void 0, series.xAxis);
          }
        }
      }
      point.yBottom = defined14(lowValue) ? limitedRange(yAxis2.translate(lowValue, false, true, false, true)) : void 0;
      if (series.dataModify) {
        yValue = series.dataModify.modifyValue(yValue, i);
      }
      let plotY;
      if (isNumber18(yValue) && point.plotX !== void 0) {
        plotY = yAxis2.translate(yValue, false, true, false, true);
        plotY = isNumber18(plotY) ? limitedRange(plotY) : void 0;
      } else if (!isNumber18(yValue) && nullYSubstitute) {
        plotY = nullYSubstitute;
      }
      point.plotY = plotY;
      point.isInside = this.isPointInside(point);
      point.clientX = dynamicallyPlaced ? correctFloat4(xAxis2.translate(xValue, false, false, false, true, pointPlacement)) : plotX;
      point.negative = (point.y || 0) < (threshold || 0);
      if (!point.isNull && point.visible !== false) {
        if (typeof lastPlotX !== "undefined") {
          closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));
        }
        lastPlotX = plotX;
      }
      point.zone = this.zones.length ? point.getZone() : void 0;
      if (!point.graphic && series.group && enabledDataSorting) {
        point.isNew = true;
      }
    }
    series.closestPointRangePx = closestPointRangePx;
    fireEvent12(this, "afterTranslate");
  }
  /**
   * Return the series points with null points filtered out.
   *
   * @function Highcharts.Series#getValidPoints
   *
   * @param {Array<Highcharts.Point>} [points]
   * The points to inspect, defaults to {@link Series.points}.
   *
   * @param {boolean} [insideOnly=false]
   * Whether to inspect only the points that are inside the visible view.
   *
   * @param {boolean} [allowNull=false]
   * Whether to allow null points to pass as valid points.
   *
   * @return {Array<Highcharts.Point>}
   * The valid points.
   */
  getValidPoints(points, insideOnly, allowNull) {
    const chart = this.chart;
    return (points || this.points || []).filter(function(point) {
      const { plotX, plotY } = point, asNull = !allowNull && (point.isNull || !isNumber18(plotY));
      if (asNull || insideOnly && !chart.isInsidePlot(plotX, plotY, { inverted: chart.inverted })) {
        return false;
      }
      return point.visible !== false;
    });
  }
  /**
   * Get the shared clip key, creating it if it doesn't exist.
   *
   * @private
   * @function Highcharts.Series#getSharedClipKey
   */
  getSharedClipKey() {
    this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
    return this.sharedClipKey;
  }
  /**
   * Set the clipping for the series. For animated series the clip is later
   * modified.
   *
   * @private
   * @function Highcharts.Series#setClip
   */
  setClip() {
    const { chart, group, markerGroup } = this, sharedClips = chart.sharedClips, renderer = chart.renderer, clipBox = chart.getClipBox(this), sharedClipKey = this.getSharedClipKey();
    let clipRect = sharedClips[sharedClipKey];
    if (!clipRect) {
      sharedClips[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
    } else {
      clipRect.animate(clipBox);
    }
    if (group) {
      group.clip(this.options.clip === false ? void 0 : clipRect);
    }
    if (markerGroup) {
      markerGroup.clip();
    }
  }
  /**
   * Animate in the series. Called internally twice. First with the `init`
   * parameter set to true, which sets up the initial state of the
   * animation. Then when ready, it is called with the `init` parameter
   * undefined, in order to perform the actual animation.
   *
   * @function Highcharts.Series#animate
   *
   * @param {boolean} [init]
   * Initialize the animation.
   */
  animate(init3) {
    const { chart, group, markerGroup } = this, inverted = chart.inverted, animation = animObject6(this.options.animation), animationClipKey = [
      this.getSharedClipKey(),
      animation.duration,
      animation.easing,
      animation.defer
    ].join(",");
    let animationClipRect = chart.sharedClips[animationClipKey], markerAnimationClipRect = chart.sharedClips[animationClipKey + "m"];
    if (init3 && group) {
      const clipBox = chart.getClipBox(this);
      if (!animationClipRect) {
        clipBox.width = 0;
        if (inverted) {
          clipBox.x = chart.plotHeight;
        }
        animationClipRect = chart.renderer.clipRect(clipBox);
        chart.sharedClips[animationClipKey] = animationClipRect;
        const markerClipBox = {
          x: inverted ? -99 : -99,
          y: inverted ? -99 : -99,
          width: inverted ? chart.plotWidth + 199 : 99,
          height: inverted ? 99 : chart.plotHeight + 199
        };
        markerAnimationClipRect = chart.renderer.clipRect(markerClipBox);
        chart.sharedClips[animationClipKey + "m"] = markerAnimationClipRect;
      } else {
        animationClipRect.attr("height", clipBox.height);
      }
      group.clip(animationClipRect);
      markerGroup?.clip(markerAnimationClipRect);
    } else if (animationClipRect && // Only first series in this pane
    !animationClipRect.hasClass("highcharts-animating")) {
      const finalBox = chart.getClipBox(this), step = animation.step;
      if (markerGroup?.element.childNodes.length || chart.series.length > 1) {
        animation.step = function(val, fx) {
          if (step) {
            step.apply(fx, arguments);
          }
          if (fx.prop === "width" && markerAnimationClipRect?.element) {
            markerAnimationClipRect.attr(inverted ? "height" : "width", val + 99);
          }
        };
      }
      animationClipRect.addClass("highcharts-animating").animate(finalBox, animation);
    }
  }
  /**
   * This runs after animation to land on the final plot clipping.
   *
   * @private
   * @function Highcharts.Series#afterAnimate
   *
   * @emits Highcharts.Series#event:afterAnimate
   */
  afterAnimate() {
    this.setClip();
    objectEach14(this.chart.sharedClips, (clip, key, sharedClips) => {
      if (clip && !this.chart.container.querySelector(`[clip-path="url(#${clip.id})"]`)) {
        clip.destroy();
        delete sharedClips[key];
      }
    });
    this.finishedAnimating = true;
    fireEvent12(this, "afterAnimate");
  }
  /**
   * Draw the markers for line-like series types, and columns or other
   * graphical representation for {@link Point} objects for other series
   * types. The resulting element is typically stored as
   * {@link Point.graphic}, and is created on the first call and updated
   * and moved on subsequent calls.
   *
   * @function Highcharts.Series#drawPoints
   */
  drawPoints(points = this.points) {
    const series = this, chart = series.chart, styledMode = chart.styledMode, { colorAxis, options: options2 } = series, seriesMarkerOptions = options2.marker, nullInteraction = options2.nullInteraction, markerGroup = series[series.specialGroup || "markerGroup"], xAxis2 = series.xAxis, globallyEnabled = pick18(
      seriesMarkerOptions.enabled,
      !xAxis2 || xAxis2.isRadial ? true : null,
      // Use larger or equal as radius is null in bubbles (#6321)
      series.closestPointRangePx >= seriesMarkerOptions.enabledThreshold * seriesMarkerOptions.radius
    );
    let i, point, graphic, verb, pointMarkerOptions, hasPointMarker, markerAttribs;
    if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {
      for (i = 0; i < points.length; i++) {
        point = points[i];
        graphic = point.graphic;
        verb = graphic ? "animate" : "attr";
        pointMarkerOptions = point.marker || {};
        hasPointMarker = !!point.marker;
        const isNull = point.isNull, shouldDrawMarker = (globallyEnabled && !defined14(pointMarkerOptions.enabled) || pointMarkerOptions.enabled) && (!isNull || nullInteraction) && point.visible !== false;
        if (shouldDrawMarker) {
          const symbol = pick18(pointMarkerOptions.symbol, series.symbol, "rect");
          markerAttribs = series.markerAttribs(point, point.selected && "select");
          if (series.enabledDataSorting) {
            point.startXPos = xAxis2.reversed ? -(markerAttribs.width || 0) : xAxis2.width;
          }
          const isInside = point.isInside !== false;
          if (!graphic && isInside && ((markerAttribs.width || 0) > 0 || point.hasImage)) {
            point.graphic = graphic = chart.renderer.symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ? pointMarkerOptions : seriesMarkerOptions).add(markerGroup);
            if (series.enabledDataSorting && chart.hasRendered) {
              graphic.attr({
                x: point.startXPos
              });
              verb = "animate";
            }
          }
          if (graphic && verb === "animate") {
            graphic[isInside ? "show" : "hide"](isInside).animate(markerAttribs);
          }
          if (graphic) {
            const pointAttr = series.pointAttribs(point, styledMode || !point.selected ? void 0 : "select");
            if (!styledMode) {
              graphic[verb](pointAttr);
            } else if (colorAxis) {
              graphic["css"]({
                fill: pointAttr.fill
              });
            }
          }
          if (graphic) {
            graphic.addClass(point.getClassName(), true);
          }
        } else if (graphic) {
          point.graphic = graphic.destroy();
        }
      }
    }
  }
  /**
   * Get non-presentational attributes for a point. Used internally for
   * both styled mode and classic. Can be overridden for different series
   * types.
   *
   * @see Series#pointAttribs
   *
   * @function Highcharts.Series#markerAttribs
   *
   * @param {Highcharts.Point} point
   * The Point to inspect.
   *
   * @param {string} [state]
   * The state, can be either `hover`, `select` or undefined.
   *
   * @return {Highcharts.SVGAttributes}
   * A hash containing those attributes that are not settable from CSS.
   */
  markerAttribs(point, state) {
    const seriesOptions = this.options, seriesMarkerOptions = seriesOptions.marker, pointMarkerOptions = point.marker || {}, symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol, attribs = {};
    let seriesStateOptions, pointStateOptions, radius = pick18(pointMarkerOptions.radius, seriesMarkerOptions?.radius);
    if (state) {
      seriesStateOptions = seriesMarkerOptions.states[state];
      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state];
      radius = pick18(pointStateOptions?.radius, seriesStateOptions?.radius, radius && radius + (seriesStateOptions?.radiusPlus || 0));
    }
    point.hasImage = symbol && symbol.indexOf("url") === 0;
    if (point.hasImage) {
      radius = 0;
    }
    const pos = point.pos();
    if (isNumber18(radius) && pos) {
      if (seriesOptions.crisp) {
        pos[0] = crisp5(pos[0], point.hasImage ? 0 : symbol === "rect" ? (
          // Rectangle symbols need crisp edges, others don't
          seriesMarkerOptions?.lineWidth || 0
        ) : 1);
      }
      attribs.x = pos[0] - radius;
      attribs.y = pos[1] - radius;
    }
    if (radius) {
      attribs.width = attribs.height = 2 * radius;
    }
    return attribs;
  }
  /**
   * Internal function to get presentational attributes for each point.
   * Unlike {@link Series#markerAttribs}, this function should return
   * those attributes that can also be set in CSS. In styled mode,
   * `pointAttribs` won't be called.
   *
   * @private
   * @function Highcharts.Series#pointAttribs
   *
   * @param {Highcharts.Point} [point]
   * The point instance to inspect.
   *
   * @param {string} [state]
   * The point state, can be either `hover`, `select` or 'normal'. If
   * undefined, normal state is assumed.
   *
   * @return {Highcharts.SVGAttributes}
   * The presentational attributes to be set on the point.
   */
  pointAttribs(point, state) {
    const options2 = this.options, seriesMarkerOptions = options2.marker, pointOptions = point?.options, pointMarkerOptions = pointOptions?.marker || {}, pointColorOption = pointOptions?.color, pointColor = point?.color, zoneColor = point?.zone?.color;
    let seriesStateOptions, pointStateOptions, color14 = this.color, fill, stroke, strokeWidth = pick18(pointMarkerOptions.lineWidth, seriesMarkerOptions.lineWidth), opacity = point?.isNull && options2.nullInteraction ? 0 : 1;
    color14 = pointColorOption || zoneColor || pointColor || color14;
    fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color14;
    stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color14;
    state = state || "normal";
    if (state) {
      seriesStateOptions = seriesMarkerOptions.states[state] || {};
      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
      strokeWidth = pick18(pointStateOptions.lineWidth, seriesStateOptions.lineWidth, strokeWidth + pick18(pointStateOptions.lineWidthPlus, seriesStateOptions.lineWidthPlus, 0));
      fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;
      stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;
      opacity = pick18(pointStateOptions.opacity, seriesStateOptions.opacity, opacity);
    }
    return {
      "stroke": stroke,
      "stroke-width": strokeWidth,
      "fill": fill,
      "opacity": opacity
    };
  }
  /**
   * Clear DOM objects and free up memory.
   *
   * @private
   * @function Highcharts.Series#destroy
   *
   * @emits Highcharts.Series#event:destroy
   */
  destroy(keepEventsForUpdate) {
    const series = this, chart = series.chart, issue134 = /AppleWebKit\/533/.test(win9.navigator.userAgent), data = series.data || [];
    let destroy, i, axis;
    fireEvent12(series, "destroy", { keepEventsForUpdate });
    this.removeEvents(keepEventsForUpdate);
    (series.axisTypes || []).forEach(function(AXIS) {
      axis = series[AXIS];
      if (axis?.series) {
        erase7(axis.series, series);
        axis.isDirty = axis.forceRedraw = true;
      }
    });
    if (series.legendItem) {
      series.chart.legend.destroyItem(series);
    }
    i = data.length;
    while (i--) {
      data[i]?.destroy?.();
    }
    for (const zone of series.zones) {
      destroyObjectProperties6(zone, void 0, true);
    }
    Utilities_default.clearTimeout(series.animationTimeout);
    objectEach14(series, function(val, prop) {
      if (val instanceof SVGElement_default && !val.survive) {
        destroy = issue134 && prop === "group" ? "hide" : "destroy";
        val[destroy]();
      }
    });
    if (chart.hoverSeries === series) {
      chart.hoverSeries = void 0;
    }
    erase7(chart.series, series);
    chart.orderItems("series");
    objectEach14(series, function(val, prop) {
      if (!keepEventsForUpdate || prop !== "hcEvents") {
        delete series[prop];
      }
    });
  }
  /**
   * Clip the graphs into zones for colors and styling.
   *
   * @private
   * @function Highcharts.Series#applyZones
   */
  applyZones() {
    const series = this, { area, chart, graph, zones, points, xAxis: xAxis2, yAxis: yAxis2, zoneAxis } = series, { inverted, renderer } = chart, axis = this[`${zoneAxis}Axis`], { isXAxis, len = 0, minPointOffset = 0 } = axis || {}, halfWidth = (graph?.strokeWidth() || 0) / 2 + 1, avoidClose = (zone, plotX = 0, plotY = 0) => {
      if (inverted) {
        plotY = len - plotY;
      }
      const { translated = 0, lineClip } = zone, distance = plotY - translated;
      lineClip?.push([
        "L",
        plotX,
        Math.abs(distance) < halfWidth ? plotY - halfWidth * (distance <= 0 ? -1 : 1) : translated
      ]);
    };
    if (zones.length && (graph || area) && axis && isNumber18(axis.min)) {
      const axisMax2 = axis.getExtremes().max + minPointOffset, invertPath = (path) => {
        path.forEach((segment, i) => {
          if (segment[0] === "M" || segment[0] === "L") {
            path[i] = [
              segment[0],
              isXAxis ? len - segment[1] : segment[1],
              isXAxis ? segment[2] : len - segment[2]
            ];
          }
        });
      };
      zones.forEach((zone) => {
        zone.lineClip = [];
        zone.translated = clamp6(axis.toPixels(pick18(zone.value, axisMax2), true) || 0, 0, len);
      });
      if (graph && !this.showLine) {
        graph.hide();
      }
      if (area) {
        area.hide();
      }
      if (zoneAxis === "y" && // Overheat protection
      points.length < xAxis2.len) {
        for (const point of points) {
          const { plotX, plotY, zone } = point, zoneBelow = zone && zones[zones.indexOf(zone) - 1];
          if (zone) {
            avoidClose(zone, plotX, plotY);
          }
          if (zoneBelow) {
            avoidClose(zoneBelow, plotX, plotY);
          }
        }
      }
      let lastLineClip = [], lastTranslated = axis.toPixels(axis.getExtremes().min - minPointOffset, true);
      zones.forEach((zone) => {
        const lineClip = zone.lineClip || [], translated = Math.round(zone.translated || 0);
        if (xAxis2.reversed) {
          lineClip.reverse();
        }
        let { clip, simpleClip } = zone, x1 = 0, y1 = 0, x2 = xAxis2.len, y2 = yAxis2.len;
        if (isXAxis) {
          x1 = translated;
          x2 = lastTranslated;
        } else {
          y1 = translated;
          y2 = lastTranslated;
        }
        const simplePath = [
          ["M", x1, y1],
          ["L", x2, y1],
          ["L", x2, y2],
          ["L", x1, y2],
          ["Z"]
        ], adaptivePath = [
          simplePath[0],
          ...lineClip,
          simplePath[1],
          simplePath[2],
          ...lastLineClip,
          simplePath[3],
          simplePath[4]
        ];
        lastLineClip = lineClip.reverse();
        lastTranslated = translated;
        if (inverted) {
          invertPath(adaptivePath);
          if (area) {
            invertPath(simplePath);
          }
        }
        if (clip) {
          clip.animate({ d: adaptivePath });
          simpleClip?.animate({ d: simplePath });
        } else {
          clip = zone.clip = renderer.path(adaptivePath);
          if (area) {
            simpleClip = zone.simpleClip = renderer.path(simplePath);
          }
        }
        if (graph) {
          zone.graph?.clip(clip);
        }
        if (area) {
          zone.area?.clip(simpleClip);
        }
      });
    } else if (series.visible) {
      if (graph) {
        graph.show();
      }
      if (area) {
        area.show();
      }
    }
  }
  /**
   * General abstraction for creating plot groups like series.group,
   * series.dataLabelsGroup and series.markerGroup. On subsequent calls,
   * the group will only be adjusted to the updated plot size.
   *
   * @private
   * @function Highcharts.Series#plotGroup
   */
  plotGroup(prop, name, visibility, zIndex, parent) {
    let group = this[prop];
    const isNew = !group, attrs = {
      visibility,
      zIndex: zIndex || 0.1
      // Pointer logic uses this
    };
    if (defined14(this.opacity) && !this.chart.styledMode && this.state !== "inactive") {
      attrs.opacity = this.opacity;
    }
    if (!group) {
      this[prop] = group = this.chart.renderer.g().add(parent);
    }
    group.addClass("highcharts-" + name + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (defined14(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (group.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
    group.attr(attrs)[isNew ? "attr" : "animate"](this.getPlotBox(name));
    return group;
  }
  /**
   * Get the translation and scale for the plot area of this series.
   *
   * @function Highcharts.Series#getPlotBox
   */
  getPlotBox(name) {
    let horAxis = this.xAxis, vertAxis = this.yAxis;
    const chart = this.chart, inverted = chart.inverted && !chart.polar && horAxis && this.invertible && name === "series";
    if (chart.inverted) {
      horAxis = vertAxis;
      vertAxis = this.xAxis;
    }
    return {
      translateX: horAxis ? horAxis.left : chart.plotLeft,
      translateY: vertAxis ? vertAxis.top : chart.plotTop,
      rotation: inverted ? 90 : 0,
      rotationOriginX: inverted ? (horAxis.len - vertAxis.len) / 2 : 0,
      rotationOriginY: inverted ? (horAxis.len + vertAxis.len) / 2 : 0,
      scaleX: inverted ? -1 : 1,
      // #1623
      scaleY: 1
    };
  }
  /**
   * Removes the event handlers attached previously with addEvents.
   * @private
   * @function Highcharts.Series#removeEvents
   */
  removeEvents(keepEventsForUpdate) {
    const { eventsToUnbind } = this;
    if (!keepEventsForUpdate) {
      removeEvent6(this);
    }
    if (eventsToUnbind.length) {
      eventsToUnbind.forEach((unbind) => {
        unbind();
      });
      eventsToUnbind.length = 0;
    }
  }
  /**
   * Render the graph and markers. Called internally when first rendering
   * and later when redrawing the chart. This function can be extended in
   * plugins, but normally shouldn't be called directly.
   *
   * @function Highcharts.Series#render
   *
   * @emits Highcharts.Series#event:afterRender
   */
  render() {
    const series = this, { chart, options: options2, hasRendered } = series, animOptions = animObject6(options2.animation), visibility = series.visible ? "inherit" : "hidden", zIndex = options2.zIndex, chartSeriesGroup = chart.seriesGroup;
    let animDuration = series.finishedAnimating ? 0 : animOptions.duration;
    fireEvent12(this, "render");
    series.plotGroup("group", "series", visibility, zIndex, chartSeriesGroup);
    series.markerGroup = series.plotGroup("markerGroup", "markers", visibility, zIndex, chartSeriesGroup);
    if (options2.clip !== false) {
      series.setClip();
    }
    if (animDuration) {
      series.animate?.(true);
    }
    if (series.drawGraph) {
      series.drawGraph();
      series.applyZones();
    }
    if (series.visible) {
      series.drawPoints();
    }
    series.drawDataLabels?.();
    series.redrawPoints?.();
    if (options2.enableMouseTracking) {
      series.drawTracker?.();
    }
    if (animDuration) {
      series.animate?.();
    }
    if (!hasRendered) {
      if (animDuration && animOptions.defer) {
        animDuration += animOptions.defer;
      }
      series.animationTimeout = syncTimeout6(() => {
        series.afterAnimate();
      }, animDuration || 0);
    }
    series.isDirty = false;
    series.hasRendered = true;
    fireEvent12(series, "afterRender");
  }
  /**
   * Redraw the series. This function is called internally from
   * `chart.redraw` and normally shouldn't be called directly.
   * @private
   * @function Highcharts.Series#redraw
   */
  redraw() {
    const wasDirty = this.isDirty || this.isDirtyData;
    this.translate();
    this.render();
    if (wasDirty) {
      delete this.kdTree;
    }
  }
  /**
   * Whether to reserve space for the series, either because it is visible or
   * because the `chart.ignoreHiddenSeries` option is false.
   *
   * @private
   */
  reserveSpace() {
    return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
  }
  /**
   * Find the nearest point from a pointer event. This applies to series that
   * use k-d-trees to get the nearest point. Native pointer events must be
   * normalized using `Pointer.normalize`, that adds `chartX` and `chartY`
   * properties.
   *
   * @sample highcharts/demo/synchronized-charts
   *         Synchronized charts with tooltips
   *
   * @function Highcharts.Series#searchPoint
   *
   * @param {Highcharts.PointerEvent} e
   *        The normalized pointer event
   * @param {boolean} [compareX=false]
   *        Search only by the X value, not Y
   *
   * @return {Point|undefined}
   *        The closest point to the pointer event
   */
  searchPoint(e, compareX) {
    const { xAxis: xAxis2, yAxis: yAxis2 } = this, inverted = this.chart.inverted;
    return this.searchKDTree({
      clientX: inverted ? xAxis2.len - e.chartY + xAxis2.pos : e.chartX - xAxis2.pos,
      plotY: inverted ? yAxis2.len - e.chartX + yAxis2.pos : e.chartY - yAxis2.pos
    }, compareX, e);
  }
  /**
   * Build the k-d-tree that is used by mouse and touch interaction to get
   * the closest point. Line-like series typically have a one-dimensional
   * tree where points are searched along the X axis, while scatter-like
   * series typically search in two dimensions, X and Y.
   *
   * @private
   * @function Highcharts.Series#buildKDTree
   */
  buildKDTree(e) {
    this.buildingKdTree = true;
    const series = this, seriesOptions = series.options, dimensions = seriesOptions.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
    function kdtree(points, depth, dimensions2) {
      const length = points?.length;
      let axis, median;
      if (length) {
        axis = series.kdAxisArray[depth % dimensions2];
        points.sort((a, b) => (a[axis] || 0) - (b[axis] || 0));
        median = Math.floor(length / 2);
        return {
          point: points[median],
          left: kdtree(points.slice(0, median), depth + 1, dimensions2),
          right: kdtree(points.slice(median + 1), depth + 1, dimensions2)
        };
      }
    }
    function startRecursive() {
      series.kdTree = kdtree(series.getValidPoints(
        void 0,
        // For line-type series restrict to plot area, but
        // column-type series not (#3916, #4511)
        !series.directTouch,
        seriesOptions?.nullInteraction
      ), dimensions, dimensions);
      series.buildingKdTree = false;
    }
    delete series.kdTree;
    syncTimeout6(startRecursive, seriesOptions.kdNow || e?.type === "touchstart" ? 0 : 1);
  }
  /**
   * @private
   * @function Highcharts.Series#searchKDTree
   */
  searchKDTree(point, compareX, e, suppliedPointEvaluator, suppliedBSideCheckEvaluator) {
    const series = this, [kdX, kdY] = this.kdAxisArray, kdComparer = compareX ? "distX" : "dist", kdDimensions = (series.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, useRadius = !!series.isBubble, pointEvaluator = suppliedPointEvaluator || ((p1, p2, comparisonProp) => {
      const p1Val = p1[comparisonProp] || 0, p2Val = p2[comparisonProp] || 0;
      return [
        p1Val === p2Val && p1.index > p2.index || p1Val < p2Val ? p1 : p2,
        false
      ];
    }), bSideCheckEvaluator = suppliedBSideCheckEvaluator || ((a, b) => a < b);
    function setDistance(p1, p2) {
      const p1kdX = p1[kdX], p2kdX = p2[kdX], x = defined14(p1kdX) && defined14(p2kdX) ? p1kdX - p2kdX : null, p1kdY = p1[kdY], p2kdY = p2[kdY], y = defined14(p1kdY) && defined14(p2kdY) ? p1kdY - p2kdY : 0, radius = useRadius ? p2.marker?.radius || 0 : 0;
      p2.dist = Math.sqrt((x && x * x || 0) + y * y) - radius;
      p2.distX = defined14(x) ? Math.abs(x) - radius : Number.MAX_VALUE;
    }
    function doSearch(search, tree, depth, dimensions) {
      const point2 = tree.point, axis = series.kdAxisArray[depth % dimensions];
      let ret = point2, flip = false;
      setDistance(search, point2);
      const tdist = (search[axis] || 0) - (point2[axis] || 0) + (useRadius ? point2.marker?.radius || 0 : 0), sideA = tdist < 0 ? "left" : "right", sideB = tdist < 0 ? "right" : "left";
      if (tree[sideA]) {
        [ret, flip] = pointEvaluator(point2, doSearch(search, tree[sideA], depth + 1, dimensions), kdComparer);
      }
      if (tree[sideB]) {
        const sqrtTDist = Math.sqrt(tdist * tdist), retDist = ret[kdComparer];
        if (bSideCheckEvaluator(sqrtTDist, retDist, flip)) {
          ret = pointEvaluator(ret, doSearch(search, tree[sideB], depth + 1, dimensions), kdComparer)[0];
        }
      }
      return ret;
    }
    if (!this.kdTree && !this.buildingKdTree) {
      this.buildKDTree(e);
    }
    if (this.kdTree) {
      return doSearch(point, this.kdTree, kdDimensions, kdDimensions);
    }
  }
  /**
   * @private
   * @function Highcharts.Series#pointPlacementToXValue
   */
  pointPlacementToXValue() {
    const { options: options2, xAxis: xAxis2 } = this;
    let factor = options2.pointPlacement;
    if (factor === "between") {
      factor = xAxis2.reversed ? -0.5 : 0.5;
    }
    return isNumber18(factor) ? factor * (options2.pointRange || xAxis2.pointRange) : 0;
  }
  /**
   * @private
   * @function Highcharts.Series#isPointInside
   */
  isPointInside(point) {
    const { chart, xAxis: xAxis2, yAxis: yAxis2 } = this, { plotX = -1, plotY = -1 } = point, isInside = plotY >= 0 && plotY <= (yAxis2 ? yAxis2.len : chart.plotHeight) && plotX >= 0 && plotX <= (xAxis2 ? xAxis2.len : chart.plotWidth);
    return isInside;
  }
  /**
   * Draw the tracker object that sits above all data labels and markers to
   * track mouse events on the graph or points. For the line type charts
   * the tracker uses the same graphPath, but with a greater stroke width
   * for better control.
   * @private
   */
  drawTracker() {
    const series = this, options2 = series.options, trackByArea = options2.trackByArea, trackerPath = [].concat((trackByArea ? series.areaPath : series.graphPath) || []), chart = series.chart, pointer = chart.pointer, renderer = chart.renderer, snap = chart.options.tooltip?.snap || 0, onMouseOver = () => {
      if (options2.enableMouseTracking && chart.hoverSeries !== series) {
        series.onMouseOver();
      }
    }, TRACKER_FILL2 = "rgba(192,192,192," + (svg2 ? 1e-4 : 2e-3) + ")";
    let tracker = series.tracker;
    if (tracker) {
      tracker.attr({ d: trackerPath });
    } else if (series.graph) {
      series.tracker = tracker = renderer.path(trackerPath).attr({
        visibility: series.visible ? "inherit" : "hidden",
        zIndex: 2
      }).addClass(trackByArea ? "highcharts-tracker-area" : "highcharts-tracker-line").add(series.group);
      if (!chart.styledMode) {
        tracker.attr({
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          // #1225
          stroke: TRACKER_FILL2,
          fill: trackByArea ? TRACKER_FILL2 : "none",
          "stroke-width": series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap)
        });
      }
      [
        series.tracker,
        series.markerGroup,
        series.dataLabelsGroup
      ].forEach((tracker2) => {
        if (tracker2) {
          tracker2.addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", (e) => {
            pointer?.onTrackerMouseOut(e);
          });
          if (options2.cursor && !chart.styledMode) {
            tracker2.css({ cursor: options2.cursor });
          }
          tracker2.on("touchstart", onMouseOver);
        }
      });
    }
    fireEvent12(this, "afterDrawTracker");
  }
  /**
   * Add a point to the series after render time. The point can be added at
   * the end, or by giving it an X value, to the start or in the middle of the
   * series.
   *
   * @sample highcharts/members/series-addpoint-append/
   *         Append point
   * @sample highcharts/members/series-addpoint-append-and-shift/
   *         Append and shift
   * @sample highcharts/members/series-addpoint-x-and-y/
   *         Both X and Y values given
   * @sample highcharts/members/series-addpoint-pie/
   *         Append pie slice
   * @sample stock/members/series-addpoint/
   *         Append 100 points in Highcharts Stock
   * @sample stock/members/series-addpoint-shift/
   *         Append and shift in Highcharts Stock
   * @sample maps/members/series-addpoint/
   *         Add a point in Highmaps
   *
   * @function Highcharts.Series#addPoint
   *
   * @param {Highcharts.PointOptionsType} options
   *        The point options. If options is a single number, a point with
   *        that y value is appended to the series. If it is an array, it will
   *        be interpreted as x and y values respectively. If it is an
   *        object, advanced options as outlined under `series.data` are
   *        applied.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after the point is added. When adding
   *        more than one point, it is highly recommended that the redraw
   *        option be set to false, and instead {@link Chart#redraw} is
   *        explicitly called after the adding of points is finished.
   *        Otherwise, the chart will redraw after adding each point.
   *
   * @param {boolean} [shift=false]
   *        If true, a point is shifted off the start of the series as one is
   *        appended to the end.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
   *        Whether to apply animation, and optionally animation
   *        configuration.
   *
   * @param {boolean} [withEvent=true]
   *        Used internally, whether to fire the series `addPoint` event.
   *
   * @emits Highcharts.Series#event:addPoint
   */
  addPoint(options2, redraw, shift, animation, withEvent) {
    const series = this, seriesOptions = series.options, { chart, data, dataTable: table, xAxis: xAxis2 } = series, names = xAxis2?.hasNames && xAxis2.names, dataOptions = seriesOptions.data, xData = series.getColumn("x");
    let isInTheMiddle, i;
    redraw = pick18(redraw, true);
    const point = { series };
    series.pointClass.prototype.applyOptions.apply(point, [options2]);
    const x = point.x;
    i = xData.length;
    if (series.requireSorting && x < xData[i - 1]) {
      isInTheMiddle = true;
      while (i && xData[i - 1] > x) {
        i--;
      }
    }
    table.setRow(point, i, true, { addColumns: false });
    if (names && point.name) {
      names[x] = point.name;
    }
    dataOptions?.splice(i, 0, options2);
    if (isInTheMiddle || // When processedData is present we need to splice an empty slot
    // into series.data, otherwise generatePoints won't pick it up.
    series.processedData) {
      series.data.splice(i, 0, null);
      series.processData();
    }
    if (seriesOptions.legendType === "point") {
      series.generatePoints();
    }
    if (shift) {
      if (data[0] && !!data[0].remove) {
        data[0].remove(false);
      } else {
        [
          data,
          dataOptions
        ].filter(defined14).forEach((coll) => {
          coll.shift();
        });
        table.deleteRows(0);
      }
    }
    if (withEvent !== false) {
      fireEvent12(series, "addPoint", { point });
    }
    series.isDirty = true;
    series.isDirtyData = true;
    if (redraw) {
      chart.redraw(animation);
    }
  }
  /**
   * Remove a point from the series. Unlike the
   * {@link Highcharts.Point#remove} method, this can also be done on a point
   * that is not instantiated because it is outside the view or subject to
   * Highcharts Stock data grouping.
   *
   * @sample highcharts/members/series-removepoint/
   *         Remove cropped point
   *
   * @function Highcharts.Series#removePoint
   *
   * @param {number} i
   *        The index of the point in the {@link Highcharts.Series.data|data}
   *        array.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after the point is added. When
   *        removing more than one point, it is highly recommended that the
   *        `redraw` option be set to `false`, and instead {@link
   *        Highcharts.Chart#redraw} is explicitly called after the adding of
   *        points is finished.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
   *        Whether and optionally how the series should be animated.
   *
   * @emits Highcharts.Point#event:remove
   */
  removePoint(i, redraw, animation) {
    const series = this, { chart, data, points, dataTable: table } = series, point = data[i], remove = function() {
      [
        // #4935
        points?.length === data.length ? points : void 0,
        data,
        series.options.data
      ].filter(defined14).forEach((coll) => {
        coll.splice(i, 1);
      });
      table.deleteRows(i);
      point?.destroy();
      series.isDirty = true;
      series.isDirtyData = true;
      if (redraw) {
        chart.redraw();
      }
    };
    setAnimation2(animation, chart);
    redraw = pick18(redraw, true);
    if (point) {
      point.firePointEvent("remove", null, remove);
    } else {
      remove();
    }
  }
  /**
   * Remove a series and optionally redraw the chart.
   *
   * @sample highcharts/members/series-remove/
   *         Remove first series from a button
   *
   * @function Highcharts.Series#remove
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart or wait for an explicit call to
   *        {@link Highcharts.Chart#redraw}.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
   *        Whether to apply animation, and optionally animation
   *        configuration.
   *
   * @param {boolean} [withEvent=true]
   *        Used internally, whether to fire the series `remove` event.
   *
   * @emits Highcharts.Series#event:remove
   */
  remove(redraw, animation, withEvent, keepEvents) {
    const series = this, chart = series.chart;
    function remove() {
      series.destroy(keepEvents);
      chart.isDirtyLegend = chart.isDirtyBox = true;
      chart.linkSeries(keepEvents);
      if (pick18(redraw, true)) {
        chart.redraw(animation);
      }
    }
    if (withEvent !== false) {
      fireEvent12(series, "remove", null, remove);
    } else {
      remove();
    }
  }
  /**
   * Update the series with a new set of options. For a clean and precise
   * handling of new options, all methods and elements from the series are
   * removed, and it is initialized from scratch. Therefore, this method is
   * more performance expensive than some other utility methods like {@link
   * Series#setData} or {@link Series#setVisible}.
   *
   * Note that `Series.update` may mutate the passed `data` options.
   *
   * @sample highcharts/members/series-update/
   *         Updating series options
   * @sample maps/members/series-update/
   *         Update series options in Highmaps
   *
   * @function Highcharts.Series#update
   *
   * @param {Highcharts.SeriesOptionsType} options
   *        New options that will be merged with the series' existing options.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after the series is altered. If doing
   *        more operations on the chart, it is a good idea to set redraw to
   *        false and call {@link Chart#redraw} after.
   *
   * @emits Highcharts.Series#event:update
   * @emits Highcharts.Series#event:afterUpdate
   */
  update(options2, redraw) {
    options2 = diffObjects2(options2, this.userOptions);
    fireEvent12(this, "update", { options: options2 });
    const series = this, chart = series.chart, oldOptions = series.userOptions, initialType = series.initialType || series.type, plotOptions = chart.options.plotOptions, initialSeriesProto = seriesTypes[initialType].prototype, groups = [
      "group",
      "markerGroup",
      "dataLabelsGroup",
      "transformGroup"
    ], optionsToCheck = [
      "dataGrouping",
      "pointStart",
      "pointInterval",
      "pointIntervalUnit",
      "keys"
    ], animation = series.finishedAnimating && { animation: false }, kinds = {};
    let seriesOptions, n, keepProps = _Series.keepProps.slice(), newType = options2.type || oldOptions.type || chart.options.chart.type;
    const keepPoints = !// Indicators, histograms etc recalculate the data. It should be
    // possible to omit this.
    (this.hasDerivedData || // New type requires new point classes
    newType && newType !== this.type || // New options affecting how the data points are built
    typeof options2.keys !== "undefined" || typeof options2.pointStart !== "undefined" || typeof options2.pointInterval !== "undefined" || typeof options2.relativeXValue !== "undefined" || options2.joinBy || options2.mapData || // #11636
    // Changes to data grouping requires new points in new group
    optionsToCheck.some((option) => series.hasOptionChanged(option)));
    newType = newType || initialType;
    if (keepPoints) {
      keepProps.push.apply(keepProps, _Series.keepPropsForPoints);
      if (options2.visible !== false) {
        keepProps.push("area", "graph");
      }
      series.parallelArrays.forEach(function(key) {
        keepProps.push(key + "Data");
      });
      if (options2.data) {
        if (options2.dataSorting) {
          extend18(series.options.dataSorting, options2.dataSorting);
        }
        this.setData(options2.data, false);
      }
    } else {
      this.dataTable.modified = this.dataTable;
    }
    options2 = merge16(oldOptions, {
      // When oldOptions.index is null it should't be cleared.
      // Otherwise navigator series will have wrong indexes (#10193).
      index: oldOptions.index === void 0 ? series.index : oldOptions.index,
      pointStart: (
        // When updating from blank (#7933)
        plotOptions?.series?.pointStart ?? oldOptions.pointStart ?? // When updating after addPoint
        series.getColumn("x")[0]
      )
    }, !keepPoints && { data: series.options.data }, options2, animation);
    if (keepPoints && options2.data) {
      options2.data = series.options.data;
    }
    keepProps = groups.concat(keepProps);
    keepProps.forEach(function(prop) {
      keepProps[prop] = series[prop];
      delete series[prop];
    });
    let casting = false;
    if (seriesTypes[newType]) {
      casting = newType !== series.type;
      series.remove(false, false, false, true);
      if (casting) {
        chart.propFromSeries();
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(series, seriesTypes[newType].prototype);
        } else {
          const ownEvents = Object.hasOwnProperty.call(series, "hcEvents") && series.hcEvents;
          for (n in initialSeriesProto) {
            series[n] = void 0;
          }
          extend18(series, seriesTypes[newType].prototype);
          if (ownEvents) {
            series.hcEvents = ownEvents;
          } else {
            delete series.hcEvents;
          }
        }
      }
    } else {
      error5(17, true, chart, { missingModuleFor: newType });
    }
    keepProps.forEach(function(prop) {
      series[prop] = keepProps[prop];
    });
    series.init(chart, options2);
    if (keepPoints && this.points) {
      seriesOptions = series.options;
      if (seriesOptions.visible === false) {
        kinds.graphic = 1;
        kinds.dataLabel = 1;
      } else {
        if (this.hasMarkerChanged(seriesOptions, oldOptions)) {
          kinds.graphic = 1;
        }
        if (!series.hasDataLabels?.()) {
          kinds.dataLabel = 1;
        }
      }
      for (const point of this.points) {
        if (point?.series) {
          point.resolveColor();
          if (Object.keys(kinds).length) {
            point.destroyElements(kinds);
          }
          if (seriesOptions.showInLegend === false && point.legendItem) {
            chart.legend.destroyItem(point);
          }
        }
      }
    }
    series.initialType = initialType;
    chart.linkSeries();
    chart.setSortedData();
    if (casting && series.linkedSeries.length) {
      series.isDirtyData = true;
    }
    fireEvent12(this, "afterUpdate");
    if (pick18(redraw, true)) {
      chart.redraw(keepPoints ? void 0 : false);
    }
  }
  /**
   * Used from within series.update
   * @private
   */
  setName(name) {
    this.name = this.options.name = this.userOptions.name = name;
    this.chart.isDirtyLegend = true;
  }
  /**
   * Check if the option has changed.
   * @private
   */
  hasOptionChanged(optionName) {
    const chart = this.chart, option = this.options[optionName], plotOptions = chart.options.plotOptions, oldOption = this.userOptions[optionName], plotOptionsOption = pick18(plotOptions?.[this.type]?.[optionName], plotOptions?.series?.[optionName]);
    if (oldOption && !defined14(plotOptionsOption)) {
      return option !== oldOption;
    }
    return option !== pick18(plotOptionsOption, option);
  }
  /**
   * Runs on mouse over the series graphical items.
   *
   * @function Highcharts.Series#onMouseOver
   * @emits Highcharts.Series#event:mouseOver
   */
  onMouseOver() {
    const series = this, chart = series.chart, hoverSeries = chart.hoverSeries, pointer = chart.pointer;
    pointer?.setHoverChartIndex();
    if (hoverSeries && hoverSeries !== series) {
      hoverSeries.onMouseOut();
    }
    if (series.options.events.mouseOver) {
      fireEvent12(series, "mouseOver");
    }
    series.setState("hover");
    chart.hoverSeries = series;
  }
  /**
   * Runs on mouse out of the series graphical items.
   *
   * @function Highcharts.Series#onMouseOut
   *
   * @emits Highcharts.Series#event:mouseOut
   */
  onMouseOut() {
    const series = this, options2 = series.options, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;
    chart.hoverSeries = null;
    if (hoverPoint) {
      hoverPoint.onMouseOut();
    }
    if (series && options2.events.mouseOut) {
      fireEvent12(series, "mouseOut");
    }
    if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
      tooltip.hide();
    }
    chart.series.forEach(function(s) {
      s.setState("", true);
    });
  }
  /**
   * Set the state of the series. Called internally on mouse interaction
   * operations, but it can also be called directly to visually
   * highlight a series.
   *
   * @function Highcharts.Series#setState
   *
   * @param {Highcharts.SeriesStateValue|""} [state]
   *        The new state, can be either `'hover'`, `'inactive'`, `'select'`,
   *        or `''` (an empty string), `'normal'` or `undefined` to set to
   *        normal state.
   * @param {boolean} [inherit]
   *        Determines if state should be inherited by points too.
   */
  setState(state, inherit) {
    const series = this, options2 = series.options, graph = series.graph, inactiveOtherPoints = options2.inactiveOtherPoints, stateOptions = options2.states, stateAnimation = pick18(stateOptions[state || "normal"] && stateOptions[state || "normal"].animation, series.chart.options.chart.animation);
    let lineWidth = options2.lineWidth, opacity = options2.opacity;
    state = state || "";
    if (series.state !== state) {
      [
        series.group,
        series.markerGroup,
        series.dataLabelsGroup
      ].forEach(function(group) {
        if (group) {
          if (series.state) {
            group.removeClass("highcharts-series-" + series.state);
          }
          if (state) {
            group.addClass("highcharts-series-" + state);
          }
        }
      });
      series.state = state;
      if (!series.chart.styledMode) {
        if (stateOptions[state] && stateOptions[state].enabled === false) {
          return;
        }
        if (state) {
          lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0);
          opacity = pick18(stateOptions[state].opacity, opacity);
        }
        if (graph && !graph.dashstyle && isNumber18(lineWidth)) {
          for (const graphElement of [
            graph,
            ...this.zones.map((zone) => zone.graph)
          ]) {
            graphElement?.animate({
              "stroke-width": lineWidth
            }, stateAnimation);
          }
        }
        if (!inactiveOtherPoints) {
          [
            series.group,
            series.markerGroup,
            series.dataLabelsGroup,
            series.labelBySeries
          ].forEach(function(group) {
            if (group) {
              group.animate({
                opacity
              }, stateAnimation);
            }
          });
        }
      }
    }
    if (inherit && inactiveOtherPoints && series.points) {
      series.setAllPointsToState(state || void 0);
    }
  }
  /**
   * Set the state for all points in the series.
   *
   * @function Highcharts.Series#setAllPointsToState
   *
   * @private
   *
   * @param {string} [state]
   *        Can be either `hover` or undefined to set to normal state.
   */
  setAllPointsToState(state) {
    this.points.forEach(function(point) {
      if (point.setState) {
        point.setState(state);
      }
    });
  }
  /**
   * Show or hide the series.
   *
   * @function Highcharts.Series#setVisible
   *
   * @param {boolean} [visible]
   * True to show the series, false to hide. If undefined, the visibility is
   * toggled.
   *
   * @param {boolean} [redraw=true]
   * Whether to redraw the chart after the series is altered. If doing more
   * operations on the chart, it is a good idea to set redraw to false and
   * call {@link Chart#redraw|chart.redraw()} after.
   *
   * @emits Highcharts.Series#event:hide
   * @emits Highcharts.Series#event:show
   */
  setVisible(vis, redraw) {
    const series = this, chart = series.chart, ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries, oldVisibility = series.visible;
    series.visible = vis = series.options.visible = series.userOptions.visible = typeof vis === "undefined" ? !oldVisibility : vis;
    const showOrHide = vis ? "show" : "hide";
    [
      "group",
      "dataLabelsGroup",
      "markerGroup",
      "tracker",
      "tt"
    ].forEach((key) => {
      series[key]?.[showOrHide]();
    });
    if (chart.hoverSeries === series || chart.hoverPoint?.series === series) {
      series.onMouseOut();
    }
    if (series.legendItem) {
      chart.legend.colorizeItem(series, vis);
    }
    series.isDirty = true;
    if (series.options.stacking) {
      chart.series.forEach((otherSeries) => {
        if (otherSeries.options.stacking && otherSeries.visible) {
          otherSeries.isDirty = true;
        }
      });
    }
    series.linkedSeries.forEach((otherSeries) => {
      otherSeries.setVisible(vis, false);
    });
    if (ignoreHiddenSeries) {
      chart.isDirtyBox = true;
    }
    fireEvent12(series, showOrHide);
    if (redraw !== false) {
      chart.redraw();
    }
  }
  /**
   * Show the series if hidden.
   *
   * @sample highcharts/members/series-hide/
   *         Toggle visibility from a button
   *
   * @function Highcharts.Series#show
   * @emits Highcharts.Series#event:show
   */
  show() {
    this.setVisible(true);
  }
  /**
   * Hide the series if visible. If the
   * [chart.ignoreHiddenSeries](https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries)
   * option is true, the chart is redrawn without this series.
   *
   * @sample highcharts/members/series-hide/
   *         Toggle visibility from a button
   *
   * @function Highcharts.Series#hide
   * @emits Highcharts.Series#event:hide
   */
  hide() {
    this.setVisible(false);
  }
  /**
   * Select or unselect the series. This means its
   * {@link Highcharts.Series.selected|selected}
   * property is set, the checkbox in the legend is toggled and when selected,
   * the series is returned by the {@link Highcharts.Chart#getSelectedSeries}
   * function.
   *
   * @sample highcharts/members/series-select/
   *         Select a series from a button
   *
   * @function Highcharts.Series#select
   *
   * @param {boolean} [selected]
   * True to select the series, false to unselect. If undefined, the selection
   * state is toggled.
   *
   * @emits Highcharts.Series#event:select
   * @emits Highcharts.Series#event:unselect
   */
  select(selected) {
    const series = this;
    series.selected = selected = this.options.selected = typeof selected === "undefined" ? !series.selected : selected;
    if (series.checkbox) {
      series.checkbox.checked = selected;
    }
    fireEvent12(series, selected ? "select" : "unselect");
  }
  /**
   * Checks if a tooltip should be shown for a given point.
   *
   * @private
   */
  shouldShowTooltip(plotX, plotY, options2 = {}) {
    options2.series = this;
    options2.visiblePlotOnly = true;
    return this.chart.isInsidePlot(plotX, plotY, options2);
  }
  /**
   * Draws the legend symbol based on the legendSymbol user option.
   *
   * @private
   */
  drawLegendSymbol(legend, item) {
    LegendSymbol_default[this.options.legendSymbol || "rectangle"]?.call(this, legend, item);
  }
};
Series.defaultOptions = SeriesDefaults_default;
Series.types = SeriesRegistry_default.seriesTypes;
Series.registerType = SeriesRegistry_default.registerSeriesType;
Series.keepProps = [
  "colorIndex",
  "eventOptions",
  "navigatorSeries",
  "symbolIndex",
  "baseSeries"
];
Series.keepPropsForPoints = [
  "data",
  "isDirtyData",
  // GeoHeatMap interpolation
  "isDirtyCanvas",
  "points",
  "dataTable",
  "processedData",
  // #17057
  "xIncrement",
  "cropped",
  "_hasPointMarkers",
  "hasDataLabels",
  // Networkgraph (#14397)
  "nodes",
  "layout",
  // Treemap
  "level",
  // Map specific, consider moving it to series-specific preserve-
  // properties (#10617)
  "mapMap",
  "mapData",
  "minY",
  "maxY",
  "minX",
  "maxX",
  "transformGroups"
  // #18857
];
extend18(Series.prototype, {
  axisTypes: ["xAxis", "yAxis"],
  coll: "series",
  colorCounter: 0,
  directTouch: false,
  invertible: true,
  isCartesian: true,
  kdAxisArray: ["clientX", "plotY"],
  // Each point's x and y values are stored in this.xData and this.yData:
  parallelArrays: ["x", "y"],
  pointClass: Point_default,
  requireSorting: true,
  // Requires the data to be sorted:
  sorted: true
});
SeriesRegistry_default.series = Series;
var Series_default = Series;

// node_modules/highcharts/es-modules/Core/Legend/Legend.js
var { animObject: animObject7, setAnimation: setAnimation3 } = AnimationUtilities_default;
var { registerEventOptions: registerEventOptions3 } = Foundation_default;
var { composed: composed4, marginNames } = Globals_default;
var { distribute: distribute2 } = RendererUtilities_default;
var { format: format5 } = Templating_default;
var { addEvent: addEvent11, createElement: createElement6, css: css9, defined: defined15, discardElement: discardElement3, find: find4, fireEvent: fireEvent13, isNumber: isNumber19, merge: merge17, pick: pick19, pushUnique: pushUnique7, relativeLength: relativeLength3, stableSort: stableSort3, syncTimeout: syncTimeout7 } = Utilities_default;
var Legend = class {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Initialize the legend.
   *
   * @private
   * @function Highcharts.Legend#init
   *
   * @param {Highcharts.Chart} chart
   * The chart instance.
   *
   * @param {Highcharts.LegendOptions} options
   * Legend options.
   */
  constructor(chart, options2) {
    this.allItems = [];
    this.initialItemY = 0;
    this.itemHeight = 0;
    this.itemMarginBottom = 0;
    this.itemMarginTop = 0;
    this.itemX = 0;
    this.itemY = 0;
    this.lastItemY = 0;
    this.lastLineHeight = 0;
    this.legendHeight = 0;
    this.legendWidth = 0;
    this.maxItemWidth = 0;
    this.maxLegendWidth = 0;
    this.offsetWidth = 0;
    this.padding = 0;
    this.pages = [];
    this.symbolHeight = 0;
    this.symbolWidth = 0;
    this.titleHeight = 0;
    this.totalItemWidth = 0;
    this.widthOption = 0;
    this.chart = chart;
    this.setOptions(options2);
    if (options2.enabled) {
      this.render();
      registerEventOptions3(this, options2);
      addEvent11(this.chart, "endResize", function() {
        this.legend.positionCheckboxes();
      });
    }
    addEvent11(this.chart, "render", () => {
      if (this.options.enabled && this.proximate) {
        this.proximatePositions();
        this.positionItems();
      }
    });
  }
  /**
   * @private
   * @function Highcharts.Legend#setOptions
   * @param {Highcharts.LegendOptions} options
   */
  setOptions(options2) {
    const padding = pick19(options2.padding, 8);
    this.options = options2;
    if (!this.chart.styledMode) {
      this.itemStyle = options2.itemStyle;
      this.itemHiddenStyle = merge17(this.itemStyle, options2.itemHiddenStyle);
    }
    this.itemMarginTop = options2.itemMarginTop;
    this.itemMarginBottom = options2.itemMarginBottom;
    this.padding = padding;
    this.initialItemY = padding - 5;
    this.symbolWidth = pick19(options2.symbolWidth, 16);
    this.pages = [];
    this.proximate = options2.layout === "proximate" && !this.chart.inverted;
    this.baseline = void 0;
  }
  /**
   * Update the legend with new options. Equivalent to running `chart.update`
   * with a legend configuration option.
   *
   * @sample highcharts/legend/legend-update/
   *         Legend update
   *
   * @function Highcharts.Legend#update
   *
   * @param {Highcharts.LegendOptions} options
   * Legend options.
   *
   * @param {boolean} [redraw=true]
   * Whether to redraw the chart after the axis is altered. If doing more
   * operations on the chart, it is a good idea to set redraw to false and
   * call {@link Chart#redraw} after. Whether to redraw the chart.
   *
   * @emits Highcharts.Legends#event:afterUpdate
   */
  update(options2, redraw) {
    const chart = this.chart;
    this.setOptions(merge17(true, this.options, options2));
    if ("events" in this.options) {
      registerEventOptions3(this, this.options);
    }
    this.destroy();
    chart.isDirtyLegend = chart.isDirtyBox = true;
    if (pick19(redraw, true)) {
      chart.redraw();
    }
    fireEvent13(this, "afterUpdate", { redraw });
  }
  /**
   * Set the colors for the legend item.
   *
   * @private
   * @function Highcharts.Legend#colorizeItem
   * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item
   *        A Series or Point instance
   * @param {boolean} [visible=false]
   *        Dimmed or colored
   *
   * @todo
   * Make events official: Fires the event `afterColorizeItem`.
   */
  colorizeItem(item, visible) {
    const originalColor = item.color, { area, group, label, line: line2, symbol } = item.legendItem || {};
    if (item instanceof Series_default || item instanceof Point_default) {
      item.color = item.options?.legendSymbolColor || originalColor;
    }
    group?.[visible ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
    if (!this.chart.styledMode) {
      const { itemHiddenStyle = {} } = this, hiddenColor = itemHiddenStyle.color, { fillColor, fillOpacity, lineColor, marker } = item.options, colorizeHidden = (attr18) => {
        if (!visible) {
          if (attr18.fill) {
            attr18.fill = hiddenColor;
          }
          if (attr18.stroke) {
            attr18.stroke = hiddenColor;
          }
        }
        return attr18;
      };
      label?.css(merge17(visible ? this.itemStyle : itemHiddenStyle));
      line2?.attr(colorizeHidden({ stroke: lineColor || item.color }));
      if (symbol) {
        symbol.attr(colorizeHidden(marker && symbol.isMarker ? (
          // #585
          item.pointAttribs()
        ) : { fill: item.color }));
      }
      area?.attr(colorizeHidden({
        fill: fillColor || item.color,
        "fill-opacity": fillColor ? 1 : fillOpacity ?? 0.75
      }));
    }
    item.color = originalColor;
    fireEvent13(this, "afterColorizeItem", { item, visible });
  }
  /**
   * @private
   * @function Highcharts.Legend#positionItems
   */
  positionItems() {
    this.allItems.forEach(this.positionItem, this);
    if (!this.chart.isResizing) {
      this.positionCheckboxes();
    }
  }
  /**
   * Position the legend item.
   *
   * @private
   * @function Highcharts.Legend#positionItem
   * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item
   * The item to position
   */
  positionItem(item) {
    const legend = this, { group, x = 0, y = 0 } = item.legendItem || {}, options2 = legend.options, symbolPadding = options2.symbolPadding, ltr = !options2.rtl, checkbox = item.checkbox;
    if (group?.element) {
      const attribs = {
        translateX: ltr ? x : legend.legendWidth - x - 2 * symbolPadding - 4,
        translateY: y
      };
      const complete = () => {
        fireEvent13(this, "afterPositionItem", { item });
      };
      group[defined15(group.translateY) ? "animate" : "attr"](attribs, void 0, complete);
    }
    if (checkbox) {
      checkbox.x = x;
      checkbox.y = y;
    }
  }
  /**
   * Destroy a single legend item, used internally on removing series items.
   *
   * @private
   * @function Highcharts.Legend#destroyItem
   * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item
   * The item to remove
   */
  destroyItem(item) {
    const checkbox = item.checkbox, legendItem = item.legendItem || {};
    for (const key of ["group", "label", "line", "symbol"]) {
      if (legendItem[key]) {
        legendItem[key] = legendItem[key].destroy();
      }
    }
    if (checkbox) {
      discardElement3(checkbox);
    }
    item.legendItem = void 0;
  }
  /**
   * Destroy the legend. Used internally. To reflow objects, `chart.redraw`
   * must be called after destruction.
   *
   * @private
   * @function Highcharts.Legend#destroy
   */
  destroy() {
    const legend = this;
    for (const item of this.getAllItems()) {
      this.destroyItem(item);
    }
    for (const key of [
      "clipRect",
      "up",
      "down",
      "pager",
      "nav",
      "box",
      "title",
      "group"
    ]) {
      if (legend[key]) {
        legend[key] = legend[key].destroy();
      }
    }
    this.display = null;
  }
  /**
   * Position the checkboxes after the width is determined.
   *
   * @private
   * @function Highcharts.Legend#positionCheckboxes
   */
  positionCheckboxes() {
    const alignAttr = this.group?.alignAttr, clipHeight = this.clipHeight || this.legendHeight, titleHeight = this.titleHeight;
    let translateY;
    if (alignAttr) {
      translateY = alignAttr.translateY;
      this.allItems.forEach(function(item) {
        const checkbox = item.checkbox;
        let top;
        if (checkbox) {
          top = translateY + titleHeight + checkbox.y + (this.scrollOffset || 0) + 3;
          css9(checkbox, {
            left: alignAttr.translateX + item.checkboxOffset + checkbox.x - 20 + "px",
            top: top + "px",
            display: this.proximate || top > translateY - 6 && top < translateY + clipHeight - 6 ? "" : "none"
          });
        }
      }, this);
    }
  }
  /**
   * Render the legend title on top of the legend.
   *
   * @private
   * @function Highcharts.Legend#renderTitle
   */
  renderTitle() {
    const options2 = this.options, padding = this.padding, titleOptions = options2.title;
    let bBox, titleHeight = 0;
    if (titleOptions.text) {
      if (!this.title) {
        this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, void 0, void 0, void 0, options2.useHTML, void 0, "legend-title").attr({ zIndex: 1 });
        if (!this.chart.styledMode) {
          this.title.css(titleOptions.style);
        }
        this.title.add(this.group);
      }
      if (!titleOptions.width) {
        this.title.css({
          width: this.maxLegendWidth + "px"
        });
      }
      bBox = this.title.getBBox();
      titleHeight = bBox.height;
      this.offsetWidth = bBox.width;
      this.contentGroup.attr({ translateY: titleHeight });
    }
    this.titleHeight = titleHeight;
  }
  /**
   * Set the legend item text.
   *
   * @function Highcharts.Legend#setText
   * @param {Highcharts.Point|Highcharts.Series} item
   *        The item for which to update the text in the legend.
   */
  setText(item) {
    const options2 = this.options;
    item.legendItem.label.attr({
      text: options2.labelFormat ? format5(options2.labelFormat, item, this.chart) : options2.labelFormatter.call(item)
    });
  }
  /**
   * Render a single specific legend item. Called internally from the `render`
   * function.
   *
   * @private
   * @function Highcharts.Legend#renderItem
   * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item
   * The item to render.
   */
  renderItem(item) {
    const legend = this, legendItem = item.legendItem = item.legendItem || {}, chart = legend.chart, renderer = chart.renderer, options2 = legend.options, horizontal = options2.layout === "horizontal", symbolWidth = legend.symbolWidth, symbolPadding = options2.symbolPadding || 0, itemStyle = legend.itemStyle, itemHiddenStyle = legend.itemHiddenStyle, itemDistance = horizontal ? pick19(options2.itemDistance, 20) : 0, ltr = !options2.rtl, isSeries = !item.series, series = !isSeries && item.series.drawLegendSymbol ? item.series : item, seriesOptions = series.options, showCheckbox = !!legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox, useHTML = options2.useHTML, itemClassName = item.options.className;
    let label = legendItem.label, itemExtraWidth = symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
    if (!label) {
      legendItem.group = renderer.g("legend-item").addClass("highcharts-" + series.type + "-series highcharts-color-" + item.colorIndex + (itemClassName ? " " + itemClassName : "") + (isSeries ? " highcharts-series-" + item.index : "")).attr({ zIndex: 1 }).add(legend.scrollGroup);
      legendItem.label = label = renderer.text("", ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline || 0, useHTML);
      if (!chart.styledMode) {
        label.css(merge17(item.visible ? itemStyle : itemHiddenStyle));
      }
      label.attr({
        align: ltr ? "left" : "right",
        zIndex: 2
      }).add(legendItem.group);
      if (!legend.baseline) {
        legend.fontMetrics = renderer.fontMetrics(label);
        legend.baseline = legend.fontMetrics.f + 3 + legend.itemMarginTop;
        label.attr("y", legend.baseline);
        legend.symbolHeight = pick19(options2.symbolHeight, legend.fontMetrics.f);
        if (options2.squareSymbol) {
          legend.symbolWidth = pick19(options2.symbolWidth, Math.max(legend.symbolHeight, 16));
          itemExtraWidth = legend.symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
          if (ltr) {
            label.attr("x", legend.symbolWidth + symbolPadding);
          }
        }
      }
      series.drawLegendSymbol(legend, item);
      if (legend.setItemEvents) {
        legend.setItemEvents(item, label, useHTML);
      }
    }
    if (showCheckbox && !item.checkbox && legend.createCheckboxForItem) {
      legend.createCheckboxForItem(item);
    }
    legend.colorizeItem(item, item.visible);
    if (chart.styledMode || !itemStyle.width) {
      label.css({
        width: (options2.itemWidth || legend.widthOption || chart.spacingBox.width) - itemExtraWidth + "px"
      });
    }
    legend.setText(item);
    const bBox = label.getBBox();
    const fontMetricsH = legend.fontMetrics?.h || 0;
    item.itemWidth = item.checkboxOffset = options2.itemWidth || legendItem.labelWidth || bBox.width + itemExtraWidth;
    legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);
    legend.totalItemWidth += item.itemWidth;
    legend.itemHeight = item.itemHeight = Math.round(legendItem.labelHeight || // Use bBox for multiline (#16398)
    (bBox.height > fontMetricsH * 1.5 ? bBox.height : fontMetricsH));
  }
  /**
   * Get the position of the item in the layout. We now know the
   * maxItemWidth from the previous loop.
   *
   * @private
   * @function Highcharts.Legend#layoutItem
   * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item
   */
  layoutItem(item) {
    const options2 = this.options, padding = this.padding, horizontal = options2.layout === "horizontal", itemHeight = item.itemHeight, itemMarginBottom = this.itemMarginBottom, itemMarginTop = this.itemMarginTop, itemDistance = horizontal ? pick19(options2.itemDistance, 20) : 0, maxLegendWidth = this.maxLegendWidth, itemWidth = options2.alignColumns && this.totalItemWidth > maxLegendWidth ? this.maxItemWidth : item.itemWidth, legendItem = item.legendItem || {};
    if (horizontal && this.itemX - padding + itemWidth > maxLegendWidth) {
      this.itemX = padding;
      if (this.lastLineHeight) {
        this.itemY += itemMarginTop + this.lastLineHeight + itemMarginBottom;
      }
      this.lastLineHeight = 0;
    }
    this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;
    this.lastLineHeight = Math.max(
      // #915
      itemHeight,
      this.lastLineHeight
    );
    legendItem.x = this.itemX;
    legendItem.y = this.itemY;
    if (horizontal) {
      this.itemX += itemWidth;
    } else {
      this.itemY += itemMarginTop + itemHeight + itemMarginBottom;
      this.lastLineHeight = itemHeight;
    }
    this.offsetWidth = this.widthOption || Math.max((horizontal ? this.itemX - padding - (item.checkbox ? (
      // Decrease by itemDistance only when no checkbox #4853
      0
    ) : itemDistance) : itemWidth) + padding, this.offsetWidth);
  }
  /**
   * Get all items, which is one item per series for most series and one
   * item per point for pie series and its derivatives. Fires the event
   * `afterGetAllItems`.
   *
   * @private
   * @function Highcharts.Legend#getAllItems
   * @return {Array<(Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series)>}
   * The current items in the legend.
   * @emits Highcharts.Legend#event:afterGetAllItems
   */
  getAllItems() {
    let allItems = [];
    this.chart.series.forEach(function(series) {
      const seriesOptions = series?.options;
      if (series && pick19(seriesOptions.showInLegend, !defined15(seriesOptions.linkedTo) ? void 0 : false, true)) {
        allItems = allItems.concat(series.legendItem?.labels || (seriesOptions.legendType === "point" ? series.data : series));
      }
    });
    fireEvent13(this, "afterGetAllItems", { allItems });
    return allItems;
  }
  /**
   * Get a short, three letter string reflecting the alignment and layout.
   *
   * @private
   * @function Highcharts.Legend#getAlignment
   * @return {string}
   * The alignment, empty string if floating
   */
  getAlignment() {
    const options2 = this.options;
    if (this.proximate) {
      return options2.align.charAt(0) + "tv";
    }
    return options2.floating ? "" : options2.align.charAt(0) + options2.verticalAlign.charAt(0) + options2.layout.charAt(0);
  }
  /**
   * Adjust the chart margins by reserving space for the legend on only one
   * side of the chart. If the position is set to a corner, top or bottom is
   * reserved for horizontal legends and left or right for vertical ones.
   *
   * @private
   * @function Highcharts.Legend#adjustMargins
   * @param {Array<number>} margin
   * @param {Array<number>} spacing
   */
  adjustMargins(margin, spacing) {
    const chart = this.chart, options2 = this.options, alignment = this.getAlignment();
    if (alignment) {
      [
        /(lth|ct|rth)/,
        /(rtv|rm|rbv)/,
        /(rbh|cb|lbh)/,
        /(lbv|lm|ltv)/
      ].forEach(function(alignments, side) {
        if (alignments.test(alignment) && !defined15(margin[side])) {
          chart[marginNames[side]] = Math.max(chart[marginNames[side]], chart.legend[(side + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][side] * options2[side % 2 ? "x" : "y"] + pick19(options2.margin, 12) + spacing[side] + (chart.titleOffset[side] || 0));
        }
      });
    }
  }
  /**
   * @private
   * @function Highcharts.Legend#proximatePositions
   */
  proximatePositions() {
    const chart = this.chart, boxes = [], alignLeft = this.options.align === "left";
    this.allItems.forEach(function(item) {
      let lastPoint, height, useFirstPoint = alignLeft, target, top;
      if (item.yAxis) {
        if (item.xAxis.options.reversed) {
          useFirstPoint = !useFirstPoint;
        }
        if (item.points) {
          lastPoint = find4(useFirstPoint ? item.points : item.points.slice(0).reverse(), function(item2) {
            return isNumber19(item2.plotY);
          });
        }
        height = this.itemMarginTop + item.legendItem.label.getBBox().height + this.itemMarginBottom;
        top = item.yAxis.top - chart.plotTop;
        if (item.visible) {
          target = lastPoint ? lastPoint.plotY : item.yAxis.height;
          target += top - 0.3 * height;
        } else {
          target = top + item.yAxis.height;
        }
        boxes.push({
          target,
          size: height,
          item
        });
      }
    }, this);
    let legendItem;
    for (const box of distribute2(boxes, chart.plotHeight)) {
      legendItem = box.item.legendItem || {};
      if (isNumber19(box.pos)) {
        legendItem.y = chart.plotTop - chart.spacing[0] + box.pos;
      }
    }
  }
  /**
   * Render the legend. This method can be called both before and after
   * `chart.render`. If called after, it will only rearrange items instead
   * of creating new ones. Called internally on initial render and after
   * redraws.
   *
   * @private
   * @function Highcharts.Legend#render
   */
  render() {
    const legend = this, chart = legend.chart, renderer = chart.renderer, options2 = legend.options, padding = legend.padding, allItems = legend.getAllItems();
    let display, legendWidth, legendHeight, legendGroup = legend.group, allowedWidth, box = legend.box;
    legend.itemX = padding;
    legend.itemY = legend.initialItemY;
    legend.offsetWidth = 0;
    legend.lastItemY = 0;
    legend.widthOption = relativeLength3(options2.width, chart.spacingBox.width - padding);
    allowedWidth = chart.spacingBox.width - 2 * padding - options2.x;
    if (["rm", "lm"].indexOf(legend.getAlignment().substring(0, 2)) > -1) {
      allowedWidth /= 2;
    }
    legend.maxLegendWidth = legend.widthOption || allowedWidth;
    if (!legendGroup) {
      legend.group = legendGroup = renderer.g("legend").addClass(options2.className || "").attr({ zIndex: 7 }).add();
      legend.contentGroup = renderer.g().attr({ zIndex: 1 }).add(legendGroup);
      legend.scrollGroup = renderer.g().add(legend.contentGroup);
    }
    legend.renderTitle();
    stableSort3(allItems, (a, b) => (a.options?.legendIndex || 0) - (b.options?.legendIndex || 0));
    if (options2.reversed) {
      allItems.reverse();
    }
    legend.allItems = allItems;
    legend.display = display = !!allItems.length;
    legend.lastLineHeight = 0;
    legend.maxItemWidth = 0;
    legend.totalItemWidth = 0;
    legend.itemHeight = 0;
    allItems.forEach(legend.renderItem, legend);
    allItems.forEach(legend.layoutItem, legend);
    legendWidth = (legend.widthOption || legend.offsetWidth) + padding;
    legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
    legendHeight = legend.handleOverflow(legendHeight);
    legendHeight += padding;
    if (!box) {
      legend.box = box = renderer.rect().addClass("highcharts-legend-box").attr({
        r: options2.borderRadius
      }).add(legendGroup);
    }
    if (!chart.styledMode) {
      box.attr({
        stroke: options2.borderColor,
        "stroke-width": options2.borderWidth || 0,
        fill: options2.backgroundColor || "none"
      }).shadow(options2.shadow);
    }
    if (legendWidth > 0 && legendHeight > 0) {
      box[box.placed ? "animate" : "attr"](box.crisp.call({}, {
        x: 0,
        y: 0,
        width: legendWidth,
        height: legendHeight
      }, box.strokeWidth()));
    }
    legendGroup[display ? "show" : "hide"]();
    if (chart.styledMode && legendGroup.getStyle("display") === "none") {
      legendWidth = legendHeight = 0;
    }
    legend.legendWidth = legendWidth;
    legend.legendHeight = legendHeight;
    if (display) {
      legend.align();
    }
    if (!this.proximate) {
      this.positionItems();
    }
    fireEvent13(this, "afterRender");
  }
  /**
   * Align the legend to chart's box.
   *
   * @private
   * @function Highcharts.align
   * @param {Highcharts.BBoxObject} alignTo
   */
  align(alignTo = this.chart.spacingBox) {
    const chart = this.chart, options2 = this.options;
    let y = alignTo.y;
    if (/(lth|ct|rth)/.test(this.getAlignment()) && chart.titleOffset[0] > 0) {
      y += chart.titleOffset[0];
    } else if (/(lbh|cb|rbh)/.test(this.getAlignment()) && chart.titleOffset[2] > 0) {
      y -= chart.titleOffset[2];
    }
    if (y !== alignTo.y) {
      alignTo = merge17(alignTo, { y });
    }
    if (!chart.hasRendered) {
      this.group.placed = false;
    }
    this.group.align(merge17(options2, {
      width: this.legendWidth,
      height: this.legendHeight,
      verticalAlign: this.proximate ? "top" : options2.verticalAlign
    }), true, alignTo);
  }
  /**
   * Set up the overflow handling by adding navigation with up and down arrows
   * below the legend.
   *
   * @private
   * @function Highcharts.Legend#handleOverflow
   */
  handleOverflow(legendHeight) {
    const legend = this, chart = this.chart, renderer = chart.renderer, options2 = this.options, optionsY = options2.y, alignTop = options2.verticalAlign === "top", padding = this.padding, maxHeight = options2.maxHeight, navOptions = options2.navigation, animation = pick19(navOptions.animation, true), arrowSize = navOptions.arrowSize || 12, pages = this.pages, allItems = this.allItems, clipToHeight = function(height) {
      if (typeof height === "number") {
        clipRect.attr({
          height
        });
      } else if (clipRect) {
        legend.clipRect = clipRect.destroy();
        legend.contentGroup.clip();
      }
      if (legend.contentGroup.div) {
        legend.contentGroup.div.style.clip = height ? "rect(" + padding + "px,9999px," + (padding + height) + "px,0)" : "auto";
      }
    }, addTracker = function(key) {
      legend[key] = renderer.circle(0, 0, arrowSize * 1.3).translate(arrowSize / 2, arrowSize / 2).add(nav);
      if (!chart.styledMode) {
        legend[key].attr("fill", "rgba(0,0,0,0.0001)");
      }
      return legend[key];
    };
    let clipHeight, lastY, legendItem, lastLegendItem, spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - padding, nav = this.nav, clipRect = this.clipRect;
    if (options2.layout === "horizontal" && options2.verticalAlign !== "middle" && !options2.floating) {
      spaceHeight /= 2;
    }
    if (maxHeight) {
      spaceHeight = Math.min(spaceHeight, maxHeight);
    }
    pages.length = 0;
    if (legendHeight && spaceHeight > 0 && legendHeight > spaceHeight && navOptions.enabled !== false) {
      this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
      this.currentPage = pick19(this.currentPage, 1);
      this.fullHeight = legendHeight;
      allItems.forEach((item, i) => {
        legendItem = item.legendItem || {};
        const y = legendItem.y || 0, h = Math.round(legendItem.label.getBBox().height);
        let len = pages.length;
        if (!len || y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1]) {
          pages.push(lastY || y);
          len++;
        }
        legendItem.pageIx = len - 1;
        if (lastY && lastLegendItem) {
          lastLegendItem.pageIx = len - 1;
        }
        if (
          // Check the last item
          i === allItems.length - 1 && // If adding next page is needed (#18768)
          y + h - pages[len - 1] > clipHeight && y > pages[len - 1]
        ) {
          pages.push(y);
          legendItem.pageIx = len;
        }
        if (y !== lastY) {
          lastY = y;
        }
        lastLegendItem = legendItem;
      });
      if (!clipRect) {
        clipRect = legend.clipRect = renderer.clipRect(0, padding - 2, 9999, 0);
        legend.contentGroup.clip(clipRect);
      }
      clipToHeight(clipHeight);
      if (!nav) {
        this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
        this.up = renderer.symbol("triangle", 0, 0, arrowSize, arrowSize).add(nav);
        addTracker("upTracker").on("click", function() {
          legend.scroll(-1, animation);
        });
        this.pager = renderer.text("", 15, 10).addClass("highcharts-legend-navigation");
        if (!chart.styledMode && navOptions.style) {
          this.pager.css(navOptions.style);
        }
        this.pager.add(nav);
        this.down = renderer.symbol("triangle-down", 0, 0, arrowSize, arrowSize).add(nav);
        addTracker("downTracker").on("click", function() {
          legend.scroll(1, animation);
        });
      }
      legend.scroll(0);
      legendHeight = spaceHeight;
    } else if (nav) {
      clipToHeight();
      this.nav = nav.destroy();
      this.scrollGroup.attr({
        translateY: 1
      });
      this.clipHeight = 0;
    }
    return legendHeight;
  }
  /**
   * Scroll the legend by a number of pages.
   *
   * @private
   * @function Highcharts.Legend#scroll
   *
   * @param {number} scrollBy
   *        The number of pages to scroll.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
   *        Whether and how to apply animation.
   *
   */
  scroll(scrollBy, animation) {
    const chart = this.chart, pages = this.pages, pageCount = pages.length, clipHeight = this.clipHeight, navOptions = this.options.navigation, pager = this.pager, padding = this.padding;
    let currentPage = this.currentPage + scrollBy;
    if (currentPage > pageCount) {
      currentPage = pageCount;
    }
    if (currentPage > 0) {
      if (typeof animation !== "undefined") {
        setAnimation3(animation, chart);
      }
      this.nav.attr({
        translateX: padding,
        translateY: clipHeight + this.padding + 7 + this.titleHeight,
        visibility: "inherit"
      });
      [this.up, this.upTracker].forEach(function(elem) {
        elem.attr({
          "class": currentPage === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
        });
      });
      pager.attr({
        text: currentPage + "/" + pageCount
      });
      [this.down, this.downTracker].forEach(function(elem) {
        elem.attr({
          // Adjust to text width
          x: 18 + this.pager.getBBox().width,
          "class": currentPage === pageCount ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
        });
      }, this);
      if (!chart.styledMode) {
        this.up.attr({
          fill: currentPage === 1 ? navOptions.inactiveColor : navOptions.activeColor
        });
        this.upTracker.css({
          cursor: currentPage === 1 ? "default" : "pointer"
        });
        this.down.attr({
          fill: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor
        });
        this.downTracker.css({
          cursor: currentPage === pageCount ? "default" : "pointer"
        });
      }
      this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;
      this.scrollGroup.animate({
        translateY: this.scrollOffset
      });
      this.currentPage = currentPage;
      this.positionCheckboxes();
      const animOptions = animObject7(pick19(animation, chart.renderer.globalAnimation, true));
      syncTimeout7(() => {
        fireEvent13(this, "afterScroll", { currentPage });
      }, animOptions.duration);
    }
  }
  /**
   * @private
   * @function Highcharts.Legend#setItemEvents
   * @param {Highcharts.BubbleLegendItem|Point|Highcharts.Series} item
   * @param {Highcharts.SVGElement} legendLabel
   * @param {boolean} [useHTML=false]
   * @emits Highcharts.Legend#event:itemClick
   */
  setItemEvents(item, legendLabel, useHTML) {
    const legend = this, legendItem = item.legendItem || {}, boxWrapper = legend.chart.renderer.boxWrapper, isPoint = item instanceof Point_default, isSeries = item instanceof Series_default, activeClass = "highcharts-legend-" + (isPoint ? "point" : "series") + "-active", styledMode = legend.chart.styledMode, legendElements = useHTML ? [legendLabel, legendItem.symbol] : [legendItem.group];
    const setOtherItemsState = (state) => {
      legend.allItems.forEach((otherItem) => {
        if (item !== otherItem) {
          [otherItem].concat(otherItem.linkedSeries || []).forEach((otherItem2) => {
            otherItem2.setState(state, !isPoint);
          });
        }
      });
    };
    for (const element of legendElements) {
      if (element) {
        element.on("mouseover", function() {
          if (item.visible) {
            setOtherItemsState("inactive");
          }
          item.setState("hover");
          if (item.visible) {
            boxWrapper.addClass(activeClass);
          }
          if (!styledMode) {
            legendLabel.css(legend.options.itemHoverStyle);
          }
        }).on("mouseout", function() {
          if (!legend.chart.styledMode) {
            legendLabel.css(merge17(item.visible ? legend.itemStyle : legend.itemHiddenStyle));
          }
          setOtherItemsState("");
          boxWrapper.removeClass(activeClass);
          item.setState();
        }).on("click", function(event) {
          const defaultItemClick = function() {
            if (item.setVisible) {
              item.setVisible();
            }
            setOtherItemsState(item.visible ? "inactive" : "");
          };
          boxWrapper.removeClass(activeClass);
          fireEvent13(legend, "itemClick", {
            // Pass over the click/touch event. #4.
            browserEvent: event,
            legendItem: item
          }, defaultItemClick);
          if (isPoint) {
            item.firePointEvent("legendItemClick", {
              browserEvent: event
            });
          } else if (isSeries) {
            fireEvent13(item, "legendItemClick", {
              browserEvent: event
            });
          }
        });
      }
    }
  }
  /**
   * @private
   * @function Highcharts.Legend#createCheckboxForItem
   * @param {Highcharts.BubbleLegendItem|Point|Highcharts.Series} item
   * @emits Highcharts.Series#event:checkboxClick
   */
  createCheckboxForItem(item) {
    const legend = this;
    item.checkbox = createElement6("input", {
      type: "checkbox",
      className: "highcharts-legend-checkbox",
      checked: item.selected,
      defaultChecked: item.selected
      // Required by IE7
    }, legend.options.itemCheckboxStyle, legend.chart.container);
    addEvent11(item.checkbox, "click", function(event) {
      const target = event.target;
      fireEvent13(item.series || item, "checkboxClick", {
        checked: target.checked,
        item
      }, function() {
        item.select();
      });
    });
  }
};
(function(Legend2) {
  function compose27(ChartClass) {
    if (pushUnique7(composed4, "Core.Legend")) {
      addEvent11(ChartClass, "beforeMargins", function() {
        this.legend = new Legend2(this, this.options.legend);
      });
    }
  }
  Legend2.compose = compose27;
})(Legend || (Legend = {}));
var Legend_default = Legend;

// node_modules/highcharts/es-modules/Core/Chart/Chart.js
var { animate: animate3, animObject: animObject8, setAnimation: setAnimation4 } = AnimationUtilities_default;
var { defaultOptions: defaultOptions8 } = Defaults_default;
var { numberFormat: numberFormat2 } = Templating_default;
var { registerEventOptions: registerEventOptions4 } = Foundation_default;
var { charts: charts4, doc: doc6, marginNames: marginNames2, svg: svg3, win: win10 } = Globals_default;
var { seriesTypes: seriesTypes2 } = SeriesRegistry_default;
var { addEvent: addEvent12, attr: attr9, createElement: createElement7, css: css10, defined: defined16, diffObjects: diffObjects3, discardElement: discardElement4, erase: erase8, error: error6, extend: extend19, find: find5, fireEvent: fireEvent14, getAlignFactor: getAlignFactor7, getStyle: getStyle3, isArray: isArray10, isNumber: isNumber20, isObject: isObject10, isString: isString12, merge: merge18, objectEach: objectEach15, pick: pick20, pInt: pInt6, relativeLength: relativeLength4, removeEvent: removeEvent7, splat: splat7, syncTimeout: syncTimeout8, uniqueKey: uniqueKey6 } = Utilities_default;
var Chart = class _Chart {
  /**
   * Factory function for basic charts.
   *
   * @example
   * // Render a chart in to div#container
   * let chart = Highcharts.chart('container', {
   *     title: {
   *         text: 'My chart'
   *     },
   *     series: [{
   *         data: [1, 3, 2, 4]
   *     }]
   * });
   *
   * @function Highcharts.chart
   *
   * @param {string|Highcharts.HTMLDOMElement} [renderTo]
   * The DOM element to render to, or its id.
   *
   * @param {Highcharts.Options} options
   * The chart options structure.
   *
   * @param {Highcharts.ChartCallbackFunction} [callback]
   * Function to run when the chart has loaded and all external images are
   * loaded. Defining a
   * [chart.events.load](https://api.highcharts.com/highcharts/chart.events.load)
   * handler is equivalent.
   *
   * @return {Highcharts.Chart}
   * Returns the Chart object.
   */
  static chart(a, b, c) {
    return new _Chart(a, b, c);
  }
  // Implementation
  constructor(a, b, c) {
    this.sharedClips = {};
    const args = [
      // ES5 builds fail unless we cast it to an Array
      ...arguments
    ];
    if (isString12(a) || a.nodeName) {
      this.renderTo = args.shift();
    }
    this.init(args[0], args[1]);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Function setting zoom options after chart init and after chart update.
   * Offers support for deprecated options.
   *
   * @private
   * @function Highcharts.Chart#setZoomOptions
   */
  setZoomOptions() {
    const chart = this, options2 = chart.options.chart, zooming = options2.zooming;
    chart.zooming = {
      ...zooming,
      type: pick20(options2.zoomType, zooming.type),
      key: pick20(options2.zoomKey, zooming.key),
      pinchType: pick20(options2.pinchType, zooming.pinchType),
      singleTouch: pick20(options2.zoomBySingleTouch, zooming.singleTouch, false),
      resetButton: merge18(zooming.resetButton, options2.resetZoomButton)
    };
  }
  /**
   * Overridable function that initializes the chart. The constructor's
   * arguments are passed on directly.
   *
   * @function Highcharts.Chart#init
   *
   * @param {Highcharts.Options} userOptions
   *        Custom options.
   *
   * @param {Function} [callback]
   *        Function to run when the chart has loaded and all external
   *        images are loaded.
   *
   *
   * @emits Highcharts.Chart#event:init
   * @emits Highcharts.Chart#event:afterInit
   */
  init(userOptions, callback) {
    fireEvent14(this, "init", { args: arguments }, function() {
      const options2 = merge18(defaultOptions8, userOptions), optionsChart = options2.chart, renderTo = this.renderTo || optionsChart.renderTo;
      this.userOptions = extend19({}, userOptions);
      if (!(this.renderTo = isString12(renderTo) ? doc6.getElementById(renderTo) : renderTo)) {
        error6(13, true, this);
      }
      this.margin = [];
      this.spacing = [];
      this.labelCollectors = [];
      this.callback = callback;
      this.isResizing = 0;
      this.options = options2;
      this.axes = [];
      this.series = [];
      this.locale = options2.lang.locale ?? this.renderTo.closest("[lang]")?.lang;
      this.time = new Time_default(extend19(options2.time || {}, {
        locale: this.locale
      }), options2.lang);
      options2.time = this.time.options;
      this.numberFormatter = (optionsChart.numberFormatter || numberFormat2).bind(this);
      this.styledMode = optionsChart.styledMode;
      this.hasCartesianSeries = optionsChart.showAxes;
      const chart = this;
      chart.index = charts4.length;
      charts4.push(chart);
      Globals_default.chartCount++;
      registerEventOptions4(this, optionsChart);
      chart.xAxis = [];
      chart.yAxis = [];
      chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;
      this.setZoomOptions();
      fireEvent14(chart, "afterInit");
      chart.firstRender();
    });
  }
  /**
   * Internal function to unitialize an individual series.
   *
   * @private
   * @function Highcharts.Chart#initSeries
   */
  initSeries(options2) {
    const chart = this, optionsChart = chart.options.chart, type = options2.type || optionsChart.type, SeriesClass = seriesTypes2[type];
    if (!SeriesClass) {
      error6(17, true, chart, { missingModuleFor: type });
    }
    const series = new SeriesClass();
    if (typeof series.init === "function") {
      series.init(chart, options2);
    }
    return series;
  }
  /**
   * Internal function to set data for all series with enabled sorting.
   *
   * @private
   * @function Highcharts.Chart#setSortedData
   */
  setSortedData() {
    this.getSeriesOrderByLinks().forEach(function(series) {
      if (!series.points && !series.data && series.enabledDataSorting) {
        series.setData(series.options.data, false);
      }
    });
  }
  /**
   * Sort and return chart series in order depending on the number of linked
   * series.
   *
   * @private
   * @function Highcharts.Series#getSeriesOrderByLinks
   */
  getSeriesOrderByLinks() {
    return this.series.concat().sort(function(a, b) {
      if (a.linkedSeries.length || b.linkedSeries.length) {
        return b.linkedSeries.length - a.linkedSeries.length;
      }
      return 0;
    });
  }
  /**
   * Order all series or axes above a given index. When series or axes are
   * added and ordered by configuration, only the last series is handled
   * (#248, #1123, #2456, #6112). This function is called on series and axis
   * initialization and destroy.
   *
   * @private
   * @function Highcharts.Chart#orderItems
   * @param {string} coll The collection name
   * @param {number} [fromIndex=0]
   * If this is given, only the series above this index are handled.
   */
  orderItems(coll, fromIndex = 0) {
    const collection = this[coll], optionsArray = this.options[coll] = splat7(this.options[coll]).slice(), userOptionsArray = this.userOptions[coll] = this.userOptions[coll] ? splat7(this.userOptions[coll]).slice() : [];
    if (this.hasRendered) {
      optionsArray.splice(fromIndex);
      userOptionsArray.splice(fromIndex);
    }
    if (collection) {
      for (let i = fromIndex, iEnd = collection.length; i < iEnd; ++i) {
        const item = collection[i];
        if (item) {
          item.index = i;
          if (item instanceof Series_default) {
            item.name = item.getName();
          }
          if (!item.options.isInternal) {
            optionsArray[i] = item.options;
            userOptionsArray[i] = item.userOptions;
          }
        }
      }
    }
  }
  /**
   * Get the clipping for a series. Could be called for a series to initialate
   * animating the clip or to set the final clip (only width and x).
   *
   * @private
   * @function Highcharts.Chart#getClipBox
   */
  getClipBox(series, chartCoords) {
    const inverted = this.inverted, { xAxis: xAxis2, yAxis: yAxis2 } = series || {};
    let { x, y, width, height } = merge18(this.clipBox);
    if (series) {
      if (xAxis2 && xAxis2.len !== this.plotSizeX) {
        width = xAxis2.len;
      }
      if (yAxis2 && yAxis2.len !== this.plotSizeY) {
        height = yAxis2.len;
      }
      if (inverted && !series.invertible) {
        [width, height] = [height, width];
      }
    }
    if (chartCoords) {
      x += (inverted ? yAxis2 : xAxis2)?.pos ?? this.plotLeft;
      y += (inverted ? xAxis2 : yAxis2)?.pos ?? this.plotTop;
    }
    return { x, y, width, height };
  }
  /**
   * Check whether a given point is within the plot area.
   *
   * @function Highcharts.Chart#isInsidePlot
   *
   * @param {number} plotX
   * Pixel x relative to the plot area.
   *
   * @param {number} plotY
   * Pixel y relative to the plot area.
   *
   * @param {Highcharts.ChartIsInsideOptionsObject} [options]
   * Options object.
   *
   * @return {boolean}
   * Returns true if the given point is inside the plot area.
   */
  isInsidePlot(plotX, plotY, options2 = {}) {
    const { inverted, plotBox, plotLeft, plotTop, scrollablePlotBox } = this, { scrollLeft = 0, scrollTop = 0 } = options2.visiblePlotOnly && this.scrollablePlotArea?.scrollingContainer || {}, series = options2.series, box = options2.visiblePlotOnly && scrollablePlotBox || plotBox, x = options2.inverted ? plotY : plotX, y = options2.inverted ? plotX : plotY, e = {
      x,
      y,
      isInsidePlot: true,
      options: options2
    };
    if (!options2.ignoreX) {
      const xAxis2 = series && (inverted && !this.polar ? series.yAxis : series.xAxis) || {
        pos: plotLeft,
        len: Infinity
      };
      const chartX = options2.paneCoordinates ? xAxis2.pos + x : plotLeft + x;
      if (!(chartX >= Math.max(scrollLeft + plotLeft, xAxis2.pos) && chartX <= Math.min(scrollLeft + plotLeft + box.width, xAxis2.pos + xAxis2.len))) {
        e.isInsidePlot = false;
      }
    }
    if (!options2.ignoreY && e.isInsidePlot) {
      const yAxis2 = !inverted && options2.axis && !options2.axis.isXAxis && options2.axis || series && (inverted ? series.xAxis : series.yAxis) || {
        pos: plotTop,
        len: Infinity
      };
      const chartY = options2.paneCoordinates ? yAxis2.pos + y : plotTop + y;
      if (!(chartY >= Math.max(scrollTop + plotTop, yAxis2.pos) && chartY <= Math.min(scrollTop + plotTop + box.height, yAxis2.pos + yAxis2.len))) {
        e.isInsidePlot = false;
      }
    }
    fireEvent14(this, "afterIsInsidePlot", e);
    return e.isInsidePlot;
  }
  /**
   * Redraw the chart after changes have been done to the data, axis extremes
   * chart size or chart elements. All methods for updating axes, series or
   * points have a parameter for redrawing the chart. This is `true` by
   * default. But in many cases you want to do more than one operation on the
   * chart before redrawing, for example add a number of points. In those
   * cases it is a waste of resources to redraw the chart for each new point
   * added. So you add the points and call `chart.redraw()` after.
   *
   * @function Highcharts.Chart#redraw
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
   * If or how to apply animation to the redraw. When `undefined`, it applies
   * the animation that is set in the `chart.animation` option.
   *
   * @emits Highcharts.Chart#event:afterSetExtremes
   * @emits Highcharts.Chart#event:beforeRedraw
   * @emits Highcharts.Chart#event:predraw
   * @emits Highcharts.Chart#event:redraw
   * @emits Highcharts.Chart#event:render
   * @emits Highcharts.Chart#event:updatedData
   */
  redraw(animation) {
    fireEvent14(this, "beforeRedraw");
    const chart = this, axes = chart.hasCartesianSeries ? chart.axes : chart.colorAxis || [], series = chart.series, pointer = chart.pointer, legend = chart.legend, legendUserOptions = chart.userOptions.legend, renderer = chart.renderer, isHiddenChart = renderer.isHidden(), afterRedraw = [];
    let hasDirtyStacks, hasStackedSeries, i, isDirtyBox = chart.isDirtyBox, redrawLegend = chart.isDirtyLegend, serie;
    renderer.rootFontSize = renderer.boxWrapper.getStyle("font-size");
    if (chart.setResponsive) {
      chart.setResponsive(false);
    }
    setAnimation4(chart.hasRendered ? animation : false, chart);
    if (isHiddenChart) {
      chart.temporaryDisplay();
    }
    chart.layOutTitles(false);
    i = series.length;
    while (i--) {
      serie = series[i];
      if (serie.options.stacking || serie.options.centerInCategory) {
        hasStackedSeries = true;
        if (serie.isDirty) {
          hasDirtyStacks = true;
          break;
        }
      }
    }
    if (hasDirtyStacks) {
      i = series.length;
      while (i--) {
        serie = series[i];
        if (serie.options.stacking) {
          serie.isDirty = true;
        }
      }
    }
    series.forEach(function(serie2) {
      if (serie2.isDirty) {
        if (serie2.options.legendType === "point") {
          if (typeof serie2.updateTotals === "function") {
            serie2.updateTotals();
          }
          redrawLegend = true;
        } else if (legendUserOptions && (!!legendUserOptions.labelFormatter || legendUserOptions.labelFormat)) {
          redrawLegend = true;
        }
      }
      if (serie2.isDirtyData) {
        fireEvent14(serie2, "updatedData");
      }
    });
    if (redrawLegend && legend && legend.options.enabled) {
      legend.render();
      chart.isDirtyLegend = false;
    }
    if (hasStackedSeries) {
      chart.getStacks();
    }
    axes.forEach(function(axis) {
      axis.updateNames();
      axis.setScale();
    });
    chart.getMargins();
    axes.forEach(function(axis) {
      if (axis.isDirty) {
        isDirtyBox = true;
      }
    });
    axes.forEach(function(axis) {
      const key = axis.min + "," + axis.max;
      if (axis.extKey !== key) {
        axis.extKey = key;
        afterRedraw.push(function() {
          fireEvent14(axis, "afterSetExtremes", extend19(axis.eventArgs, axis.getExtremes()));
          delete axis.eventArgs;
        });
      }
      if (isDirtyBox || hasStackedSeries) {
        axis.redraw();
      }
    });
    if (isDirtyBox) {
      chart.drawChartBox();
    }
    fireEvent14(chart, "predraw");
    series.forEach(function(serie2) {
      if ((isDirtyBox || serie2.isDirty) && serie2.visible) {
        serie2.redraw();
      }
      serie2.isDirtyData = false;
    });
    if (pointer) {
      pointer.reset(true);
    }
    renderer.draw();
    fireEvent14(chart, "redraw");
    fireEvent14(chart, "render");
    if (isHiddenChart) {
      chart.temporaryDisplay(true);
    }
    afterRedraw.forEach(function(callback) {
      callback.call();
    });
  }
  /**
   * Get an axis, series or point object by `id` as given in the configuration
   * options. Returns `undefined` if no item is found.
   *
   * @sample highcharts/plotoptions/series-id/
   *         Get series by id
   *
   * @function Highcharts.Chart#get
   *
   * @param {string} id
   * The id as given in the configuration options.
   *
   * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}
   * The retrieved item.
   */
  get(id) {
    const series = this.series;
    function itemById(item) {
      return item.id === id || item.options && item.options.id === id;
    }
    let ret = (
      // Search axes
      find5(this.axes, itemById) || // Search series
      find5(this.series, itemById)
    );
    for (let i = 0; !ret && i < series.length; i++) {
      ret = find5(series[i].points || [], itemById);
    }
    return ret;
  }
  /**
   * Create the Axis instances based on the config options.
   *
   * @private
   * @function Highcharts.Chart#createAxes
   * @emits Highcharts.Chart#event:afterCreateAxes
   * @emits Highcharts.Chart#event:createAxes
   */
  createAxes() {
    const options2 = this.userOptions;
    fireEvent14(this, "createAxes");
    for (const coll of ["xAxis", "yAxis"]) {
      const arr = options2[coll] = splat7(options2[coll] || {});
      for (const axisOptions of arr) {
        new Axis_default(this, axisOptions, coll);
      }
    }
    fireEvent14(this, "afterCreateAxes");
  }
  /**
   * Returns an array of all currently selected points in the chart. Points
   * can be selected by clicking or programmatically by the
   * {@link Highcharts.Point#select}
   * function.
   *
   * @sample highcharts/plotoptions/series-allowpointselect-line/
   *         Get selected points
   * @sample highcharts/members/point-select-lasso/
   *         Lasso selection
   * @sample highcharts/chart/events-selection-points/
   *         Rectangle selection
   *
   * @function Highcharts.Chart#getSelectedPoints
   *
   * @return {Array<Highcharts.Point>}
   *         The currently selected points.
   */
  getSelectedPoints() {
    return this.series.reduce((acc, series) => {
      series.getPointsCollection().forEach((point) => {
        if (pick20(point.selectedStaging, point.selected)) {
          acc.push(point);
        }
      });
      return acc;
    }, []);
  }
  /**
   * Returns an array of all currently selected series in the chart. Series
   * can be selected either programmatically by the
   * {@link Highcharts.Series#select}
   * function or by checking the checkbox next to the legend item if
   * [series.showCheckBox](https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox)
   * is true.
   *
   * @sample highcharts/members/chart-getselectedseries/
   *         Get selected series
   *
   * @function Highcharts.Chart#getSelectedSeries
   *
   * @return {Array<Highcharts.Series>}
   *         The currently selected series.
   */
  getSelectedSeries() {
    return this.series.filter((s) => s.selected);
  }
  /**
   * Set a new title or subtitle for the chart.
   *
   * @sample highcharts/members/chart-settitle/
   *         Set title text and styles
   *
   * @function Highcharts.Chart#setTitle
   *
   * @param {Highcharts.TitleOptions} [titleOptions]
   *        New title options. The title text itself is set by the
   *        `titleOptions.text` property.
   *
   * @param {Highcharts.SubtitleOptions} [subtitleOptions]
   *        New subtitle options. The subtitle text itself is set by the
   *        `subtitleOptions.text` property.
   *
   * @param {boolean} [redraw]
   *        Whether to redraw the chart or wait for a later call to
   *        `chart.redraw()`.
   */
  setTitle(titleOptions, subtitleOptions, redraw) {
    this.applyDescription("title", titleOptions);
    this.applyDescription("subtitle", subtitleOptions);
    this.applyDescription("caption", void 0);
    this.layOutTitles(redraw);
  }
  /**
   * Apply a title, subtitle or caption for the chart
   *
   * @private
   * @function Highcharts.Chart#applyDescription
   * @param key {string}
   * Either title, subtitle or caption
   * @param {Highcharts.TitleOptions|Highcharts.SubtitleOptions|Highcharts.CaptionOptions|undefined} explicitOptions
   * The options to set, will be merged with default options.
   */
  applyDescription(key, explicitOptions) {
    const chart = this;
    const options2 = this.options[key] = merge18(this.options[key], explicitOptions);
    let elem = this[key];
    if (elem && explicitOptions) {
      this[key] = elem = elem.destroy();
    }
    if (options2 && !elem) {
      elem = this.renderer.text(options2.text, 0, 0, options2.useHTML).attr({
        align: options2.align,
        "class": "highcharts-" + key,
        zIndex: options2.zIndex || 4
      }).css({
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      }).add();
      elem.update = function(updateOptions, redraw) {
        chart.applyDescription(key, updateOptions);
        chart.layOutTitles(redraw);
      };
      if (!this.styledMode) {
        elem.css(extend19(key === "title" ? {
          // #2944
          fontSize: this.options.isStock ? "1em" : "1.2em"
        } : {}, options2.style));
      }
      elem.textPxLength = elem.getBBox().width;
      elem.css({ whiteSpace: options2.style?.whiteSpace });
      this[key] = elem;
    }
  }
  /**
   * Internal function to lay out the chart title, subtitle and caption, and
   * cache the full offset height for use in `getMargins`. The result is
   * stored in `this.titleOffset`.
   *
   * @private
   * @function Highcharts.Chart#layOutTitles
   *
   * @param {boolean} [redraw=true]
   * @emits Highcharts.Chart#event:afterLayOutTitles
   */
  layOutTitles(redraw = true) {
    const titleOffset = [0, 0, 0], { options: options2, renderer, spacingBox } = this;
    ["title", "subtitle", "caption"].forEach((key) => {
      const desc = this[key], descOptions = this.options[key], alignTo = merge18(spacingBox), textPxLength = desc?.textPxLength || 0;
      if (desc && descOptions) {
        fireEvent14(this, "layOutTitle", { alignTo, key, textPxLength });
        const fontMetrics = renderer.fontMetrics(desc), baseline = fontMetrics.b, lineHeight = fontMetrics.h, verticalAlign = descOptions.verticalAlign || "top", topAligned = verticalAlign === "top", minScale = topAligned && descOptions.minScale || 1, offset3 = key === "title" ? topAligned ? -3 : 0 : (
          // Floating subtitle (#6574)
          topAligned ? titleOffset[0] + 2 : 0
        ), uncappedScale = Math.min(alignTo.width / textPxLength, 1), scale = Math.max(minScale, uncappedScale), alignAttr = merge18({
          y: verticalAlign === "bottom" ? baseline : offset3 + baseline
        }, {
          align: key === "title" ? (
            // Title defaults to center for short titles,
            // left for word-wrapped titles
            uncappedScale < minScale ? "left" : "center"
          ) : (
            // Subtitle defaults to the title.align
            this.title?.alignValue
          )
        }, descOptions), width = (descOptions.width || (uncappedScale > minScale ? (
          // One line
          this.chartWidth
        ) : (
          // Allow word wrap
          alignTo.width
        )) / scale) + "px";
        if (desc.alignValue !== alignAttr.align) {
          desc.placed = false;
        }
        const height = Math.round(desc.css({ width }).getBBox(descOptions.useHTML).height);
        alignAttr.height = height;
        desc.align(alignAttr, false, alignTo).attr({
          align: alignAttr.align,
          scaleX: scale,
          scaleY: scale,
          "transform-origin": `${alignTo.x + textPxLength * scale * getAlignFactor7(alignAttr.align)} ${lineHeight}`
        });
        if (!descOptions.floating) {
          const offset4 = height * // When scaling down the title, preserve the offset as
          // long as it's only one line, but scale down the offset
          // if the title wraps to multiple lines.
          (height < lineHeight * 1.2 ? 1 : scale);
          if (verticalAlign === "top") {
            titleOffset[0] = Math.ceil(titleOffset[0] + offset4);
          } else if (verticalAlign === "bottom") {
            titleOffset[2] = Math.ceil(titleOffset[2] + offset4);
          }
        }
      }
    }, this);
    if (titleOffset[0] && (options2.title?.verticalAlign || "top") === "top") {
      titleOffset[0] += options2.title?.margin || 0;
    }
    if (titleOffset[2] && options2.caption?.verticalAlign === "bottom") {
      titleOffset[2] += options2.caption?.margin || 0;
    }
    const requiresDirtyBox = !this.titleOffset || this.titleOffset.join(",") !== titleOffset.join(",");
    this.titleOffset = titleOffset;
    fireEvent14(this, "afterLayOutTitles");
    if (!this.isDirtyBox && requiresDirtyBox) {
      this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox;
      if (this.hasRendered && redraw && this.isDirtyBox) {
        this.redraw();
      }
    }
  }
  /**
   * Internal function to get the available size of the container element
   *
   * @private
   * @function Highcharts.Chart#getContainerBox
   */
  getContainerBox() {
    const nonContainers = [].map.call(this.renderTo.children, (child) => {
      if (child !== this.container) {
        const display = child.style.display;
        child.style.display = "none";
        return [child, display];
      }
    }), box = {
      width: getStyle3(this.renderTo, "width", true) || 0,
      height: getStyle3(this.renderTo, "height", true) || 0
    };
    nonContainers.filter(Boolean).forEach(([div, display]) => {
      div.style.display = display;
    });
    return box;
  }
  /**
   * Internal function to get the chart width and height according to options
   * and container size. Sets {@link Chart.chartWidth} and
   * {@link Chart.chartHeight}.
   *
   * @private
   * @function Highcharts.Chart#getChartSize
   */
  getChartSize() {
    const chart = this, optionsChart = chart.options.chart, widthOption = optionsChart.width, heightOption = optionsChart.height, containerBox = chart.getContainerBox(), enableDefaultHeight = containerBox.height <= 1 || // #21510, prevent infinite reflow
    !chart.renderTo.parentElement?.style.height && chart.renderTo.style.height === "100%";
    chart.chartWidth = Math.max(
      // #1393
      0,
      widthOption || containerBox.width || 600
      // #1460
    );
    chart.chartHeight = Math.max(0, relativeLength4(heightOption, chart.chartWidth) || (enableDefaultHeight ? 400 : containerBox.height));
    chart.containerBox = containerBox;
  }
  /**
   * If the renderTo element has no offsetWidth, most likely one or more of
   * its parents are hidden. Loop up the DOM tree to temporarily display the
   * parents, then save the original display properties, and when the true
   * size is retrieved, reset them. Used on first render and on redraws.
   *
   * @private
   * @function Highcharts.Chart#temporaryDisplay
   *
   * @param {boolean} [revert]
   * Revert to the saved original styles.
   */
  temporaryDisplay(revert) {
    let node = this.renderTo, tempStyle;
    if (!revert) {
      while (node?.style) {
        if (!doc6.body.contains(node) && !node.parentNode) {
          node.hcOrigDetached = true;
          doc6.body.appendChild(node);
        }
        if (getStyle3(node, "display", false) === "none" || node.hcOricDetached) {
          node.hcOrigStyle = {
            display: node.style.display,
            height: node.style.height,
            overflow: node.style.overflow
          };
          tempStyle = {
            display: "block",
            overflow: "hidden"
          };
          if (node !== this.renderTo) {
            tempStyle.height = 0;
          }
          css10(node, tempStyle);
          if (!node.offsetWidth) {
            node.style.setProperty("display", "block", "important");
          }
        }
        node = node.parentNode;
        if (node === doc6.body) {
          break;
        }
      }
    } else {
      while (node?.style) {
        if (node.hcOrigStyle) {
          css10(node, node.hcOrigStyle);
          delete node.hcOrigStyle;
        }
        if (node.hcOrigDetached) {
          doc6.body.removeChild(node);
          node.hcOrigDetached = false;
        }
        node = node.parentNode;
      }
    }
  }
  /**
   * Set the {@link Chart.container|chart container's} class name, in
   * addition to `highcharts-container`.
   *
   * @function Highcharts.Chart#setClassName
   *
   * @param {string} [className]
   * The additional class name.
   */
  setClassName(className) {
    this.container.className = "highcharts-container " + (className || "");
  }
  /**
   * Get the containing element, determine the size and create the inner
   * container div to hold the chart.
   *
   * @private
   * @function Highcharts.Chart#afterGetContainer
   * @emits Highcharts.Chart#event:afterGetContainer
   */
  getContainer() {
    const chart = this, options2 = chart.options, optionsChart = options2.chart, indexAttrName = "data-highcharts-chart", containerId = uniqueKey6(), renderTo = chart.renderTo;
    let containerStyle;
    const oldChartIndex = pInt6(attr9(renderTo, indexAttrName));
    if (isNumber20(oldChartIndex) && charts4[oldChartIndex] && charts4[oldChartIndex].hasRendered) {
      charts4[oldChartIndex].destroy();
    }
    attr9(renderTo, indexAttrName, chart.index);
    renderTo.innerHTML = AST_default.emptyHTML;
    if (!optionsChart.skipClone && !renderTo.offsetWidth) {
      chart.temporaryDisplay();
    }
    chart.getChartSize();
    const chartHeight = chart.chartHeight;
    let chartWidth = chart.chartWidth;
    css10(renderTo, { overflow: "hidden" });
    if (!chart.styledMode) {
      containerStyle = extend19({
        position: "relative",
        // Needed for context menu (avoidscrollbars) and content
        // overflow in IE
        overflow: "hidden",
        width: chartWidth + "px",
        height: chartHeight + "px",
        textAlign: "left",
        lineHeight: "normal",
        // #427
        zIndex: 0,
        // #1072
        "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
        userSelect: "none",
        // #13503
        "touch-action": "manipulation",
        outline: "none",
        padding: "0px"
      }, optionsChart.style || {});
    }
    const container = createElement7("div", {
      id: containerId
    }, containerStyle, renderTo);
    chart.container = container;
    chart.getChartSize();
    if (chartWidth !== chart.chartWidth) {
      chartWidth = chart.chartWidth;
      if (!chart.styledMode) {
        css10(container, {
          width: pick20(optionsChart.style?.width, chartWidth + "px")
        });
      }
    }
    chart.containerBox = chart.getContainerBox();
    chart._cursor = container.style.cursor;
    const Renderer = optionsChart.renderer || !svg3 ? RendererRegistry_default.getRendererType(optionsChart.renderer) : SVGRenderer_default;
    chart.renderer = new Renderer(container, chartWidth, chartHeight, void 0, optionsChart.forExport, options2.exporting?.allowHTML, chart.styledMode);
    setAnimation4(void 0, chart);
    chart.setClassName(optionsChart.className);
    if (!chart.styledMode) {
      chart.renderer.setStyle(optionsChart.style);
    } else {
      for (const key in options2.defs) {
        this.renderer.definition(options2.defs[key]);
      }
    }
    chart.renderer.chartIndex = chart.index;
    fireEvent14(this, "afterGetContainer");
  }
  /**
   * Calculate margins by rendering axis labels in a preliminary position.
   * Title, subtitle and legend have already been rendered at this stage, but
   * will be moved into their final positions.
   *
   * @private
   * @function Highcharts.Chart#getMargins
   * @emits Highcharts.Chart#event:getMargins
   */
  getMargins(skipAxes) {
    const { spacing, margin, titleOffset } = this;
    this.resetMargins();
    if (titleOffset[0] && !defined16(margin[0])) {
      this.plotTop = Math.max(this.plotTop, titleOffset[0] + spacing[0]);
    }
    if (titleOffset[2] && !defined16(margin[2])) {
      this.marginBottom = Math.max(this.marginBottom, titleOffset[2] + spacing[2]);
    }
    if (this.legend?.display) {
      this.legend.adjustMargins(margin, spacing);
    }
    fireEvent14(this, "getMargins");
    if (!skipAxes) {
      this.getAxisMargins();
    }
  }
  /**
   * @private
   * @function Highcharts.Chart#getAxisMargins
   */
  getAxisMargins() {
    const chart = this, axisOffset = chart.axisOffset = [0, 0, 0, 0], colorAxis = chart.colorAxis, margin = chart.margin, getOffset2 = function(axes) {
      axes.forEach(function(axis) {
        if (axis.visible) {
          axis.getOffset();
        }
      });
    };
    if (chart.hasCartesianSeries) {
      getOffset2(chart.axes);
    } else if (colorAxis?.length) {
      getOffset2(colorAxis);
    }
    marginNames2.forEach(function(m, side) {
      if (!defined16(margin[side])) {
        chart[m] += axisOffset[side];
      }
    });
    chart.setChartSize();
  }
  /**
   * Return the current options of the chart, but only those that differ from
   * default options. Items that can be either an object or an array of
   * objects, like `series`, `xAxis` and `yAxis`, are always returned as
   * array.
   *
   * @sample highcharts/members/chart-getoptions
   *
   * @function Highcharts.Chart#getOptions
   *
   * @since 11.1.0
   */
  getOptions() {
    return diffObjects3(this.userOptions, defaultOptions8);
  }
  /**
   * Reflows the chart to its container. By default, the Resize Observer is
   * attached to the chart's div which allows to reflows the chart
   * automatically to its container, as per the
   * [chart.reflow](https://api.highcharts.com/highcharts/chart.reflow)
   * option.
   *
   * @sample highcharts/chart/events-container/
   *         Pop up and reflow
   *
   * @function Highcharts.Chart#reflow
   *
   * @param {global.Event} [e]
   *        Event arguments. Used primarily when the function is called
   *        internally as a response to window resize.
   */
  reflow(e) {
    const chart = this, oldBox = chart.containerBox, containerBox = chart.getContainerBox();
    delete chart.pointer?.chartPosition;
    if (!chart.isPrinting && !chart.isResizing && oldBox && // When fired by resize observer inside hidden container
    containerBox.width) {
      if (containerBox.width !== oldBox.width || containerBox.height !== oldBox.height) {
        Utilities_default.clearTimeout(chart.reflowTimeout);
        chart.reflowTimeout = syncTimeout8(function() {
          if (chart.container) {
            chart.setSize(void 0, void 0, false);
          }
        }, e ? 100 : 0);
      }
      chart.containerBox = containerBox;
    }
  }
  /**
   * Toggle the event handlers necessary for auto resizing, depending on the
   * `chart.reflow` option.
   *
   * @private
   * @function Highcharts.Chart#setReflow
   */
  setReflow() {
    const chart = this;
    const runReflow = (e) => {
      if (chart.options?.chart.reflow && chart.hasLoaded) {
        chart.reflow(e);
      }
    };
    if (typeof ResizeObserver === "function") {
      new ResizeObserver(runReflow).observe(chart.renderTo);
    } else {
      const unbind = addEvent12(win10, "resize", runReflow);
      addEvent12(this, "destroy", unbind);
    }
  }
  /**
   * Resize the chart to a given width and height. In order to set the width
   * only, the height argument may be skipped. To set the height only, pass
   * `undefined` for the width.
   *
   * @sample highcharts/members/chart-setsize-button/
   *         Test resizing from buttons
   * @sample highcharts/members/chart-setsize-jquery-resizable/
   *         Add a jQuery UI resizable
   * @sample stock/members/chart-setsize/
   *         Highcharts Stock with UI resizable
   *
   * @function Highcharts.Chart#setSize
   *
   * @param {number|null} [width]
   *        The new pixel width of the chart. Since v4.2.6, the argument can
   *        be `undefined` in order to preserve the current value (when
   *        setting height only), or `null` to adapt to the width of the
   *        containing element.
   *
   * @param {number|null} [height]
   *        The new pixel height of the chart. Since v4.2.6, the argument can
   *        be `undefined` in order to preserve the current value, or `null`
   *        in order to adapt to the height of the containing element.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
   *        Whether and how to apply animation. When `undefined`, it applies
   *        the animation that is set in the `chart.animation` option.
   *
   *
   * @emits Highcharts.Chart#event:endResize
   * @emits Highcharts.Chart#event:resize
   */
  setSize(width, height, animation) {
    const chart = this, renderer = chart.renderer;
    chart.isResizing += 1;
    setAnimation4(animation, chart);
    const globalAnimation = renderer.globalAnimation;
    chart.oldChartHeight = chart.chartHeight;
    chart.oldChartWidth = chart.chartWidth;
    if (typeof width !== "undefined") {
      chart.options.chart.width = width;
    }
    if (typeof height !== "undefined") {
      chart.options.chart.height = height;
    }
    chart.getChartSize();
    const { chartWidth, chartHeight, scrollablePixelsX = 0, scrollablePixelsY = 0 } = chart;
    if (chart.isDirtyBox || chartWidth !== chart.oldChartWidth || chartHeight !== chart.oldChartHeight) {
      if (!chart.styledMode) {
        (globalAnimation ? animate3 : css10)(chart.container, {
          width: `${chartWidth + scrollablePixelsX}px`,
          height: `${chartHeight + scrollablePixelsY}px`
        }, globalAnimation);
      }
      chart.setChartSize(true);
      renderer.setSize(chartWidth, chartHeight, globalAnimation);
      chart.axes.forEach(function(axis) {
        axis.isDirty = true;
        axis.setScale();
      });
      chart.isDirtyLegend = true;
      chart.isDirtyBox = true;
      chart.layOutTitles();
      chart.getMargins();
      chart.redraw(globalAnimation);
      chart.oldChartHeight = void 0;
      fireEvent14(chart, "resize");
      setTimeout(() => {
        if (chart) {
          fireEvent14(chart, "endResize");
        }
      }, animObject8(globalAnimation).duration);
    }
    chart.isResizing -= 1;
  }
  /**
   * Set the public chart properties. This is done before and after the
   * pre-render to determine margin sizes.
   *
   * @private
   * @function Highcharts.Chart#setChartSize
   * @emits Highcharts.Chart#event:afterSetChartSize
   */
  setChartSize(skipAxes) {
    const chart = this, { chartHeight, chartWidth, inverted, spacing, renderer } = chart, clipOffset = chart.clipOffset, clipRoundFunc = Math[inverted ? "floor" : "round"];
    let plotLeft, plotTop, plotWidth, plotHeight;
    chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
    chart.plotTop = plotTop = Math.round(chart.plotTop);
    chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - (chart.marginRight ?? 0)));
    chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - (chart.marginBottom ?? 0)));
    chart.plotSizeX = inverted ? plotHeight : plotWidth;
    chart.plotSizeY = inverted ? plotWidth : plotHeight;
    chart.spacingBox = renderer.spacingBox = {
      x: spacing[3],
      y: spacing[0],
      width: chartWidth - spacing[3] - spacing[1],
      height: chartHeight - spacing[0] - spacing[2]
    };
    chart.plotBox = renderer.plotBox = {
      x: plotLeft,
      y: plotTop,
      width: plotWidth,
      height: plotHeight
    };
    if (clipOffset) {
      chart.clipBox = {
        x: clipRoundFunc(clipOffset[3]),
        y: clipRoundFunc(clipOffset[0]),
        width: clipRoundFunc(chart.plotSizeX - clipOffset[1] - clipOffset[3]),
        height: clipRoundFunc(chart.plotSizeY - clipOffset[0] - clipOffset[2])
      };
    }
    if (!skipAxes) {
      chart.axes.forEach(function(axis) {
        axis.setAxisSize();
        axis.setAxisTranslation();
      });
      renderer.alignElements();
    }
    fireEvent14(chart, "afterSetChartSize", { skipAxes });
  }
  /**
   * Initial margins before auto size margins are applied.
   *
   * @private
   * @function Highcharts.Chart#resetMargins
   */
  resetMargins() {
    fireEvent14(this, "resetMargins");
    const chart = this, chartOptions = chart.options.chart, plotBorderWidth = chartOptions.plotBorderWidth || 0, halfWidth = Math.round(plotBorderWidth) / 2;
    ["margin", "spacing"].forEach(function splashArrays(target) {
      const value = chartOptions[target], values = isObject10(value) ? value : [value, value, value, value];
      [
        "Top",
        "Right",
        "Bottom",
        "Left"
      ].forEach(function(sideName, side) {
        chart[target][side] = pick20(chartOptions[target + sideName], values[side]);
      });
    });
    marginNames2.forEach(function(m, side) {
      chart[m] = pick20(chart.margin[side], chart.spacing[side]);
    });
    chart.axisOffset = [0, 0, 0, 0];
    chart.clipOffset = [
      halfWidth,
      halfWidth,
      halfWidth,
      halfWidth
    ];
    chart.plotBorderWidth = plotBorderWidth;
  }
  /**
   * Internal function to draw or redraw the borders and backgrounds for chart
   * and plot area.
   *
   * @private
   * @function Highcharts.Chart#drawChartBox
   * @emits Highcharts.Chart#event:afterDrawChartBox
   */
  drawChartBox() {
    const chart = this, optionsChart = chart.options.chart, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, styledMode = chart.styledMode, plotBGImage = chart.plotBGImage, chartBackgroundColor = optionsChart.backgroundColor, plotBackgroundColor = optionsChart.plotBackgroundColor, plotBackgroundImage = optionsChart.plotBackgroundImage, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotBox = chart.plotBox, clipRect = chart.clipRect, clipBox = chart.clipBox;
    let chartBackground = chart.chartBackground, plotBackground = chart.plotBackground, plotBorder = chart.plotBorder, chartBorderWidth, mgn, bgAttr, verb = "animate";
    if (!chartBackground) {
      chart.chartBackground = chartBackground = renderer.rect().addClass("highcharts-background").add();
      verb = "attr";
    }
    if (!styledMode) {
      chartBorderWidth = optionsChart.borderWidth || 0;
      mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
      bgAttr = {
        fill: chartBackgroundColor || "none"
      };
      if (chartBorderWidth || chartBackground["stroke-width"]) {
        bgAttr.stroke = optionsChart.borderColor;
        bgAttr["stroke-width"] = chartBorderWidth;
      }
      chartBackground.attr(bgAttr).shadow(optionsChart.shadow);
    } else {
      chartBorderWidth = mgn = chartBackground.strokeWidth();
    }
    chartBackground[verb]({
      x: mgn / 2,
      y: mgn / 2,
      width: chartWidth - mgn - chartBorderWidth % 2,
      height: chartHeight - mgn - chartBorderWidth % 2,
      r: optionsChart.borderRadius
    });
    verb = "animate";
    if (!plotBackground) {
      verb = "attr";
      chart.plotBackground = plotBackground = renderer.rect().addClass("highcharts-plot-background").add();
    }
    plotBackground[verb](plotBox);
    if (!styledMode) {
      plotBackground.attr({
        fill: plotBackgroundColor || "none"
      }).shadow(optionsChart.plotShadow);
      if (plotBackgroundImage) {
        if (!plotBGImage) {
          chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight).add();
        } else {
          if (plotBackgroundImage !== plotBGImage.attr("href")) {
            plotBGImage.attr("href", plotBackgroundImage);
          }
          plotBGImage.animate(plotBox);
        }
      }
    }
    if (!clipRect) {
      chart.clipRect = renderer.clipRect(clipBox);
    } else {
      clipRect.animate({
        width: clipBox.width,
        height: clipBox.height
      });
    }
    verb = "animate";
    if (!plotBorder) {
      verb = "attr";
      chart.plotBorder = plotBorder = renderer.rect().addClass("highcharts-plot-border").attr({
        zIndex: 1
        // Above the grid
      }).add();
    }
    if (!styledMode) {
      plotBorder.attr({
        stroke: optionsChart.plotBorderColor,
        "stroke-width": optionsChart.plotBorderWidth || 0,
        fill: "none"
      });
    }
    plotBorder[verb](plotBorder.crisp(
      plotBox,
      // #3282 plotBorder should be negative
      -plotBorder.strokeWidth()
    ));
    chart.isDirtyBox = false;
    fireEvent14(this, "afterDrawChartBox");
  }
  /**
   * Detect whether a certain chart property is needed based on inspecting its
   * options and series. This mainly applies to the chart.inverted property,
   * and in extensions to the chart.angular and chart.polar properties.
   *
   * @private
   * @function Highcharts.Chart#propFromSeries
   */
  propFromSeries() {
    const chart = this, optionsChart = chart.options.chart, seriesOptions = chart.options.series;
    let i, klass, value;
    ["inverted", "angular", "polar"].forEach(function(key) {
      klass = seriesTypes2[optionsChart.type];
      value = // It is set in the options:
      optionsChart[key] || // The default series class:
      klass && klass.prototype[key];
      i = seriesOptions?.length;
      while (!value && i--) {
        klass = seriesTypes2[seriesOptions[i].type];
        if (klass && klass.prototype[key]) {
          value = true;
        }
      }
      chart[key] = value;
    });
  }
  /**
   * Internal function to link two or more series together, based on the
   * `linkedTo` option. This is done from `Chart.render`, and after
   * `Chart.addSeries` and `Series.remove`.
   *
   * @private
   * @function Highcharts.Chart#linkSeries
   * @emits Highcharts.Chart#event:afterLinkSeries
   */
  linkSeries(isUpdating) {
    const chart = this, chartSeries = chart.series;
    chartSeries.forEach(function(series) {
      series.linkedSeries.length = 0;
    });
    chartSeries.forEach(function(series) {
      const { linkedTo } = series.options;
      if (isString12(linkedTo)) {
        let linkedParent;
        if (linkedTo === ":previous") {
          linkedParent = chart.series[series.index - 1];
        } else {
          linkedParent = chart.get(linkedTo);
        }
        if (linkedParent && linkedParent.linkedParent !== series) {
          linkedParent.linkedSeries.push(series);
          series.linkedParent = linkedParent;
          if (linkedParent.enabledDataSorting) {
            series.setDataSortingOptions();
          }
          series.visible = pick20(series.options.visible, linkedParent.options.visible, series.visible);
        }
      }
    });
    fireEvent14(this, "afterLinkSeries", { isUpdating });
  }
  /**
   * Render series for the chart.
   *
   * @private
   * @function Highcharts.Chart#renderSeries
   */
  renderSeries() {
    this.series.forEach(function(serie) {
      serie.translate();
      serie.render();
    });
  }
  /**
   * Render all graphics for the chart. Runs internally on initialization.
   *
   * @private
   * @function Highcharts.Chart#render
   */
  render() {
    const chart = this, axes = chart.axes, colorAxis = chart.colorAxis, renderer = chart.renderer, axisLayoutRuns = chart.options.chart.axisLayoutRuns || 2, renderAxes = (axes2) => {
      axes2.forEach((axis) => {
        if (axis.visible) {
          axis.render();
        }
      });
    };
    let expectedSpace = 0, redoHorizontal = true, redoVertical, run = 0;
    chart.setTitle();
    fireEvent14(chart, "beforeMargins");
    chart.getStacks?.();
    chart.getMargins(true);
    chart.setChartSize();
    for (const axis of axes) {
      const { options: options2 } = axis, { labels } = options2;
      if (chart.hasCartesianSeries && // #20948
      axis.horiz && axis.visible && labels.enabled && axis.series.length && axis.coll !== "colorAxis" && !chart.polar) {
        expectedSpace = options2.tickLength;
        axis.createGroups();
        const mockTick = new Tick_default(axis, 0, "", true), label = mockTick.createLabel("x", labels);
        mockTick.destroy();
        if (label && pick20(labels.reserveSpace, !isNumber20(options2.crossing))) {
          expectedSpace = label.getBBox().height + labels.distance + Math.max(options2.offset || 0, 0);
        }
        if (expectedSpace) {
          label?.destroy();
          break;
        }
      }
    }
    chart.plotHeight = Math.max(chart.plotHeight - expectedSpace, 0);
    while ((redoHorizontal || redoVertical || axisLayoutRuns > 1) && run < axisLayoutRuns) {
      const tempWidth = chart.plotWidth, tempHeight = chart.plotHeight;
      for (const axis of axes) {
        if (run === 0) {
          axis.setScale();
        } else if (axis.horiz && redoHorizontal || !axis.horiz && redoVertical) {
          axis.setTickInterval(true);
        }
      }
      if (run === 0) {
        chart.getAxisMargins();
      } else {
        chart.getMargins();
      }
      redoHorizontal = tempWidth / chart.plotWidth > (run ? 1 : 1.1);
      redoVertical = tempHeight / chart.plotHeight > (run ? 1 : 1.05);
      run++;
    }
    chart.drawChartBox();
    if (chart.hasCartesianSeries) {
      renderAxes(axes);
    } else if (colorAxis?.length) {
      renderAxes(colorAxis);
    }
    if (!chart.seriesGroup) {
      chart.seriesGroup = renderer.g("series-group").attr({ zIndex: 3 }).shadow(chart.options.chart.seriesGroupShadow).add();
    }
    chart.renderSeries();
    chart.addCredits();
    if (chart.setResponsive) {
      chart.setResponsive();
    }
    chart.hasRendered = true;
  }
  /**
   * Set a new credits label for the chart.
   *
   * @sample highcharts/credits/credits-update/
   *         Add and update credits
   *
   * @function Highcharts.Chart#addCredits
   *
   * @param {Highcharts.CreditsOptions} [credits]
   * A configuration object for the new credits.
   */
  addCredits(credits) {
    const chart = this, creds = merge18(true, this.options.credits, credits);
    if (creds.enabled && !this.credits) {
      this.credits = this.renderer.text(creds.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
        if (creds.href) {
          win10.location.href = creds.href;
        }
      }).attr({
        align: creds.position.align,
        zIndex: 8
      });
      if (!chart.styledMode) {
        this.credits.css(creds.style);
      }
      this.credits.add().align(creds.position);
      this.credits.update = function(options2) {
        chart.credits = chart.credits.destroy();
        chart.addCredits(options2);
      };
    }
  }
  /**
   * Remove the chart and purge memory. This method is called internally
   * before adding a second chart into the same container, as well as on
   * window unload to prevent leaks.
   *
   * @sample highcharts/members/chart-destroy/
   *         Destroy the chart from a button
   * @sample stock/members/chart-destroy/
   *         Destroy with Highcharts Stock
   *
   * @function Highcharts.Chart#destroy
   *
   * @emits Highcharts.Chart#event:destroy
   */
  destroy() {
    const chart = this, axes = chart.axes, series = chart.series, container = chart.container, parentNode = container?.parentNode;
    let i;
    fireEvent14(chart, "destroy");
    if (chart.renderer.forExport) {
      erase8(charts4, chart);
    } else {
      charts4[chart.index] = void 0;
    }
    Globals_default.chartCount--;
    chart.renderTo.removeAttribute("data-highcharts-chart");
    removeEvent7(chart);
    i = axes.length;
    while (i--) {
      axes[i] = axes[i].destroy();
    }
    this.scroller?.destroy?.();
    i = series.length;
    while (i--) {
      series[i] = series[i].destroy();
    }
    [
      "title",
      "subtitle",
      "chartBackground",
      "plotBackground",
      "plotBGImage",
      "plotBorder",
      "seriesGroup",
      "clipRect",
      "credits",
      "pointer",
      "rangeSelector",
      "legend",
      "resetZoomButton",
      "tooltip",
      "renderer"
    ].forEach((name) => {
      chart[name] = chart[name]?.destroy?.();
    });
    if (container) {
      container.innerHTML = AST_default.emptyHTML;
      removeEvent7(container);
      if (parentNode) {
        discardElement4(container);
      }
    }
    objectEach15(chart, function(val, key) {
      delete chart[key];
    });
  }
  /**
   * Prepare for first rendering after all data are loaded.
   *
   * @private
   * @function Highcharts.Chart#firstRender
   * @emits Highcharts.Chart#event:beforeRender
   */
  firstRender() {
    const chart = this, options2 = chart.options;
    chart.getContainer();
    chart.resetMargins();
    chart.setChartSize();
    chart.propFromSeries();
    chart.createAxes();
    const series = isArray10(options2.series) ? options2.series : [];
    options2.series = [];
    series.forEach(
      // #9680
      function(serieOptions) {
        chart.initSeries(serieOptions);
      }
    );
    chart.linkSeries();
    chart.setSortedData();
    fireEvent14(chart, "beforeRender");
    chart.render();
    chart.pointer?.getChartPosition();
    if (!chart.renderer.imgCount && !chart.hasLoaded) {
      chart.onload();
    }
    chart.temporaryDisplay(true);
  }
  /**
   * Internal function that runs on chart load, async if any images are loaded
   * in the chart. Runs the callbacks and triggers the `load` and `render`
   * events.
   *
   * @private
   * @function Highcharts.Chart#onload
   * @emits Highcharts.Chart#event:load
   * @emits Highcharts.Chart#event:render
   */
  onload() {
    this.callbacks.concat([this.callback]).forEach(function(fn) {
      if (fn && typeof this.index !== "undefined") {
        fn.apply(this, [this]);
      }
    }, this);
    fireEvent14(this, "load");
    fireEvent14(this, "render");
    if (defined16(this.index)) {
      this.setReflow();
    }
    this.warnIfA11yModuleNotLoaded();
    this.hasLoaded = true;
  }
  /**
   * Emit console warning if the a11y module is not loaded.
   * @private
   */
  warnIfA11yModuleNotLoaded() {
    const { options: options2, title } = this;
    if (options2 && !this.accessibility) {
      this.renderer.boxWrapper.attr({
        role: "img",
        "aria-label": (title?.element.textContent || "").replace(/</g, "&lt;")
      });
      if (!(options2.accessibility && options2.accessibility.enabled === false)) {
        error6('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, this);
      }
    }
  }
  /**
   * Add a series to the chart after render time. Note that this method should
   * never be used when adding data synchronously at chart render time, as it
   * adds expense to the calculations and rendering. When adding data at the
   * same time as the chart is initialized, add the series as a configuration
   * option instead. With multiple axes, the `offset` is dynamically adjusted.
   *
   * @sample highcharts/members/chart-addseries/
   *         Add a series from a button
   * @sample stock/members/chart-addseries/
   *         Add a series in Highcharts Stock
   *
   * @function Highcharts.Chart#addSeries
   *
   * @param {Highcharts.SeriesOptionsType} options
   *        The config options for the series.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after adding.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
   *        Whether to apply animation, and optionally animation
   *        configuration. When `undefined`, it applies the animation that is
   *        set in the `chart.animation` option.
   *
   * @return {Highcharts.Series}
   *         The newly created series object.
   *
   * @emits Highcharts.Chart#event:addSeries
   * @emits Highcharts.Chart#event:afterAddSeries
   */
  addSeries(options2, redraw, animation) {
    const chart = this;
    let series;
    if (options2) {
      redraw = pick20(redraw, true);
      fireEvent14(chart, "addSeries", { options: options2 }, function() {
        series = chart.initSeries(options2);
        chart.isDirtyLegend = true;
        chart.linkSeries();
        if (series.enabledDataSorting) {
          series.setData(options2.data, false);
        }
        fireEvent14(chart, "afterAddSeries", { series });
        if (redraw) {
          chart.redraw(animation);
        }
      });
    }
    return series;
  }
  /**
   * Add an axis to the chart after render time. Note that this method should
   * never be used when adding data synchronously at chart render time, as it
   * adds expense to the calculations and rendering. When adding data at the
   * same time as the chart is initialized, add the axis as a configuration
   * option instead.
   *
   * @sample highcharts/members/chart-addaxis/
   *         Add and remove axes
   *
   * @function Highcharts.Chart#addAxis
   *
   * @param {Highcharts.AxisOptions} options
   *        The axis options.
   *
   * @param {boolean} [isX=false]
   *        Whether it is an X axis or a value axis.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after adding.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
   *        Whether and how to apply animation in the redraw. When
   *        `undefined`, it applies the animation that is set in the
   *        `chart.animation` option.
   *
   * @return {Highcharts.Axis}
   *         The newly generated Axis object.
   */
  addAxis(options2, isX, redraw, animation) {
    return this.createAxis(isX ? "xAxis" : "yAxis", { axis: options2, redraw, animation });
  }
  /**
   * Add a color axis to the chart after render time. Note that this method
   * should never be used when adding data synchronously at chart render time,
   * as it adds expense to the calculations and rendering. When adding data at
   * the same time as the chart is initialized, add the axis as a
   * configuration option instead.
   *
   * @sample highcharts/members/chart-addaxis/
   *         Add and remove axes
   *
   * @function Highcharts.Chart#addColorAxis
   *
   * @param {Highcharts.ColorAxisOptions} options
   *        The axis options.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after adding.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
   *        Whether and how to apply animation in the redraw. When
   *        `undefined`, it applies the animation that is set in the
   *        `chart.animation` option.
   *
   * @return {Highcharts.Axis}
   *         The newly generated Axis object.
   */
  addColorAxis(options2, redraw, animation) {
    return this.createAxis("colorAxis", { axis: options2, redraw, animation });
  }
  /**
   * Factory for creating different axis types.
   *
   * @private
   * @function Highcharts.Chart#createAxis
   *
   * @param {string} coll
   *        An axis type.
   *
   * @param {...Array<*>} arguments
   *        All arguments for the constructor.
   *
   * @return {Highcharts.Axis}
   *         The newly generated Axis object.
   */
  createAxis(coll, options2) {
    const axis = new Axis_default(this, options2.axis, coll);
    if (pick20(options2.redraw, true)) {
      this.redraw(options2.animation);
    }
    return axis;
  }
  /**
   * Dim the chart and show a loading text or symbol. Options for the loading
   * screen are defined in {@link
   * https://api.highcharts.com/highcharts/loading|the loading options}.
   *
   * @sample highcharts/members/chart-hideloading/
   *         Show and hide loading from a button
   * @sample highcharts/members/chart-showloading/
   *         Apply different text labels
   * @sample stock/members/chart-show-hide-loading/
   *         Toggle loading in Highcharts Stock
   *
   * @function Highcharts.Chart#showLoading
   *
   * @param {string} [str]
   *        An optional text to show in the loading label instead of the
   *        default one. The default text is set in
   *        [lang.loading](https://api.highcharts.com/highcharts/lang.loading).
   */
  showLoading(str) {
    const chart = this, options2 = chart.options, loadingOptions = options2.loading, setLoadingSize = function() {
      if (loadingDiv) {
        css10(loadingDiv, {
          left: chart.plotLeft + "px",
          top: chart.plotTop + "px",
          width: chart.plotWidth + "px",
          height: chart.plotHeight + "px"
        });
      }
    };
    let loadingDiv = chart.loadingDiv, loadingSpan = chart.loadingSpan;
    if (!loadingDiv) {
      chart.loadingDiv = loadingDiv = createElement7("div", {
        className: "highcharts-loading highcharts-loading-hidden"
      }, null, chart.container);
    }
    if (!loadingSpan) {
      chart.loadingSpan = loadingSpan = createElement7("span", { className: "highcharts-loading-inner" }, null, loadingDiv);
      addEvent12(chart, "redraw", setLoadingSize);
    }
    loadingDiv.className = "highcharts-loading";
    AST_default.setElementHTML(loadingSpan, pick20(str, options2.lang.loading, ""));
    if (!chart.styledMode) {
      css10(loadingDiv, extend19(loadingOptions.style, {
        zIndex: 10
      }));
      css10(loadingSpan, loadingOptions.labelStyle);
      if (!chart.loadingShown) {
        css10(loadingDiv, {
          opacity: 0,
          display: ""
        });
        animate3(loadingDiv, {
          opacity: loadingOptions.style.opacity || 0.5
        }, {
          duration: loadingOptions.showDuration || 0
        });
      }
    }
    chart.loadingShown = true;
    setLoadingSize();
  }
  /**
   * Hide the loading layer.
   *
   * @see Highcharts.Chart#showLoading
   *
   * @sample highcharts/members/chart-hideloading/
   *         Show and hide loading from a button
   * @sample stock/members/chart-show-hide-loading/
   *         Toggle loading in Highcharts Stock
   *
   * @function Highcharts.Chart#hideLoading
   */
  hideLoading() {
    const options2 = this.options, loadingDiv = this.loadingDiv;
    if (loadingDiv) {
      loadingDiv.className = "highcharts-loading highcharts-loading-hidden";
      if (!this.styledMode) {
        animate3(loadingDiv, {
          opacity: 0
        }, {
          duration: options2.loading.hideDuration || 100,
          complete: function() {
            css10(loadingDiv, { display: "none" });
          }
        });
      }
    }
    this.loadingShown = false;
  }
  /**
   * A generic function to update any element of the chart. Elements can be
   * enabled and disabled, moved, re-styled, re-formatted etc.
   *
   * A special case is configuration objects that take arrays, for example
   * [xAxis](https://api.highcharts.com/highcharts/xAxis),
   * [yAxis](https://api.highcharts.com/highcharts/yAxis) or
   * [series](https://api.highcharts.com/highcharts/series). For these
   * collections, an `id` option is used to map the new option set to an
   * existing object. If an existing object of the same id is not found, the
   * corresponding item is updated. So for example, running `chart.update`
   * with a series item without an id, will cause the existing chart's series
   * with the same index in the series array to be updated. When the
   * `oneToOne` parameter is true, `chart.update` will also take care of
   * adding and removing items from the collection. Read more under the
   * parameter description below.
   *
   * Note that when changing series data, `chart.update` may mutate the passed
   * data options.
   *
   * See also the
   * [responsive option set](https://api.highcharts.com/highcharts/responsive).
   * Switching between `responsive.rules` basically runs `chart.update` under
   * the hood.
   *
   * @sample highcharts/members/chart-update/
   *         Update chart geometry
   *
   * @function Highcharts.Chart#update
   *
   * @param {Highcharts.Options} options
   *        A configuration object for the new chart options.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart.
   *
   * @param {boolean} [oneToOne=false]
   *        When `true`, the `series`, `xAxis`, `yAxis` and `annotations`
   *        collections will be updated one to one, and items will be either
   *        added or removed to match the new updated options. For example,
   *        if the chart has two series and we call `chart.update` with a
   *        configuration containing three series, one will be added. If we
   *        call `chart.update` with one series, one will be removed. Setting
   *        an empty `series` array will remove all series, but leaving out
   *        the`series` property will leave all series untouched. If the
   *        series have id's, the new series options will be matched by id,
   *        and the remaining ones removed.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
   *        Whether to apply animation, and optionally animation
   *        configuration. When `undefined`, it applies the animation that is
   *        set in the `chart.animation` option.
   *
   * @emits Highcharts.Chart#event:update
   * @emits Highcharts.Chart#event:afterUpdate
   */
  update(options2, redraw, oneToOne, animation) {
    const chart = this, adders = {
      credits: "addCredits",
      title: "setTitle",
      subtitle: "setSubtitle",
      caption: "setCaption"
    }, isResponsiveOptions = options2.isResponsiveOptions, itemsForRemoval = [];
    let updateAllAxes, updateAllSeries, runSetSize;
    fireEvent14(chart, "update", { options: options2 });
    if (!isResponsiveOptions) {
      chart.setResponsive(false, true);
    }
    options2 = diffObjects3(options2, chart.options);
    chart.userOptions = merge18(chart.userOptions, options2);
    const optionsChart = options2.chart;
    if (optionsChart) {
      merge18(true, chart.options.chart, optionsChart);
      this.setZoomOptions();
      if ("className" in optionsChart) {
        chart.setClassName(optionsChart.className);
      }
      if ("inverted" in optionsChart || "polar" in optionsChart || "type" in optionsChart) {
        chart.propFromSeries();
        updateAllAxes = true;
      }
      if ("alignTicks" in optionsChart) {
        updateAllAxes = true;
      }
      if ("events" in optionsChart) {
        registerEventOptions4(this, optionsChart);
      }
      objectEach15(optionsChart, function(val, key) {
        if (chart.propsRequireUpdateSeries.indexOf("chart." + key) !== -1) {
          updateAllSeries = true;
        }
        if (chart.propsRequireDirtyBox.indexOf(key) !== -1) {
          chart.isDirtyBox = true;
        }
        if (chart.propsRequireReflow.indexOf(key) !== -1) {
          chart.isDirtyBox = true;
          if (!isResponsiveOptions) {
            runSetSize = true;
          }
        }
      });
      if (!chart.styledMode && optionsChart.style) {
        chart.renderer.setStyle(chart.options.chart.style || {});
      }
    }
    if (!chart.styledMode && options2.colors) {
      this.options.colors = options2.colors;
    }
    objectEach15(options2, function(val, key) {
      if (chart[key] && typeof chart[key].update === "function") {
        chart[key].update(val, false);
      } else if (typeof chart[adders[key]] === "function") {
        chart[adders[key]](val);
      } else if (key !== "colors" && chart.collectionsWithUpdate.indexOf(key) === -1) {
        merge18(true, chart.options[key], options2[key]);
      }
      if (key !== "chart" && chart.propsRequireUpdateSeries.indexOf(key) !== -1) {
        updateAllSeries = true;
      }
    });
    this.collectionsWithUpdate.forEach(function(coll) {
      if (options2[coll]) {
        splat7(options2[coll]).forEach(function(newOptions, i) {
          const hasId = defined16(newOptions.id);
          let item;
          if (hasId) {
            item = chart.get(newOptions.id);
          }
          if (!item && chart[coll]) {
            item = chart[coll][pick20(newOptions.index, i)];
            if (item && (hasId && defined16(item.options.id) || item.options.isInternal)) {
              item = void 0;
            }
          }
          if (item && item.coll === coll) {
            item.update(newOptions, false);
            if (oneToOne) {
              item.touched = true;
            }
          }
          if (!item && oneToOne && chart.collectionsWithInit[coll]) {
            chart.collectionsWithInit[coll][0].apply(
              chart,
              // [newOptions, ...extraArguments, redraw=false]
              [
                newOptions
              ].concat(
                // Not all initializers require extra args
                chart.collectionsWithInit[coll][1] || []
              ).concat([
                false
              ])
            ).touched = true;
          }
        });
        if (oneToOne) {
          chart[coll].forEach(function(item) {
            if (!item.touched && !item.options.isInternal) {
              itemsForRemoval.push(item);
            } else {
              delete item.touched;
            }
          });
        }
      }
    });
    itemsForRemoval.forEach(function(item) {
      if (item.chart && item.remove) {
        item.remove(false);
      }
    });
    if (updateAllAxes) {
      chart.axes.forEach(function(axis) {
        axis.update({}, false);
      });
    }
    if (updateAllSeries) {
      chart.getSeriesOrderByLinks().forEach(function(series) {
        if (series.chart) {
          series.update({}, false);
        }
      }, this);
    }
    const newWidth = optionsChart?.width;
    const newHeight = optionsChart && (isString12(optionsChart.height) ? relativeLength4(optionsChart.height, newWidth || chart.chartWidth) : optionsChart.height);
    if (
      // In this case, run chart.setSize with newWidth and newHeight which
      // are undefined, only for reflowing chart elements because margin
      // or spacing has been set (#8190)
      runSetSize || // In this case, the size is actually set
      isNumber20(newWidth) && newWidth !== chart.chartWidth || isNumber20(newHeight) && newHeight !== chart.chartHeight
    ) {
      chart.setSize(newWidth, newHeight, animation);
    } else if (pick20(redraw, true)) {
      chart.redraw(animation);
    }
    fireEvent14(chart, "afterUpdate", {
      options: options2,
      redraw,
      animation
    });
  }
  /**
   * Shortcut to set the subtitle options. This can also be done from {@link
   * Chart#update} or {@link Chart#setTitle}.
   *
   * @function Highcharts.Chart#setSubtitle
   *
   * @param {Highcharts.SubtitleOptions} options
   *        New subtitle options. The subtitle text itself is set by the
   *        `options.text` property.
   */
  setSubtitle(options2, redraw) {
    this.applyDescription("subtitle", options2);
    this.layOutTitles(redraw);
  }
  /**
   * Set the caption options. This can also be done from {@link
   * Chart#update}.
   *
   * @function Highcharts.Chart#setCaption
   *
   * @param {Highcharts.CaptionOptions} options
   *        New caption options. The caption text itself is set by the
   *        `options.text` property.
   */
  setCaption(options2, redraw) {
    this.applyDescription("caption", options2);
    this.layOutTitles(redraw);
  }
  /**
   * Display the zoom button, so users can reset zoom to the default view
   * settings.
   *
   * @function Highcharts.Chart#showResetZoom
   *
   * @emits Highcharts.Chart#event:afterShowResetZoom
   * @emits Highcharts.Chart#event:beforeShowResetZoom
   */
  showResetZoom() {
    const chart = this, lang6 = defaultOptions8.lang, btnOptions = chart.zooming.resetButton, theme2 = btnOptions.theme, alignTo = btnOptions.relativeTo === "chart" || btnOptions.relativeTo === "spacingBox" ? null : "plotBox";
    function zoomOut() {
      chart.zoomOut();
    }
    fireEvent14(this, "beforeShowResetZoom", null, function() {
      chart.resetZoomButton = chart.renderer.button(lang6.resetZoom, null, null, zoomOut, theme2).attr({
        align: btnOptions.position.align,
        title: lang6.resetZoomTitle
      }).addClass("highcharts-reset-zoom").add().align(btnOptions.position, false, alignTo);
    });
    fireEvent14(this, "afterShowResetZoom");
  }
  /**
   * Zoom the chart out after a user has zoomed in. See also
   * [Axis.setExtremes](/class-reference/Highcharts.Axis#setExtremes).
   *
   * @function Highcharts.Chart#zoomOut
   *
   * @emits Highcharts.Chart#event:selection
   */
  zoomOut() {
    fireEvent14(this, "selection", { resetSelection: true }, () => this.transform({ reset: true, trigger: "zoom" }));
  }
  /**
   * Pan the chart by dragging the mouse across the pane. This function is
   * called on mouse move, and the distance to pan is computed from chartX
   * compared to the first chartX position in the dragging operation.
   *
   * @private
   * @function Highcharts.Chart#pan
   * @param {Highcharts.PointerEventObject} event
   * @param {string} panning
   */
  pan(event, panning) {
    const chart = this, panningOptions = typeof panning === "object" ? panning : {
      enabled: panning,
      type: "x"
    }, type = panningOptions.type, axes = type && chart[{
      x: "xAxis",
      xy: "axes",
      y: "yAxis"
    }[type]].filter((axis) => axis.options.panningEnabled && !axis.options.isInternal), chartOptions = chart.options.chart;
    if (chartOptions?.panning) {
      chartOptions.panning = panningOptions;
    }
    fireEvent14(this, "pan", { originalEvent: event }, () => {
      chart.transform({
        axes,
        event,
        to: {
          x: event.chartX - (chart.mouseDownX || 0),
          y: event.chartY - (chart.mouseDownY || 0)
        },
        trigger: "pan"
      });
      css10(chart.container, { cursor: "move" });
    });
  }
  /**
   * Pan and scale the chart. Used internally by mouse-pan, touch-pan,
   * touch-zoom, and mousewheel zoom.
   *
   * The main positioning logic is created around two imaginary boxes. What is
   * currently within the `from` rectangle, should be transformed to fill up
   * the `to` rectangle.
   * - In a mouse zoom, the `from` rectangle is the selection, while the `to`
   *   rectangle is the full plot area.
   * - In a touch zoom, the `from` rectangle is made up of the last two-finger
   *   touch, while the `to`` rectangle is the current touch.
   * - In a mousewheel zoom, the `to` rectangle is a 10x10 px square,
   *   while the `to` rectangle reflects the scale around that.
   *
   * @private
   * @function Highcharts.Chart#transform
   */
  transform(params) {
    const { axes = this.axes, event, from = {}, reset, selection, to = {}, trigger } = params, { inverted, time } = this;
    let hasZoomed = false, displayButton, isAnyAxisPanning;
    this.hoverPoints?.forEach((point) => point.setState());
    for (const axis of axes) {
      const { horiz, len, minPointOffset = 0, options: options2, reversed } = axis, wh = horiz ? "width" : "height", xy = horiz ? "x" : "y", toLength = pick20(to[wh], axis.len), fromLength = pick20(from[wh], axis.len), scale = Math.abs(toLength) < 10 ? 1 : toLength / fromLength, fromCenter = (from[xy] || 0) + fromLength / 2 - axis.pos, toCenter = (to[xy] ?? axis.pos) + toLength / 2 - axis.pos, move = fromCenter - toCenter / scale, pointRangeDirection = reversed && !inverted || !reversed && inverted ? -1 : 1, minPx = move;
      if (!reset && (fromCenter < 0 || fromCenter > axis.len)) {
        continue;
      }
      let newMin = axis.toValue(minPx, true) + // Don't apply offset for selection (#20784)
      (selection || axis.isOrdinal ? 0 : minPointOffset * pointRangeDirection), newMax = axis.toValue(minPx + len / scale, true) - // Don't apply offset for selection (#20784)
      (selection || axis.isOrdinal ? 0 : minPointOffset * pointRangeDirection || // Polar zoom tests failed when this was not
      // commented:
      // (axis.isXAxis && axis.pointRangePadding) ||
      0), allExtremes = axis.allExtremes;
      if (newMin > newMax) {
        [newMin, newMax] = [newMax, newMin];
      }
      if (scale === 1 && !reset && axis.coll === "yAxis" && !allExtremes) {
        for (const series of axis.series) {
          const seriesExtremes = series.getExtremes(series.getProcessedData(true).modified.getColumn("y") || [], true);
          allExtremes ?? (allExtremes = {
            dataMin: Number.MAX_VALUE,
            dataMax: -Number.MAX_VALUE
          });
          if (isNumber20(seriesExtremes.dataMin) && isNumber20(seriesExtremes.dataMax)) {
            allExtremes.dataMin = Math.min(seriesExtremes.dataMin, allExtremes.dataMin);
            allExtremes.dataMax = Math.max(seriesExtremes.dataMax, allExtremes.dataMax);
          }
        }
        axis.allExtremes = allExtremes;
      }
      const { dataMin, dataMax, min: min4, max: max4 } = extend19(axis.getExtremes(), allExtremes || {}), optionsMin = time.parse(options2.min), optionsMax = time.parse(options2.max), safeDataMin = dataMin ?? optionsMin, safeDataMax = dataMax ?? optionsMax, range2 = newMax - newMin, padRange = axis.categories ? 0 : Math.min(range2, safeDataMax - safeDataMin), paddedMin = safeDataMin - padRange * (defined16(optionsMin) ? 0 : options2.minPadding), paddedMax = safeDataMax + padRange * (defined16(optionsMax) ? 0 : options2.maxPadding), allowZoomOutside = axis.allowZoomOutside || scale === 1 || trigger !== "zoom" && scale > 1, floor = Math.min(optionsMin ?? paddedMin, paddedMin, allowZoomOutside ? min4 : paddedMin), ceiling = Math.max(optionsMax ?? paddedMax, paddedMax, allowZoomOutside ? max4 : paddedMax);
      if (!axis.isOrdinal || axis.options.overscroll || // #21316
      scale !== 1 || reset) {
        if (newMin < floor) {
          newMin = floor;
          if (scale >= 1) {
            newMax = newMin + range2;
          }
        }
        if (newMax > ceiling) {
          newMax = ceiling;
          if (scale >= 1) {
            newMin = newMax - range2;
          }
        }
        if (reset || axis.series.length && (newMin !== min4 || newMax !== max4) && newMin >= floor && newMax <= ceiling) {
          if (selection) {
            selection[axis.coll].push({
              axis,
              min: newMin,
              max: newMax
            });
          } else {
            axis.isPanning = trigger !== "zoom";
            if (axis.isPanning) {
              isAnyAxisPanning = true;
            }
            axis.setExtremes(reset ? void 0 : newMin, reset ? void 0 : newMax, false, false, { move, trigger, scale });
            if (!reset && (newMin > floor || newMax < ceiling) && trigger !== "mousewheel") {
              displayButton = true;
            }
          }
          hasZoomed = true;
        }
        if (event) {
          this[horiz ? "mouseDownX" : "mouseDownY"] = event[horiz ? "chartX" : "chartY"];
        }
      }
    }
    if (hasZoomed) {
      if (selection) {
        fireEvent14(
          this,
          "selection",
          selection,
          // Run transform again, this time without the selection data
          // so that the transform is applied.
          () => {
            delete params.selection;
            params.trigger = "zoom";
            this.transform(params);
          }
        );
      } else {
        if (displayButton && !isAnyAxisPanning && !this.resetZoomButton) {
          this.showResetZoom();
        } else if (!displayButton && this.resetZoomButton) {
          this.resetZoomButton = this.resetZoomButton.destroy();
        }
        this.redraw(trigger === "zoom" && (this.options.chart.animation ?? this.pointCount < 100));
      }
    }
    return hasZoomed;
  }
};
extend19(Chart.prototype, {
  // Hook for adding callbacks in modules
  callbacks: [],
  /**
   * These collections (arrays) implement `Chart.addSomething` method used in
   * chart.update() to create new object in the collection. Equivalent for
   * deleting is resolved by simple `Something.remove()`.
   *
   * Note: We need to define these references after initializers are bound to
   * chart's prototype.
   *
   * @private
   */
  collectionsWithInit: {
    // CollectionName: [ initializingMethod, [extraArguments] ]
    xAxis: [Chart.prototype.addAxis, [true]],
    yAxis: [Chart.prototype.addAxis, [false]],
    series: [Chart.prototype.addSeries]
  },
  /**
   * These collections (arrays) implement update() methods with support for
   * one-to-one option.
   * @private
   */
  collectionsWithUpdate: [
    "xAxis",
    "yAxis",
    "series"
  ],
  /**
   * These properties cause isDirtyBox to be set to true when updating. Can be
   * extended from plugins.
   * @private
   */
  propsRequireDirtyBox: [
    "backgroundColor",
    "borderColor",
    "borderWidth",
    "borderRadius",
    "plotBackgroundColor",
    "plotBackgroundImage",
    "plotBorderColor",
    "plotBorderWidth",
    "plotShadow",
    "shadow"
  ],
  /**
   * These properties require a full reflow of chart elements, best
   * implemented through running `Chart.setSize` internally (#8190).
   * @private
   */
  propsRequireReflow: [
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "spacing",
    "spacingTop",
    "spacingRight",
    "spacingBottom",
    "spacingLeft"
  ],
  /**
   * These properties cause all series to be updated when updating. Can be
   * extended from plugins.
   * @private
   */
  propsRequireUpdateSeries: [
    "chart.inverted",
    "chart.polar",
    "chart.ignoreHiddenSeries",
    "chart.type",
    "colors",
    "plotOptions",
    "time",
    "tooltip"
  ]
});
var Chart_default = Chart;

// node_modules/highcharts/es-modules/Extensions/ScrollablePlotArea.js
var { stop: stop3 } = AnimationUtilities_default;
var { composed: composed5 } = Globals_default;
var { addEvent: addEvent13, createElement: createElement8, css: css11, defined: defined17, erase: erase9, merge: merge19, pushUnique: pushUnique8 } = Utilities_default;
function onChartRender() {
  let scrollablePlotArea = this.scrollablePlotArea;
  if ((this.scrollablePixelsX || this.scrollablePixelsY) && !scrollablePlotArea) {
    this.scrollablePlotArea = scrollablePlotArea = new ScrollablePlotArea(this);
  }
  scrollablePlotArea?.applyFixed();
}
function markDirty() {
  if (this.chart.scrollablePlotArea) {
    this.chart.scrollablePlotArea.isDirty = true;
  }
}
var ScrollablePlotArea = class _ScrollablePlotArea {
  static compose(AxisClass, ChartClass, SeriesClass) {
    if (pushUnique8(composed5, this.compose)) {
      addEvent13(AxisClass, "afterInit", markDirty);
      addEvent13(ChartClass, "afterSetChartSize", (e) => this.afterSetSize(e.target, e));
      addEvent13(ChartClass, "render", onChartRender);
      addEvent13(SeriesClass, "show", markDirty);
    }
  }
  static afterSetSize(chart, e) {
    const { minWidth, minHeight } = chart.options.chart.scrollablePlotArea || {}, { clipBox, plotBox, inverted, renderer } = chart;
    let scrollablePixelsX, scrollablePixelsY, recalculateHoriz;
    if (!renderer.forExport) {
      if (minWidth) {
        chart.scrollablePixelsX = scrollablePixelsX = Math.max(0, minWidth - chart.chartWidth);
        if (scrollablePixelsX) {
          chart.scrollablePlotBox = merge19(chart.plotBox);
          plotBox.width = chart.plotWidth += scrollablePixelsX;
          clipBox[inverted ? "height" : "width"] += scrollablePixelsX;
          recalculateHoriz = true;
        }
      } else if (minHeight) {
        chart.scrollablePixelsY = scrollablePixelsY = Math.max(0, minHeight - chart.chartHeight);
        if (defined17(scrollablePixelsY)) {
          chart.scrollablePlotBox = merge19(chart.plotBox);
          plotBox.height = chart.plotHeight += scrollablePixelsY;
          clipBox[inverted ? "width" : "height"] += scrollablePixelsY;
          recalculateHoriz = false;
        }
      }
      if (defined17(recalculateHoriz) && !e.skipAxes) {
        for (const axis of chart.axes) {
          if (axis.horiz === recalculateHoriz || // Or parallel axes
          chart.hasParallelCoordinates && axis.coll === "yAxis") {
            axis.setAxisSize();
            axis.setAxisTranslation();
          }
        }
      }
    }
  }
  constructor(chart) {
    const chartOptions = chart.options.chart, Renderer = RendererRegistry_default.getRendererType(), scrollableOptions = chartOptions.scrollablePlotArea || {}, moveFixedElements = this.moveFixedElements.bind(this), styles = {
      WebkitOverflowScrolling: "touch",
      overflowX: "hidden",
      overflowY: "hidden"
    };
    if (chart.scrollablePixelsX) {
      styles.overflowX = "auto";
    }
    if (chart.scrollablePixelsY) {
      styles.overflowY = "auto";
    }
    this.chart = chart;
    const parentDiv = this.parentDiv = createElement8("div", {
      className: "highcharts-scrolling-parent"
    }, {
      position: "relative"
    }, chart.renderTo), scrollingContainer = this.scrollingContainer = createElement8("div", {
      "className": "highcharts-scrolling"
    }, styles, parentDiv), innerContainer = this.innerContainer = createElement8("div", {
      "className": "highcharts-inner-container"
    }, void 0, scrollingContainer), fixedDiv = this.fixedDiv = createElement8("div", {
      className: "highcharts-fixed"
    }, {
      position: "absolute",
      overflow: "hidden",
      pointerEvents: "none",
      zIndex: (chartOptions.style?.zIndex || 0) + 2,
      top: 0
    }, void 0, true), fixedRenderer = this.fixedRenderer = new Renderer(fixedDiv, chart.chartWidth, chart.chartHeight, chartOptions.style);
    this.mask = fixedRenderer.path().attr({
      fill: chartOptions.backgroundColor || "#fff",
      "fill-opacity": scrollableOptions.opacity ?? 0.85,
      zIndex: -1
    }).addClass("highcharts-scrollable-mask").add();
    scrollingContainer.parentNode.insertBefore(fixedDiv, scrollingContainer);
    css11(chart.renderTo, { overflow: "visible" });
    addEvent13(chart, "afterShowResetZoom", moveFixedElements);
    addEvent13(chart, "afterApplyDrilldown", moveFixedElements);
    addEvent13(chart, "afterLayOutTitles", moveFixedElements);
    let lastHoverPoint;
    addEvent13(scrollingContainer, "scroll", () => {
      const { pointer, hoverPoint } = chart;
      if (pointer) {
        delete pointer.chartPosition;
        if (hoverPoint) {
          lastHoverPoint = hoverPoint;
        }
        pointer.runPointActions(void 0, lastHoverPoint, true);
      }
    });
    innerContainer.appendChild(chart.container);
  }
  applyFixed() {
    const { chart, fixedRenderer, isDirty, scrollingContainer } = this, { axisOffset, chartWidth, chartHeight, container, plotHeight, plotLeft, plotTop, plotWidth, scrollablePixelsX = 0, scrollablePixelsY = 0 } = chart, chartOptions = chart.options.chart, scrollableOptions = chartOptions.scrollablePlotArea || {}, { scrollPositionX = 0, scrollPositionY = 0 } = scrollableOptions, scrollableWidth = chartWidth + scrollablePixelsX, scrollableHeight = chartHeight + scrollablePixelsY;
    fixedRenderer.setSize(chartWidth, chartHeight);
    if (isDirty ?? true) {
      this.isDirty = false;
      this.moveFixedElements();
    }
    stop3(chart.container);
    css11(container, {
      width: `${scrollableWidth}px`,
      height: `${scrollableHeight}px`
    });
    chart.renderer.boxWrapper.attr({
      width: scrollableWidth,
      height: scrollableHeight,
      viewBox: [0, 0, scrollableWidth, scrollableHeight].join(" ")
    });
    chart.chartBackground?.attr({
      width: scrollableWidth,
      height: scrollableHeight
    });
    css11(scrollingContainer, {
      width: `${chartWidth}px`,
      height: `${chartHeight}px`
    });
    if (!defined17(isDirty)) {
      scrollingContainer.scrollLeft = scrollablePixelsX * scrollPositionX;
      scrollingContainer.scrollTop = scrollablePixelsY * scrollPositionY;
    }
    const maskTop = plotTop - axisOffset[0] - 1, maskLeft = plotLeft - axisOffset[3] - 1, maskBottom = plotTop + plotHeight + axisOffset[2] + 1, maskRight = plotLeft + plotWidth + axisOffset[1] + 1, maskPlotRight = plotLeft + plotWidth - scrollablePixelsX, maskPlotBottom = plotTop + plotHeight - scrollablePixelsY;
    let d = [["M", 0, 0]];
    if (scrollablePixelsX) {
      d = [
        // Left side
        ["M", 0, maskTop],
        ["L", plotLeft - 1, maskTop],
        ["L", plotLeft - 1, maskBottom],
        ["L", 0, maskBottom],
        ["Z"],
        // Right side
        ["M", maskPlotRight, maskTop],
        ["L", chartWidth, maskTop],
        ["L", chartWidth, maskBottom],
        ["L", maskPlotRight, maskBottom],
        ["Z"]
      ];
    } else if (scrollablePixelsY) {
      d = [
        // Top side
        ["M", maskLeft, 0],
        ["L", maskLeft, plotTop - 1],
        ["L", maskRight, plotTop - 1],
        ["L", maskRight, 0],
        ["Z"],
        // Bottom side
        ["M", maskLeft, maskPlotBottom],
        ["L", maskLeft, chartHeight],
        ["L", maskRight, chartHeight],
        ["L", maskRight, maskPlotBottom],
        ["Z"]
      ];
    }
    if (chart.redrawTrigger !== "adjustHeight") {
      this.mask.attr({ d });
    }
  }
  /**
   * These elements are moved over to the fixed renderer and stay fixed when
   * the user scrolls the chart
   * @private
   */
  moveFixedElements() {
    const { container, inverted, scrollablePixelsX, scrollablePixelsY } = this.chart, fixedRenderer = this.fixedRenderer, fixedSelectors = _ScrollablePlotArea.fixedSelectors;
    let axisClass;
    if (scrollablePixelsX && !inverted) {
      axisClass = ".highcharts-yaxis";
    } else if (scrollablePixelsX && inverted) {
      axisClass = ".highcharts-xaxis";
    } else if (scrollablePixelsY && !inverted) {
      axisClass = ".highcharts-xaxis";
    } else if (scrollablePixelsY && inverted) {
      axisClass = ".highcharts-yaxis";
    }
    if (axisClass && !(this.chart.hasParallelCoordinates && axisClass === ".highcharts-yaxis")) {
      for (const className of [
        `${axisClass}:not(.highcharts-radial-axis)`,
        `${axisClass}-labels:not(.highcharts-radial-axis-labels)`
      ]) {
        pushUnique8(fixedSelectors, className);
      }
    } else {
      for (const classBase of [
        ".highcharts-xaxis",
        ".highcharts-yaxis"
      ]) {
        for (const className of [
          `${classBase}:not(.highcharts-radial-axis)`,
          `${classBase}-labels:not(.highcharts-radial-axis-labels)`
        ]) {
          erase9(fixedSelectors, className);
        }
      }
    }
    for (const className of fixedSelectors) {
      [].forEach.call(container.querySelectorAll(className), (elem) => {
        (elem.namespaceURI === fixedRenderer.SVG_NS ? fixedRenderer.box : fixedRenderer.box.parentNode).appendChild(elem);
        elem.style.pointerEvents = "auto";
      });
    }
  }
};
ScrollablePlotArea.fixedSelectors = [
  ".highcharts-breadcrumbs-group",
  ".highcharts-contextbutton",
  ".highcharts-caption",
  ".highcharts-credits",
  ".highcharts-drillup-button",
  ".highcharts-legend",
  ".highcharts-legend-checkbox",
  ".highcharts-navigator-series",
  ".highcharts-navigator-xaxis",
  ".highcharts-navigator-yaxis",
  ".highcharts-navigator",
  ".highcharts-range-selector-group",
  ".highcharts-reset-zoom",
  ".highcharts-scrollbar",
  ".highcharts-subtitle",
  ".highcharts-title"
];
var ScrollablePlotArea_default = ScrollablePlotArea;

// node_modules/highcharts/es-modules/Core/Axis/Stacking/StackItem.js
var { format: format6 } = Templating_default;
var { series: Series2 } = SeriesRegistry_default;
var { destroyObjectProperties: destroyObjectProperties7, fireEvent: fireEvent15, getAlignFactor: getAlignFactor8, isNumber: isNumber21, pick: pick21 } = Utilities_default;
var StackItem = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(axis, options2, negativeValue, x, stackOption) {
    const inverted = axis.chart.inverted, reversed = axis.reversed;
    this.axis = axis;
    const isNegative = this.isNegative = !!negativeValue !== !!reversed;
    this.options = options2 = options2 || {};
    this.x = x;
    this.total = null;
    this.cumulative = null;
    this.points = {};
    this.hasValidPoints = false;
    this.stack = stackOption;
    this.leftCliff = 0;
    this.rightCliff = 0;
    this.alignOptions = {
      align: options2.align || (inverted ? isNegative ? "left" : "right" : "center"),
      verticalAlign: options2.verticalAlign || (inverted ? "middle" : isNegative ? "bottom" : "top"),
      y: options2.y,
      x: options2.x
    };
    this.textAlign = options2.textAlign || (inverted ? !isNegative ? "left" : "right" : "center");
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  destroy() {
    destroyObjectProperties7(this, this.axis);
  }
  /**
   * Renders the stack total label and adds it to the stack label group.
   * @private
   */
  render(group) {
    const chart = this.axis.chart, options2 = this.options, formatOption = options2.format, str = formatOption ? format6(formatOption, this, chart) : options2.formatter.call(this);
    if (this.label) {
      this.label.attr({ text: str, visibility: "hidden" });
    } else {
      this.label = chart.renderer.label(str, null, void 0, options2.shape, void 0, void 0, options2.useHTML, false, "stack-labels");
      const attr18 = {
        r: options2.borderRadius || 0,
        text: str,
        // Set default padding to 5 as it is in datalabels #12308
        padding: pick21(options2.padding, 5),
        visibility: "hidden"
        // Hidden until setOffset is called
      };
      if (!chart.styledMode) {
        attr18.fill = options2.backgroundColor;
        attr18.stroke = options2.borderColor;
        attr18["stroke-width"] = options2.borderWidth;
        this.label.css(options2.style || {});
      }
      this.label.attr(attr18);
      if (!this.label.added) {
        this.label.add(group);
      }
    }
    this.label.labelrank = chart.plotSizeY;
    fireEvent15(this, "afterRender");
  }
  /**
   * Sets the offset that the stack has from the x value and repositions the
   * label.
   * @private
   */
  setOffset(xOffset, width, boxBottom, boxTop, defaultX, xAxis2) {
    const { alignOptions, axis, label, options: options2, textAlign } = this, chart = axis.chart, stackBox = this.getStackBox({
      xOffset,
      width,
      boxBottom,
      boxTop,
      defaultX,
      xAxis: xAxis2
    }), { verticalAlign } = alignOptions;
    if (label && stackBox) {
      const labelBox = label.getBBox(void 0, 0), padding = label.padding;
      let isJustify = pick21(options2.overflow, "justify") === "justify", visible;
      alignOptions.x = options2.x || 0;
      alignOptions.y = options2.y || 0;
      const { x, y } = this.adjustStackPosition({
        labelBox,
        verticalAlign,
        textAlign
      });
      stackBox.x -= x;
      stackBox.y -= y;
      label.align(alignOptions, false, stackBox);
      visible = chart.isInsidePlot(label.alignAttr.x + alignOptions.x + x, label.alignAttr.y + alignOptions.y + y);
      if (!visible) {
        isJustify = false;
      }
      if (isJustify) {
        Series2.prototype.justifyDataLabel.call(axis, label, alignOptions, label.alignAttr, labelBox, stackBox);
      }
      label.attr({
        x: label.alignAttr.x,
        y: label.alignAttr.y,
        rotation: options2.rotation,
        rotationOriginX: labelBox.width * getAlignFactor8(options2.textAlign || "center"),
        rotationOriginY: labelBox.height / 2
      });
      if (pick21(!isJustify && options2.crop, true)) {
        visible = isNumber21(label.x) && isNumber21(label.y) && chart.isInsidePlot(label.x - padding + (label.width || 0), label.y) && chart.isInsidePlot(label.x + padding, label.y);
      }
      label[visible ? "show" : "hide"]();
    }
    fireEvent15(this, "afterSetOffset", { xOffset, width });
  }
  /**
   * Adjust the stack BBox position, to take into consideration the alignment
   * of the dataLabel. This is necessary to make the stackDataLabel work with
   * core methods like `SVGLabel.adjust` and `Series.justifyDataLabel`.
   * @param AdjustStackPositionProps
   * @return {{x: number, y: number}} Adjusted BBox position of the stack.
   */
  adjustStackPosition({ labelBox, verticalAlign, textAlign }) {
    return {
      x: labelBox.width / 2 + labelBox.width / 2 * (2 * getAlignFactor8(textAlign) - 1),
      y: labelBox.height / 2 * 2 * (1 - getAlignFactor8(verticalAlign))
    };
  }
  /**
   * Get the bbox of the stack.
   * @private
   * @function Highcharts.StackItem#getStackBox
   * @return {BBoxObject} The x, y, height, width of the stack.
   */
  getStackBox(stackBoxProps) {
    const stackItem = this, axis = this.axis, chart = axis.chart, { boxTop, defaultX, xOffset, width, boxBottom } = stackBoxProps, totalStackValue = axis.stacking.usePercentage ? 100 : pick21(boxTop, this.total, 0), y = axis.toPixels(totalStackValue), xAxis2 = stackBoxProps.xAxis || chart.xAxis[0], x = pick21(defaultX, xAxis2.translate(this.x)) + xOffset, yZero = axis.toPixels(boxBottom || isNumber21(axis.min) && axis.logarithmic && axis.logarithmic.lin2log(axis.min) || 0), height = Math.abs(y - yZero), inverted = chart.inverted, neg = stackItem.isNegative;
    return inverted ? {
      x: (neg ? y : y - height) - chart.plotLeft,
      y: xAxis2.height - x - width + xAxis2.top - chart.plotTop,
      width: height,
      height: width
    } : {
      x: x + xAxis2.transB - chart.plotLeft,
      y: (neg ? y - height : y) - chart.plotTop,
      width,
      height
    };
  }
};
var StackItem_default = StackItem;

// node_modules/highcharts/es-modules/Core/Axis/Stacking/StackingAxis.js
var { getDeferredAnimation: getDeferredAnimation2 } = AnimationUtilities_default;
var { series: { prototype: seriesProto } } = SeriesRegistry_default;
var { addEvent: addEvent14, correctFloat: correctFloat5, defined: defined18, destroyObjectProperties: destroyObjectProperties8, fireEvent: fireEvent16, isNumber: isNumber22, objectEach: objectEach16, pick: pick22 } = Utilities_default;
function chartGetStacks() {
  const chart = this, inverted = chart.inverted;
  chart.axes.forEach((axis) => {
    if (axis.stacking?.stacks && axis.hasVisibleSeries) {
      axis.stacking.oldStacks = axis.stacking.stacks;
    }
  });
  chart.series.forEach((series) => {
    const xAxisOptions = series.xAxis?.options || {};
    if (series.options.stacking && series.reserveSpace()) {
      series.stackKey = [
        series.type,
        pick22(series.options.stack, ""),
        inverted ? xAxisOptions.top : xAxisOptions.left,
        inverted ? xAxisOptions.height : xAxisOptions.width
      ].join(",");
    }
  });
}
function onAxisDestroy() {
  const stacking = this.stacking;
  if (stacking) {
    const stacks = stacking.stacks;
    objectEach16(stacks, (stack, stackKey) => {
      destroyObjectProperties8(stack);
      delete stacks[stackKey];
    });
    stacking.stackTotalGroup?.destroy();
  }
}
function onAxisInit() {
  if (!this.stacking) {
    this.stacking = new AxisAdditions(this);
  }
}
function seriesGetStackIndicator(stackIndicator, x, index, key) {
  if (!defined18(stackIndicator) || stackIndicator.x !== x || key && stackIndicator.stackKey !== key) {
    stackIndicator = {
      x,
      index: 0,
      key,
      stackKey: key
    };
  } else {
    stackIndicator.index++;
  }
  stackIndicator.key = [index, x, stackIndicator.index].join(",");
  return stackIndicator;
}
function seriesModifyStacks() {
  const series = this, yAxis2 = series.yAxis, stackKey = series.stackKey || "", stacks = yAxis2.stacking.stacks, processedXData = series.getColumn("x", true), stacking = series.options.stacking, stacker = series[stacking + "Stacker"];
  let stackIndicator;
  if (stacker) {
    [stackKey, "-" + stackKey].forEach((key) => {
      let i = processedXData.length, x, stackItem, pointExtremes;
      while (i--) {
        x = processedXData[i];
        stackIndicator = series.getStackIndicator(stackIndicator, x, series.index, key);
        stackItem = stacks[key]?.[x];
        pointExtremes = stackItem?.points[stackIndicator.key || ""];
        if (pointExtremes) {
          stacker.call(series, pointExtremes, stackItem, i);
        }
      }
    });
  }
}
function seriesPercentStacker(pointExtremes, stack, i) {
  const totalFactor = stack.total ? 100 / stack.total : 0;
  pointExtremes[0] = correctFloat5(pointExtremes[0] * totalFactor);
  pointExtremes[1] = correctFloat5(pointExtremes[1] * totalFactor);
  this.stackedYData[i] = pointExtremes[1];
}
function seriesSetGroupedPoints(axis) {
  if (this.is("column") || this.is("columnrange")) {
    if (this.options.centerInCategory && // With only one series, we don't need to consider centerInCategory
    this.chart.series.length > 1) {
      seriesProto.setStackedPoints.call(this, axis, "group");
    } else {
      axis.stacking.resetStacks();
    }
  }
}
function seriesSetStackedPoints(axis, stackingParam) {
  const type = stackingParam || this.options.stacking;
  if (!type || !this.reserveSpace() || // Group stacks (centerInCategory) belong on the x-axis, other stacks on
  // the y-axis.
  ({ group: "xAxis" }[type] || "yAxis") !== axis.coll) {
    return;
  }
  const series = this, xData = series.getColumn("x", true), yData = series.getColumn(series.pointValKey || "y", true), stackedYData = [], yDataLength = yData.length, seriesOptions = series.options, threshold = seriesOptions.threshold || 0, stackThreshold = seriesOptions.startFromThreshold ? threshold : 0, stackOption = seriesOptions.stack, stackKey = stackingParam ? `${series.type},${type}` : series.stackKey || "", negKey = "-" + stackKey, negStacks = series.negStacks, stacking = axis.stacking, stacks = stacking.stacks, oldStacks = stacking.oldStacks;
  let stackIndicator, isNegative, stack, other, key, pointKey, i;
  stacking.stacksTouched += 1;
  for (i = 0; i < yDataLength; i++) {
    const x = xData[i] || 0, y = yData[i], yNumber = isNumber22(y) && y || 0;
    stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
    pointKey = stackIndicator.key || "";
    isNegative = negStacks && yNumber < (stackThreshold ? 0 : threshold);
    key = isNegative ? negKey : stackKey;
    if (!stacks[key]) {
      stacks[key] = {};
    }
    if (!stacks[key][x]) {
      if (oldStacks[key]?.[x]) {
        stacks[key][x] = oldStacks[key][x];
        stacks[key][x].total = null;
      } else {
        stacks[key][x] = new StackItem_default(axis, axis.options.stackLabels, !!isNegative, x, stackOption);
      }
    }
    stack = stacks[key][x];
    if (y !== null) {
      stack.points[pointKey] = stack.points[series.index] = [
        pick22(stack.cumulative, stackThreshold)
      ];
      if (!defined18(stack.cumulative)) {
        stack.base = pointKey;
      }
      stack.touched = stacking.stacksTouched;
      if (stackIndicator.index > 0 && series.singleStacks === false) {
        stack.points[pointKey][0] = stack.points[series.index + "," + x + ",0"][0];
      }
    } else {
      delete stack.points[pointKey];
      delete stack.points[series.index];
    }
    let total = stack.total || 0;
    if (type === "percent") {
      other = isNegative ? stackKey : negKey;
      if (negStacks && stacks[other]?.[x]) {
        other = stacks[other][x];
        total = other.total = Math.max(other.total || 0, total) + Math.abs(yNumber);
      } else {
        total = correctFloat5(total + Math.abs(yNumber));
      }
    } else if (type === "group") {
      if (isNumber22(y)) {
        total++;
      }
    } else {
      total = correctFloat5(total + yNumber);
    }
    if (type === "group") {
      stack.cumulative = (total || 1) - 1;
    } else {
      stack.cumulative = correctFloat5(pick22(stack.cumulative, stackThreshold) + yNumber);
    }
    stack.total = total;
    if (y !== null) {
      stack.points[pointKey].push(stack.cumulative);
      stackedYData[i] = stack.cumulative;
      stack.hasValidPoints = true;
    }
  }
  if (type === "percent") {
    stacking.usePercentage = true;
  }
  if (type !== "group") {
    this.stackedYData = stackedYData;
  }
  stacking.oldStacks = {};
}
var AxisAdditions = class {
  /* *
   *
   *  Constructors
   *
   * */
  constructor(axis) {
    this.oldStacks = {};
    this.stacks = {};
    this.stacksTouched = 0;
    this.axis = axis;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Build the stacks from top down
   * @private
   */
  buildStacks() {
    const stacking = this, axis = stacking.axis, axisSeries = axis.series, isXAxis = axis.coll === "xAxis", reversedStacks = axis.options.reversedStacks, len = axisSeries.length;
    let actualSeries, i;
    this.resetStacks();
    stacking.usePercentage = false;
    i = len;
    while (i--) {
      actualSeries = axisSeries[reversedStacks ? i : len - i - 1];
      if (isXAxis) {
        actualSeries.setGroupedPoints(axis);
      }
      actualSeries.setStackedPoints(axis);
    }
    if (!isXAxis) {
      for (i = 0; i < len; i++) {
        axisSeries[i].modifyStacks();
      }
    }
    fireEvent16(axis, "afterBuildStacks");
  }
  /**
   * @private
   */
  cleanStacks() {
    if (this.oldStacks) {
      this.stacks = this.oldStacks;
      objectEach16(this.stacks, (type) => {
        objectEach16(type, (stack) => {
          stack.cumulative = stack.total;
        });
      });
    }
  }
  /**
   * Set all the stacks to initial states and destroy unused ones.
   * @private
   */
  resetStacks() {
    objectEach16(this.stacks, (type) => {
      objectEach16(type, (stack, x) => {
        if (isNumber22(stack.touched) && stack.touched < this.stacksTouched) {
          stack.destroy();
          delete type[x];
        } else {
          stack.total = null;
          stack.cumulative = null;
        }
      });
    });
  }
  /**
   * @private
   */
  renderStackTotals() {
    const stacking = this, axis = stacking.axis, chart = axis.chart, renderer = chart.renderer, stacks = stacking.stacks, stackLabelsAnim = axis.options.stackLabels?.animation, animationConfig = getDeferredAnimation2(chart, stackLabelsAnim || false), stackTotalGroup = stacking.stackTotalGroup = stacking.stackTotalGroup || renderer.g("stack-labels").attr({
      zIndex: 6,
      opacity: 0
    }).add();
    stackTotalGroup.translate(chart.plotLeft, chart.plotTop);
    objectEach16(stacks, (type) => {
      objectEach16(type, (stack) => {
        stack.render(stackTotalGroup);
      });
    });
    stackTotalGroup.animate({
      opacity: 1
    }, animationConfig);
  }
};
var StackingAxis;
(function(StackingAxis2) {
  function compose27(AxisClass, ChartClass, SeriesClass) {
    const chartProto = ChartClass.prototype, seriesProto7 = SeriesClass.prototype;
    if (!chartProto.getStacks) {
      addEvent14(AxisClass, "init", onAxisInit);
      addEvent14(AxisClass, "destroy", onAxisDestroy);
      chartProto.getStacks = chartGetStacks;
      seriesProto7.getStackIndicator = seriesGetStackIndicator;
      seriesProto7.modifyStacks = seriesModifyStacks;
      seriesProto7.percentStacker = seriesPercentStacker;
      seriesProto7.setGroupedPoints = seriesSetGroupedPoints;
      seriesProto7.setStackedPoints = seriesSetStackedPoints;
    }
  }
  StackingAxis2.compose = compose27;
})(StackingAxis || (StackingAxis = {}));
var StackingAxis_default = StackingAxis;

// node_modules/highcharts/es-modules/Series/Line/LineSeries.js
var { defined: defined19, merge: merge20, isObject: isObject11 } = Utilities_default;
var LineSeries = class extends Series_default {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Draw the graph. Called internally when rendering line-like series
   * types. The first time it generates the `series.graph` item and
   * optionally other series-wide items like `series.area` for area
   * charts. On subsequent calls these items are updated with new
   * positions and attributes.
   *
   * @function Highcharts.Series#drawGraph
   */
  drawGraph() {
    const options2 = this.options, graphPath = (this.gappedPath || this.getGraphPath).call(this), styledMode = this.chart.styledMode;
    [this, ...this.zones].forEach((owner, i) => {
      let attribs, graph = owner.graph;
      const verb = graph ? "animate" : "attr", dashStyle = owner.dashStyle || options2.dashStyle;
      if (graph) {
        graph.endX = this.preventGraphAnimation ? null : graphPath.xMap;
        graph.animate({ d: graphPath });
      } else if (graphPath.length) {
        owner.graph = graph = this.chart.renderer.path(graphPath).addClass("highcharts-graph" + (i ? ` highcharts-zone-graph-${i - 1} ` : " ") + (i && owner.className || "")).attr({ zIndex: 1 }).add(this.group);
      }
      if (graph && !styledMode) {
        attribs = {
          "stroke": !i && options2.lineColor || // Series only
          owner.color || this.color || "#cccccc",
          "stroke-width": options2.lineWidth || 0,
          // Polygon series use filled graph
          "fill": this.fillGraph && this.color || "none"
        };
        if (dashStyle) {
          attribs.dashstyle = dashStyle;
        } else if (options2.linecap !== "square") {
          attribs["stroke-linecap"] = attribs["stroke-linejoin"] = "round";
        }
        graph[verb](attribs).shadow(options2.shadow && // If shadow is defined, call function with
        // `filterUnits: 'userSpaceOnUse'` to avoid known
        // SVG filter bug (#19093)
        merge20({ filterUnits: "userSpaceOnUse" }, isObject11(options2.shadow) ? options2.shadow : {}));
      }
      if (graph) {
        graph.startX = graphPath.xMap;
        graph.isArea = graphPath.isArea;
      }
    });
  }
  // eslint-disable-next-line valid-jsdoc
  /**
   * Get the graph path.
   *
   * @private
   */
  getGraphPath(points, nullsAsZeroes, connectCliffs) {
    const series = this, options2 = series.options, graphPath = [], xMap = [];
    let gap, step = options2.step;
    points = points || series.points;
    const reversed = points.reversed;
    if (reversed) {
      points.reverse();
    }
    step = {
      right: 1,
      center: 2
    }[step] || step && 3;
    if (step && reversed) {
      step = 4 - step;
    }
    points = this.getValidPoints(points, false, options2.nullInteraction || !(options2.connectNulls && !nullsAsZeroes && !connectCliffs));
    points.forEach(function(point, i) {
      const plotX = point.plotX, plotY = point.plotY, lastPoint = points[i - 1], isNull = point.isNull || typeof plotY !== "number";
      let pathToPoint;
      if ((point.leftCliff || lastPoint?.rightCliff) && !connectCliffs) {
        gap = true;
      }
      if (isNull && !defined19(nullsAsZeroes) && i > 0) {
        gap = !options2.connectNulls;
      } else if (isNull && !nullsAsZeroes) {
        gap = true;
      } else {
        if (i === 0 || gap) {
          pathToPoint = [[
            "M",
            point.plotX,
            point.plotY
          ]];
        } else if (series.getPointSpline) {
          pathToPoint = [series.getPointSpline(points, point, i)];
        } else if (step) {
          if (step === 1) {
            pathToPoint = [[
              "L",
              lastPoint.plotX,
              plotY
            ]];
          } else if (step === 2) {
            pathToPoint = [[
              "L",
              (lastPoint.plotX + plotX) / 2,
              lastPoint.plotY
            ], [
              "L",
              (lastPoint.plotX + plotX) / 2,
              plotY
            ]];
          } else {
            pathToPoint = [[
              "L",
              plotX,
              lastPoint.plotY
            ]];
          }
          pathToPoint.push([
            "L",
            plotX,
            plotY
          ]);
        } else {
          pathToPoint = [[
            "L",
            plotX,
            plotY
          ]];
        }
        xMap.push(point.x);
        if (step) {
          xMap.push(point.x);
          if (step === 2) {
            xMap.push(point.x);
          }
        }
        graphPath.push.apply(graphPath, pathToPoint);
        gap = false;
      }
    });
    graphPath.xMap = xMap;
    series.graphPath = graphPath;
    return graphPath;
  }
};
LineSeries.defaultOptions = merge20(
  Series_default.defaultOptions,
  /**
   * General options for all series types.
   *
   * @optionparent plotOptions.series
   */
  {
    legendSymbol: "lineMarker"
  }
);
SeriesRegistry_default.registerSeriesType("line", LineSeries);

// node_modules/highcharts/es-modules/Series/Area/AreaSeriesDefaults.js
var AreaSeriesDefaults = {
  /**
   * @see [fillColor](#plotOptions.area.fillColor)
   * @see [fillOpacity](#plotOptions.area.fillOpacity)
   *
   * @apioption plotOptions.area.color
   */
  /**
   * Fill color or gradient for the area. When `undefined`, the series'
   * `color` is used with the series' `fillOpacity`.
   *
   * In styled mode, the fill color can be set with the `.highcharts-area`
   * class name.
   *
   * @see [color](#plotOptions.area.color)
   * @see [fillOpacity](#plotOptions.area.fillOpacity)
   *
   * @sample {highcharts} highcharts/plotoptions/area-fillcolor-default/
   *         Undefined by default
   * @sample {highcharts} highcharts/plotoptions/area-fillcolor-gradient/
   *         Gradient
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product   highcharts highstock
   * @apioption plotOptions.area.fillColor
   */
  /**
   * Fill opacity for the area. When you set an explicit `fillColor`,
   * the `fillOpacity` is not applied. Instead, you should define the
   * opacity in the `fillColor` with an rgba color definition. The
   * `fillOpacity` setting, also the default setting, overrides the alpha
   * component of the `color` setting.
   *
   * In styled mode, the fill opacity can be set with the
   * `.highcharts-area` class name.
   *
   * @see [color](#plotOptions.area.color)
   * @see [fillColor](#plotOptions.area.fillColor)
   *
   * @sample {highcharts} highcharts/plotoptions/area-fillopacity/
   *         Automatic fill color and fill opacity of 0.1
   *
   * @type      {number}
   * @default   {highcharts} 0.75
   * @default   {highstock} 0.75
   * @product   highcharts highstock
   * @apioption plotOptions.area.fillOpacity
   */
  /**
   * A separate color for the graph line. By default the line takes the
   * `color` of the series, but the lineColor setting allows setting a
   * separate color for the line without altering the `fillColor`.
   *
   * In styled mode, the line stroke can be set with the
   * `.highcharts-graph` class name.
   *
   * @sample {highcharts} highcharts/plotoptions/area-linecolor/
   *         Dark gray line
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product   highcharts highstock
   * @apioption plotOptions.area.lineColor
   */
  /**
   * A separate color for the negative part of the area. Note that `zones`
   * takes precedence over the negative fill color.
   *
   * In styled mode, a negative color is set with the
   * `.highcharts-negative` class name.
   *
   * @see [negativeColor](#plotOptions.area.negativeColor)
   *
   * @sample {highcharts} highcharts/css/series-negative-color/
   *         Negative color in styled mode
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     3.0
   * @product   highcharts
   * @apioption plotOptions.area.negativeFillColor
   */
  /**
   * Whether the whole area or just the line should respond to mouseover
   * tooltips and other mouse or touch events.
   *
   * @sample {highcharts|highstock} highcharts/plotoptions/area-trackbyarea/
   *         Display the tooltip when the area is hovered
   *
   * @type      {boolean}
   * @default   false
   * @since     1.1.6
   * @product   highcharts highstock
   * @apioption plotOptions.area.trackByArea
   */
  /**
   * The Y axis value to serve as the base for the area, for
   * distinguishing between values above and below a threshold. The area
   * between the graph and the threshold is filled.
   *
   * * If a number is given, the Y axis will scale to the threshold.
   * * If `null`, the scaling behaves like a line series with fill between
   *   the graph and the Y axis minimum.
   * * If `Infinity` or `-Infinity`, the area between the graph and the
   *   corresponding Y axis extreme is filled (since v6.1.0).
   *
   * @sample {highcharts} highcharts/plotoptions/area-threshold/
   *         A threshold of 100
   * @sample {highcharts} highcharts/plotoptions/area-threshold-infinity/
   *         A threshold of Infinity
   *
   * @type    {number|null}
   * @since   2.0
   * @product highcharts highstock
   */
  threshold: 0,
  legendSymbol: "areaMarker"
};
var AreaSeriesDefaults_default = AreaSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Area/AreaSeries.js
var { seriesTypes: { line: LineSeries2 } } = SeriesRegistry_default;
var { extend: extend20, merge: merge21, objectEach: objectEach17, pick: pick23 } = Utilities_default;
var AreaSeries = class extends LineSeries2 {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Draw the graph and the underlying area. This method calls the Series
   * base function and adds the area. The areaPath is calculated in the
   * getSegmentPath method called from Series.prototype.drawGraph.
   * @private
   */
  drawGraph() {
    this.areaPath = [];
    super.drawGraph.apply(this);
    const { areaPath, options: options2 } = this;
    [this, ...this.zones].forEach((owner, i) => {
      const attribs = {}, fillColor = owner.fillColor || options2.fillColor;
      let area = owner.area;
      const verb = area ? "animate" : "attr";
      if (area) {
        area.endX = this.preventGraphAnimation ? null : areaPath.xMap;
        area.animate({ d: areaPath });
      } else {
        attribs.zIndex = 0;
        area = owner.area = this.chart.renderer.path(areaPath).addClass("highcharts-area" + (i ? ` highcharts-zone-area-${i - 1} ` : " ") + (i && owner.className || "")).add(this.group);
        area.isArea = true;
      }
      if (!this.chart.styledMode) {
        attribs.fill = fillColor || owner.color || this.color;
        attribs["fill-opacity"] = fillColor ? 1 : options2.fillOpacity ?? 0.75;
        area.css({
          pointerEvents: this.stickyTracking ? "none" : "auto"
        });
      }
      area[verb](attribs);
      area.startX = areaPath.xMap;
      area.shiftUnit = options2.step ? 2 : 1;
    });
  }
  /**
   * @private
   */
  getGraphPath(points) {
    const getGraphPath = LineSeries2.prototype.getGraphPath, options2 = this.options, stacking = options2.stacking, yAxis2 = this.yAxis, bottomPoints = [], graphPoints = [], seriesIndex = this.index, stacks = yAxis2.stacking.stacks[this.stackKey], threshold = options2.threshold, translatedThreshold = Math.round(
      // #10909
      yAxis2.getThreshold(options2.threshold)
    ), connectNulls = pick23(
      // #10574
      options2.connectNulls,
      stacking === "percent"
    ), addDummyPoints = function(i, otherI, side) {
      const point = points[i], stackedValues = stacking && stacks[point.x].points[seriesIndex], nullVal = point[side + "Null"] || 0, cliffVal = point[side + "Cliff"] || 0;
      let top, bottom, isNull2 = true;
      if (cliffVal || nullVal) {
        top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
        bottom = stackedValues[0] + cliffVal;
        isNull2 = !!nullVal;
      } else if (!stacking && points[otherI] && points[otherI].isNull) {
        top = bottom = threshold;
      }
      if (typeof top !== "undefined") {
        graphPoints.push({
          plotX,
          plotY: top === null ? translatedThreshold : yAxis2.getThreshold(top),
          isNull: isNull2,
          isCliff: true
        });
        bottomPoints.push({
          plotX,
          plotY: bottom === null ? translatedThreshold : yAxis2.getThreshold(bottom),
          doCurve: false
          // #1041, gaps in areaspline areas
        });
      }
    };
    let plotX, isNull, yBottom;
    points = points || this.points;
    if (stacking) {
      points = this.getStackPoints(points);
    }
    for (let i = 0, iEnd = points.length; i < iEnd; ++i) {
      if (!stacking) {
        points[i].leftCliff = points[i].rightCliff = points[i].leftNull = points[i].rightNull = void 0;
      }
      isNull = points[i].isNull;
      plotX = pick23(points[i].rectPlotX, points[i].plotX);
      yBottom = stacking ? pick23(points[i].yBottom, translatedThreshold) : translatedThreshold;
      if (!isNull || connectNulls) {
        if (!connectNulls) {
          addDummyPoints(i, i - 1, "left");
        }
        if (!(isNull && !stacking && connectNulls)) {
          graphPoints.push(points[i]);
          bottomPoints.push({
            x: i,
            plotX,
            plotY: yBottom
          });
        }
        if (!connectNulls) {
          addDummyPoints(i, i + 1, "right");
        }
      }
    }
    const topPath = getGraphPath.call(this, graphPoints, true, true);
    bottomPoints.reversed = true;
    const bottomPath = getGraphPath.call(this, bottomPoints, true, true);
    const firstBottomPoint = bottomPath[0];
    if (firstBottomPoint && firstBottomPoint[0] === "M") {
      bottomPath[0] = ["L", firstBottomPoint[1], firstBottomPoint[2]];
    }
    const areaPath = topPath.concat(bottomPath);
    if (areaPath.length) {
      areaPath.push(["Z"]);
    }
    const graphPath = getGraphPath.call(this, graphPoints, false, connectNulls);
    if (this.chart.series.length > 1 && stacking && graphPoints.some((point) => point.isCliff)) {
      areaPath.hasStackedCliffs = graphPath.hasStackedCliffs = true;
    }
    areaPath.xMap = topPath.xMap;
    this.areaPath = areaPath;
    return graphPath;
  }
  /**
   * Return an array of stacked points, where null and missing points are
   * replaced by dummy points in order for gaps to be drawn correctly in
   * stacks.
   * @private
   */
  getStackPoints(points) {
    const series = this, segment = [], keys = [], xAxis2 = this.xAxis, yAxis2 = this.yAxis, stack = yAxis2.stacking.stacks[this.stackKey], pointMap = {}, yAxisSeries = yAxis2.series, seriesLength = yAxisSeries.length, upOrDown = yAxis2.options.reversedStacks ? 1 : -1, seriesIndex = yAxisSeries.indexOf(series);
    points = points || this.points;
    if (this.options.stacking) {
      for (let i = 0; i < points.length; i++) {
        points[i].leftNull = points[i].rightNull = void 0;
        pointMap[points[i].x] = points[i];
      }
      objectEach17(stack, function(stackX, x) {
        if (stackX.total !== null) {
          keys.push(x);
        }
      });
      keys.sort(function(a, b) {
        return a - b;
      });
      const visibleSeries = yAxisSeries.map((s) => s.visible);
      keys.forEach(function(x, idx) {
        let y = 0, stackPoint, stackedValues;
        if (pointMap[x] && !pointMap[x].isNull) {
          segment.push(pointMap[x]);
          [-1, 1].forEach(function(direction) {
            const nullName = direction === 1 ? "rightNull" : "leftNull", cliffName = direction === 1 ? "rightCliff" : "leftCliff", otherStack = stack[keys[idx + direction]];
            let cliff = 0;
            if (otherStack) {
              let i = seriesIndex;
              while (i >= 0 && i < seriesLength) {
                const si = yAxisSeries[i].index;
                stackPoint = otherStack.points[si];
                if (!stackPoint) {
                  if (si === series.index) {
                    pointMap[x][nullName] = true;
                  } else if (visibleSeries[i]) {
                    stackedValues = stack[x].points[si];
                    if (stackedValues) {
                      cliff -= stackedValues[1] - stackedValues[0];
                    }
                  }
                }
                i += upOrDown;
              }
            }
            pointMap[x][cliffName] = cliff;
          });
        } else {
          let i = seriesIndex;
          while (i >= 0 && i < seriesLength) {
            const si = yAxisSeries[i].index;
            stackPoint = stack[x].points[si];
            if (stackPoint) {
              y = stackPoint[1];
              break;
            }
            i += upOrDown;
          }
          y = pick23(y, 0);
          y = yAxis2.translate(
            // #6272
            y,
            0,
            1,
            0,
            1
          );
          segment.push({
            isNull: true,
            plotX: xAxis2.translate(
              // #6272
              x,
              0,
              0,
              0,
              1
            ),
            x,
            plotY: y,
            yBottom: y
          });
        }
      });
    }
    return segment;
  }
};
AreaSeries.defaultOptions = merge21(LineSeries2.defaultOptions, AreaSeriesDefaults_default);
extend20(AreaSeries.prototype, {
  singleStacks: false
});
SeriesRegistry_default.registerSeriesType("area", AreaSeries);

// node_modules/highcharts/es-modules/Series/Spline/SplineSeries.js
var { line: LineSeries3 } = SeriesRegistry_default.seriesTypes;
var { merge: merge22, pick: pick24 } = Utilities_default;
var SplineSeries = class extends LineSeries3 {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Get the spline segment from a given point's previous neighbour to the
   * given point.
   *
   * @private
   * @function Highcharts.seriesTypes.spline#getPointSpline
   */
  getPointSpline(points, point, i) {
    const smoothing = 1.5, denom = smoothing + 1, plotX = point.plotX || 0, plotY = point.plotY || 0, lastPoint = points[i - 1], nextPoint = points[i + 1];
    let leftContX, leftContY, rightContX, rightContY;
    function doCurve(otherPoint) {
      return otherPoint && !otherPoint.isNull && otherPoint.doCurve !== false && // #6387, area splines next to null:
      !point.isCliff;
    }
    if (doCurve(lastPoint) && doCurve(nextPoint)) {
      const lastX = lastPoint.plotX || 0, lastY = lastPoint.plotY || 0, nextX = nextPoint.plotX || 0, nextY = nextPoint.plotY || 0;
      let correction = 0;
      leftContX = (smoothing * plotX + lastX) / denom;
      leftContY = (smoothing * plotY + lastY) / denom;
      rightContX = (smoothing * plotX + nextX) / denom;
      rightContY = (smoothing * plotY + nextY) / denom;
      if (rightContX !== leftContX) {
        correction = (rightContY - leftContY) * (rightContX - plotX) / (rightContX - leftContX) + plotY - rightContY;
      }
      leftContY += correction;
      rightContY += correction;
      if (leftContY > lastY && leftContY > plotY) {
        leftContY = Math.max(lastY, plotY);
        rightContY = 2 * plotY - leftContY;
      } else if (leftContY < lastY && leftContY < plotY) {
        leftContY = Math.min(lastY, plotY);
        rightContY = 2 * plotY - leftContY;
      }
      if (rightContY > nextY && rightContY > plotY) {
        rightContY = Math.max(nextY, plotY);
        leftContY = 2 * plotY - rightContY;
      } else if (rightContY < nextY && rightContY < plotY) {
        rightContY = Math.min(nextY, plotY);
        leftContY = 2 * plotY - rightContY;
      }
      point.rightContX = rightContX;
      point.rightContY = rightContY;
      point.controlPoints = {
        low: [leftContX, leftContY],
        high: [rightContX, rightContY]
      };
    }
    const ret = [
      "C",
      pick24(lastPoint.rightContX, lastPoint.plotX, 0),
      pick24(lastPoint.rightContY, lastPoint.plotY, 0),
      pick24(leftContX, plotX, 0),
      pick24(leftContY, plotY, 0),
      plotX,
      plotY
    ];
    lastPoint.rightContX = lastPoint.rightContY = void 0;
    return ret;
  }
};
SplineSeries.defaultOptions = merge22(LineSeries3.defaultOptions);
SeriesRegistry_default.registerSeriesType("spline", SplineSeries);
var SplineSeries_default = SplineSeries;

// node_modules/highcharts/es-modules/Series/AreaSpline/AreaSplineSeries.js
var { area: AreaSeries2, area: { prototype: areaProto } } = SeriesRegistry_default.seriesTypes;
var { extend: extend21, merge: merge23 } = Utilities_default;
var AreaSplineSeries = class extends SplineSeries_default {
};
AreaSplineSeries.defaultOptions = merge23(SplineSeries_default.defaultOptions, AreaSeries2.defaultOptions);
extend21(AreaSplineSeries.prototype, {
  getGraphPath: areaProto.getGraphPath,
  getStackPoints: areaProto.getStackPoints,
  drawGraph: areaProto.drawGraph
});
SeriesRegistry_default.registerSeriesType("areaspline", AreaSplineSeries);

// node_modules/highcharts/es-modules/Series/Column/ColumnSeriesDefaults.js
var ColumnSeriesDefaults = {
  /**
   * The corner radius of the border surrounding each column or bar. A number
   * signifies pixels. A percentage string, like for example `50%`, signifies
   * a relative size. For columns this is relative to the column width, for
   * pies it is relative to the radius and the inner radius.
   *
   * @sample  {highcharts} highcharts/plotoptions/column-borderradius/
   *          Rounded columns
   * @sample  highcharts/plotoptions/series-border-radius
   *          Column and pie with rounded border
   *
   * @type    {number|string|Highcharts.BorderRadiusOptionsObject}
   * @product highcharts highstock gantt
   */
  borderRadius: 3,
  /**
   * When using automatic point colors pulled from the global
   * [colors](colors) or series-specific
   * [plotOptions.column.colors](series.colors) collections, this option
   * determines whether the chart should receive one color per series or
   * one color per point.
   *
   * In styled mode, the `colors` or `series.colors` arrays are not
   * supported, and instead this option gives the points individual color
   * class names on the form `highcharts-color-{n}`.
   *
   * @see [series colors](#plotOptions.column.colors)
   *
   * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-false/
   *         False by default
   * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-true/
   *         True
   *
   * @type      {boolean}
   * @default   false
   * @since     2.0
   * @product   highcharts highstock gantt
   * @apioption plotOptions.column.colorByPoint
   */
  /**
   * A series specific or series type specific color set to apply instead
   * of the global [colors](#colors) when [colorByPoint](
   * #plotOptions.column.colorByPoint) is true.
   *
   * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
   * @since     3.0
   * @product   highcharts highstock gantt
   * @apioption plotOptions.column.colors
   */
  /**
   * When `true`, the columns will center in the category, ignoring null
   * or missing points. When `false`, space will be reserved for null or
   * missing points.
   *
   * @sample {highcharts} highcharts/series-column/centerincategory/
   *         Center in category
   * @sample {highcharts} highcharts/series/stack-centerincategory/
   *         Center in category, stacked and grouped
   *
   * @since   8.0.1
   * @product highcharts highstock gantt
   */
  centerInCategory: false,
  /**
   * Padding between each value groups, in x axis units.
   *
   * @sample {highcharts} highcharts/plotoptions/column-grouppadding-default/
   *         0.2 by default
   * @sample {highcharts} highcharts/plotoptions/column-grouppadding-none/
   *         No group padding - all columns are evenly spaced
   *
   * @product highcharts highstock gantt
   */
  groupPadding: 0.2,
  /**
   * Whether to group non-stacked columns or to let them render
   * independent of each other. Non-grouped columns will be laid out
   * individually and overlap each other.
   *
   * @sample {highcharts} highcharts/plotoptions/column-grouping-false/
   *         Grouping disabled
   * @sample {highstock} highcharts/plotoptions/column-grouping-false/
   *         Grouping disabled
   *
   * @type      {boolean}
   * @default   true
   * @since     2.3.0
   * @product   highcharts highstock gantt
   * @apioption plotOptions.column.grouping
   */
  /** @ignore-option */
  marker: null,
  // Point options are specified in the base options
  /**
   * The maximum allowed pixel width for a column, translated to the
   * height of a bar in a bar chart. This prevents the columns from
   * becoming too wide when there is a small number of points in the
   * chart.
   *
   * @see [pointWidth](#plotOptions.column.pointWidth)
   *
   * @sample {highcharts} highcharts/plotoptions/column-maxpointwidth-20/
   *         Limited to 50
   * @sample {highstock} highcharts/plotoptions/column-maxpointwidth-20/
   *         Limited to 50
   *
   * @type      {number}
   * @since     4.1.8
   * @product   highcharts highstock gantt
   * @apioption plotOptions.column.maxPointWidth
   */
  /**
   * Padding between each column or bar, in x axis units.
   *
   * @sample {highcharts} highcharts/plotoptions/column-pointpadding-default/
   *         0.1 by default
   * @sample {highcharts} highcharts/plotoptions/column-pointpadding-025/
   *          0.25
   * @sample {highcharts} highcharts/plotoptions/column-pointpadding-none/
   *         0 for tightly packed columns
   *
   * @product highcharts highstock gantt
   */
  pointPadding: 0.1,
  /**
   * A pixel value specifying a fixed width for each column or bar point.
   * When set to `undefined`, the width is calculated from the
   * `pointPadding` and `groupPadding`. The width effects the dimension
   * that is not based on the point value. For column series it is the
   * horizontal length and for bar series it is the vertical length.
   *
   * @see [maxPointWidth](#plotOptions.column.maxPointWidth)
   *
   * @sample {highcharts} highcharts/plotoptions/column-pointwidth-20/
   *         20px wide columns regardless of chart width or the amount of
   *         data points
   *
   * @type      {number}
   * @since     1.2.5
   * @product   highcharts highstock gantt
   * @apioption plotOptions.column.pointWidth
   */
  /**
   * A pixel value specifying a fixed width for the column or bar.
   * Overrides pointWidth on the series.
   *
   * @see [series.pointWidth](#plotOptions.column.pointWidth)
   *
   * @type      {number}
   * @default   undefined
   * @since     7.0.0
   * @product   highcharts highstock gantt
   * @apioption series.column.data.pointWidth
   */
  /**
   * The minimal height for a column or width for a bar. By default,
   * 0 values are not shown. To visualize a 0 (or close to zero) point,
   * set the minimal point length to a pixel value like 3\. In stacked
   * column charts, minPointLength might not be respected for tightly
   * packed values.
   *
   * @sample {highcharts} highcharts/plotoptions/column-minpointlength/
   *         Zero base value
   * @sample {highcharts} highcharts/plotoptions/column-minpointlength-pos-and-neg/
   *         Positive and negative close to zero values
   *
   * @product highcharts highstock gantt
   */
  minPointLength: 0,
  /**
   * When the series contains less points than the crop threshold, all
   * points are drawn, event if the points fall outside the visible plot
   * area at the current zoom. The advantage of drawing all points
   * (including markers and columns), is that animation is performed on
   * updates. On the other hand, when the series contains more points than
   * the crop threshold, the series data is cropped to only contain points
   * that fall within the plot area. The advantage of cropping away
   * invisible points is to increase performance on large series.
   *
   * @product highcharts highstock gantt
   */
  cropThreshold: 50,
  /**
   * The X axis range that each point is valid for. This determines the
   * width of the column. On a categorized axis, the range will be 1
   * by default (one category unit). On linear and datetime axes, the
   * range will be computed as the distance between the two closest data
   * points.
   *
   * The default `null` means it is computed automatically, but this
   * option can be used to override the automatic value.
   *
   * This option is set by default to 1 if data sorting is enabled.
   *
   * @sample {highcharts} highcharts/plotoptions/column-pointrange/
   *         Set the point range to one day on a data set with one week
   *         between the points
   *
   * @type    {number|null}
   * @since   2.3
   * @product highcharts highstock gantt
   */
  pointRange: null,
  states: {
    /**
     * Options for the hovered point. These settings override the normal
     * state options when a point is moused over or touched.
     *
     * @extends   plotOptions.series.states.hover
     * @excluding halo, lineWidth, lineWidthPlus, marker
     * @product   highcharts highstock gantt
     */
    hover: {
      /** @ignore-option */
      halo: false,
      /**
       * A specific border color for the hovered point. Defaults to
       * inherit the normal state border color.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product   highcharts gantt
       * @apioption plotOptions.column.states.hover.borderColor
       */
      /**
       * A specific color for the hovered point.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product   highcharts gantt
       * @apioption plotOptions.column.states.hover.color
       */
      /**
       * How much to brighten the point on interaction. Requires the
       * main color to be defined in hex or rgb(a) format.
       *
       * In styled mode, the hover brightening is by default replaced
       * with a fill-opacity set in the `.highcharts-point:hover`
       * rule.
       *
       * @sample {highcharts} highcharts/plotoptions/column-states-hover-brightness/
       *         Brighten by 0.5
       *
       * @product highcharts highstock gantt
       */
      brightness: 0.1
    },
    /**
     * Options for the selected point. These settings override the
     * normal state options when a point is selected.
     *
     * @extends   plotOptions.series.states.select
     * @excluding halo, lineWidth, lineWidthPlus, marker
     * @product   highcharts highstock gantt
     */
    select: {
      /**
       * A specific color for the selected point.
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default #cccccc
       * @product highcharts highstock gantt
       */
      color: "#cccccc",
      /**
       * A specific border color for the selected point.
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default #000000
       * @product highcharts highstock gantt
       */
      borderColor: "#000000"
      /* Palette.neutralColor100 */
    }
  },
  dataLabels: {
    align: void 0,
    verticalAlign: void 0,
    /**
     * The y position offset of the label relative to the point in
     * pixels.
     *
     * @type {number}
     */
    y: void 0
  },
  // False doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/
  /** @ignore-option */
  startFromThreshold: true,
  stickyTracking: false,
  tooltip: {
    distance: 6
  },
  /**
   * The Y axis value to serve as the base for the columns, for
   * distinguishing between values above and below a threshold. If `null`,
   * the columns extend from the padding Y axis minimum.
   *
   * @type    {number|null}
   * @since   2.0
   * @product highcharts
   */
  threshold: 0,
  /**
   * The width of the border surrounding each column or bar. Defaults to
   * `1` when there is room for a border, but to `0` when the columns are
   * so dense that a border would cover the next column.
   *
   * In styled mode, the stroke width can be set with the
   * `.highcharts-point` rule.
   *
   * @sample {highcharts} highcharts/plotoptions/column-borderwidth/
   *         2px black border
   *
   * @type      {number}
   * @default   undefined
   * @product   highcharts highstock gantt
   * @apioption plotOptions.column.borderWidth
   */
  /**
   * The color of the border surrounding each column or bar.
   *
   * In styled mode, the border stroke can be set with the
   * `.highcharts-point` rule.
   *
   * @sample {highcharts} highcharts/plotoptions/column-bordercolor/
   *         Dark gray border
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default   #ffffff
   * @product   highcharts highstock gantt
   */
  borderColor: "#ffffff"
  /* Palette.backgroundColor */
};
var ColumnSeriesDefaults_default = ColumnSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Column/ColumnSeries.js
var { animObject: animObject9 } = AnimationUtilities_default;
var { parse: color3 } = Color_default;
var { noop: noop2 } = Globals_default;
var { clamp: clamp7, crisp: crisp6, defined: defined20, extend: extend22, fireEvent: fireEvent17, isArray: isArray11, isNumber: isNumber23, merge: merge24, pick: pick25, objectEach: objectEach18 } = Utilities_default;
var ColumnSeries = class extends Series_default {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Animate the column heights one by one from zero.
   *
   * @private
   * @function Highcharts.seriesTypes.column#animate
   *
   * @param {boolean} init
   *        Whether to initialize the animation or run it
   */
  animate(init3) {
    const series = this, yAxis2 = this.yAxis, yAxisPos = yAxis2.pos, reversed = yAxis2.reversed, options2 = series.options, { clipOffset, inverted } = this.chart, attr18 = {}, translateProp = inverted ? "translateX" : "translateY";
    let translateStart, translatedThreshold;
    if (init3 && clipOffset) {
      attr18.scaleY = 1e-3;
      translatedThreshold = clamp7(yAxis2.toPixels(options2.threshold || 0), yAxisPos, yAxisPos + yAxis2.len);
      if (inverted) {
        translatedThreshold += reversed ? -Math.floor(clipOffset[0]) : Math.ceil(clipOffset[2]);
        attr18.translateX = translatedThreshold - yAxis2.len;
      } else {
        translatedThreshold += reversed ? Math.ceil(clipOffset[0]) : -Math.floor(clipOffset[2]);
        attr18.translateY = translatedThreshold;
      }
      if (series.clipBox) {
        series.setClip();
      }
      series.group.attr(attr18);
    } else {
      translateStart = Number(series.group.attr(translateProp));
      series.group.animate({ scaleY: 1 }, extend22(animObject9(series.options.animation), {
        // Do the scale synchronously to ensure smooth
        // updating (#5030, #7228)
        step: function(val, fx) {
          if (series.group) {
            attr18[translateProp] = translateStart + fx.pos * (yAxisPos - translateStart);
            series.group.attr(attr18);
          }
        }
      }));
    }
  }
  /**
   * Initialize the series. Extends the basic Series.init method by
   * marking other series of the same type as dirty.
   *
   * @private
   * @function Highcharts.seriesTypes.column#init
   */
  init(chart, options2) {
    super.init.apply(this, arguments);
    const series = this;
    chart = series.chart;
    if (chart.hasRendered) {
      chart.series.forEach(function(otherSeries) {
        if (otherSeries.type === series.type) {
          otherSeries.isDirty = true;
        }
      });
    }
  }
  /**
   * Return the width and x offset of the columns adjusted for grouping,
   * groupPadding, pointPadding, pointWidth etc.
   *
   * @private
   * @function Highcharts.seriesTypes.column#getColumnMetrics
   */
  getColumnMetrics() {
    const series = this, options2 = series.options, xAxis2 = series.xAxis, yAxis2 = series.yAxis, reversedStacks = xAxis2.options.reversedStacks, reverseStacks = xAxis2.reversed && !reversedStacks || !xAxis2.reversed && reversedStacks, stackGroups = {};
    let stackKey, columnCount = 0;
    if (options2.grouping === false) {
      columnCount = 1;
    } else {
      series.chart.series.forEach(function(otherSeries) {
        const otherYAxis = otherSeries.yAxis, otherOptions = otherSeries.options;
        let columnIndex;
        if (otherSeries.type === series.type && otherSeries.reserveSpace() && yAxis2.len === otherYAxis.len && yAxis2.pos === otherYAxis.pos) {
          if (otherOptions.stacking && otherOptions.stacking !== "group") {
            stackKey = otherSeries.stackKey;
            if (typeof stackGroups[stackKey] === "undefined") {
              stackGroups[stackKey] = columnCount++;
            }
            columnIndex = stackGroups[stackKey];
          } else if (otherOptions.grouping !== false) {
            columnIndex = columnCount++;
          }
          otherSeries.columnIndex = columnIndex;
        }
      });
    }
    const categoryWidth = Math.min(
      Math.abs(xAxis2.transA) * (!xAxis2.brokenAxis?.hasBreaks && xAxis2.ordinal?.slope || options2.pointRange || xAxis2.closestPointRange || xAxis2.tickInterval || 1),
      // #2610
      xAxis2.len
      // #1535
    ), groupPadding = categoryWidth * options2.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / (columnCount || 1), pointWidth = Math.min(options2.maxPointWidth || xAxis2.len, pick25(options2.pointWidth, pointOffsetWidth * (1 - 2 * options2.pointPadding))), pointPadding = (pointOffsetWidth - pointWidth) / 2, colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0), pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - categoryWidth / 2) * (reverseStacks ? -1 : 1);
    series.columnMetrics = {
      width: pointWidth,
      offset: pointXOffset,
      paddedWidth: pointOffsetWidth,
      columnCount
    };
    return series.columnMetrics;
  }
  /**
   * Make the columns crisp. The edges are rounded to the nearest full
   * pixel.
   *
   * @private
   * @function Highcharts.seriesTypes.column#crispCol
   */
  crispCol(x, y, width, height) {
    const borderWidth = this.borderWidth, inverted = this.chart.inverted, bottom = crisp6(y + height, borderWidth, inverted);
    y = crisp6(y, borderWidth, inverted);
    height = bottom - y;
    if (this.options.crisp) {
      const right = crisp6(x + width, borderWidth);
      x = crisp6(x, borderWidth);
      width = right - x;
    }
    return { x, y, width, height };
  }
  /**
   * Adjust for missing columns, according to the `centerInCategory`
   * option. Missing columns are either single points or stacks where the
   * point or points are either missing or null.
   *
   * @private
   * @function Highcharts.seriesTypes.column#adjustForMissingColumns
   * @param {number} x
   * The x coordinate of the column, left side
   *
   * @param {number} pointWidth
   * The pointWidth, already computed upstream
   *
   * @param {Highcharts.ColumnPoint} point
   * The point instance
   *
   * @param {Highcharts.ColumnMetricsObject} metrics
   * The series-wide column metrics
   *
   * @return {number}
   * The adjusted x position, or the original if not adjusted
   */
  adjustForMissingColumns(x, pointWidth, point, metrics) {
    if (!point.isNull && metrics.columnCount > 1) {
      const visibleSeries = this.xAxis.series.filter((s) => s.visible).map((s) => s.index);
      let indexInCategory = 0, totalInCategory = 0;
      objectEach18(this.xAxis.stacking?.stacks, (stack) => {
        const points = typeof point.x === "number" ? stack[point.x.toString()]?.points : void 0, pointValues = points?.[this.index], yStackMap = {};
        if (points && isArray11(pointValues)) {
          let baseIndex = this.index;
          const seriesIndexes = Object.keys(points).filter((pointKey) => (
            // Filter out duplicate X's
            !pointKey.match(",") && // Filter out null points
            points[pointKey] && points[pointKey].length > 1
          )).map(parseFloat).filter((index) => visibleSeries.indexOf(index) !== -1).filter((index) => {
            const otherOptions = this.chart.series[index].options, yStack = otherOptions.stacking && otherOptions.stack;
            if (defined20(yStack)) {
              if (isNumber23(yStackMap[yStack])) {
                if (baseIndex === index) {
                  baseIndex = yStackMap[yStack];
                }
                return false;
              }
              yStackMap[yStack] = index;
            }
            return true;
          }).sort((a, b) => b - a);
          indexInCategory = seriesIndexes.indexOf(baseIndex);
          totalInCategory = seriesIndexes.length;
        }
      });
      indexInCategory = this.xAxis.reversed ? totalInCategory - 1 - indexInCategory : indexInCategory;
      const boxWidth = (totalInCategory - 1) * metrics.paddedWidth + pointWidth;
      x = (point.plotX || 0) + boxWidth / 2 - pointWidth - indexInCategory * metrics.paddedWidth;
    }
    return x;
  }
  /**
   * Translate each point to the plot area coordinate system and find
   * shape positions
   *
   * @private
   * @function Highcharts.seriesTypes.column#translate
   */
  translate() {
    const series = this, chart = series.chart, options2 = series.options, dense = series.dense = series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick25(
      options2.borderWidth,
      dense ? 0 : 1
      // #3635
    ), xAxis2 = series.xAxis, yAxis2 = series.yAxis, threshold = options2.threshold, minPointLength = pick25(options2.minPointLength, 5), metrics = series.getColumnMetrics(), seriesPointWidth = metrics.width, seriesXOffset = series.pointXOffset = metrics.offset, dataMin = series.dataMin, dataMax = series.dataMax, translatedThreshold = series.translatedThreshold = yAxis2.getThreshold(threshold);
    let seriesBarW = series.barW = Math.max(seriesPointWidth, 1 + 2 * borderWidth);
    if (options2.pointPadding && options2.crisp) {
      seriesBarW = Math.ceil(seriesBarW);
    }
    Series_default.prototype.translate.apply(series);
    series.points.forEach(function(point) {
      const yBottom = pick25(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotX = point.plotX || 0, plotY = clamp7(point.plotY, -safeDistance, yAxis2.len + safeDistance);
      let up, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, pointWidth = seriesPointWidth, barX = plotX + seriesXOffset, barW = seriesBarW;
      if (minPointLength && Math.abs(barH) < minPointLength) {
        barH = minPointLength;
        up = !yAxis2.reversed && !point.negative || yAxis2.reversed && point.negative;
        if (isNumber23(threshold) && isNumber23(dataMax) && point.y === threshold && dataMax <= threshold && // And if there's room for it (#7311)
        (yAxis2.min || 0) < threshold && // If all points are the same value (i.e zero) not draw
        // as negative points (#10646), but only if there's room
        // for it (#14876)
        (dataMin !== dataMax || (yAxis2.max || 0) <= threshold)) {
          up = !up;
          point.negative = !point.negative;
        }
        barY = Math.abs(barY - translatedThreshold) > minPointLength ? (
          // ...keep position
          yBottom - minPointLength
        ) : (
          // #1485, #4051
          translatedThreshold - (up ? minPointLength : 0)
        );
      }
      if (defined20(point.options.pointWidth)) {
        pointWidth = barW = Math.ceil(point.options.pointWidth);
        barX -= Math.round((pointWidth - seriesPointWidth) / 2);
      }
      if (options2.centerInCategory) {
        barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);
      }
      point.barX = barX;
      point.pointWidth = pointWidth;
      point.tooltipPos = chart.inverted ? [
        clamp7(yAxis2.len + yAxis2.pos - chart.plotLeft - plotY, yAxis2.pos - chart.plotLeft, yAxis2.len + yAxis2.pos - chart.plotLeft),
        xAxis2.len + xAxis2.pos - chart.plotTop - barX - barW / 2,
        barH
      ] : [
        xAxis2.left - chart.plotLeft + barX + barW / 2,
        clamp7(plotY + yAxis2.pos - chart.plotTop, yAxis2.pos - chart.plotTop, yAxis2.len + yAxis2.pos - chart.plotTop),
        barH
      ];
      point.shapeType = series.pointClass.prototype.shapeType || "roundedRect";
      point.shapeArgs = series.crispCol(
        barX,
        // #3169, drilldown from null must have a position to work from.
        // #6585, dataLabel should be placed on xAxis, not floating in
        // the middle of the chart.
        barY,
        barW,
        point.isNull ? 0 : barH
      );
    });
    fireEvent17(this, "afterColumnTranslate");
  }
  /**
   * Columns have no graph
   *
   * @private
   * @function Highcharts.seriesTypes.column#drawGraph
   */
  drawGraph() {
    this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
  }
  /**
   * Get presentational attributes
   *
   * @private
   * @function Highcharts.seriesTypes.column#pointAttribs
   */
  pointAttribs(point, state) {
    const options2 = this.options, p2o = this.pointAttrToOptions || {}, strokeOption = p2o.stroke || "borderColor", strokeWidthOption = p2o["stroke-width"] || "borderWidth";
    let stateOptions, zone, brightness, fill = point && point.color || this.color, stroke = point && point[strokeOption] || options2[strokeOption] || fill, dashstyle = point && point.options.dashStyle || options2.dashStyle, strokeWidth = point && point[strokeWidthOption] || options2[strokeWidthOption] || this[strokeWidthOption] || 0, opacity = point?.isNull && options2.nullInteraction ? 0 : point?.opacity ?? options2.opacity ?? 1;
    if (point && this.zones.length) {
      zone = point.getZone();
      fill = point.options.color || zone && (zone.color || point.nonZonedColor) || this.color;
      if (zone) {
        stroke = zone.borderColor || stroke;
        dashstyle = zone.dashStyle || dashstyle;
        strokeWidth = zone.borderWidth || strokeWidth;
      }
    }
    if (state && point) {
      stateOptions = merge24(
        options2.states[state],
        // #6401
        point.options.states && point.options.states[state] || {}
      );
      brightness = stateOptions.brightness;
      fill = stateOptions.color || typeof brightness !== "undefined" && color3(fill).brighten(stateOptions.brightness).get() || fill;
      stroke = stateOptions[strokeOption] || stroke;
      strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
      dashstyle = stateOptions.dashStyle || dashstyle;
      opacity = pick25(stateOptions.opacity, opacity);
    }
    const ret = {
      fill,
      stroke,
      "stroke-width": strokeWidth,
      opacity
    };
    if (dashstyle) {
      ret.dashstyle = dashstyle;
    }
    return ret;
  }
  /**
   * Draw the columns. For bars, the series.group is rotated, so the same
   * coordinates apply for columns and bars. This method is inherited by
   * scatter series.
   *
   * @private
   * @function Highcharts.seriesTypes.column#drawPoints
   */
  drawPoints(points = this.points) {
    const series = this, chart = this.chart, options2 = series.options, nullInteraction = options2.nullInteraction, renderer = chart.renderer, animationLimit = options2.animationLimit || 250;
    let shapeArgs;
    points.forEach(function(point) {
      const plotY = point.plotY;
      let graphic = point.graphic, hasGraphic = !!graphic, verb = graphic && chart.pointCount < animationLimit ? "animate" : "attr";
      if (isNumber23(plotY) && (point.y !== null || nullInteraction)) {
        shapeArgs = point.shapeArgs;
        if (graphic && point.hasNewShapeType()) {
          graphic = graphic.destroy();
        }
        if (series.enabledDataSorting) {
          point.startXPos = series.xAxis.reversed ? -(shapeArgs ? shapeArgs.width || 0 : 0) : series.xAxis.width;
        }
        if (!graphic) {
          point.graphic = graphic = renderer[point.shapeType](shapeArgs).add(point.group || series.group);
          if (graphic && series.enabledDataSorting && chart.hasRendered && chart.pointCount < animationLimit) {
            graphic.attr({
              x: point.startXPos
            });
            hasGraphic = true;
            verb = "animate";
          }
        }
        if (graphic && hasGraphic) {
          graphic[verb](merge24(shapeArgs));
        }
        if (!chart.styledMode) {
          graphic[verb](series.pointAttribs(point, point.selected && "select")).shadow(point.allowShadow !== false && options2.shadow);
        }
        if (graphic) {
          graphic.addClass(point.getClassName(), true);
          graphic.attr({
            visibility: point.visible ? "inherit" : "hidden"
          });
        }
      } else if (graphic) {
        point.graphic = graphic.destroy();
      }
    });
  }
  /**
   * Draw the tracker for a point.
   * @private
   */
  drawTracker(points = this.points) {
    const series = this, chart = series.chart, pointer = chart.pointer, onMouseOver = function(e) {
      pointer?.normalize(e);
      const point = pointer?.getPointFromEvent(e);
      if (pointer && point && series.options.enableMouseTracking && // Run point events only for points inside plot area, #21136
      (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop, {
        visiblePlotOnly: true
      }) || pointer?.inClass(e.target, "highcharts-data-label"))) {
        pointer.isDirectTouch = true;
        point.onMouseOver(e);
      }
    };
    let dataLabels;
    points.forEach(function(point) {
      dataLabels = isArray11(point.dataLabels) ? point.dataLabels : point.dataLabel ? [point.dataLabel] : [];
      if (point.graphic) {
        point.graphic.element.point = point;
      }
      dataLabels.forEach(function(dataLabel) {
        (dataLabel.div || dataLabel.element).point = point;
      });
    });
    if (!series._hasTracking) {
      series.trackerGroups.forEach(function(key) {
        if (series[key]) {
          series[key].addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", function(e) {
            pointer?.onTrackerMouseOut(e);
          }).on("touchstart", onMouseOver);
          if (!chart.styledMode && series.options.cursor) {
            series[key].css({ cursor: series.options.cursor });
          }
        }
      });
      series._hasTracking = true;
    }
    fireEvent17(this, "afterDrawTracker");
  }
  /**
   * Remove this series from the chart
   *
   * @private
   * @function Highcharts.seriesTypes.column#remove
   */
  remove() {
    const series = this, chart = series.chart;
    if (chart.hasRendered) {
      chart.series.forEach(function(otherSeries) {
        if (otherSeries.type === series.type) {
          otherSeries.isDirty = true;
        }
      });
    }
    Series_default.prototype.remove.apply(series, arguments);
  }
};
ColumnSeries.defaultOptions = merge24(Series_default.defaultOptions, ColumnSeriesDefaults_default);
extend22(ColumnSeries.prototype, {
  // When tooltip is not shared, this series (and derivatives) requires
  // direct touch/hover. KD-tree does not apply.
  directTouch: true,
  getSymbol: noop2,
  // Use separate negative stacks, unlike area stacks where a negative
  // point is subtracted from previous (#1910)
  negStacks: true,
  trackerGroups: ["group", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("column", ColumnSeries);
var ColumnSeries_default = ColumnSeries;

// node_modules/highcharts/es-modules/Core/Series/DataLabel.js
var { getDeferredAnimation: getDeferredAnimation3 } = AnimationUtilities_default;
var { format: format7 } = Templating_default;
var { defined: defined21, extend: extend23, fireEvent: fireEvent18, getAlignFactor: getAlignFactor9, isArray: isArray12, isString: isString13, merge: merge25, objectEach: objectEach19, pick: pick26, pInt: pInt7, splat: splat8 } = Utilities_default;
var DataLabel;
(function(DataLabel2) {
  function hasDataLabels() {
    return mergedDataLabelOptions(this).some((o) => o?.enabled);
  }
  function alignDataLabel(point, dataLabel, options2, alignTo, isNew) {
    const series = this, { chart, enabledDataSorting } = this, inverted = this.isCartesian && chart.inverted, plotX = point.plotX, plotY = point.plotY, rotation = options2.rotation || 0, isInsidePlot = defined21(plotX) && defined21(plotY) && chart.isInsidePlot(plotX, Math.round(plotY), {
      inverted,
      paneCoordinates: true,
      series
    }), setStartPos = (alignOptions) => {
      if (enabledDataSorting && series.xAxis && !justify) {
        series.setDataLabelStartPos(point, dataLabel, isNew, isInsidePlot, alignOptions);
      }
    }, justify = rotation === 0 ? pick26(options2.overflow, enabledDataSorting ? "none" : "justify") === "justify" : false;
    let visible = this.visible && point.visible !== false && defined21(plotX) && (point.series.forceDL || enabledDataSorting && !justify || isInsidePlot || // If the data label is inside the align box, it is enough
    // that parts of the align box is inside the plot area
    // (#12370). When stacking, it is always inside regardless
    // of the option (#15148).
    pick26(options2.inside, !!this.options.stacking) && alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, {
      inverted,
      paneCoordinates: true,
      series
    }));
    const pos = point.pos();
    if (visible && pos) {
      const bBox = dataLabel.getBBox(), unrotatedbBox = dataLabel.getBBox(void 0, 0);
      alignTo = extend23({
        x: pos[0],
        y: Math.round(pos[1]),
        width: 0,
        height: 0
      }, alignTo || {});
      if (options2.alignTo === "plotEdges" && series.isCartesian) {
        alignTo[inverted ? "x" : "y"] = 0;
        alignTo[inverted ? "width" : "height"] = this.yAxis?.len || 0;
      }
      extend23(options2, {
        width: bBox.width,
        height: bBox.height
      });
      setStartPos(alignTo);
      dataLabel.align(merge25(options2, {
        width: unrotatedbBox.width,
        height: unrotatedbBox.height
      }), false, alignTo, false);
      dataLabel.alignAttr.x += getAlignFactor9(options2.align) * (unrotatedbBox.width - bBox.width);
      dataLabel.alignAttr.y += getAlignFactor9(options2.verticalAlign) * (unrotatedbBox.height - bBox.height);
      dataLabel[dataLabel.placed ? "animate" : "attr"]({
        "text-align": dataLabel.alignAttr["text-align"] || "center",
        x: dataLabel.alignAttr.x + (bBox.width - unrotatedbBox.width) / 2,
        y: dataLabel.alignAttr.y + (bBox.height - unrotatedbBox.height) / 2,
        rotationOriginX: (dataLabel.width || 0) / 2,
        rotationOriginY: (dataLabel.height || 0) / 2
      });
      if (justify && alignTo.height >= 0) {
        this.justifyDataLabel(dataLabel, options2, dataLabel.alignAttr, bBox, alignTo, isNew);
      } else if (pick26(options2.crop, true)) {
        const { x, y } = dataLabel.alignAttr, correction = 1;
        visible = chart.isInsidePlot(x, y, {
          paneCoordinates: true,
          series
        }) && chart.isInsidePlot(x + bBox.width - correction, y + bBox.height - correction, {
          paneCoordinates: true,
          series
        });
      }
      if (options2.shape && !rotation) {
        dataLabel[isNew ? "attr" : "animate"]({
          anchorX: pos[0],
          anchorY: pos[1]
        });
      }
    }
    if (isNew && enabledDataSorting) {
      dataLabel.placed = false;
    }
    if (!visible && (!enabledDataSorting || justify)) {
      dataLabel.hide();
      dataLabel.placed = false;
    } else {
      dataLabel.show();
      dataLabel.placed = true;
    }
  }
  function applyFilter(point, options2) {
    const filter = options2.filter;
    if (filter) {
      const op = filter.operator, prop = point[filter.property], val = filter.value;
      if (op === ">" && prop > val || op === "<" && prop < val || op === ">=" && prop >= val || op === "<=" && prop <= val || op === "==" && prop == val || // eslint-disable-line eqeqeq
      op === "===" && prop === val || op === "!=" && prop != val || // eslint-disable-line eqeqeq
      op === "!==" && prop !== val) {
        return true;
      }
      return false;
    }
    return true;
  }
  function compose27(SeriesClass) {
    const seriesProto7 = SeriesClass.prototype;
    if (!seriesProto7.initDataLabels) {
      seriesProto7.initDataLabels = initDataLabels3;
      seriesProto7.initDataLabelsGroup = initDataLabelsGroup;
      seriesProto7.alignDataLabel = alignDataLabel;
      seriesProto7.drawDataLabels = drawDataLabels;
      seriesProto7.justifyDataLabel = justifyDataLabel;
      seriesProto7.mergeArrays = mergeArrays;
      seriesProto7.setDataLabelStartPos = setDataLabelStartPos;
      seriesProto7.hasDataLabels = hasDataLabels;
    }
  }
  DataLabel2.compose = compose27;
  function initDataLabelsGroup() {
    return this.plotGroup(
      "dataLabelsGroup",
      "data-labels",
      this.hasRendered ? "inherit" : "hidden",
      // #5133, #10220
      this.options.dataLabels.zIndex || 6
    );
  }
  function initDataLabels3(animationConfig) {
    const series = this, hasRendered = series.hasRendered || 0;
    const dataLabelsGroup = this.initDataLabelsGroup().attr({ opacity: +hasRendered });
    if (!hasRendered && dataLabelsGroup) {
      if (series.visible) {
        dataLabelsGroup.show();
      }
      if (series.options.animation) {
        dataLabelsGroup.animate({ opacity: 1 }, animationConfig);
      } else {
        dataLabelsGroup.attr({ opacity: 1 });
      }
    }
    return dataLabelsGroup;
  }
  function drawDataLabels(points) {
    points = points || this.points;
    const series = this, chart = series.chart, seriesOptions = series.options, renderer = chart.renderer, { backgroundColor, plotBackgroundColor } = chart.options.chart, contrastColor = renderer.getContrast(
      isString13(plotBackgroundColor) && plotBackgroundColor || isString13(backgroundColor) && backgroundColor || "#000000"
      /* Palette.neutralColor100 */
    ), seriesDlOptions = mergedDataLabelOptions(series);
    let pointOptions, dataLabelsGroup;
    const { animation, defer } = seriesDlOptions[0], animationConfig = defer ? getDeferredAnimation3(chart, animation, series) : { defer: 0, duration: 0 };
    fireEvent18(this, "drawDataLabels");
    if (series.hasDataLabels?.()) {
      dataLabelsGroup = this.initDataLabels(animationConfig);
      points.forEach((point) => {
        const dataLabels = point.dataLabels || [], pointColor = point.color || series.color;
        pointOptions = splat8(mergeArrays(
          seriesDlOptions,
          // The dlOptions prop is used in treemaps
          point.dlOptions || point.options?.dataLabels
        ));
        pointOptions.forEach((labelOptions, i) => {
          const labelEnabled = labelOptions.enabled && (point.visible || point.dataLabelOnHidden) && // #2282, #4641, #7112, #10049
          (!point.isNull || point.dataLabelOnNull) && applyFilter(point, labelOptions), { backgroundColor: backgroundColor2, borderColor, distance, style = {} } = labelOptions;
          let formatString, labelText, rotation, attr18 = {}, dataLabel = dataLabels[i], isNew = !dataLabel, labelBgColor;
          if (labelEnabled) {
            formatString = pick26(labelOptions[point.formatPrefix + "Format"], labelOptions.format);
            labelText = defined21(formatString) ? format7(formatString, point, chart) : (labelOptions[point.formatPrefix + "Formatter"] || labelOptions.formatter).call(point, labelOptions);
            rotation = labelOptions.rotation;
            if (!chart.styledMode) {
              style.color = pick26(
                labelOptions.color,
                style.color,
                isString13(series.color) ? series.color : void 0,
                "#000000"
                /* Palette.neutralColor100 */
              );
              if (style.color === "contrast") {
                if (backgroundColor2 !== "none") {
                  labelBgColor = backgroundColor2;
                }
                point.contrastColor = renderer.getContrast(labelBgColor !== "auto" && isString13(labelBgColor) && labelBgColor || (isString13(pointColor) ? pointColor : ""));
                style.color = labelBgColor || // #20007
                !defined21(distance) && labelOptions.inside || pInt7(distance || 0) < 0 || seriesOptions.stacking ? point.contrastColor : contrastColor;
              } else {
                delete point.contrastColor;
              }
              if (seriesOptions.cursor) {
                style.cursor = seriesOptions.cursor;
              }
            }
            attr18 = {
              r: labelOptions.borderRadius || 0,
              rotation,
              padding: labelOptions.padding,
              zIndex: 1
            };
            if (!chart.styledMode) {
              attr18.fill = backgroundColor2 === "auto" ? point.color : backgroundColor2;
              attr18.stroke = borderColor === "auto" ? point.color : borderColor;
              attr18["stroke-width"] = labelOptions.borderWidth;
            }
            objectEach19(attr18, (val, name) => {
              if (typeof val === "undefined") {
                delete attr18[name];
              }
            });
          }
          if (dataLabel && (!labelEnabled || !defined21(labelText) || // Changed useHTML value
          !!(dataLabel.div || dataLabel.text?.foreignObject) !== !!labelOptions.useHTML || // Change from no rotation to rotation and
          // vice versa. Don't use defined() because
          // rotation = 0 means also rotation = undefined
          (!dataLabel.rotation || !labelOptions.rotation) && dataLabel.rotation !== labelOptions.rotation)) {
            dataLabel = void 0;
            isNew = true;
          }
          if (labelEnabled && defined21(labelText)) {
            if (!dataLabel) {
              dataLabel = renderer.label(labelText, 0, 0, labelOptions.shape, void 0, void 0, labelOptions.useHTML, void 0, "data-label");
              dataLabel.addClass(" highcharts-data-label-color-" + point.colorIndex + " " + (labelOptions.className || "") + // #3398
              (labelOptions.useHTML ? " highcharts-tracker" : ""));
            } else {
              attr18.text = labelText;
            }
            if (dataLabel) {
              dataLabel.options = labelOptions;
              dataLabel.attr(attr18);
              if (!chart.styledMode) {
                dataLabel.css(style).shadow(labelOptions.shadow);
              } else if (style.width) {
                dataLabel.css({
                  width: style.width,
                  textOverflow: style.textOverflow,
                  whiteSpace: style.whiteSpace
                });
              }
              fireEvent18(dataLabel, "beforeAddingDataLabel", { labelOptions, point });
              if (!dataLabel.added) {
                dataLabel.add(dataLabelsGroup);
              }
              series.alignDataLabel(point, dataLabel, labelOptions, void 0, isNew);
              dataLabel.isActive = true;
              if (dataLabels[i] && dataLabels[i] !== dataLabel) {
                dataLabels[i].destroy();
              }
              dataLabels[i] = dataLabel;
            }
          }
        });
        let j = dataLabels.length;
        while (j--) {
          if (!dataLabels[j]?.isActive) {
            dataLabels[j]?.destroy();
            dataLabels.splice(j, 1);
          } else {
            dataLabels[j].isActive = false;
          }
        }
        point.dataLabel = dataLabels[0];
        point.dataLabels = dataLabels;
      });
    }
    fireEvent18(this, "afterDrawDataLabels");
  }
  function justifyDataLabel(dataLabel, options2, alignAttr, bBox, alignTo, isNew) {
    const chart = this.chart, align = options2.align, verticalAlign = options2.verticalAlign, padding = dataLabel.box ? 0 : dataLabel.padding || 0, horizontalAxis = chart.inverted ? this.yAxis : this.xAxis, horizontalAxisShift = horizontalAxis ? horizontalAxis.left - chart.plotLeft : 0, verticalAxis = chart.inverted ? this.xAxis : this.yAxis, verticalAxisShift = verticalAxis ? verticalAxis.top - chart.plotTop : 0;
    let { x = 0, y = 0 } = options2, off, justified;
    off = (alignAttr.x || 0) + padding + horizontalAxisShift;
    if (off < 0) {
      if (align === "right" && x >= 0) {
        options2.align = "left";
        options2.inside = true;
      } else {
        x -= off;
      }
      justified = true;
    }
    off = (alignAttr.x || 0) + bBox.width - padding + horizontalAxisShift;
    if (off > chart.plotWidth) {
      if (align === "left" && x <= 0) {
        options2.align = "right";
        options2.inside = true;
      } else {
        x += chart.plotWidth - off;
      }
      justified = true;
    }
    off = alignAttr.y + padding + verticalAxisShift;
    if (off < 0) {
      if (verticalAlign === "bottom" && y >= 0) {
        options2.verticalAlign = "top";
        options2.inside = true;
      } else {
        y -= off;
      }
      justified = true;
    }
    off = (alignAttr.y || 0) + bBox.height - padding + verticalAxisShift;
    if (off > chart.plotHeight) {
      if (verticalAlign === "top" && y <= 0) {
        options2.verticalAlign = "bottom";
        options2.inside = true;
      } else {
        y += chart.plotHeight - off;
      }
      justified = true;
    }
    if (justified) {
      options2.x = x;
      options2.y = y;
      dataLabel.placed = !isNew;
      dataLabel.align(options2, void 0, alignTo);
    }
    return justified;
  }
  function mergeArrays(one, two) {
    let res = [], i;
    if (isArray12(one) && !isArray12(two)) {
      res = one.map(function(el) {
        return merge25(el, two);
      });
    } else if (isArray12(two) && !isArray12(one)) {
      res = two.map(function(el) {
        return merge25(one, el);
      });
    } else if (!isArray12(one) && !isArray12(two)) {
      res = merge25(one, two);
    } else if (isArray12(one) && isArray12(two)) {
      i = Math.max(one.length, two.length);
      while (i--) {
        res[i] = merge25(one[i], two[i]);
      }
    }
    return res;
  }
  function mergedDataLabelOptions(series) {
    const plotOptions = series.chart.options.plotOptions;
    return splat8(mergeArrays(mergeArrays(plotOptions?.series?.dataLabels, plotOptions?.[series.type]?.dataLabels), series.options.dataLabels));
  }
  function setDataLabelStartPos(point, dataLabel, isNew, isInside, alignOptions) {
    const chart = this.chart, inverted = chart.inverted, xAxis2 = this.xAxis, reversed = xAxis2.reversed, labelCenter = ((inverted ? dataLabel.height : dataLabel.width) || 0) / 2, pointWidth = point.pointWidth, halfWidth = pointWidth ? pointWidth / 2 : 0;
    dataLabel.startXPos = inverted ? alignOptions.x : reversed ? -labelCenter - halfWidth : xAxis2.width - labelCenter + halfWidth;
    dataLabel.startYPos = inverted ? reversed ? this.yAxis.height - labelCenter + halfWidth : -labelCenter - halfWidth : alignOptions.y;
    if (!isInside) {
      dataLabel.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, dataLabel.hide);
    } else if (dataLabel.visibility === "hidden") {
      dataLabel.show();
      dataLabel.attr({ opacity: 0 }).animate({ opacity: 1 });
    }
    if (!chart.hasRendered) {
      return;
    }
    if (isNew) {
      dataLabel.attr({ x: dataLabel.startXPos, y: dataLabel.startYPos });
    }
    dataLabel.placed = true;
  }
})(DataLabel || (DataLabel = {}));
var DataLabel_default = DataLabel;

// node_modules/highcharts/es-modules/Series/Column/ColumnDataLabel.js
var { composed: composed6 } = Globals_default;
var { series: Series3 } = SeriesRegistry_default;
var { merge: merge26, pushUnique: pushUnique9 } = Utilities_default;
var ColumnDataLabel;
(function(ColumnDataLabel3) {
  function alignDataLabel(point, dataLabel, dlOptions, alignTo, isNew) {
    const { chart, options: options2 } = this, inverted = chart.inverted, xLen = this.xAxis?.len || chart.plotSizeX || 0, yLen = this.yAxis?.len || chart.plotSizeY || 0, dlBox = point.dlBox || point.shapeArgs, below = point.below ?? // Range series
    (point.plotY || 0) > (this.translatedThreshold ?? yLen), inside = dlOptions.inside ?? !!options2.stacking;
    if (dlBox) {
      alignTo = merge26(dlBox);
      if (dlOptions.overflow !== "allow" || dlOptions.crop !== false || options2.clip !== false) {
        if (alignTo.y < 0) {
          alignTo.height += alignTo.y;
          alignTo.y = 0;
        }
        const overshoot = alignTo.y + alignTo.height - yLen;
        if (overshoot > 0 && overshoot < alignTo.height - 1) {
          alignTo.height -= overshoot;
        }
      }
      if (inverted) {
        alignTo = {
          x: yLen - alignTo.y - alignTo.height,
          y: xLen - alignTo.x - alignTo.width,
          width: alignTo.height,
          height: alignTo.width
        };
      }
      if (!inside) {
        if (inverted) {
          alignTo.x += below ? 0 : alignTo.width;
          alignTo.width = 0;
        } else {
          alignTo.y += below ? alignTo.height : 0;
          alignTo.height = 0;
        }
      }
    }
    dlOptions.align ?? (dlOptions.align = !inverted || inside ? "center" : below ? "right" : "left");
    dlOptions.verticalAlign ?? (dlOptions.verticalAlign = inverted || inside ? "middle" : below ? "top" : "bottom");
    Series3.prototype.alignDataLabel.call(this, point, dataLabel, dlOptions, alignTo, isNew);
    if (dlOptions.inside && point.contrastColor) {
      dataLabel.css({
        color: point.contrastColor
      });
    }
  }
  function compose27(ColumnSeriesClass) {
    DataLabel_default.compose(Series3);
    if (pushUnique9(composed6, "ColumnDataLabel")) {
      ColumnSeriesClass.prototype.alignDataLabel = alignDataLabel;
    }
  }
  ColumnDataLabel3.compose = compose27;
})(ColumnDataLabel || (ColumnDataLabel = {}));
var ColumnDataLabel_default = ColumnDataLabel;

// node_modules/highcharts/es-modules/Series/Bar/BarSeries.js
var { extend: extend24, merge: merge27 } = Utilities_default;
var BarSeries = class extends ColumnSeries_default {
};
BarSeries.defaultOptions = merge27(ColumnSeries_default.defaultOptions, {
  // Nothing here yet
});
extend24(BarSeries.prototype, {
  inverted: true
});
SeriesRegistry_default.registerSeriesType("bar", BarSeries);

// node_modules/highcharts/es-modules/Series/Scatter/ScatterSeriesDefaults.js
var ScatterSeriesDefaults = {
  /**
   * The width of the line connecting the data points.
   *
   * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-none/
   *         0 by default
   * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-1/
   *         1px
   *
   * @product highcharts highstock
   */
  lineWidth: 0,
  findNearestPointBy: "xy",
  /**
   * Apply a jitter effect for the rendered markers. When plotting
   * discrete values, a little random noise may help telling the points
   * apart. The jitter setting applies a random displacement of up to `n`
   * axis units in either direction. So for example on a horizontal X
   * axis, setting the `jitter.x` to 0.24 will render the point in a
   * random position between 0.24 units to the left and 0.24 units to the
   * right of the true axis position. On a category axis, setting it to
   * 0.5 will fill up the bin and make the data appear continuous.
   *
   * When rendered on top of a box plot or a column series, a jitter value
   * of 0.24 will correspond to the underlying series' default
   * [groupPadding](
   * https://api.highcharts.com/highcharts/plotOptions.column.groupPadding)
   * and [pointPadding](
   * https://api.highcharts.com/highcharts/plotOptions.column.pointPadding)
   * settings.
   *
   * **Note:** With boost mode enabled, the jitter effect is not supported.
   *
   * @sample {highcharts} highcharts/demo/scatter-jitter
   *         Jitter on a scatter plot
   *
   * @sample {highcharts} highcharts/series-scatter/jitter-boxplot
   *         Jittered scatter plot on top of a box plot
   *
   * @product highcharts highstock
   * @since 7.0.2
   */
  jitter: {
    /**
     * The maximal X offset for the random jitter effect.
     */
    x: 0,
    /**
     * The maximal Y offset for the random jitter effect.
     */
    y: 0
  },
  marker: {
    enabled: true
    // Overrides auto-enabling in line series (#3647)
  },
  /**
   * Sticky tracking of mouse events. When true, the `mouseOut` event
   * on a series isn't triggered until the mouse moves over another
   * series, or out of the plot area. When false, the `mouseOut` event on
   * a series is triggered when the mouse leaves the area around the
   * series' graph or markers. This also implies the tooltip. When
   * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
   * will be hidden when moving the mouse between series.
   *
   * @type      {boolean}
   * @default   false
   * @product   highcharts highstock highmaps
   * @apioption plotOptions.scatter.stickyTracking
   */
  /**
   * A configuration object for the tooltip rendering of each single
   * series. Properties are inherited from [tooltip](#tooltip).
   * Overridable properties are `headerFormat`, `pointFormat`,
   * `yDecimals`, `xDateFormat`, `yPrefix` and `ySuffix`. Unlike other
   * series, in a scatter plot the series.name by default shows in the
   * headerFormat and point.x and point.y in the pointFormat.
   *
   * @product highcharts highstock highmaps
   */
  tooltip: {
    /**
     * @product highcharts highstock
     */
    headerFormat: '<span style="color:{point.color}"></span> <span style="font-size: 0.8em"> {series.name}</span><br/>',
    pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
  }
};
var ScatterSeriesDefaults_default = ScatterSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Scatter/ScatterSeries.js
var { column: ColumnSeries2, line: LineSeries4 } = SeriesRegistry_default.seriesTypes;
var { addEvent: addEvent15, extend: extend25, merge: merge28 } = Utilities_default;
var ScatterSeries = class extends LineSeries4 {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Optionally add the jitter effect.
   * @private
   */
  applyJitter() {
    const series = this, jitter = this.options.jitter, len = this.points.length;
    function unrandom(seed) {
      const rand = Math.sin(seed) * 1e4;
      return rand - Math.floor(rand);
    }
    if (jitter) {
      this.points.forEach(function(point, i) {
        ["x", "y"].forEach(function(dim, j) {
          if (jitter[dim] && !point.isNull) {
            const plotProp = `plot${dim.toUpperCase()}`, axis = series[`${dim}Axis`], translatedJitter = jitter[dim] * axis.transA;
            if (axis && !axis.logarithmic) {
              const min4 = Math.max(0, (point[plotProp] || 0) - translatedJitter), max4 = Math.min(axis.len, (point[plotProp] || 0) + translatedJitter);
              point[plotProp] = min4 + (max4 - min4) * unrandom(i + j * len);
              if (dim === "x") {
                point.clientX = point.plotX;
              }
            }
          }
        });
      });
    }
  }
  /**
   * @private
   */
  drawGraph() {
    if (this.options.lineWidth) {
      super.drawGraph();
    } else if (this.graph) {
      this.graph = this.graph.destroy();
    }
  }
};
ScatterSeries.defaultOptions = merge28(LineSeries4.defaultOptions, ScatterSeriesDefaults_default);
extend25(ScatterSeries.prototype, {
  drawTracker: ColumnSeries2.prototype.drawTracker,
  sorted: false,
  requireSorting: false,
  noSharedTooltip: true,
  trackerGroups: ["group", "markerGroup", "dataLabelsGroup"]
});
addEvent15(ScatterSeries, "afterTranslate", function() {
  this.applyJitter();
});
SeriesRegistry_default.registerSeriesType("scatter", ScatterSeries);
var ScatterSeries_default = ScatterSeries;

// node_modules/highcharts/es-modules/Series/CenteredUtilities.js
var { deg2rad: deg2rad5 } = Globals_default;
var { fireEvent: fireEvent19, isNumber: isNumber24, pick: pick27, relativeLength: relativeLength5 } = Utilities_default;
var CenteredUtilities;
(function(CenteredUtilities2) {
  function getCenter() {
    const options2 = this.options, chart = this.chart, slicingRoom = 2 * (options2.slicedOffset || 0), plotWidth = chart.plotWidth - 2 * slicingRoom, plotHeight = chart.plotHeight - 2 * slicingRoom, centerOption = options2.center, smallestSize = Math.min(plotWidth, plotHeight), thickness = options2.thickness;
    let handleSlicingRoom, size = options2.size, innerSize = options2.innerSize || 0, i, value;
    if (typeof size === "string") {
      size = parseFloat(size);
    }
    if (typeof innerSize === "string") {
      innerSize = parseFloat(innerSize);
    }
    const positions = [
      pick27(centerOption?.[0], "50%"),
      pick27(centerOption?.[1], "50%"),
      // Prevent from negative values
      pick27(size && size < 0 ? void 0 : options2.size, "100%"),
      pick27(innerSize && innerSize < 0 ? void 0 : options2.innerSize || 0, "0%")
    ];
    if (chart.angular && !(this instanceof Series_default)) {
      positions[3] = 0;
    }
    for (i = 0; i < 4; ++i) {
      value = positions[i];
      handleSlicingRoom = i < 2 || i === 2 && /%$/.test(value);
      positions[i] = relativeLength5(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) + (handleSlicingRoom ? slicingRoom : 0);
    }
    if (positions[3] > positions[2]) {
      positions[3] = positions[2];
    }
    if (isNumber24(thickness) && thickness * 2 < positions[2] && thickness > 0) {
      positions[3] = positions[2] - thickness * 2;
    }
    fireEvent19(this, "afterGetCenter", { positions });
    return positions;
  }
  CenteredUtilities2.getCenter = getCenter;
  function getStartAndEndRadians2(start, end) {
    const startAngle = isNumber24(start) ? start : 0, endAngle = isNumber24(end) && // Must be a number
    end > startAngle && // Must be larger than the start angle
    // difference must be less than 360 degrees
    end - startAngle < 360 ? end : startAngle + 360, correction = -90;
    return {
      start: deg2rad5 * (startAngle + correction),
      end: deg2rad5 * (endAngle + correction)
    };
  }
  CenteredUtilities2.getStartAndEndRadians = getStartAndEndRadians2;
})(CenteredUtilities || (CenteredUtilities = {}));
var CenteredUtilities_default = CenteredUtilities;

// node_modules/highcharts/es-modules/Series/Pie/PiePoint.js
var { setAnimation: setAnimation5 } = AnimationUtilities_default;
var { addEvent: addEvent16, defined: defined22, extend: extend26, isNumber: isNumber25, pick: pick28, relativeLength: relativeLength6 } = Utilities_default;
var PiePoint = class extends Point_default {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Extendable method for getting the path of the connector between the
   * data label and the pie slice.
   * @private
   */
  getConnectorPath(dataLabel) {
    const labelPosition = dataLabel.dataLabelPosition, options2 = dataLabel.options || {}, connectorShape = options2.connectorShape, shapeFunc = this.connectorShapes[connectorShape] || connectorShape;
    return labelPosition && shapeFunc.call(this, {
      // Pass simplified label position object for user's convenience
      ...labelPosition.computed,
      alignment: labelPosition.alignment
    }, labelPosition.connectorPosition, options2) || [];
  }
  /**
   * @private
   */
  getTranslate() {
    return this.sliced && this.slicedTranslation || {
      translateX: 0,
      translateY: 0
    };
  }
  /**
   * @private
   */
  haloPath(size) {
    const shapeArgs = this.shapeArgs;
    return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(shapeArgs.x, shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
      // Substract 1px to ensure the background is not bleeding
      // through between the halo and the slice (#7495).
      innerR: shapeArgs.r - 1,
      start: shapeArgs.start,
      end: shapeArgs.end,
      borderRadius: shapeArgs.borderRadius
    });
  }
  /**
   * Initialize the pie slice.
   * @private
   */
  constructor(series, options2, x) {
    super(series, options2, x);
    this.half = 0;
    this.name ?? (this.name = series.chart.options.lang.pieSliceName);
    const toggleSlice = (e) => {
      this.slice(e.type === "select");
    };
    addEvent16(this, "select", toggleSlice);
    addEvent16(this, "unselect", toggleSlice);
  }
  /**
   * Negative points are not valid (#1530, #3623, #5322)
   * @private
   */
  isValid() {
    return isNumber25(this.y) && this.y >= 0;
  }
  /**
   * Toggle the visibility of a pie slice or other data point. Note that this
   * method is available only for some series, like pie, treemap and sunburst.
   *
   * @function Highcharts.Point#setVisible
   *
   * @param {boolean} [vis]
   * True to show the pie slice or other data point, false to hide. If
   * undefined, the visibility is toggled.
   *
   * @param {boolean} [redraw] Whether to redraw the chart after the point is
   * altered. If doing more operations on the chart, it is a good idea to set
   * redraw to false and call {@link Chart#redraw|chart.redraw()} after.
   *
   */
  setVisible(vis, redraw = true) {
    if (vis !== this.visible) {
      this.update({
        visible: vis ?? !this.visible
      }, redraw, void 0, false);
    }
  }
  /**
   * Set or toggle whether the slice is cut out from the pie.
   * @private
   *
   * @param {boolean} sliced
   * When undefined, the slice state is toggled.
   *
   * @param {boolean} [redraw]
   * Whether to redraw the chart. True by default.
   *
   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
   * Animation options.
   */
  slice(sliced, redraw, animation) {
    const series = this.series, chart = series.chart;
    setAnimation5(animation, chart);
    redraw = pick28(redraw, true);
    this.sliced = this.options.sliced = sliced = defined22(sliced) ? sliced : !this.sliced;
    series.options.data[series.data.indexOf(this)] = this.options;
    if (this.graphic) {
      this.graphic.animate(this.getTranslate());
    }
  }
};
extend26(PiePoint.prototype, {
  connectorShapes: {
    // Only one available before v7.0.0
    fixedOffset: function(labelPosition, connectorPosition, options2) {
      const breakAt = connectorPosition.breakAt, touchingSliceAt = connectorPosition.touchingSliceAt, lineSegment = options2.softConnector ? [
        "C",
        // Soft break
        // 1st control point (of the curve)
        labelPosition.x + // 5 gives the connector a little horizontal bend
        (labelPosition.alignment === "left" ? -5 : 5),
        labelPosition.y,
        //
        2 * breakAt.x - touchingSliceAt.x,
        // 2nd control point
        2 * breakAt.y - touchingSliceAt.y,
        //
        breakAt.x,
        // End of the curve
        breakAt.y
        //
      ] : [
        "L",
        // Pointy break
        breakAt.x,
        breakAt.y
      ];
      return [
        ["M", labelPosition.x, labelPosition.y],
        lineSegment,
        ["L", touchingSliceAt.x, touchingSliceAt.y]
      ];
    },
    straight: function(labelPosition, connectorPosition) {
      const touchingSliceAt = connectorPosition.touchingSliceAt;
      return [
        ["M", labelPosition.x, labelPosition.y],
        ["L", touchingSliceAt.x, touchingSliceAt.y]
      ];
    },
    crookedLine: function(labelPosition, connectorPosition, options2) {
      const { angle = this.angle || 0, breakAt, touchingSliceAt } = connectorPosition, { series } = this, [cx, cy, diameter] = series.center, r = diameter / 2, { plotLeft, plotWidth } = series.chart, leftAligned = labelPosition.alignment === "left", { x, y } = labelPosition;
      let crookX = breakAt.x;
      if (options2.crookDistance) {
        const crookDistance = relativeLength6(
          // % to fraction
          options2.crookDistance,
          1
        );
        crookX = leftAligned ? cx + r + (plotWidth + plotLeft - cx - r) * (1 - crookDistance) : plotLeft + (cx - r) * crookDistance;
      } else {
        crookX = cx + (cy - y) * Math.tan(angle - Math.PI / 2);
      }
      const path = [["M", x, y]];
      if (leftAligned ? crookX <= x && crookX >= breakAt.x : crookX >= x && crookX <= breakAt.x) {
        path.push(["L", crookX, y]);
      }
      path.push(["L", breakAt.x, breakAt.y], ["L", touchingSliceAt.x, touchingSliceAt.y]);
      return path;
    }
  }
});
var PiePoint_default = PiePoint;

// node_modules/highcharts/es-modules/Series/Pie/PieSeriesDefaults.js
var PieSeriesDefaults = {
  /**
   * The corner radius of the border surrounding each slice. A number
   * signifies pixels. A percentage string, like for example `50%`, signifies
   * a size relative to the radius and the inner radius.
   *
   * @sample  highcharts/plotoptions/series-border-radius
   *          Column and pie with rounded border
   *
   * @since   11.0.0
   *
   * @type      {number|string|Highcharts.BorderRadiusOptionsObject}
   */
  borderRadius: 3,
  /**
   * @excluding legendItemClick
   * @apioption plotOptions.pie.events
   */
  /**
   * Fires when the checkbox next to the point name in the legend is
   * clicked. One parameter, event, is passed to the function. The state
   * of the checkbox is found by event.checked. The checked item is found
   * by event.item. Return false to prevent the default action which is to
   * toggle the select state of the series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
   *         Alert checkbox status
   *
   * @type      {Function}
   * @since     1.2.0
   * @product   highcharts highmaps
   * @context   Highcharts.Point
   * @apioption plotOptions.pie.events.checkboxClick
   */
  /**
   * Fires when the legend item belonging to the pie point (slice) is
   * clicked. The `this` keyword refers to the point itself. One
   * parameter, `event`, is passed to the function, containing common
   * event information. The default action is to toggle the visibility of
   * the point. This can be prevented by calling `event.preventDefault()`.
   *
   *  **Note:** This option is deprecated in favor of
   * [legend.events.itemClick](#legend.events.itemClick).
   *
   * @deprecated 11.4.4
   * @type       {Highcharts.PointLegendItemClickCallbackFunction}
   * @since      1.2.0
   * @product    highcharts highmaps
   * @apioption  plotOptions.pie.point.events.legendItemClick
   */
  /**
   * The center of the pie chart relative to the plot area. Can be
   * percentages or pixel values. The default behaviour (as of 3.0) is to
   * center the pie so that all slices and data labels are within the plot
   * area. As a consequence, the pie may actually jump around in a chart
   * with dynamic values, as the data labels move. In that case, the
   * center should be explicitly set, for example to `["50%", "50%"]`.
   *
   * @sample {highcharts} highcharts/plotoptions/pie-center/
   *         Centered at 100, 100
   *
   * @type    {Array<(number|string|null),(number|string|null)>}
   * @default [null, null]
   * @product highcharts highmaps
   *
   * @private
   */
  center: [null, null],
  /**
   * The color of the pie series. A pie series is represented as an empty
   * circle if the total sum of its values is 0. Use this property to
   * define the color of its border.
   *
   * In styled mode, the color can be defined by the
   * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
   * color can be set with the `.highcharts-series`,
   * `.highcharts-color-{n}`, `.highcharts-{type}-series` or
   * `.highcharts-series-{n}` class, or individual classes given by the
   * `className` option.
   *
   * @sample {highcharts} highcharts/plotoptions/pie-emptyseries/
   *         Empty pie series
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default   ${palette.neutralColor20}
   * @apioption plotOptions.pie.color
   */
  /**
   * @product highcharts
   *
   * @private
   */
  clip: false,
  /**
   * @ignore-option
   *
   * @private
   */
  colorByPoint: true,
  // Always true for pies
  /**
   * A series specific or series type specific color set to use instead
   * of the global [colors](#colors).
   *
   * @sample {highcharts} highcharts/demo/pie-monochrome/
   *         Set default colors for all pies
   *
   * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
   * @since     3.0
   * @product   highcharts highmaps
   * @apioption plotOptions.pie.colors
   */
  /**
   * @declare   Highcharts.SeriesPieDataLabelsOptionsObject
   * @extends   plotOptions.series.dataLabels
   * @excluding align, allowOverlap, inside, staggerLines, step
   * @private
   */
  dataLabels: {
    /**
     * Alignment method for data labels. Possible values are:
     *
     * - `plotEdges`: Each label touches the nearest vertical edge of
     *   the plot area.
     *
     * - `connectors`: Connectors have the same x position and the
     *   widest label of each half (left & right) touches the nearest
     *   vertical edge of the plot area.
     *
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-alignto-connectors/
     *         alignTo: connectors
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-alignto-plotedges/
     *         alignTo: plotEdges
     *
     * @type      {string}
     * @since     7.0.0
     * @product   highcharts highmaps
     * @apioption plotOptions.pie.dataLabels.alignTo
     */
    /**
     * The color of the line connecting the data label to the pie slice.
     * The default color is the same as the point's color.
     *
     * In styled mode, the connector stroke is given in the
     * `.highcharts-data-label-connector` class.
     *
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorcolor/
     *         Blue connectors
     * @sample {highcharts} highcharts/css/pie-point/
     *         Styled connectors
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @since     2.1
     * @product   highcharts highmaps
     * @apioption plotOptions.pie.dataLabels.connectorColor
     */
    /**
     * The distance from the data label to the connector. Note that
     * data labels also have a default `padding`, so in order for the
     * connector to touch the text, the `padding` must also be 0.
     *
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorpadding/
     *         No padding
     *
     * @since   2.1
     * @product highcharts highmaps
     */
    connectorPadding: 5,
    /**
     * Specifies the method that is used to generate the connector path.
     * Highcharts provides 3 built-in connector shapes: `'crookedLine'`
     * (default since v11), `'fixedOffset'` and `'straight'`.
     *
     * Users can provide their own method by passing a function instead of a
     * string. Three arguments are passed to the callback:
     *
     * - An object that holds the information about the coordinates of the
     *   label (`x` & `y` properties) and how the label is located in
     *   relation to the pie (`alignment` property). `alignment` can by one
     *   of the following: `'left'` (pie on the left side of the data
     *   label), `'right'` (pie on the right side of the data label) or
     *   `'center'` (data label overlaps the pie).
     *
     * - An object that holds the information about the position of the
     *   connector. Its `touchingSliceAt`  porperty tells the position of
     *   the place where the connector touches the slice.
     *
     * - Data label options
     *
     * The function has to return an SVG path definition in array form (see
     * the example).
     *
     * @sample {highcharts}
     *         highcharts/plotoptions/pie-datalabels-connectorshape-string/
     *         connectorShape is a String
     * @sample {highcharts}
     *         highcharts/plotoptions/pie-datalabels-connectorshape-function/
     *         connectorShape is a function
     *
     * @type    {string|Function}
     * @since   7.0.0
     * @product highcharts highmaps
     */
    connectorShape: "crookedLine",
    /**
     * The width of the line connecting the data label to the pie slice.
     *
     * In styled mode, the connector stroke width is given in the
     * `.highcharts-data-label-connector` class.
     *
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorwidth-disabled/
     *         Disable the connector
     * @sample {highcharts} highcharts/css/pie-point/
     *         Styled connectors
     *
     * @type      {number}
     * @default   1
     * @since     2.1
     * @product   highcharts highmaps
     * @apioption plotOptions.pie.dataLabels.connectorWidth
     */
    /**
     * Works only if `connectorShape` is `'crookedLine'`. It defines how
     * far from the vertical plot edge the coonnector path should be
     * crooked. With the default, `undefined`, the crook is placed so that
     * the horizontal line from the label intersects with the radial line
     * extending through the center of the pie slice.
     *
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-crookdistance/
     *         crookDistance set to 90%
     *
     * @since   7.0.0
     * @product highcharts highmaps
     */
    crookDistance: void 0,
    /**
     * The distance of the data label from the pie's edge. Negative
     * numbers put the data label on top of the pie slices. Can also be
     * defined as a percentage of pie's radius. Connectors are only
     * shown for data labels outside the pie.
     *
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-distance/
     *         Data labels on top of the pie
     *
     * @type    {number|string}
     * @since   2.1
     * @product highcharts highmaps
     */
    distance: 30,
    enabled: true,
    /**
     * A
     * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
     * for the data label. Available variables are the same as for
     * `formatter`.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
     *         Add a unit
     *
     * @type      {string}
     * @default   undefined
     * @since     3.0
     * @apioption plotOptions.pie.dataLabels.format
     */
    // eslint-disable-next-line valid-jsdoc
    /**
     * Callback JavaScript function to format the data label. Note that
     * if a `format` is defined, the format takes precedence and the
     * formatter is ignored.
     *
     * @type {Highcharts.DataLabelsFormatterCallbackFunction}
     * @default function () { return this.point.isNull ? void 0 : this.point.name; }
     */
    formatter: function() {
      return this.isNull ? void 0 : this.name;
    },
    /**
     * Whether to render the connector as a soft arc or a line with a sharp
     * break. Works only if `connectorShape` equals to `fixedOffset`.
     *
     * @sample {highcharts}
     *         highcharts/plotoptions/pie-datalabels-softconnector-true/
     *         Soft
     * @sample {highcharts}
     *         highcharts/plotoptions/pie-datalabels-softconnector-false/
     *         Non soft
     *
     * @since   2.1.7
     * @product highcharts highmaps
     */
    softConnector: true,
    /**
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow
     *         Long labels truncated with an ellipsis
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow-wrap
     *         Long labels are wrapped
     *
     * @type      {Highcharts.CSSObject}
     * @apioption plotOptions.pie.dataLabels.style
     */
    x: 0
  },
  /**
   * If the total sum of the pie's values is 0, the series is represented
   * as an empty circle . The `fillColor` option defines the color of that
   * circle. Use [pie.borderWidth](#plotOptions.pie.borderWidth) to set
   * the border thickness.
   *
   * @sample {highcharts} highcharts/plotoptions/pie-emptyseries/
   *         Empty pie series
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @private
   */
  fillColor: void 0,
  /**
   * The end angle of the pie in degrees where 0 is top and 90 is right.
   * Defaults to `startAngle` plus 360.
   *
   * @sample {highcharts} highcharts/demo/pie-semi-circle/
   *         Semi-circle donut
   *
   * @type      {number}
   * @since     1.3.6
   * @product   highcharts highmaps
   * @apioption plotOptions.pie.endAngle
   */
  /**
   * Thickness describing the ring size for a donut type chart,
   * overriding [innerSize](#plotOptions.pie.innerSize).
   *
   * @type      {number}
   * @default   undefined
   * @product   highcharts
   * @since 10.1.0
   * @apioption plotOptions.pie.thickness
   * @private
   */
  /**
   * Equivalent to [chart.ignoreHiddenSeries](#chart.ignoreHiddenSeries),
   * this option tells whether the series shall be redrawn as if the
   * hidden point were `null`.
   *
   * The default value changed from `false` to `true` with Highcharts
   * 3.0.
   *
   * @sample {highcharts} highcharts/plotoptions/pie-ignorehiddenpoint/
   *         True, the hiddden point is ignored
   *
   * @since   2.3.0
   * @product highcharts highmaps
   *
   * @private
   */
  ignoreHiddenPoint: true,
  /**
   * @default   true
   * @extends   plotOptions.series.inactiveOtherPoints
   * @private
   */
  inactiveOtherPoints: true,
  /**
   * The size of the inner diameter for the pie. A size greater than 0
   * renders a donut chart. Can be a percentage or pixel value.
   * Percentages are relative to the pie size. Pixel values are given as
   * integers. Setting overridden by thickness.
   *
   *
   * Note: in Highcharts < 4.1.2, the percentage was relative to the plot
   * area, not the pie size.
   *
   * @sample {highcharts} highcharts/plotoptions/pie-innersize-80px/
   *         80px inner size
   * @sample {highcharts} highcharts/plotoptions/pie-innersize-50percent/
   *         50% of the plot area
   * @sample {highcharts} highcharts/demo/3d-pie-donut/
   *         3D donut
   *
   * @type      {number|string}
   * @default   0
   * @since     2.0
   * @product   highcharts highmaps
   * @apioption plotOptions.pie.innerSize
   */
  /**
   * @ignore-option
   *
   * @private
   */
  legendType: "point",
  /**
   * @ignore-option
   *
   * @private
   */
  marker: null,
  // Point options are specified in the base options
  /**
   * The minimum size for a pie in response to auto margins. The pie will
   * try to shrink to make room for data labels in side the plot area,
   *  but only to this size.
   *
   * @type      {number|string}
   * @default   80
   * @since     3.0
   * @product   highcharts highmaps
   * @apioption plotOptions.pie.minSize
   */
  /**
   * The diameter of the pie relative to the plot area. Can be a
   * percentage or pixel value. Pixel values are given as integers. The
   * default behaviour (as of 3.0) is to scale to the plot area and give
   * room for data labels within the plot area.
   * [slicedOffset](#plotOptions.pie.slicedOffset) is also included in the
   * default size calculation. As a consequence, the size of the pie may
   * vary when points are updated and data labels more around. In that
   * case it is best to set a fixed value, for example `"75%"`.
   *
   * @sample {highcharts} highcharts/plotoptions/pie-size/
   *         Smaller pie
   *
   * @type    {number|string|null}
   * @product highcharts highmaps
   *
   * @private
   */
  size: null,
  /**
   * Whether to display this particular series or series type in the
   * legend. Since 2.1, pies are not shown in the legend by default.
   *
   * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
   *         One series in the legend, one hidden
   *
   * @product highcharts highmaps
   *
   * @private
   */
  showInLegend: false,
  /**
   * If a point is sliced, moved out from the center, how many pixels
   * should it be moved?.
   *
   * @sample {highcharts} highcharts/plotoptions/pie-slicedoffset-20/
   *         20px offset
   *
   * @product highcharts highmaps
   *
   * @private
   */
  slicedOffset: 10,
  /**
   * The start angle of the pie slices in degrees where 0 is top and 90
   * right.
   *
   * @sample {highcharts} highcharts/plotoptions/pie-startangle-90/
   *         Start from right
   *
   * @type      {number}
   * @default   0
   * @since     2.3.4
   * @product   highcharts highmaps
   * @apioption plotOptions.pie.startAngle
   */
  /**
   * Sticky tracking of mouse events. When true, the `mouseOut` event
   * on a series isn't triggered until the mouse moves over another
   * series, or out of the plot area. When false, the `mouseOut` event on
   * a series is triggered when the mouse leaves the area around the
   * series'  graph or markers. This also implies the tooltip. When
   * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
   * will be hidden when moving the mouse between series.
   *
   * @product highcharts highmaps
   *
   * @private
   */
  stickyTracking: false,
  tooltip: {
    followPointer: true
  },
  /**
   * The color of the border surrounding each slice. When `null`, the
   * border takes the same color as the slice fill. This can be used
   * together with a `borderWidth` to fill drawing gaps created by
   * antialiazing artefacts in borderless pies.
   *
   * In styled mode, the border stroke is given in the `.highcharts-point`
   * class.
   *
   * @sample {highcharts} highcharts/plotoptions/pie-bordercolor-black/
   *         Black border
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default #ffffff
   * @product highcharts highmaps
   *
   * @private
   */
  borderColor: "#ffffff",
  /**
   * The width of the border surrounding each slice.
   *
   * When setting the border width to 0, there may be small gaps between
   * the slices due to SVG antialiasing artefacts. To work around this,
   * keep the border width at 0.5 or 1, but set the `borderColor` to
   * `null` instead.
   *
   * In styled mode, the border stroke width is given in the
   * `.highcharts-point` class.
   *
   * @sample {highcharts} highcharts/plotoptions/pie-borderwidth/
   *         3px border
   *
   * @product highcharts highmaps
   *
   * @private
   */
  borderWidth: 1,
  /**
   * @ignore-option
   * @private
   */
  lineWidth: void 0,
  // #12222
  states: {
    /**
     * @extends   plotOptions.series.states.hover
     * @excluding marker, lineWidth, lineWidthPlus
     * @product   highcharts highmaps
     */
    hover: {
      /**
       * How much to brighten the point on interaction. Requires the
       * main color to be defined in hex or rgb(a) format.
       *
       * In styled mode, the hover brightness is by default replaced
       * by a fill-opacity given in the `.highcharts-point-hover`
       * class.
       *
       * @sample {highcharts} highcharts/plotoptions/pie-states-hover-brightness/
       *         Brightened by 0.5
       *
       * @product highcharts highmaps
       */
      brightness: 0.1
    }
  }
};
var PieSeriesDefaults_default = PieSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Pie/PieSeries.js
var { getStartAndEndRadians } = CenteredUtilities_default;
var { noop: noop3 } = Globals_default;
var { clamp: clamp8, extend: extend27, fireEvent: fireEvent20, merge: merge29, pick: pick29 } = Utilities_default;
var PieSeries = class extends Series_default {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Animates the pies in.
   * @private
   */
  animate(init3) {
    const series = this, points = series.points, startAngleRad = series.startAngleRad;
    if (!init3) {
      points.forEach(function(point) {
        const graphic = point.graphic, args = point.shapeArgs;
        if (graphic && args) {
          graphic.attr({
            // Animate from inner radius (#779)
            r: pick29(point.startR, series.center && series.center[3] / 2),
            start: startAngleRad,
            end: startAngleRad
          });
          graphic.animate({
            r: args.r,
            start: args.start,
            end: args.end
          }, series.options.animation);
        }
      });
    }
  }
  /**
   * Called internally to draw auxiliary graph in pie-like series in
   * situtation when the default graph is not sufficient enough to present
   * the data well. Auxiliary graph is saved in the same object as
   * regular graph.
   * @private
   */
  drawEmpty() {
    const start = this.startAngleRad, end = this.endAngleRad, options2 = this.options;
    let centerX, centerY;
    if (this.total === 0 && this.center) {
      centerX = this.center[0];
      centerY = this.center[1];
      if (!this.graph) {
        this.graph = this.chart.renderer.arc(centerX, centerY, this.center[1] / 2, 0, start, end).addClass("highcharts-empty-series").add(this.group);
      }
      this.graph.attr({
        d: Symbols_default.arc(centerX, centerY, this.center[2] / 2, 0, {
          start,
          end,
          innerR: this.center[3] / 2
        })
      });
      if (!this.chart.styledMode) {
        this.graph.attr({
          "stroke-width": options2.borderWidth,
          fill: options2.fillColor || "none",
          stroke: options2.color || "#cccccc"
          /* Palette.neutralColor20 */
        });
      }
    } else if (this.graph) {
      this.graph = this.graph.destroy();
    }
  }
  /**
   * Slices in pie chart are initialized in DOM, but it's shapes and
   * animations are normally run in `drawPoints()`.
   * @private
   */
  drawPoints() {
    const renderer = this.chart.renderer;
    this.points.forEach(function(point) {
      if (point.graphic && point.hasNewShapeType()) {
        point.graphic = point.graphic.destroy();
      }
      if (!point.graphic) {
        point.graphic = renderer[point.shapeType](point.shapeArgs).add(point.series.group);
        point.delayedRendering = true;
      }
    });
  }
  /**
   * Extend the generatePoints method by adding total and percentage
   * properties to each point
   * @private
   */
  generatePoints() {
    super.generatePoints();
    this.updateTotals();
  }
  /**
   * Utility for getting the x value from a given y, used for anticollision
   * logic in data labels.
   * @private
   */
  getX(y, left, point, dataLabel) {
    const center = this.center, radius = this.radii ? this.radii[point.index] || 0 : center[2] / 2, labelPosition = dataLabel.dataLabelPosition, distance = labelPosition?.distance || 0;
    const angle = Math.asin(clamp8((y - center[1]) / (radius + distance), -1, 1));
    const x = center[0] + (left ? -1 : 1) * (Math.cos(angle) * (radius + distance)) + (distance > 0 ? (left ? -1 : 1) * (dataLabel.padding || 0) : 0);
    return x;
  }
  /**
   * Define hasData function for non-cartesian series. Returns true if the
   * series has points at all.
   * @private
   */
  hasData() {
    return !!this.dataTable.rowCount;
  }
  /**
   * Draw the data points
   * @private
   */
  redrawPoints() {
    const series = this, chart = series.chart;
    let groupTranslation, graphic, pointAttr, shapeArgs;
    this.drawEmpty();
    if (series.group && !chart.styledMode) {
      series.group.shadow(series.options.shadow);
    }
    series.points.forEach(function(point) {
      const animateTo = {};
      graphic = point.graphic;
      if (!point.isNull && graphic) {
        shapeArgs = point.shapeArgs;
        groupTranslation = point.getTranslate();
        if (!chart.styledMode) {
          pointAttr = series.pointAttribs(point, point.selected && "select");
        }
        if (!point.delayedRendering) {
          graphic.setRadialReference(series.center);
          if (!chart.styledMode) {
            merge29(true, animateTo, pointAttr);
          }
          merge29(true, animateTo, shapeArgs, groupTranslation);
          graphic.animate(animateTo);
        } else {
          graphic.setRadialReference(series.center).attr(shapeArgs).attr(groupTranslation);
          if (!chart.styledMode) {
            graphic.attr(pointAttr).attr({ "stroke-linejoin": "round" });
          }
          point.delayedRendering = false;
        }
        graphic.attr({
          visibility: point.visible ? "inherit" : "hidden"
        });
        graphic.addClass(point.getClassName(), true);
      } else if (graphic) {
        point.graphic = graphic.destroy();
      }
    });
  }
  /**
   * Utility for sorting data labels.
   * @private
   */
  sortByAngle(points, sign) {
    points.sort(function(a, b) {
      return typeof a.angle !== "undefined" && (b.angle - a.angle) * sign;
    });
  }
  /**
   * Do translation for pie slices
   * @private
   */
  translate(positions) {
    fireEvent20(this, "translate");
    this.generatePoints();
    const series = this, precision = 1e3, options2 = series.options, slicedOffset = options2.slicedOffset, radians = getStartAndEndRadians(options2.startAngle, options2.endAngle), startAngleRad = series.startAngleRad = radians.start, endAngleRad = series.endAngleRad = radians.end, circ = endAngleRad - startAngleRad, points = series.points, ignoreHiddenPoint = options2.ignoreHiddenPoint, len = points.length;
    let start, end, angle, radiusX, radiusY, i, point, cumulative = 0;
    if (!positions) {
      series.center = positions = series.getCenter();
    }
    for (i = 0; i < len; i++) {
      point = points[i];
      start = startAngleRad + cumulative * circ;
      if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
        cumulative += point.percentage / 100;
      }
      end = startAngleRad + cumulative * circ;
      const shapeArgs = {
        x: positions[0],
        y: positions[1],
        r: positions[2] / 2,
        innerR: positions[3] / 2,
        start: Math.round(start * precision) / precision,
        end: Math.round(end * precision) / precision
      };
      point.shapeType = "arc";
      point.shapeArgs = shapeArgs;
      angle = (end + start) / 2;
      if (angle > 1.5 * Math.PI) {
        angle -= 2 * Math.PI;
      } else if (angle < -Math.PI / 2) {
        angle += 2 * Math.PI;
      }
      point.slicedTranslation = {
        translateX: Math.round(Math.cos(angle) * slicedOffset),
        translateY: Math.round(Math.sin(angle) * slicedOffset)
      };
      radiusX = Math.cos(angle) * positions[2] / 2;
      radiusY = Math.sin(angle) * positions[2] / 2;
      point.tooltipPos = [
        positions[0] + radiusX * 0.7,
        positions[1] + radiusY * 0.7
      ];
      point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
      point.angle = angle;
    }
    fireEvent20(series, "afterTranslate");
  }
  /**
   * Recompute total chart sum and update percentages of points.
   * @private
   */
  updateTotals() {
    const points = this.points, len = points.length, ignoreHiddenPoint = this.options.ignoreHiddenPoint;
    let i, point, total = 0;
    for (i = 0; i < len; i++) {
      point = points[i];
      if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
        total += point.y;
      }
    }
    this.total = total;
    for (i = 0; i < len; i++) {
      point = points[i];
      point.percentage = total > 0 && (point.visible || !ignoreHiddenPoint) ? point.y / total * 100 : 0;
      point.total = total;
    }
  }
};
PieSeries.defaultOptions = merge29(Series_default.defaultOptions, PieSeriesDefaults_default);
extend27(PieSeries.prototype, {
  axisTypes: [],
  directTouch: true,
  drawGraph: void 0,
  drawTracker: ColumnSeries_default.prototype.drawTracker,
  getCenter: CenteredUtilities_default.getCenter,
  getSymbol: noop3,
  invertible: false,
  isCartesian: false,
  noSharedTooltip: true,
  pointAttribs: ColumnSeries_default.prototype.pointAttribs,
  pointClass: PiePoint_default,
  requireSorting: false,
  searchPoint: noop3,
  trackerGroups: ["group", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("pie", PieSeries);

// node_modules/highcharts/es-modules/Series/Pie/PieDataLabel.js
var { composed: composed7, noop: noop4 } = Globals_default;
var { distribute: distribute3 } = RendererUtilities_default;
var { series: Series4 } = SeriesRegistry_default;
var { arrayMax: arrayMax5, clamp: clamp9, defined: defined23, pick: pick30, pushUnique: pushUnique10, relativeLength: relativeLength7 } = Utilities_default;
var ColumnDataLabel2;
(function(ColumnDataLabel3) {
  const dataLabelPositioners = {
    // Based on the value computed in Highcharts' distribute algorithm.
    radialDistributionY: function(point, dataLabel) {
      return (dataLabel.dataLabelPosition?.top || 0) + point.distributeBox.pos;
    },
    // Get the x - use the natural x position for labels near the top and
    // bottom, to prevent the top and botton slice connectors from touching
    // each other on either side. Based on the value computed in Highcharts'
    // distribute algorithm.
    radialDistributionX: function(series, point, y, naturalY, dataLabel) {
      const pos = dataLabel.dataLabelPosition;
      return series.getX(y < (pos?.top || 0) + 2 || y > (pos?.bottom || 0) - 2 ? naturalY : y, point.half, point, dataLabel);
    },
    // The dataLabels.distance determines the x position of the label
    justify: function(point, dataLabel, radius, seriesCenter) {
      return seriesCenter[0] + (point.half ? -1 : 1) * (radius + (dataLabel.dataLabelPosition?.distance || 0));
    },
    // Left edges of the left-half labels touch the left edge of the plot
    // area. Right edges of the right-half labels touch the right edge of
    // the plot area.
    alignToPlotEdges: function(dataLabel, half, plotWidth, plotLeft) {
      const dataLabelWidth = dataLabel.getBBox().width;
      return half ? dataLabelWidth + plotLeft : plotWidth - dataLabelWidth - plotLeft;
    },
    // Connectors of each side end in the same x position. Labels are
    // aligned to them. Left edge of the widest left-half label touches the
    // left edge of the plot area. Right edge of the widest right-half label
    // touches the right edge of the plot area.
    alignToConnectors: function(points, half, plotWidth, plotLeft) {
      let maxDataLabelWidth = 0, dataLabelWidth;
      points.forEach(function(point) {
        dataLabelWidth = point.dataLabel.getBBox().width;
        if (dataLabelWidth > maxDataLabelWidth) {
          maxDataLabelWidth = dataLabelWidth;
        }
      });
      return half ? maxDataLabelWidth + plotLeft : plotWidth - maxDataLabelWidth - plotLeft;
    }
  };
  function compose27(PieSeriesClass) {
    DataLabel_default.compose(Series4);
    if (pushUnique10(composed7, "PieDataLabel")) {
      const pieProto = PieSeriesClass.prototype;
      pieProto.dataLabelPositioners = dataLabelPositioners;
      pieProto.alignDataLabel = noop4;
      pieProto.drawDataLabels = drawDataLabels;
      pieProto.getDataLabelPosition = getDataLabelPosition;
      pieProto.placeDataLabels = placeDataLabels;
      pieProto.verifyDataLabelOverflow = verifyDataLabelOverflow;
    }
  }
  ColumnDataLabel3.compose = compose27;
  function getDataLabelPosition(point, distance) {
    const halfPI = Math.PI / 2, { start = 0, end = 0 } = point.shapeArgs || {};
    let angle = point.angle || 0;
    if (distance > 0 && // Crossing the bottom
    start < halfPI && end > halfPI && // Angle within the bottom quadrant
    angle > halfPI / 2 && angle < halfPI * 1.5) {
      angle = angle <= halfPI ? Math.max(halfPI / 2, (start + halfPI) / 2) : Math.min(halfPI * 1.5, (halfPI + end) / 2);
    }
    const { center, options: options2 } = this, r = center[2] / 2, cosAngle = Math.cos(angle), sinAngle = Math.sin(angle), x = center[0] + cosAngle * r, y = center[1] + sinAngle * r, finalConnectorOffset = Math.min((options2.slicedOffset || 0) + (options2.borderWidth || 0), distance / 5);
    return {
      natural: {
        // Initial position of the data label - it's utilized for
        // finding the final position for the label
        x: x + cosAngle * distance,
        y: y + sinAngle * distance
      },
      computed: {
        // Used for generating connector path - initialized later in
        // drawDataLabels function x: undefined, y: undefined
      },
      // Left - pie on the left side of the data label
      // Right - pie on the right side of the data label
      // Center - data label overlaps the pie
      alignment: distance < 0 ? "center" : point.half ? "right" : "left",
      connectorPosition: {
        angle,
        breakAt: {
          x: x + cosAngle * finalConnectorOffset,
          y: y + sinAngle * finalConnectorOffset
        },
        touchingSliceAt: {
          x,
          y
        }
      },
      distance
    };
  }
  function drawDataLabels() {
    const series = this, points = series.points, chart = series.chart, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotLeft = chart.plotLeft, maxWidth = Math.round(chart.chartWidth / 3), seriesCenter = series.center, radius = seriesCenter[2] / 2, centerY = seriesCenter[1], halves = [
      [],
      // Right
      []
      // Left
    ], overflow = [0, 0, 0, 0], dataLabelPositioners2 = series.dataLabelPositioners;
    let connector, dataLabelWidth, labelHeight, maxLabelDistance = 0;
    if (!series.visible || !series.hasDataLabels?.()) {
      return;
    }
    points.forEach((point) => {
      (point.dataLabels || []).forEach((dataLabel) => {
        if (dataLabel.shortened) {
          dataLabel.attr({
            width: "auto"
          }).css({
            width: "auto",
            textOverflow: "clip"
          });
          dataLabel.shortened = false;
        }
      });
    });
    Series4.prototype.drawDataLabels.apply(series);
    points.forEach((point) => {
      (point.dataLabels || []).forEach((dataLabel, i) => {
        const r = seriesCenter[2] / 2, dataLabelOptions = dataLabel.options, distance = relativeLength7(dataLabelOptions?.distance || 0, r);
        if (i === 0) {
          halves[point.half].push(point);
        }
        if (!defined23(dataLabelOptions?.style?.width)) {
          if (dataLabel.getBBox().width > maxWidth) {
            dataLabel.css({
              // Use a fraction of the maxWidth to avoid wrapping
              // close to the end of the string.
              width: Math.round(maxWidth * 0.7) + "px"
            });
            dataLabel.shortened = true;
          }
        }
        dataLabel.dataLabelPosition = this.getDataLabelPosition(point, distance);
        maxLabelDistance = Math.max(maxLabelDistance, distance);
      });
    });
    halves.forEach((points2, halfIdx) => {
      const length = points2.length, positions = [];
      let top, bottom, size = 0, distributionLength;
      if (!length) {
        return;
      }
      series.sortByAngle(points2, halfIdx - 0.5);
      if (maxLabelDistance > 0) {
        top = Math.max(0, centerY - radius - maxLabelDistance);
        bottom = Math.min(centerY + radius + maxLabelDistance, chart.plotHeight);
        points2.forEach((point) => {
          (point.dataLabels || []).forEach((dataLabel) => {
            const labelPosition = dataLabel.dataLabelPosition;
            if (labelPosition && labelPosition.distance > 0) {
              labelPosition.top = Math.max(0, centerY - radius - labelPosition.distance);
              labelPosition.bottom = Math.min(centerY + radius + labelPosition.distance, chart.plotHeight);
              size = dataLabel.getBBox().height || 21;
              dataLabel.lineHeight = chart.renderer.fontMetrics(dataLabel.text || dataLabel).h + 2 * dataLabel.padding;
              point.distributeBox = {
                target: (dataLabel.dataLabelPosition?.natural.y || 0) - labelPosition.top + dataLabel.lineHeight / 2,
                size,
                rank: point.y
              };
              positions.push(point.distributeBox);
            }
          });
        });
        distributionLength = bottom + size - top;
        distribute3(positions, distributionLength, distributionLength / 5);
      }
      points2.forEach((point) => {
        (point.dataLabels || []).forEach((dataLabel) => {
          const dataLabelOptions = dataLabel.options || {}, distributeBox = point.distributeBox, labelPosition = dataLabel.dataLabelPosition, naturalY = labelPosition?.natural.y || 0, connectorPadding = dataLabelOptions.connectorPadding || 0, lineHeight = dataLabel.lineHeight || 21, bBox = dataLabel.getBBox(), topOffset = (lineHeight - bBox.height) / 2;
          let x = 0, y = naturalY, visibility = "inherit";
          if (labelPosition) {
            if (positions && defined23(distributeBox) && labelPosition.distance > 0) {
              if (typeof distributeBox.pos === "undefined") {
                visibility = "hidden";
              } else {
                labelHeight = distributeBox.size;
                y = dataLabelPositioners2.radialDistributionY(point, dataLabel);
              }
            }
            if (dataLabelOptions.justify) {
              x = dataLabelPositioners2.justify(point, dataLabel, radius, seriesCenter);
            } else {
              switch (dataLabelOptions.alignTo) {
                case "connectors":
                  x = dataLabelPositioners2.alignToConnectors(points2, halfIdx, plotWidth, plotLeft);
                  break;
                case "plotEdges":
                  x = dataLabelPositioners2.alignToPlotEdges(dataLabel, halfIdx, plotWidth, plotLeft);
                  break;
                default:
                  x = dataLabelPositioners2.radialDistributionX(series, point, y - topOffset, naturalY, dataLabel);
              }
            }
            labelPosition.attribs = {
              visibility,
              align: labelPosition.alignment
            };
            labelPosition.posAttribs = {
              x: x + (dataLabelOptions.x || 0) + // (#12985)
              ({
                left: connectorPadding,
                right: -connectorPadding
              }[labelPosition.alignment] || 0),
              y: y + (dataLabelOptions.y || 0) - // (#12985)
              // Vertically center
              lineHeight / 2
            };
            labelPosition.computed.x = x;
            labelPosition.computed.y = y - topOffset;
            if (pick30(dataLabelOptions.crop, true)) {
              dataLabelWidth = dataLabel.getBBox().width;
              let sideOverflow;
              if (x - dataLabelWidth < connectorPadding && halfIdx === 1) {
                sideOverflow = Math.round(dataLabelWidth - x + connectorPadding);
                overflow[3] = Math.max(sideOverflow, overflow[3]);
              } else if (x + dataLabelWidth > plotWidth - connectorPadding && halfIdx === 0) {
                sideOverflow = Math.round(x + dataLabelWidth - plotWidth + connectorPadding);
                overflow[1] = Math.max(sideOverflow, overflow[1]);
              }
              if (y - labelHeight / 2 < 0) {
                overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0]);
              } else if (y + labelHeight / 2 > plotHeight) {
                overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2]);
              }
              labelPosition.sideOverflow = sideOverflow;
            }
          }
        });
      });
    });
    if (arrayMax5(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
      this.placeDataLabels();
      this.points.forEach((point) => {
        (point.dataLabels || []).forEach((dataLabel) => {
          const { connectorColor, connectorWidth = 1 } = dataLabel.options || {}, labelPosition = dataLabel.dataLabelPosition;
          if (connectorWidth) {
            let isNew;
            connector = dataLabel.connector;
            if (labelPosition && labelPosition.distance > 0) {
              isNew = !connector;
              if (!connector) {
                dataLabel.connector = connector = chart.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + point.colorIndex + (point.className ? " " + point.className : "")).add(series.dataLabelsGroup);
              }
              if (!chart.styledMode) {
                connector.attr({
                  "stroke-width": connectorWidth,
                  "stroke": connectorColor || point.color || "#666666"
                });
              }
              connector[isNew ? "attr" : "animate"]({
                d: point.getConnectorPath(dataLabel)
              });
              connector.attr({
                visibility: labelPosition.attribs?.visibility
              });
            } else if (connector) {
              dataLabel.connector = connector.destroy();
            }
          }
        });
      });
    }
  }
  function placeDataLabels() {
    this.points.forEach((point) => {
      (point.dataLabels || []).forEach((dataLabel) => {
        const labelPosition = dataLabel.dataLabelPosition;
        if (labelPosition) {
          if (labelPosition.sideOverflow) {
            dataLabel.css({
              width: Math.max(dataLabel.getBBox().width - labelPosition.sideOverflow, 0) + "px",
              textOverflow: dataLabel.options?.style?.textOverflow || "ellipsis"
            });
            dataLabel.shortened = true;
          }
          dataLabel.attr(labelPosition.attribs);
          dataLabel[dataLabel.moved ? "animate" : "attr"](labelPosition.posAttribs);
          dataLabel.moved = true;
        } else if (dataLabel) {
          dataLabel.attr({ y: -9999 });
        }
      });
      delete point.distributeBox;
    }, this);
  }
  function verifyDataLabelOverflow(overflow) {
    const center = this.center, options2 = this.options, centerOption = options2.center, minSize = options2.minSize || 80;
    let newSize = minSize, ret = options2.size !== null;
    if (!ret) {
      if (centerOption[0] !== null) {
        newSize = Math.max(center[2] - Math.max(overflow[1], overflow[3]), minSize);
      } else {
        newSize = Math.max(
          // Horizontal overflow
          center[2] - overflow[1] - overflow[3],
          minSize
        );
        center[0] += (overflow[3] - overflow[1]) / 2;
      }
      if (centerOption[1] !== null) {
        newSize = clamp9(newSize, minSize, center[2] - Math.max(overflow[0], overflow[2]));
      } else {
        newSize = clamp9(
          newSize,
          minSize,
          // Vertical overflow
          center[2] - overflow[0] - overflow[2]
        );
        center[1] += (overflow[0] - overflow[2]) / 2;
      }
      if (newSize < center[2]) {
        center[2] = newSize;
        center[3] = Math.min(
          // #3632
          options2.thickness ? Math.max(0, newSize - options2.thickness * 2) : Math.max(0, relativeLength7(options2.innerSize || 0, newSize)),
          newSize
        );
        this.translate(center);
        if (this.drawDataLabels) {
          this.drawDataLabels();
        }
      } else {
        ret = true;
      }
    }
    return ret;
  }
})(ColumnDataLabel2 || (ColumnDataLabel2 = {}));
var PieDataLabel_default = ColumnDataLabel2;

// node_modules/highcharts/es-modules/Core/Geometry/GeometryUtilities.js
var GeometryUtilities;
(function(GeometryUtilities2) {
  function getCenterOfPoints(points) {
    const sum2 = points.reduce((sum3, point) => {
      sum3.x += point.x;
      sum3.y += point.y;
      return sum3;
    }, { x: 0, y: 0 });
    return {
      x: sum2.x / points.length,
      y: sum2.y / points.length
    };
  }
  GeometryUtilities2.getCenterOfPoints = getCenterOfPoints;
  function getDistanceBetweenPoints(p1, p2) {
    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
  }
  GeometryUtilities2.getDistanceBetweenPoints = getDistanceBetweenPoints;
  function getAngleBetweenPoints(p1, p2) {
    return Math.atan2(p2.x - p1.x, p2.y - p1.y);
  }
  GeometryUtilities2.getAngleBetweenPoints = getAngleBetweenPoints;
  function pointInPolygon2({ x, y }, polygon) {
    const len = polygon.length;
    let i, j, inside = false;
    for (i = 0, j = len - 1; i < len; j = i++) {
      const [x1, y1] = polygon[i], [x2, y2] = polygon[j];
      if (y1 > y !== y2 > y && x < (x2 - x1) * (y - y1) / (y2 - y1) + x1) {
        inside = !inside;
      }
    }
    return inside;
  }
  GeometryUtilities2.pointInPolygon = pointInPolygon2;
})(GeometryUtilities || (GeometryUtilities = {}));
var GeometryUtilities_default = GeometryUtilities;

// node_modules/highcharts/es-modules/Core/Series/OverlappingDataLabels.js
var { pointInPolygon } = GeometryUtilities_default;
var { addEvent: addEvent17, getAlignFactor: getAlignFactor10, fireEvent: fireEvent21, objectEach: objectEach20, pick: pick31 } = Utilities_default;
function chartHideOverlappingLabels(labels) {
  const chart = this, len = labels.length, isIntersectRect = (box12, box22) => !(box22.x >= box12.x + box12.width || box22.x + box22.width <= box12.x || box22.y >= box12.y + box12.height || box22.y + box22.height <= box12.y), isPolygonOverlap = (box1Poly, box2Poly) => {
    for (const p of box1Poly) {
      if (pointInPolygon({ x: p[0], y: p[1] }, box2Poly)) {
        return true;
      }
    }
    return false;
  };
  function getAbsoluteBox(label3) {
    if (label3 && (!label3.alignAttr || label3.placed)) {
      const padding = label3.box ? 0 : label3.padding || 0, pos = label3.alignAttr || {
        x: label3.attr("x"),
        y: label3.attr("y")
      }, { height, polygon, width } = label3.getBBox(), alignOffset = getAlignFactor10(label3.alignValue) * width;
      label3.width = width;
      label3.height = height;
      return {
        x: pos.x + (label3.parentGroup?.translateX || 0) + padding - alignOffset,
        y: pos.y + (label3.parentGroup?.translateY || 0) + padding,
        width: width - 2 * padding,
        height: height - 2 * padding,
        polygon
      };
    }
  }
  let label, label1, label2, box1, box2, isLabelAffected = false;
  for (let i = 0; i < len; i++) {
    label = labels[i];
    if (label) {
      label.oldOpacity = label.opacity;
      label.newOpacity = 1;
      label.absoluteBox = getAbsoluteBox(label);
    }
  }
  labels.sort((a, b) => (b.labelrank || 0) - (a.labelrank || 0));
  for (let i = 0; i < len; ++i) {
    label1 = labels[i];
    box1 = label1 && label1.absoluteBox;
    const box1Poly = box1?.polygon;
    for (let j = i + 1; j < len; ++j) {
      label2 = labels[j];
      box2 = label2 && label2.absoluteBox;
      let toHide = false;
      if (box1 && box2 && label1 !== label2 && // #6465, polar chart with connectEnds
      label1.newOpacity !== 0 && label2.newOpacity !== 0 && // #15863 dataLabels are no longer hidden by translation
      label1.visibility !== "hidden" && label2.visibility !== "hidden") {
        const box2Poly = box2.polygon;
        if (box1Poly && box2Poly && box1Poly !== box2Poly) {
          if (isPolygonOverlap(box1Poly, box2Poly)) {
            toHide = true;
          }
        } else if (isIntersectRect(box1, box2)) {
          toHide = true;
        }
        if (toHide) {
          const overlappingLabel = label1.labelrank < label2.labelrank ? label1 : label2, labelText = overlappingLabel.text;
          overlappingLabel.newOpacity = 0;
          if (labelText?.element.querySelector("textPath")) {
            labelText.hide();
          }
        }
      }
    }
  }
  for (const label3 of labels) {
    if (hideOrShow(label3, chart)) {
      isLabelAffected = true;
    }
  }
  if (isLabelAffected) {
    fireEvent21(chart, "afterHideAllOverlappingLabels");
  }
}
function compose(ChartClass) {
  const chartProto = ChartClass.prototype;
  if (!chartProto.hideOverlappingLabels) {
    chartProto.hideOverlappingLabels = chartHideOverlappingLabels;
    addEvent17(ChartClass, "render", onChartRender2);
  }
}
function hideOrShow(label, chart) {
  let complete, newOpacity, isLabelAffected = false;
  if (label) {
    newOpacity = label.newOpacity;
    if (label.oldOpacity !== newOpacity) {
      if (label.hasClass("highcharts-data-label")) {
        label[newOpacity ? "removeClass" : "addClass"]("highcharts-data-label-hidden");
        complete = function() {
          if (!chart.styledMode) {
            label.css({
              pointerEvents: newOpacity ? "auto" : "none"
            });
          }
        };
        isLabelAffected = true;
        label[label.isOld ? "animate" : "attr"]({ opacity: newOpacity }, void 0, complete);
        fireEvent21(chart, "afterHideOverlappingLabel");
      } else {
        label.attr({
          opacity: newOpacity
        });
      }
    }
    label.isOld = true;
  }
  return isLabelAffected;
}
function onChartRender2() {
  const chart = this;
  let labels = [];
  for (const collector of chart.labelCollectors || []) {
    labels = labels.concat(collector());
  }
  for (const yAxis2 of chart.yAxis || []) {
    if (yAxis2.stacking && yAxis2.options.stackLabels && !yAxis2.options.stackLabels.allowOverlap) {
      objectEach20(yAxis2.stacking.stacks, (stack) => {
        objectEach20(stack, (stackItem) => {
          if (stackItem.label) {
            labels.push(stackItem.label);
          }
        });
      });
    }
  }
  for (const series of chart.series || []) {
    if (series.visible && series.hasDataLabels?.()) {
      const push = (points) => {
        for (const point of points) {
          if (point.visible) {
            (point.dataLabels || []).forEach((label) => {
              const options2 = label.options || {};
              label.labelrank = pick31(options2.labelrank, point.labelrank, point.shapeArgs?.height);
              if (
                // #13449
                options2.allowOverlap ?? // Pie labels outside have a separate placement
                // logic, skip the overlap logic
                Number(options2.distance) > 0
              ) {
                label.oldOpacity = label.opacity;
                label.newOpacity = 1;
                hideOrShow(label, chart);
              } else {
                labels.push(label);
              }
            });
          }
        }
      };
      push(series.nodes || []);
      push(series.points);
    }
  }
  this.hideOverlappingLabels(labels);
}
var OverlappingDataLabels = {
  compose
};
var OverlappingDataLabels_default = OverlappingDataLabels;

// node_modules/highcharts/es-modules/Extensions/BorderRadius.js
var { defaultOptions: defaultOptions9 } = Defaults_default;
var { noop: noop5 } = Globals_default;
var { addEvent: addEvent18, extend: extend28, isObject: isObject12, merge: merge30, relativeLength: relativeLength8 } = Utilities_default;
var defaultBorderRadiusOptions = {
  radius: 0,
  scope: "stack",
  where: void 0
};
var oldArc = noop5;
var oldRoundedRect = noop5;
function applyBorderRadius(path, i, r) {
  const a = path[i];
  let b = path[i + 1];
  if (b[0] === "Z") {
    b = path[0];
  }
  let line2, arc3, fromLineToArc;
  if ((a[0] === "M" || a[0] === "L") && b[0] === "A") {
    line2 = a;
    arc3 = b;
    fromLineToArc = true;
  } else if (a[0] === "A" && (b[0] === "M" || b[0] === "L")) {
    line2 = b;
    arc3 = a;
  }
  if (line2 && arc3 && arc3.params) {
    const bigR = arc3[1], clockwise = arc3[5], params = arc3.params, { start, end, cx, cy } = params;
    const relativeR = clockwise ? bigR - r : bigR + r, angleOfBorderRadius = relativeR ? Math.asin(r / relativeR) : 0, angleOffset = clockwise ? angleOfBorderRadius : -angleOfBorderRadius, distanceBigCenterToStartArc = Math.cos(angleOfBorderRadius) * relativeR;
    if (fromLineToArc) {
      params.start = start + angleOffset;
      line2[1] = cx + distanceBigCenterToStartArc * Math.cos(start);
      line2[2] = cy + distanceBigCenterToStartArc * Math.sin(start);
      path.splice(i + 1, 0, [
        "A",
        r,
        r,
        0,
        // Slanting,
        0,
        // Long arc
        1,
        // Clockwise
        cx + bigR * Math.cos(params.start),
        cy + bigR * Math.sin(params.start)
      ]);
    } else {
      params.end = end - angleOffset;
      arc3[6] = cx + bigR * Math.cos(params.end);
      arc3[7] = cy + bigR * Math.sin(params.end);
      path.splice(i + 1, 0, [
        "A",
        r,
        r,
        0,
        0,
        1,
        cx + distanceBigCenterToStartArc * Math.cos(end),
        cy + distanceBigCenterToStartArc * Math.sin(end)
      ]);
    }
    arc3[4] = Math.abs(params.end - params.start) < Math.PI ? 0 : 1;
  }
}
function arc2(x, y, w, h, options2 = {}) {
  const path = oldArc(x, y, w, h, options2), { innerR = 0, r = w, start = 0, end = 0 } = options2;
  if (options2.open || !options2.borderRadius) {
    return path;
  }
  const alpha = end - start, sinHalfAlpha = Math.sin(alpha / 2), borderRadius = Math.max(Math.min(
    relativeLength8(options2.borderRadius || 0, r - innerR),
    // Cap to half the sector radius
    (r - innerR) / 2,
    // For smaller pie slices, cap to the largest small circle that
    // can be fitted within the sector
    r * sinHalfAlpha / (1 + sinHalfAlpha)
  ), 0), innerBorderRadius = Math.min(borderRadius, 2 * (alpha / Math.PI) * innerR);
  let i = path.length - 1;
  while (i--) {
    applyBorderRadius(path, i, i > 1 ? innerBorderRadius : borderRadius);
  }
  return path;
}
function seriesOnAfterColumnTranslate() {
  if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
    const { options: options2, yAxis: yAxis2 } = this, percent = options2.stacking === "percent", seriesDefault = defaultOptions9.plotOptions?.[this.type]?.borderRadius, borderRadius = optionsToObject(options2.borderRadius, isObject12(seriesDefault) ? seriesDefault : {}), reversed = yAxis2.options.reversed;
    for (const point of this.points) {
      const { shapeArgs } = point;
      if (point.shapeType === "roundedRect" && shapeArgs) {
        const { width = 0, height = 0, y = 0 } = shapeArgs;
        let brBoxY = y, brBoxHeight = height;
        if (borderRadius.scope === "stack" && point.stackTotal) {
          const stackEnd = yAxis2.translate(percent ? 100 : point.stackTotal, false, true, false, true), stackThreshold = yAxis2.translate(options2.threshold || 0, false, true, false, true), box = this.crispCol(0, Math.min(stackEnd, stackThreshold), 0, Math.abs(stackEnd - stackThreshold));
          brBoxY = box.y;
          brBoxHeight = box.height;
        }
        const flip = (point.negative ? -1 : 1) * (reversed ? -1 : 1) === -1;
        let where = borderRadius.where;
        if (!where && this.is("waterfall") && Math.abs((point.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth) {
          where = "all";
        }
        if (!where) {
          where = "end";
        }
        const r = Math.min(
          relativeLength8(borderRadius.radius, width),
          width / 2,
          // Cap to the height, but not if where is `end`
          where === "all" ? height / 2 : Infinity
        ) || 0;
        if (where === "end") {
          if (flip) {
            brBoxY -= r;
            brBoxHeight += r;
          } else {
            brBoxHeight += r;
          }
        }
        extend28(shapeArgs, { brBoxHeight, brBoxY, r });
      }
    }
  }
}
function compose2(SeriesClass, SVGElementClass, SVGRendererClass) {
  const PieSeriesClass = SeriesClass.types.pie;
  if (!SVGElementClass.symbolCustomAttribs.includes("borderRadius")) {
    const symbols3 = SVGRendererClass.prototype.symbols;
    addEvent18(SeriesClass, "afterColumnTranslate", seriesOnAfterColumnTranslate, {
      // After columnrange and polar column modifications
      order: 9
    });
    addEvent18(PieSeriesClass, "afterTranslate", pieSeriesOnAfterTranslate);
    SVGElementClass.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY");
    oldArc = symbols3.arc;
    oldRoundedRect = symbols3.roundedRect;
    symbols3.arc = arc2;
    symbols3.roundedRect = roundedRect2;
  }
}
function optionsToObject(options2, seriesBROptions) {
  if (!isObject12(options2)) {
    options2 = { radius: options2 || 0 };
  }
  return merge30(defaultBorderRadiusOptions, seriesBROptions, options2);
}
function pieSeriesOnAfterTranslate() {
  const borderRadius = optionsToObject(this.options.borderRadius);
  for (const point of this.points) {
    const shapeArgs = point.shapeArgs;
    if (shapeArgs) {
      shapeArgs.borderRadius = relativeLength8(borderRadius.radius, (shapeArgs.r || 0) - (shapeArgs.innerR || 0));
    }
  }
}
function roundedRect2(x, y, width, height, options2 = {}) {
  const path = oldRoundedRect(x, y, width, height, options2), { r = 0, brBoxHeight = height, brBoxY = y } = options2, brOffsetTop = y - brBoxY, brOffsetBtm = brBoxY + brBoxHeight - (y + height), rTop = brOffsetTop - r > -0.1 ? 0 : r, rBtm = brOffsetBtm - r > -0.1 ? 0 : r, cutTop = Math.max(rTop && brOffsetTop, 0), cutBtm = Math.max(rBtm && brOffsetBtm, 0);
  const a = [x + rTop, y], b = [x + width - rTop, y], c = [x + width, y + rTop], d = [
    x + width,
    y + height - rBtm
  ], e = [
    x + width - rBtm,
    y + height
  ], f = [x + rBtm, y + height], g = [x, y + height - rBtm], h = [x, y + rTop];
  const applyPythagoras = (r2, altitude) => Math.sqrt(Math.pow(r2, 2) - Math.pow(altitude, 2));
  if (cutTop) {
    const base = applyPythagoras(rTop, rTop - cutTop);
    a[0] -= base;
    b[0] += base;
    c[1] = h[1] = y + rTop - cutTop;
  }
  if (height < rTop - cutTop) {
    const base = applyPythagoras(rTop, rTop - cutTop - height);
    c[0] = d[0] = x + width - rTop + base;
    e[0] = Math.min(c[0], e[0]);
    f[0] = Math.max(d[0], f[0]);
    g[0] = h[0] = x + rTop - base;
    c[1] = h[1] = y + height;
  }
  if (cutBtm) {
    const base = applyPythagoras(rBtm, rBtm - cutBtm);
    e[0] += base;
    f[0] -= base;
    d[1] = g[1] = y + height - rBtm + cutBtm;
  }
  if (height < rBtm - cutBtm) {
    const base = applyPythagoras(rBtm, rBtm - cutBtm - height);
    c[0] = d[0] = x + width - rBtm + base;
    b[0] = Math.min(c[0], b[0]);
    a[0] = Math.max(d[0], a[0]);
    g[0] = h[0] = x + rBtm - base;
    d[1] = g[1] = y;
  }
  path.length = 0;
  path.push(
    ["M", ...a],
    // Top side
    ["L", ...b],
    // Top right corner
    ["A", rTop, rTop, 0, 0, 1, ...c],
    // Right side
    ["L", ...d],
    // Bottom right corner
    ["A", rBtm, rBtm, 0, 0, 1, ...e],
    // Bottom side
    ["L", ...f],
    // Bottom left corner
    ["A", rBtm, rBtm, 0, 0, 1, ...g],
    // Left side
    ["L", ...h],
    // Top left corner
    ["A", rTop, rTop, 0, 0, 1, ...a],
    ["Z"]
  );
  return path;
}
var BorderRadius = {
  compose: compose2,
  optionsToObject
};
var BorderRadius_default = BorderRadius;

// node_modules/highcharts/es-modules/Core/Responsive.js
var { diffObjects: diffObjects4, extend: extend29, find: find6, merge: merge31, pick: pick32, uniqueKey: uniqueKey7 } = Utilities_default;
var Responsive;
(function(Responsive2) {
  function compose27(ChartClass) {
    const chartProto = ChartClass.prototype;
    if (!chartProto.matchResponsiveRule) {
      extend29(chartProto, {
        matchResponsiveRule,
        setResponsive
      });
    }
    return ChartClass;
  }
  Responsive2.compose = compose27;
  function matchResponsiveRule(rule, matches) {
    const condition = rule.condition, fn = condition.callback || function() {
      return this.chartWidth <= pick32(condition.maxWidth, Number.MAX_VALUE) && this.chartHeight <= pick32(condition.maxHeight, Number.MAX_VALUE) && this.chartWidth >= pick32(condition.minWidth, 0) && this.chartHeight >= pick32(condition.minHeight, 0);
    };
    if (fn.call(this)) {
      matches.push(rule._id);
    }
  }
  function setResponsive(redraw, reset) {
    const options2 = this.options.responsive, currentResponsive = this.currentResponsive;
    let ruleIds = [], undoOptions;
    if (!reset && options2 && options2.rules) {
      options2.rules.forEach((rule) => {
        if (typeof rule._id === "undefined") {
          rule._id = uniqueKey7();
        }
        this.matchResponsiveRule(
          rule,
          ruleIds
          /* , redraw */
        );
      }, this);
    }
    const mergedOptions = merge31(...ruleIds.map((ruleId) => find6(options2?.rules || [], (rule) => rule._id === ruleId)).map((rule) => rule?.chartOptions));
    mergedOptions.isResponsiveOptions = true;
    ruleIds = ruleIds.toString() || void 0;
    const currentRuleIds = currentResponsive?.ruleIds;
    if (ruleIds !== currentRuleIds) {
      if (currentResponsive) {
        this.currentResponsive = void 0;
        this.updatingResponsive = true;
        this.update(currentResponsive.undoOptions, redraw, true);
        this.updatingResponsive = false;
      }
      if (ruleIds) {
        undoOptions = diffObjects4(mergedOptions, this.options, true, this.collectionsWithUpdate);
        undoOptions.isResponsiveOptions = true;
        this.currentResponsive = {
          ruleIds,
          mergedOptions,
          undoOptions
        };
        if (!this.updatingResponsive) {
          this.update(mergedOptions, redraw, true);
        }
      } else {
        this.currentResponsive = void 0;
      }
    }
  }
})(Responsive || (Responsive = {}));
var Responsive_default = Responsive;

// node_modules/highcharts/es-modules/masters/highcharts.src.js
var G = Globals_default;
G.AST = AST_default;
G.Axis = Axis_default;
G.Chart = Chart_default;
G.Color = Color_default;
G.DataLabel = DataLabel_default;
G.DataTableCore = DataTableCore_default;
G.Fx = Fx_default;
G.HTMLElement = HTMLElement_default;
G.Legend = Legend_default;
G.LegendSymbol = LegendSymbol_default;
G.OverlappingDataLabels = G.OverlappingDataLabels || OverlappingDataLabels_default;
G.PlotLineOrBand = PlotLineOrBand_default;
G.Point = Point_default;
G.Pointer = Pointer_default;
G.RendererRegistry = RendererRegistry_default;
G.Series = Series_default;
G.SeriesRegistry = SeriesRegistry_default;
G.StackItem = StackItem_default;
G.SVGElement = SVGElement_default;
G.SVGRenderer = SVGRenderer_default;
G.Templating = Templating_default;
G.Tick = Tick_default;
G.Time = Time_default;
G.Tooltip = Tooltip_default;
G.animate = AnimationUtilities_default.animate;
G.animObject = AnimationUtilities_default.animObject;
G.chart = Chart_default.chart;
G.color = Color_default.parse;
G.dateFormat = Templating_default.dateFormat;
G.defaultOptions = Defaults_default.defaultOptions;
G.distribute = RendererUtilities_default.distribute;
G.format = Templating_default.format;
G.getDeferredAnimation = AnimationUtilities_default.getDeferredAnimation;
G.getOptions = Defaults_default.getOptions;
G.numberFormat = Templating_default.numberFormat;
G.seriesType = SeriesRegistry_default.seriesType;
G.setAnimation = AnimationUtilities_default.setAnimation;
G.setOptions = Defaults_default.setOptions;
G.stop = AnimationUtilities_default.stop;
G.time = Defaults_default.defaultTime;
G.timers = Fx_default.timers;
BorderRadius_default.compose(G.Series, G.SVGElement, G.SVGRenderer);
ColumnDataLabel_default.compose(G.Series.types.column);
DataLabel_default.compose(G.Series);
DateTimeAxis_default.compose(G.Axis);
HTMLElement_default.compose(G.SVGRenderer);
Legend_default.compose(G.Chart);
LogarithmicAxis_default.compose(G.Axis);
OverlappingDataLabels_default.compose(G.Chart);
PieDataLabel_default.compose(G.Series.types.pie);
PlotLineOrBand_default.compose(G.Chart, G.Axis);
Pointer_default.compose(G.Chart);
Responsive_default.compose(G.Chart);
ScrollablePlotArea_default.compose(G.Axis, G.Chart, G.Series);
StackingAxis_default.compose(G.Axis, G.Chart, G.Series);
Tooltip_default.compose(G.Pointer);
Utilities_default.extend(G, Utilities_default);
var highcharts_src_default = G;

// node_modules/highcharts/es-modules/Series/DataModifyComposition.js
var { tooltipFormatter: pointTooltipFormatter } = Point_default.prototype;
var { addEvent: addEvent19, arrayMax: arrayMax6, arrayMin: arrayMin5, correctFloat: correctFloat6, defined: defined24, isArray: isArray13, isNumber: isNumber26, isString: isString14, pick: pick33 } = Utilities_default;
var DataModifyComposition;
(function(DataModifyComposition2) {
  function compose27(SeriesClass, AxisClass, PointClass) {
    const axisProto = AxisClass.prototype, pointProto2 = PointClass.prototype, seriesProto7 = SeriesClass.prototype;
    if (!seriesProto7.setCompare) {
      seriesProto7.setCompare = seriesSetCompare;
      seriesProto7.setCumulative = seriesSetCumulative;
      addEvent19(SeriesClass, "afterInit", afterInit);
      addEvent19(SeriesClass, "afterGetExtremes", afterGetExtremes);
      addEvent19(SeriesClass, "afterProcessData", afterProcessData);
    }
    if (!axisProto.setCompare) {
      axisProto.setCompare = axisSetCompare;
      axisProto.setModifier = setModifier;
      axisProto.setCumulative = axisSetCumulative;
      pointProto2.tooltipFormatter = tooltipFormatter;
    }
    return SeriesClass;
  }
  DataModifyComposition2.compose = compose27;
  function setModifier(mode, modeState, redraw) {
    if (!this.isXAxis) {
      this.series.forEach(function(series) {
        if (mode === "compare" && typeof modeState !== "boolean") {
          series.setCompare(modeState, false);
        } else if (mode === "cumulative" && !isString14(modeState)) {
          series.setCumulative(modeState, false);
        }
      });
      if (pick33(redraw, true)) {
        this.chart.redraw();
      }
    }
  }
  function tooltipFormatter(pointFormat) {
    const point = this, { numberFormatter } = point.series.chart, replace = function(value) {
      pointFormat = pointFormat.replace("{point." + value + "}", (point[value] > 0 && value === "change" ? "+" : "") + numberFormatter(point[value], pick33(point.series.tooltipOptions.changeDecimals, 2)));
    };
    if (defined24(point.change)) {
      replace("change");
    }
    if (defined24(point.cumulativeSum)) {
      replace("cumulativeSum");
    }
    return pointTooltipFormatter.apply(this, [pointFormat]);
  }
  function afterInit() {
    const compare = this.options.compare;
    let dataModify;
    if (compare === "percent" || compare === "value" || this.options.cumulative) {
      dataModify = new Additions(this);
      if (compare === "percent" || compare === "value") {
        dataModify.initCompare(compare);
      } else {
        dataModify.initCumulative();
      }
    }
    this.dataModify = dataModify;
  }
  function afterGetExtremes(e) {
    const dataExtremes = e.dataExtremes, activeYData = dataExtremes.activeYData;
    if (this.dataModify && dataExtremes) {
      let extremes;
      if (this.options.compare) {
        extremes = [
          this.dataModify.modifyValue(dataExtremes.dataMin),
          this.dataModify.modifyValue(dataExtremes.dataMax)
        ];
      } else if (this.options.cumulative && isArray13(activeYData) && // If only one y visible, sum doesn't change
      // so no need to change extremes
      activeYData.length >= 2) {
        extremes = Additions.getCumulativeExtremes(activeYData);
      }
      if (extremes) {
        dataExtremes.dataMin = arrayMin5(extremes);
        dataExtremes.dataMax = arrayMax6(extremes);
      }
    }
  }
  function seriesSetCompare(compare, redraw) {
    this.options.compare = this.userOptions.compare = compare;
    this.update({}, pick33(redraw, true));
    if (this.dataModify && (compare === "value" || compare === "percent")) {
      this.dataModify.initCompare(compare);
    } else {
      this.points.forEach((point) => {
        delete point.change;
      });
    }
  }
  function afterProcessData() {
    const series = this, compareColumn = this.getColumn(series.pointArrayMap && (series.options.pointValKey || series.pointValKey) || "y", true);
    if (series.xAxis && // Not pies
    compareColumn.length && series.dataModify) {
      const processedXData = series.getColumn("x", true), length = series.dataTable.rowCount, compareStart = series.options.compareStart === true ? 0 : 1;
      for (let i = 0; i < length - compareStart; i++) {
        const compareValue = compareColumn[i];
        if (isNumber26(compareValue) && compareValue !== 0 && processedXData[i + compareStart] >= (series.xAxis.min || 0)) {
          series.dataModify.compareValue = compareValue;
          break;
        }
      }
    }
  }
  function axisSetCompare(compare, redraw) {
    this.setModifier("compare", compare, redraw);
  }
  function seriesSetCumulative(cumulative, redraw) {
    cumulative = pick33(cumulative, false);
    this.options.cumulative = this.userOptions.cumulative = cumulative;
    this.update({}, pick33(redraw, true));
    if (this.dataModify) {
      this.dataModify.initCumulative();
    } else {
      this.points.forEach((point) => {
        delete point.cumulativeSum;
      });
    }
  }
  function axisSetCumulative(cumulative, redraw) {
    this.setModifier("cumulative", cumulative, redraw);
  }
  class Additions {
    /* *
     *
     *  Constructors
     *
     * */
    /**
     * @private
     */
    constructor(series) {
      this.series = series;
    }
    /* *
    *
    *  Functions
    *
    * */
    /**
     * @private
     */
    modifyValue() {
      return 0;
    }
    /**
     * @ignore
     * @function Highcharts.Series#getCumulativeExtremes
     *
     * @param {Array} [activeYData]
     *        An array cointaining all the points' y values
     *        in a visible range.
     */
    static getCumulativeExtremes(activeYData) {
      let cumulativeDataMin = Infinity, cumulativeDataMax = -Infinity;
      activeYData.reduce((prev, cur) => {
        const sum2 = prev + cur;
        cumulativeDataMin = Math.min(cumulativeDataMin, sum2, prev);
        cumulativeDataMax = Math.max(cumulativeDataMax, sum2, prev);
        return sum2;
      });
      return [cumulativeDataMin, cumulativeDataMax];
    }
    /**
     * @ignore
     * @function Highcharts.Series#initCompare
     *
     * @param {string} [compare]
     *        Can be one of `"percent"` or `"value"`.
     */
    initCompare(compare) {
      this.modifyValue = function(value, index) {
        if (value === null) {
          value = 0;
        }
        const compareValue = this.compareValue;
        if (typeof value !== "undefined" && typeof compareValue !== "undefined") {
          if (compare === "value") {
            value -= compareValue;
          } else {
            const compareBase = this.series.options.compareBase;
            value = 100 * (value / compareValue) - (compareBase === 100 ? 0 : 100);
          }
          if (typeof index !== "undefined") {
            const point = this.series.points[index];
            if (point) {
              point.change = value;
            }
          }
          return value;
        }
        return 0;
      };
    }
    /**
     * @ignore
     * @function Highcharts.Series#initCumulative
     */
    initCumulative() {
      this.modifyValue = function(value, index) {
        if (value === null) {
          value = 0;
        }
        if (value !== void 0 && index !== void 0) {
          const prevPoint = index > 0 ? this.series.points[index - 1] : null;
          if (prevPoint && prevPoint.cumulativeSum) {
            value = correctFloat6(prevPoint.cumulativeSum + value);
          }
          const point = this.series.points[index];
          const cumulativeStart = point.series.options.cumulativeStart, withinRange = point.x <= this.series.xAxis.max && point.x >= this.series.xAxis.min;
          if (point) {
            if (!cumulativeStart || withinRange) {
              point.cumulativeSum = value;
            } else {
              point.cumulativeSum = void 0;
            }
          }
          return value;
        }
        return 0;
      };
    }
  }
  DataModifyComposition2.Additions = Additions;
})(DataModifyComposition || (DataModifyComposition = {}));
var DataModifyComposition_default = DataModifyComposition;

// node_modules/highcharts/es-modules/Stock/Navigator/ChartNavigatorComposition.js
var { isTouchDevice: isTouchDevice3 } = Globals_default;
var { addEvent: addEvent20, merge: merge32, pick: pick34 } = Utilities_default;
var composedMembers = [];
var NavigatorConstructor;
function compose3(ChartClass, NavigatorClass) {
  if (Utilities_default.pushUnique(composedMembers, ChartClass)) {
    const chartProto = ChartClass.prototype;
    NavigatorConstructor = NavigatorClass;
    chartProto.callbacks.push(onChartCallback);
    addEvent20(ChartClass, "afterAddSeries", onChartAfterAddSeries);
    addEvent20(ChartClass, "afterSetChartSize", onChartAfterSetChartSize);
    addEvent20(ChartClass, "afterUpdate", onChartAfterUpdate);
    addEvent20(ChartClass, "beforeRender", onChartBeforeRender);
    addEvent20(ChartClass, "beforeShowResetZoom", onChartBeforeShowResetZoom);
    addEvent20(ChartClass, "update", onChartUpdate);
  }
}
function onChartAfterAddSeries() {
  if (this.navigator) {
    this.navigator.setBaseSeries(null, false);
  }
}
function onChartAfterSetChartSize() {
  const legend = this.legend, navigator = this.navigator;
  let legendOptions, xAxis2, yAxis2;
  if (navigator) {
    legendOptions = legend && legend.options;
    xAxis2 = navigator.xAxis;
    yAxis2 = navigator.yAxis;
    const { scrollbarHeight, scrollButtonSize } = navigator;
    if (this.inverted) {
      navigator.left = navigator.opposite ? this.chartWidth - scrollbarHeight - navigator.height : this.spacing[3] + scrollbarHeight;
      navigator.top = this.plotTop + scrollButtonSize;
    } else {
      navigator.left = pick34(xAxis2.left, this.plotLeft + scrollButtonSize);
      navigator.top = navigator.navigatorOptions.top || this.chartHeight - navigator.height - scrollbarHeight - (this.scrollbar?.options.margin || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (legendOptions && legendOptions.verticalAlign === "bottom" && legendOptions.layout !== "proximate" && // #13392
      legendOptions.enabled && !legendOptions.floating ? legend.legendHeight + pick34(legendOptions.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0);
    }
    if (xAxis2 && yAxis2) {
      if (this.inverted) {
        xAxis2.options.left = yAxis2.options.left = navigator.left;
      } else {
        xAxis2.options.top = yAxis2.options.top = navigator.top;
      }
      xAxis2.setAxisSize();
      yAxis2.setAxisSize();
    }
  }
}
function onChartAfterUpdate(event) {
  if (!this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled)) {
    this.scroller = this.navigator = new NavigatorConstructor(this);
    if (pick34(event.redraw, true)) {
      this.redraw(event.animation);
    }
  }
}
function onChartBeforeRender() {
  const options2 = this.options;
  if (options2.navigator.enabled || options2.scrollbar.enabled) {
    this.scroller = this.navigator = new NavigatorConstructor(this);
  }
}
function onChartBeforeShowResetZoom() {
  const chartOptions = this.options, navigator = chartOptions.navigator, rangeSelector2 = chartOptions.rangeSelector;
  if ((navigator && navigator.enabled || rangeSelector2 && rangeSelector2.enabled) && (!isTouchDevice3 && this.zooming.type === "x" || isTouchDevice3 && this.zooming.pinchType === "x")) {
    return false;
  }
}
function onChartCallback(chart) {
  const navigator = chart.navigator;
  if (navigator && chart.xAxis[0]) {
    const extremes = chart.xAxis[0].getExtremes();
    navigator.render(extremes.min, extremes.max);
  }
}
function onChartUpdate(e) {
  const navigatorOptions = e.options.navigator || {}, scrollbarOptions = e.options.scrollbar || {};
  if (!this.navigator && !this.scroller && (navigatorOptions.enabled || scrollbarOptions.enabled)) {
    merge32(true, this.options.navigator, navigatorOptions);
    merge32(true, this.options.scrollbar, scrollbarOptions);
    delete e.options.navigator;
    delete e.options.scrollbar;
  }
}
var ChartNavigatorComposition = {
  compose: compose3
};
var ChartNavigatorComposition_default = ChartNavigatorComposition;

// node_modules/highcharts/es-modules/Core/Axis/NavigatorAxisComposition.js
var { isTouchDevice: isTouchDevice4 } = Globals_default;
var { addEvent: addEvent21, correctFloat: correctFloat7, defined: defined25, isNumber: isNumber27, pick: pick35 } = Utilities_default;
function onAxisInit2() {
  const axis = this;
  if (!axis.navigatorAxis) {
    axis.navigatorAxis = new NavigatorAxisAdditions(axis);
  }
}
function onAxisSetExtremes(e) {
  const axis = this, chart = axis.chart, chartOptions = chart.options, navigator = chartOptions.navigator, navigatorAxis = axis.navigatorAxis, pinchType = chart.zooming.pinchType, rangeSelector2 = chartOptions.rangeSelector, zoomType = chart.zooming.type;
  let zoomed;
  if (axis.isXAxis && (navigator?.enabled || rangeSelector2?.enabled)) {
    if (zoomType === "y" && e.trigger === "zoom") {
      zoomed = false;
    } else if ((e.trigger === "zoom" && zoomType === "xy" || isTouchDevice4 && pinchType === "xy") && axis.options.range) {
      const previousZoom = navigatorAxis.previousZoom;
      if (defined25(e.min)) {
        navigatorAxis.previousZoom = [axis.min, axis.max];
      } else if (previousZoom) {
        e.min = previousZoom[0];
        e.max = previousZoom[1];
        navigatorAxis.previousZoom = void 0;
      }
    }
  }
  if (typeof zoomed !== "undefined") {
    e.preventDefault();
  }
}
var NavigatorAxisAdditions = class {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * @private
   */
  static compose(AxisClass) {
    if (!AxisClass.keepProps.includes("navigatorAxis")) {
      AxisClass.keepProps.push("navigatorAxis");
      addEvent21(AxisClass, "init", onAxisInit2);
      addEvent21(AxisClass, "setExtremes", onAxisSetExtremes);
    }
  }
  /* *
   *
   *  Constructors
   *
   * */
  constructor(axis) {
    this.axis = axis;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  destroy() {
    this.axis = void 0;
  }
  /**
   * Add logic to normalize the zoomed range in order to preserve the pressed
   * state of range selector buttons
   *
   * @private
   * @function Highcharts.Axis#toFixedRange
   */
  toFixedRange(pxMin, pxMax, fixedMin, fixedMax) {
    const axis = this.axis, halfPointRange = (axis.pointRange || 0) / 2;
    let newMin = pick35(fixedMin, axis.translate(pxMin, true, !axis.horiz)), newMax = pick35(fixedMax, axis.translate(pxMax, true, !axis.horiz));
    if (!defined25(fixedMin)) {
      newMin = correctFloat7(newMin + halfPointRange);
    }
    if (!defined25(fixedMax)) {
      newMax = correctFloat7(newMax - halfPointRange);
    }
    if (!isNumber27(newMin) || !isNumber27(newMax)) {
      newMin = newMax = void 0;
    }
    return {
      min: newMin,
      max: newMax
    };
  }
};
var NavigatorAxisComposition_default = NavigatorAxisAdditions;

// node_modules/highcharts/es-modules/Stock/Navigator/NavigatorDefaults.js
var { parse: color4 } = Color_default;
var { seriesTypes: seriesTypes3 } = SeriesRegistry_default;
var NavigatorDefaults = {
  /**
   * Whether the navigator and scrollbar should adapt to updated data
   * in the base X axis. When loading data async, as in the demo below,
   * this should be `false`. Otherwise new data will trigger navigator
   * redraw, which will cause unwanted looping. In the demo below, the
   * data in the navigator is set only once. On navigating, only the main
   * chart content is updated.
   *
   * @sample {highstock} stock/demo/lazy-loading/
   *         Set to false with async data loading
   *
   * @type      {boolean}
   * @default   true
   * @apioption navigator.adaptToUpdatedData
   */
  /**
   * An integer identifying the index to use for the base series, or a
   * string representing the id of the series.
   *
   * **Note**: As of Highcharts 5.0, this is now a deprecated option.
   * Prefer [series.showInNavigator](#plotOptions.series.showInNavigator).
   *
   * @see [series.showInNavigator](#plotOptions.series.showInNavigator)
   *
   * @deprecated
   * @type      {number|string}
   * @default   0
   * @apioption navigator.baseSeries
   */
  /**
   * Enable or disable the navigator.
   *
   * @sample {highstock} stock/navigator/enabled/
   *         Disable the navigator
   *
   * @type      {boolean}
   * @default   true
   * @apioption navigator.enabled
   */
  /**
   * When the chart is inverted, whether to draw the navigator on the
   * opposite side.
   *
   * @type      {boolean}
   * @default   false
   * @since     5.0.8
   * @apioption navigator.opposite
   */
  /**
   * The height of the navigator.
   *
   * @sample {highstock} stock/navigator/height/
   *         A higher navigator
   */
  height: 40,
  /**
   * The distance from the nearest element, the X axis or X axis labels.
   *
   * @sample {highstock} stock/navigator/margin/
   *         A margin of 2 draws the navigator closer to the X axis labels
   */
  margin: 22,
  /**
   * Whether the mask should be inside the range marking the zoomed
   * range, or outside. In Highcharts Stock 1.x it was always `false`.
   *
   * @sample {highstock} stock/demo/maskinside-false/
   *         False, mask outside
   *
   * @since   2.0
   */
  maskInside: true,
  /**
   * Options for the handles for dragging the zoomed area.
   *
   * @sample {highstock} stock/navigator/handles/
   *         Colored handles
   */
  handles: {
    /**
     * Width for handles.
     *
     * @sample {highstock} stock/navigator/styled-handles/
     *         Styled handles
     *
     * @since   6.0.0
     */
    width: 7,
    /**
     * Border radius of the handles.
     *
     * @sample {highstock} stock/navigator/handles-border-radius/
     *      Border radius on the navigator handles.
     *
     * @since 11.4.2
     */
    borderRadius: 0,
    /**
     * Height for handles.
     *
     * @sample {highstock} stock/navigator/styled-handles/
     *         Styled handles
     *
     * @since   6.0.0
     */
    height: 15,
    /**
     * Array to define shapes of handles. 0-index for left, 1-index for
     * right.
     *
     * Additionally, the URL to a graphic can be given on this form:
     * `url(graphic.png)`. Note that for the image to be applied to
     * exported charts, its URL needs to be accessible by the export
     * server.
     *
     * Custom callbacks for symbol path generation can also be added to
     * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
     * used by its method name, as shown in the demo.
     *
     * @sample {highstock} stock/navigator/styled-handles/
     *         Styled handles
     *
     * @type    {Array<string>}
     * @default ["navigator-handle", "navigator-handle"]
     * @since   6.0.0
     */
    symbols: ["navigator-handle", "navigator-handle"],
    /**
     * Allows to enable/disable handles.
     *
     * @since   6.0.0
     */
    enabled: true,
    /**
     * The width for the handle border and the stripes inside.
     *
     * @sample {highstock} stock/navigator/styled-handles/
     *         Styled handles
     *
     * @since     6.0.0
     * @apioption navigator.handles.lineWidth
     */
    lineWidth: 1,
    /**
     * The fill for the handle.
     *
     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    backgroundColor: "#f2f2f2",
    /**
     * The stroke for the handle border and the stripes inside.
     *
     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    borderColor: "#999999"
    /* Palette.neutralColor40 */
  },
  /**
   * The color of the mask covering the areas of the navigator series
   * that are currently not visible in the main series. The default
   * color is bluish with an opacity of 0.3 to see the series below.
   *
   * @see In styled mode, the mask is styled with the
   *      `.highcharts-navigator-mask` and
   *      `.highcharts-navigator-mask-inside` classes.
   *
   * @sample {highstock} stock/navigator/maskfill/
   *         Blue, semi transparent mask
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default rgba(102,133,194,0.3)
   */
  maskFill: color4(
    "#667aff"
    /* Palette.highlightColor60 */
  ).setOpacity(0.3).get(),
  /**
   * The color of the line marking the currently zoomed area in the
   * navigator.
   *
   * @sample {highstock} stock/navigator/outline/
   *         2px blue outline
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default #cccccc
   */
  outlineColor: "#999999",
  /**
   * The width of the line marking the currently zoomed area in the
   * navigator.
   *
   * @see In styled mode, the outline stroke width is set with the
   *      `.highcharts-navigator-outline` class.
   *
   * @sample {highstock} stock/navigator/outline/
   *         2px blue outline
   *
   * @type    {number}
   */
  outlineWidth: 1,
  /**
   * Options for the navigator series. Available options are the same
   * as any series, documented at [plotOptions](#plotOptions.series)
   * and [series](#series).
   *
   * Unless data is explicitly defined on navigator.series, the data
   * is borrowed from the first series in the chart.
   *
   * Default series options for the navigator series are:
   * ```js
   * series: {
   *     type: 'areaspline',
   *     fillOpacity: 0.05,
   *     dataGrouping: {
   *         smoothed: true
   *     },
   *     lineWidth: 1,
   *     marker: {
   *         enabled: false
   *     }
   * }
   * ```
   *
   * @see In styled mode, the navigator series is styled with the
   *      `.highcharts-navigator-series` class.
   *
   * @sample {highstock} stock/navigator/series-data/
   *         Using a separate data set for the navigator
   * @sample {highstock} stock/navigator/series/
   *         A green navigator series
   *
   * @type {*|Array<*>|Highcharts.SeriesOptionsType|Array<Highcharts.SeriesOptionsType>}
   */
  series: {
    /**
     * The type of the navigator series.
     *
     * Heads up:
     * In column-type navigator, zooming is limited to at least one
     * point with its `pointRange`.
     *
     * @sample {highstock} stock/navigator/column/
     *         Column type navigator
     *
     * @type    {string}
     * @default {highstock} `areaspline` if defined, otherwise `line`
     * @default {gantt} gantt
     */
    type: typeof seriesTypes3.areaspline === "undefined" ? "line" : "areaspline",
    /**
     * The fill opacity of the navigator series.
     */
    fillOpacity: 0.05,
    /**
     * The pixel line width of the navigator series.
     */
    lineWidth: 1,
    /**
     * @ignore-option
     */
    compare: null,
    /**
     * @ignore-option
     */
    sonification: {
      enabled: false
    },
    /**
     * Unless data is explicitly defined, the data is borrowed from the
     * first series in the chart.
     *
     * @type      {Array<number|Array<number|string|null>|object|null>}
     * @product   highstock
     * @apioption navigator.series.data
     */
    /**
     * Data grouping options for the navigator series.
     *
     * @extends plotOptions.series.dataGrouping
     */
    dataGrouping: {
      approximation: "average",
      enabled: true,
      groupPixelWidth: 2,
      // Replace smoothed property by anchors, #12455.
      firstAnchor: "firstPoint",
      anchor: "middle",
      lastAnchor: "lastPoint",
      // Day and week differs from plotOptions.series.dataGrouping
      units: [
        ["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
        ["second", [1, 2, 5, 10, 15, 30]],
        ["minute", [1, 2, 5, 10, 15, 30]],
        ["hour", [1, 2, 3, 4, 6, 8, 12]],
        ["day", [1, 2, 3, 4]],
        ["week", [1, 2, 3]],
        ["month", [1, 3, 6]],
        ["year", null]
      ]
    },
    /**
     * Data label options for the navigator series. Data labels are
     * disabled by default on the navigator series.
     *
     * @extends plotOptions.series.dataLabels
     */
    dataLabels: {
      enabled: false,
      zIndex: 2
      // #1839
    },
    id: "highcharts-navigator-series",
    className: "highcharts-navigator-series",
    /**
     * Sets the fill color of the navigator series.
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @apioption navigator.series.color
     */
    /**
     * Line color for the navigator series. Allows setting the color
     * while disallowing the default candlestick setting.
     *
     * @type {Highcharts.ColorString|null}
     */
    lineColor: null,
    // #4602
    marker: {
      enabled: false
    },
    /**
     * Since Highcharts Stock v8, default value is the same as default
     * `pointRange` defined for a specific type (e.g. `null` for
     * column type).
     *
     * In Highcharts Stock version < 8, defaults to 0.
     *
     * @extends plotOptions.series.pointRange
     * @type {number|null}
     * @apioption navigator.series.pointRange
     */
    /**
     * The threshold option. Setting it to 0 will make the default
     * navigator area series draw its area from the 0 value and up.
     *
     * @type {number|null}
     */
    threshold: null
  },
  /**
   * Enable or disable navigator sticking to right, while adding new
   * points. If `undefined`, the navigator sticks to the axis maximum only
   * if it was already at the maximum prior to adding points.
   *
   * @type      {boolean}
   * @default   undefined
   * @since 10.2.1
   * @sample {highstock} stock/navigator/sticktomax-false/
   * stickToMax set to false
   * @apioption navigator.stickToMax
   */
  /**
   * Options for the navigator X axis. Default series options for the
   * navigator xAxis are:
   * ```js
   * xAxis: {
   *     tickWidth: 0,
   *     lineWidth: 0,
   *     gridLineWidth: 1,
   *     tickPixelInterval: 200,
   *     labels: {
   *            align: 'left',
   *         style: {
   *             color: '#888'
   *         },
   *         x: 3,
   *         y: -4
   *     }
   * }
   * ```
   *
   * @extends   xAxis
   * @excluding linkedTo, maxZoom, minRange, opposite, range, scrollbar,
   *            showEmpty, maxRange
   */
  xAxis: {
    /**
     * Additional range on the right side of the xAxis. Works similar to
     * `xAxis.maxPadding`, but the value is set in terms of axis values,
     * percentage or pixels.
     *
     * If it's a number, it is interpreted as axis values, which in a
     * datetime axis equals milliseconds.
     *
     * If it's a percentage string, is interpreted as percentages of the
     * axis length. An overscroll of 50% will make a 100px axis 50px longer.
     *
     * If it's a pixel string, it is interpreted as a fixed pixel value, but
     * limited to 90% of the axis length.
     *
     * If it's undefined, the value is inherited from `xAxis.overscroll`.
     *
     * Can be set for both, main xAxis and navigator's xAxis.
     *
     * @type    {number | string | undefined}
     * @since   6.0.0
     * @apioption navigator.xAxis.overscroll
     */
    className: "highcharts-navigator-xaxis",
    tickLength: 0,
    lineWidth: 0,
    gridLineColor: "#e6e6e6",
    id: "navigator-x-axis",
    gridLineWidth: 1,
    tickPixelInterval: 200,
    labels: {
      align: "left",
      /**
       * @type {Highcharts.CSSObject}
       */
      style: {
        /** @ignore */
        color: "#000000",
        /** @ignore */
        fontSize: "0.7em",
        /** @ignore */
        opacity: 0.6,
        /** @ignore */
        textOutline: "2px contrast"
      },
      x: 3,
      y: -4
    },
    crosshair: false
  },
  /**
   * Options for the navigator Y axis. Default series options for the
   * navigator yAxis are:
   * ```js
   * yAxis: {
   *     gridLineWidth: 0,
   *     startOnTick: false,
   *     endOnTick: false,
   *     minPadding: 0.1,
   *     maxPadding: 0.1,
   *     labels: {
   *         enabled: false
   *     },
   *     title: {
   *         text: null
   *     },
   *     tickWidth: 0
   * }
   * ```
   *
   * @extends   yAxis
   * @excluding height, linkedTo, maxZoom, minRange, ordinal, range,
   *            showEmpty, scrollbar, top, units, maxRange, minLength,
   *            maxLength, resize
   */
  yAxis: {
    className: "highcharts-navigator-yaxis",
    gridLineWidth: 0,
    startOnTick: false,
    endOnTick: false,
    minPadding: 0.1,
    id: "navigator-y-axis",
    maxPadding: 0.1,
    labels: {
      enabled: false
    },
    crosshair: false,
    title: {
      text: void 0
    },
    tickLength: 0,
    tickWidth: 0
  }
};
var NavigatorDefaults_default = NavigatorDefaults;

// node_modules/highcharts/es-modules/Stock/Navigator/NavigatorSymbols.js
var { relativeLength: relativeLength9 } = Utilities_default;
function navigatorHandle(_x, _y, width, height, options2 = {}) {
  const halfWidth = options2.width ? options2.width / 2 : width, markerPosition = 1.5, r = relativeLength9(options2.borderRadius || 0, Math.min(halfWidth * 2, height));
  height = options2.height || height;
  return [
    ["M", -markerPosition, height / 2 - 3.5],
    ["L", -markerPosition, height / 2 + 4.5],
    ["M", markerPosition - 1, height / 2 - 3.5],
    ["L", markerPosition - 1, height / 2 + 4.5],
    ...Symbols_default.rect(-halfWidth - 1, 0.5, halfWidth * 2 + 1, height, { r })
  ];
}
var NavigatorSymbols = {
  "navigator-handle": navigatorHandle
};
var NavigatorSymbols_default = NavigatorSymbols;

// node_modules/highcharts/es-modules/Stock/Utilities/StockUtilities.js
var { defined: defined26 } = Utilities_default;
function setFixedRange(range2) {
  const xAxis2 = this.xAxis[0];
  if (defined26(xAxis2.dataMax) && defined26(xAxis2.dataMin) && range2) {
    this.fixedRange = Math.min(range2, xAxis2.dataMax - xAxis2.dataMin);
  } else {
    this.fixedRange = range2;
  }
}
var StockUtilities = {
  setFixedRange
};
var StockUtilities_default = StockUtilities;

// node_modules/highcharts/es-modules/Stock/Navigator/NavigatorComposition.js
var { setOptions: setOptions2 } = Defaults_default;
var { composed: composed8 } = Globals_default;
var { getRendererType } = RendererRegistry_default;
var { setFixedRange: setFixedRange2 } = StockUtilities_default;
var { addEvent: addEvent22, extend: extend30, pushUnique: pushUnique11 } = Utilities_default;
function compose4(ChartClass, AxisClass, SeriesClass) {
  NavigatorAxisComposition_default.compose(AxisClass);
  if (pushUnique11(composed8, "Navigator")) {
    ChartClass.prototype.setFixedRange = setFixedRange2;
    extend30(getRendererType().prototype.symbols, NavigatorSymbols_default);
    addEvent22(SeriesClass, "afterUpdate", onSeriesAfterUpdate);
    setOptions2({ navigator: NavigatorDefaults_default });
  }
}
function onSeriesAfterUpdate() {
  if (this.chart.navigator && !this.options.isInternal) {
    this.chart.navigator.setBaseSeries(null, false);
  }
}
var NavigatorComposition = {
  compose: compose4
};
var NavigatorComposition_default = NavigatorComposition;

// node_modules/highcharts/es-modules/Core/Axis/ScrollbarAxis.js
var { composed: composed9 } = Globals_default;
var { addEvent: addEvent23, defined: defined27, pick: pick36, pushUnique: pushUnique12 } = Utilities_default;
var ScrollbarAxis;
(function(ScrollbarAxis2) {
  let Scrollbar2;
  function compose27(AxisClass, ScrollbarClass) {
    if (pushUnique12(composed9, "Axis.Scrollbar")) {
      Scrollbar2 = ScrollbarClass;
      addEvent23(AxisClass, "afterGetOffset", onAxisAfterGetOffset);
      addEvent23(AxisClass, "afterInit", onAxisAfterInit);
      addEvent23(AxisClass, "afterRender", onAxisAfterRender2);
    }
  }
  ScrollbarAxis2.compose = compose27;
  function getExtremes(axis) {
    const axisMin = pick36(axis.options?.min, axis.min);
    const axisMax2 = pick36(axis.options?.max, axis.max);
    return {
      axisMin,
      axisMax: axisMax2,
      scrollMin: defined27(axis.dataMin) ? Math.min(axisMin, axis.min, axis.dataMin, pick36(axis.threshold, Infinity)) : axisMin,
      scrollMax: defined27(axis.dataMax) ? Math.max(axisMax2, axis.max, axis.dataMax, pick36(axis.threshold, -Infinity)) : axisMax2
    };
  }
  function onAxisAfterGetOffset() {
    const axis = this, scrollbar = axis.scrollbar, opposite = scrollbar && !scrollbar.options.opposite, index = axis.horiz ? 2 : opposite ? 3 : 1;
    if (scrollbar) {
      axis.chart.scrollbarsOffsets = [0, 0];
      axis.chart.axisOffset[index] += scrollbar.size + (scrollbar.options.margin || 0);
    }
  }
  function onAxisAfterInit() {
    const axis = this;
    if (axis.options?.scrollbar?.enabled) {
      axis.options.scrollbar.vertical = !axis.horiz;
      axis.options.startOnTick = axis.options.endOnTick = false;
      axis.scrollbar = new Scrollbar2(axis.chart.renderer, axis.options.scrollbar, axis.chart);
      addEvent23(axis.scrollbar, "changed", function(e) {
        const { axisMin, axisMax: axisMax2, scrollMin: unitedMin, scrollMax: unitedMax } = getExtremes(axis), range2 = unitedMax - unitedMin;
        let to, from;
        if (!defined27(axisMin) || !defined27(axisMax2)) {
          return;
        }
        if (axis.horiz && !axis.reversed || !axis.horiz && axis.reversed) {
          to = unitedMin + range2 * this.to;
          from = unitedMin + range2 * this.from;
        } else {
          to = unitedMin + range2 * (1 - this.from);
          from = unitedMin + range2 * (1 - this.to);
        }
        if (this.shouldUpdateExtremes(e.DOMType)) {
          const animate4 = e.DOMType === "mousemove" || e.DOMType === "touchmove" ? false : void 0;
          axis.setExtremes(from, to, true, animate4, e);
        } else {
          this.setRange(this.from, this.to);
        }
      });
    }
  }
  function onAxisAfterRender2() {
    const axis = this, { scrollMin, scrollMax } = getExtremes(axis), scrollbar = axis.scrollbar, offset3 = axis.axisTitleMargin + (axis.titleOffset || 0), scrollbarsOffsets = axis.chart.scrollbarsOffsets, axisMargin = axis.options.margin || 0;
    let offsetsIndex, from, to;
    if (scrollbar && scrollbarsOffsets) {
      if (axis.horiz) {
        if (!axis.opposite) {
          scrollbarsOffsets[1] += offset3;
        }
        scrollbar.position(axis.left, axis.top + axis.height + 2 + scrollbarsOffsets[1] - (axis.opposite ? axisMargin : 0), axis.width, axis.height);
        if (!axis.opposite) {
          scrollbarsOffsets[1] += axisMargin;
        }
        offsetsIndex = 1;
      } else {
        if (axis.opposite) {
          scrollbarsOffsets[0] += offset3;
        }
        let xPosition;
        if (!scrollbar.options.opposite) {
          xPosition = axis.opposite ? 0 : axisMargin;
        } else {
          xPosition = axis.left + axis.width + 2 + scrollbarsOffsets[0] - (axis.opposite ? 0 : axisMargin);
        }
        scrollbar.position(xPosition, axis.top, axis.width, axis.height);
        if (axis.opposite) {
          scrollbarsOffsets[0] += axisMargin;
        }
        offsetsIndex = 0;
      }
      scrollbarsOffsets[offsetsIndex] += scrollbar.size + (scrollbar.options.margin || 0);
      if (isNaN(scrollMin) || isNaN(scrollMax) || !defined27(axis.min) || !defined27(axis.max) || axis.dataMin === axis.dataMax) {
        scrollbar.setRange(0, 1);
      } else if (axis.min === axis.max) {
        const interval = axis.pointRange / (axis.dataMax + 1);
        from = interval * axis.min;
        to = interval * (axis.max + 1);
        scrollbar.setRange(from, to);
      } else {
        from = (axis.min - scrollMin) / (scrollMax - scrollMin);
        to = (axis.max - scrollMin) / (scrollMax - scrollMin);
        if (axis.horiz && !axis.reversed || !axis.horiz && axis.reversed) {
          scrollbar.setRange(from, to);
        } else {
          scrollbar.setRange(1 - to, 1 - from);
        }
      }
    }
  }
})(ScrollbarAxis || (ScrollbarAxis = {}));
var ScrollbarAxis_default = ScrollbarAxis;

// node_modules/highcharts/es-modules/Stock/Scrollbar/ScrollbarDefaults.js
var ScrollbarDefaults = {
  /**
   * The height of the scrollbar. If `buttonsEnabled` is true , the height
   * also applies to the width of the scroll arrows so that they are always
   * squares.
   *
   * @sample stock/scrollbar/style/
   *         Non-default height
   *
   * @type    {number}
   */
  height: 10,
  /**
   * The border rounding radius of the bar.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   */
  barBorderRadius: 5,
  /**
   * The corner radius of the scrollbar buttons.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   */
  buttonBorderRadius: 0,
  /**
   * Enable or disable the buttons at the end of the scrollbar.
   *
   * @since 11.0.0
   */
  buttonsEnabled: false,
  /**
   * Enable or disable the scrollbar.
   *
   * @sample stock/scrollbar/enabled/
   *         Disable the scrollbar, only use navigator
   *
   * @type      {boolean}
   * @default   true
   * @apioption scrollbar.enabled
   */
  /**
   * Whether to redraw the main chart as the scrollbar or the navigator
   * zoomed window is moved. Defaults to `true` for modern browsers and
   * `false` for legacy IE browsers as well as mobile devices.
   *
   * @sample stock/scrollbar/liveredraw
   *         Setting live redraw to false
   *
   * @type  {boolean}
   * @since 1.3
   */
  liveRedraw: void 0,
  /**
   * The margin between the scrollbar and its axis when the scrollbar is
   * applied directly to an axis, or the navigator in case that is enabled.
   * Defaults to 10 for axis, 3 for navigator.
   *
   * @type {number|undefined}
   */
  margin: void 0,
  /**
   * The minimum width of the scrollbar.
   *
   * @since 1.2.5
   */
  minWidth: 6,
  /** @ignore-option */
  opposite: true,
  /**
   * Whether to show or hide the scrollbar when the scrolled content is
   * zoomed out to it full extent.
   *
   * @type      {boolean}
   * @default   true
   * @apioption scrollbar.showFull
   */
  step: 0.2,
  /**
   * The z index of the scrollbar group.
   */
  zIndex: 3,
  /**
   * The background color of the scrollbar itself.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  barBackgroundColor: "#cccccc",
  /**
   * The width of the bar's border.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   */
  barBorderWidth: 0,
  /**
   * The color of the scrollbar's border.
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  barBorderColor: "#cccccc",
  /**
   * The color of the small arrow inside the scrollbar buttons.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  buttonArrowColor: "#333333",
  /**
   * The color of scrollbar buttons.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  buttonBackgroundColor: "#e6e6e6",
  /**
   * The color of the border of the scrollbar buttons.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  buttonBorderColor: "#cccccc",
  /**
   * The border width of the scrollbar buttons.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   */
  buttonBorderWidth: 1,
  /**
   * The color of the small rifles in the middle of the scrollbar.
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  rifleColor: "none",
  /**
   * The color of the track background.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  trackBackgroundColor: "rgba(255, 255, 255, 0.001)",
  // #18922
  /**
   * The color of the border of the scrollbar track.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  trackBorderColor: "#cccccc",
  /**
   * The corner radius of the border of the scrollbar track.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   */
  trackBorderRadius: 5,
  /**
   * The width of the border of the scrollbar track.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   */
  trackBorderWidth: 1
};
var ScrollbarDefaults_default = ScrollbarDefaults;

// node_modules/highcharts/es-modules/Stock/Scrollbar/Scrollbar.js
var { defaultOptions: defaultOptions10 } = Defaults_default;
var { addEvent: addEvent24, correctFloat: correctFloat8, crisp: crisp7, defined: defined28, destroyObjectProperties: destroyObjectProperties9, fireEvent: fireEvent22, merge: merge33, pick: pick37, removeEvent: removeEvent8 } = Utilities_default;
var Scrollbar = class _Scrollbar {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(AxisClass) {
    ScrollbarAxis_default.compose(AxisClass, _Scrollbar);
  }
  /**
   * When we have vertical scrollbar, rifles and arrow in buttons should be
   * rotated. The same method is used in Navigator's handles, to rotate them.
   *
   * @function Highcharts.swapXY
   *
   * @param {Highcharts.SVGPathArray} path
   * Path to be rotated.
   *
   * @param {boolean} [vertical]
   * If vertical scrollbar, swap x-y values.
   *
   * @return {Highcharts.SVGPathArray}
   * Rotated path.
   *
   * @requires modules/stock
   */
  static swapXY(path, vertical) {
    if (vertical) {
      path.forEach((seg) => {
        const len = seg.length;
        let temp;
        for (let i = 0; i < len; i += 2) {
          temp = seg[i + 1];
          if (typeof temp === "number") {
            seg[i + 1] = seg[i + 2];
            seg[i + 2] = temp;
          }
        }
      });
    }
    return path;
  }
  /* *
   *
   *  Constructors
   *
   * */
  constructor(renderer, options2, chart) {
    this._events = [];
    this.chartX = 0;
    this.chartY = 0;
    this.from = 0;
    this.scrollbarButtons = [];
    this.scrollbarLeft = 0;
    this.scrollbarStrokeWidth = 1;
    this.scrollbarTop = 0;
    this.size = 0;
    this.to = 0;
    this.trackBorderWidth = 1;
    this.x = 0;
    this.y = 0;
    this.init(renderer, options2, chart);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Set up the mouse and touch events for the Scrollbar
   *
   * @private
   * @function Highcharts.Scrollbar#addEvents
   */
  addEvents() {
    const buttonsOrder = this.options.inverted ? [1, 0] : [0, 1], buttons = this.scrollbarButtons, bar = this.scrollbarGroup.element, track = this.track.element, mouseDownHandler = this.mouseDownHandler.bind(this), mouseMoveHandler = this.mouseMoveHandler.bind(this), mouseUpHandler = this.mouseUpHandler.bind(this);
    const _events = [
      // Mouse events
      [
        buttons[buttonsOrder[0]].element,
        "click",
        this.buttonToMinClick.bind(this)
      ],
      [
        buttons[buttonsOrder[1]].element,
        "click",
        this.buttonToMaxClick.bind(this)
      ],
      [track, "click", this.trackClick.bind(this)],
      [bar, "mousedown", mouseDownHandler],
      [bar.ownerDocument, "mousemove", mouseMoveHandler],
      [bar.ownerDocument, "mouseup", mouseUpHandler],
      // Touch events
      [bar, "touchstart", mouseDownHandler],
      [bar.ownerDocument, "touchmove", mouseMoveHandler],
      [bar.ownerDocument, "touchend", mouseUpHandler]
    ];
    _events.forEach(function(args) {
      addEvent24.apply(null, args);
    });
    this._events = _events;
  }
  buttonToMaxClick(e) {
    const scroller = this;
    const range2 = (scroller.to - scroller.from) * pick37(scroller.options.step, 0.2);
    scroller.updatePosition(scroller.from + range2, scroller.to + range2);
    fireEvent22(scroller, "changed", {
      from: scroller.from,
      to: scroller.to,
      trigger: "scrollbar",
      DOMEvent: e
    });
  }
  buttonToMinClick(e) {
    const scroller = this;
    const range2 = correctFloat8(scroller.to - scroller.from) * pick37(scroller.options.step, 0.2);
    scroller.updatePosition(correctFloat8(scroller.from - range2), correctFloat8(scroller.to - range2));
    fireEvent22(scroller, "changed", {
      from: scroller.from,
      to: scroller.to,
      trigger: "scrollbar",
      DOMEvent: e
    });
  }
  /**
   * Get normalized (0-1) cursor position over the scrollbar
   *
   * @private
   * @function Highcharts.Scrollbar#cursorToScrollbarPosition
   *
   * @param  {*} normalizedEvent
   *         normalized event, with chartX and chartY values
   *
   * @return {Highcharts.Dictionary<number>}
   *         Local position {chartX, chartY}
   */
  cursorToScrollbarPosition(normalizedEvent) {
    const scroller = this, options2 = scroller.options, minWidthDifference = options2.minWidth > scroller.calculatedWidth ? options2.minWidth : 0;
    return {
      chartX: (normalizedEvent.chartX - scroller.x - scroller.xOffset) / (scroller.barWidth - minWidthDifference),
      chartY: (normalizedEvent.chartY - scroller.y - scroller.yOffset) / (scroller.barWidth - minWidthDifference)
    };
  }
  /**
   * Destroys allocated elements.
   *
   * @private
   * @function Highcharts.Scrollbar#destroy
   */
  destroy() {
    const scroller = this, navigator = scroller.chart.scroller;
    scroller.removeEvents();
    [
      "track",
      "scrollbarRifles",
      "scrollbar",
      "scrollbarGroup",
      "group"
    ].forEach(function(prop) {
      if (scroller[prop] && scroller[prop].destroy) {
        scroller[prop] = scroller[prop].destroy();
      }
    });
    if (navigator && scroller === navigator.scrollbar) {
      navigator.scrollbar = null;
      destroyObjectProperties9(navigator.scrollbarButtons);
    }
  }
  /**
   * Draw the scrollbar buttons with arrows
   *
   * @private
   * @function Highcharts.Scrollbar#drawScrollbarButton
   * @param {number} index
   *        0 is left, 1 is right
   */
  drawScrollbarButton(index) {
    const scroller = this, renderer = scroller.renderer, scrollbarButtons = scroller.scrollbarButtons, options2 = scroller.options, size = scroller.size, group = renderer.g().add(scroller.group);
    scrollbarButtons.push(group);
    if (options2.buttonsEnabled) {
      const rect2 = renderer.rect().addClass("highcharts-scrollbar-button").add(group);
      if (!scroller.chart.styledMode) {
        rect2.attr({
          stroke: options2.buttonBorderColor,
          "stroke-width": options2.buttonBorderWidth,
          fill: options2.buttonBackgroundColor
        });
      }
      rect2.attr(rect2.crisp({
        x: -0.5,
        y: -0.5,
        width: size,
        height: size,
        r: options2.buttonBorderRadius
      }, rect2.strokeWidth()));
      const arrow2 = renderer.path(_Scrollbar.swapXY([[
        "M",
        size / 2 + (index ? -1 : 1),
        size / 2 - 3
      ], [
        "L",
        size / 2 + (index ? -1 : 1),
        size / 2 + 3
      ], [
        "L",
        size / 2 + (index ? 2 : -2),
        size / 2
      ]], options2.vertical)).addClass("highcharts-scrollbar-arrow").add(scrollbarButtons[index]);
      if (!scroller.chart.styledMode) {
        arrow2.attr({
          fill: options2.buttonArrowColor
        });
      }
    }
  }
  /**
   * @private
   * @function Highcharts.Scrollbar#init
   * @param {Highcharts.SVGRenderer} renderer
   * @param {Highcharts.ScrollbarOptions} options
   * @param {Highcharts.Chart} chart
   */
  init(renderer, options2, chart) {
    const scroller = this;
    scroller.scrollbarButtons = [];
    scroller.renderer = renderer;
    scroller.userOptions = options2;
    scroller.options = merge33(ScrollbarDefaults_default, defaultOptions10.scrollbar, options2);
    scroller.options.margin = pick37(scroller.options.margin, 10);
    scroller.chart = chart;
    scroller.size = pick37(scroller.options.size, scroller.options.height);
    if (options2.enabled) {
      scroller.render();
      scroller.addEvents();
    }
  }
  mouseDownHandler(e) {
    const scroller = this, normalizedEvent = scroller.chart.pointer?.normalize(e) || e, mousePosition = scroller.cursorToScrollbarPosition(normalizedEvent);
    scroller.chartX = mousePosition.chartX;
    scroller.chartY = mousePosition.chartY;
    scroller.initPositions = [scroller.from, scroller.to];
    scroller.grabbedCenter = true;
  }
  /**
   * Event handler for the mouse move event.
   * @private
   */
  mouseMoveHandler(e) {
    const scroller = this, normalizedEvent = scroller.chart.pointer?.normalize(e) || e, options2 = scroller.options, direction = options2.vertical ? "chartY" : "chartX", initPositions = scroller.initPositions || [];
    let scrollPosition, chartPosition, change;
    if (scroller.grabbedCenter && // #4696, scrollbar failed on Android
    (!e.touches || e.touches[0][direction] !== 0)) {
      chartPosition = scroller.cursorToScrollbarPosition(normalizedEvent)[direction];
      scrollPosition = scroller[direction];
      change = chartPosition - scrollPosition;
      scroller.hasDragged = true;
      scroller.updatePosition(initPositions[0] + change, initPositions[1] + change);
      if (scroller.hasDragged) {
        fireEvent22(scroller, "changed", {
          from: scroller.from,
          to: scroller.to,
          trigger: "scrollbar",
          DOMType: e.type,
          DOMEvent: e
        });
      }
    }
  }
  /**
   * Event handler for the mouse up event.
   * @private
   */
  mouseUpHandler(e) {
    const scroller = this;
    if (scroller.hasDragged) {
      fireEvent22(scroller, "changed", {
        from: scroller.from,
        to: scroller.to,
        trigger: "scrollbar",
        DOMType: e.type,
        DOMEvent: e
      });
    }
    scroller.grabbedCenter = scroller.hasDragged = scroller.chartX = scroller.chartY = null;
  }
  /**
   * Position the scrollbar, method called from a parent with defined
   * dimensions.
   *
   * @private
   * @function Highcharts.Scrollbar#position
   * @param {number} x
   *        x-position on the chart
   * @param {number} y
   *        y-position on the chart
   * @param {number} width
   *        width of the scrollbar
   * @param {number} height
   *        height of the scrollbar
   */
  position(x, y, width, height) {
    const scroller = this, options2 = scroller.options, { buttonsEnabled, margin = 0, vertical } = options2, method = scroller.rendered ? "animate" : "attr";
    let xOffset = height, yOffset = 0;
    scroller.group.show();
    scroller.x = x;
    scroller.y = y + this.trackBorderWidth;
    scroller.width = width;
    scroller.height = height;
    scroller.xOffset = xOffset;
    scroller.yOffset = yOffset;
    if (vertical) {
      scroller.width = scroller.yOffset = width = yOffset = scroller.size;
      scroller.xOffset = xOffset = 0;
      scroller.yOffset = yOffset = buttonsEnabled ? scroller.size : 0;
      scroller.barWidth = height - (buttonsEnabled ? width * 2 : 0);
      scroller.x = x = x + margin;
    } else {
      scroller.height = height = scroller.size;
      scroller.xOffset = xOffset = buttonsEnabled ? scroller.size : 0;
      scroller.barWidth = width - (buttonsEnabled ? height * 2 : 0);
      scroller.y = scroller.y + margin;
    }
    scroller.group[method]({
      translateX: x,
      translateY: scroller.y
    });
    scroller.track[method]({
      width,
      height
    });
    scroller.scrollbarButtons[1][method]({
      translateX: vertical ? 0 : width - xOffset,
      translateY: vertical ? height - yOffset : 0
    });
  }
  /**
   * Removes the event handlers attached previously with addEvents.
   *
   * @private
   * @function Highcharts.Scrollbar#removeEvents
   */
  removeEvents() {
    this._events.forEach(function(args) {
      removeEvent8.apply(null, args);
    });
    this._events.length = 0;
  }
  /**
   * Render scrollbar with all required items.
   *
   * @private
   * @function Highcharts.Scrollbar#render
   */
  render() {
    const scroller = this, renderer = scroller.renderer, options2 = scroller.options, size = scroller.size, styledMode = scroller.chart.styledMode, group = renderer.g("scrollbar").attr({
      zIndex: options2.zIndex
    }).hide().add();
    scroller.group = group;
    scroller.track = renderer.rect().addClass("highcharts-scrollbar-track").attr({
      r: options2.trackBorderRadius || 0,
      height: size,
      width: size
    }).add(group);
    if (!styledMode) {
      scroller.track.attr({
        fill: options2.trackBackgroundColor,
        stroke: options2.trackBorderColor,
        "stroke-width": options2.trackBorderWidth
      });
    }
    const trackBorderWidth = scroller.trackBorderWidth = scroller.track.strokeWidth();
    scroller.track.attr({
      x: -crisp7(0, trackBorderWidth),
      y: -crisp7(0, trackBorderWidth)
    });
    scroller.scrollbarGroup = renderer.g().add(group);
    scroller.scrollbar = renderer.rect().addClass("highcharts-scrollbar-thumb").attr({
      height: size - trackBorderWidth,
      width: size - trackBorderWidth,
      r: options2.barBorderRadius || 0
    }).add(scroller.scrollbarGroup);
    scroller.scrollbarRifles = renderer.path(_Scrollbar.swapXY([
      ["M", -3, size / 4],
      ["L", -3, 2 * size / 3],
      ["M", 0, size / 4],
      ["L", 0, 2 * size / 3],
      ["M", 3, size / 4],
      ["L", 3, 2 * size / 3]
    ], options2.vertical)).addClass("highcharts-scrollbar-rifles").add(scroller.scrollbarGroup);
    if (!styledMode) {
      scroller.scrollbar.attr({
        fill: options2.barBackgroundColor,
        stroke: options2.barBorderColor,
        "stroke-width": options2.barBorderWidth
      });
      scroller.scrollbarRifles.attr({
        stroke: options2.rifleColor,
        "stroke-width": 1
      });
    }
    scroller.scrollbarStrokeWidth = scroller.scrollbar.strokeWidth();
    scroller.scrollbarGroup.translate(-crisp7(0, scroller.scrollbarStrokeWidth), -crisp7(0, scroller.scrollbarStrokeWidth));
    scroller.drawScrollbarButton(0);
    scroller.drawScrollbarButton(1);
  }
  /**
   * Set scrollbar size, with a given scale.
   *
   * @private
   * @function Highcharts.Scrollbar#setRange
   * @param {number} from
   *        scale (0-1) where bar should start
   * @param {number} to
   *        scale (0-1) where bar should end
   */
  setRange(from, to) {
    const scroller = this, options2 = scroller.options, vertical = options2.vertical, minWidth = options2.minWidth, fullWidth = scroller.barWidth, method = this.rendered && !this.hasDragged && !(this.chart.navigator && this.chart.navigator.hasDragged) ? "animate" : "attr";
    if (!defined28(fullWidth)) {
      return;
    }
    const toPX = fullWidth * Math.min(to, 1);
    let fromPX, newSize;
    from = Math.max(from, 0);
    fromPX = Math.ceil(fullWidth * from);
    scroller.calculatedWidth = newSize = correctFloat8(toPX - fromPX);
    if (newSize < minWidth) {
      fromPX = (fullWidth - minWidth + newSize) * from;
      newSize = minWidth;
    }
    const newPos = Math.floor(fromPX + scroller.xOffset + scroller.yOffset);
    const newRiflesPos = newSize / 2 - 0.5;
    scroller.from = from;
    scroller.to = to;
    if (!vertical) {
      scroller.scrollbarGroup[method]({
        translateX: newPos
      });
      scroller.scrollbar[method]({
        width: newSize
      });
      scroller.scrollbarRifles[method]({
        translateX: newRiflesPos
      });
      scroller.scrollbarLeft = newPos;
      scroller.scrollbarTop = 0;
    } else {
      scroller.scrollbarGroup[method]({
        translateY: newPos
      });
      scroller.scrollbar[method]({
        height: newSize
      });
      scroller.scrollbarRifles[method]({
        translateY: newRiflesPos
      });
      scroller.scrollbarTop = newPos;
      scroller.scrollbarLeft = 0;
    }
    if (newSize <= 12) {
      scroller.scrollbarRifles.hide();
    } else {
      scroller.scrollbarRifles.show();
    }
    if (options2.showFull === false) {
      if (from <= 0 && to >= 1) {
        scroller.group.hide();
      } else {
        scroller.group.show();
      }
    }
    scroller.rendered = true;
  }
  /**
   * Checks if the extremes should be updated in response to a scrollbar
   * change event.
   *
   * @private
   * @function Highcharts.Scrollbar#shouldUpdateExtremes
   */
  shouldUpdateExtremes(eventType) {
    return pick37(this.options.liveRedraw, Globals_default.svg && !Globals_default.isTouchDevice && !this.chart.boosted) || // Mouseup always should change extremes
    eventType === "mouseup" || eventType === "touchend" || // Internal events
    !defined28(eventType);
  }
  trackClick(e) {
    const scroller = this;
    const normalizedEvent = scroller.chart.pointer?.normalize(e) || e, range2 = scroller.to - scroller.from, top = scroller.y + scroller.scrollbarTop, left = scroller.x + scroller.scrollbarLeft;
    if (scroller.options.vertical && normalizedEvent.chartY > top || !scroller.options.vertical && normalizedEvent.chartX > left) {
      scroller.updatePosition(scroller.from + range2, scroller.to + range2);
    } else {
      scroller.updatePosition(scroller.from - range2, scroller.to - range2);
    }
    fireEvent22(scroller, "changed", {
      from: scroller.from,
      to: scroller.to,
      trigger: "scrollbar",
      DOMEvent: e
    });
  }
  /**
   * Update the scrollbar with new options
   *
   * @private
   * @function Highcharts.Scrollbar#update
   * @param  {Highcharts.ScrollbarOptions} options
   */
  update(options2) {
    this.destroy();
    this.init(this.chart.renderer, merge33(true, this.options, options2), this.chart);
  }
  /**
   * Update position option in the Scrollbar, with normalized 0-1 scale
   *
   * @private
   * @function Highcharts.Scrollbar#updatePosition
   * @param  {number} from
   * @param  {number} to
   */
  updatePosition(from, to) {
    if (to > 1) {
      from = correctFloat8(1 - correctFloat8(to - from));
      to = 1;
    }
    if (from < 0) {
      to = correctFloat8(to - from);
      from = 0;
    }
    this.from = from;
    this.to = to;
  }
};
Scrollbar.defaultOptions = ScrollbarDefaults_default;
defaultOptions10.scrollbar = merge33(true, Scrollbar.defaultOptions, defaultOptions10.scrollbar);
var Scrollbar_default = Scrollbar;

// node_modules/highcharts/es-modules/Stock/Navigator/Navigator.js
var { defaultOptions: defaultOptions11 } = Defaults_default;
var { isTouchDevice: isTouchDevice5 } = Globals_default;
var { prototype: { symbols } } = SVGRenderer_default;
var { addEvent: addEvent25, clamp: clamp10, correctFloat: correctFloat9, defined: defined29, destroyObjectProperties: destroyObjectProperties10, erase: erase10, extend: extend31, find: find7, fireEvent: fireEvent23, isArray: isArray14, isNumber: isNumber28, merge: merge34, pick: pick38, removeEvent: removeEvent9, splat: splat9 } = Utilities_default;
function numExt(extreme, ...args) {
  const numbers = [].filter.call(args, isNumber28);
  if (numbers.length) {
    return Math[extreme].apply(0, numbers);
  }
}
var Navigator = class _Navigator {
  /* *
   *
   *  Static Properties
   *
   * */
  static compose(ChartClass, AxisClass, SeriesClass) {
    ChartNavigatorComposition_default.compose(ChartClass, _Navigator);
    NavigatorComposition_default.compose(ChartClass, AxisClass, SeriesClass);
  }
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart) {
    this.isDirty = false;
    this.scrollbarHeight = 0;
    this.init(chart);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Draw one of the handles on the side of the zoomed range in the navigator.
   *
   * @private
   * @function Highcharts.Navigator#drawHandle
   *
   * @param {number} x
   *        The x center for the handle
   *
   * @param {number} index
   *        0 for left and 1 for right
   *
   * @param {boolean|undefined} inverted
   *        Flag for chart.inverted
   *
   * @param {string} verb
   *        Use 'animate' or 'attr'
   */
  drawHandle(x, index, inverted, verb) {
    const navigator = this, height = navigator.navigatorOptions.handles.height;
    navigator.handles[index][verb](inverted ? {
      translateX: Math.round(navigator.left + navigator.height / 2),
      translateY: Math.round(navigator.top + parseInt(x, 10) + 0.5 - height)
    } : {
      translateX: Math.round(navigator.left + parseInt(x, 10)),
      translateY: Math.round(navigator.top + navigator.height / 2 - height / 2 - 1)
    });
  }
  /**
   * Render outline around the zoomed range
   *
   * @private
   * @function Highcharts.Navigator#drawOutline
   *
   * @param {number} zoomedMin
   *        in pixels position where zoomed range starts
   *
   * @param {number} zoomedMax
   *        in pixels position where zoomed range ends
   *
   * @param {boolean|undefined} inverted
   *        flag if chart is inverted
   *
   * @param {string} verb
   *        use 'animate' or 'attr'
   */
  drawOutline(zoomedMin, zoomedMax, inverted, verb) {
    const navigator = this, maskInside = navigator.navigatorOptions.maskInside, outlineWidth = navigator.outline.strokeWidth(), halfOutline = outlineWidth / 2, outlineCorrection = outlineWidth % 2 / 2, scrollButtonSize = navigator.scrollButtonSize, navigatorSize = navigator.size, navigatorTop = navigator.top, height = navigator.height, lineTop = navigatorTop - halfOutline, lineBtm = navigatorTop + height;
    let left = navigator.left, verticalMin, path;
    if (inverted) {
      verticalMin = navigatorTop + zoomedMax + outlineCorrection;
      zoomedMax = navigatorTop + zoomedMin + outlineCorrection;
      path = [
        [
          "M",
          left + height,
          navigatorTop - scrollButtonSize - outlineCorrection
        ],
        // Top right of zoomed range
        ["L", left + height, verticalMin],
        ["L", left, verticalMin],
        // Top left of z.r.
        ["M", left, zoomedMax],
        // Bottom left of z.r.
        ["L", left + height, zoomedMax],
        // Bottom right of z.r.
        [
          "L",
          left + height,
          navigatorTop + navigatorSize + scrollButtonSize
        ]
      ];
      if (maskInside) {
        path.push(
          // Upper left of zoomed range
          ["M", left + height, verticalMin - halfOutline],
          // Upper right of z.r.
          [
            "L",
            left + height,
            zoomedMax + halfOutline
          ]
        );
      }
    } else {
      left -= scrollButtonSize;
      zoomedMin += left + scrollButtonSize - outlineCorrection;
      zoomedMax += left + scrollButtonSize - outlineCorrection;
      path = [
        // Left
        ["M", left, lineTop],
        // Upper left of zoomed range
        ["L", zoomedMin, lineTop],
        // Lower left of z.r.
        ["L", zoomedMin, lineBtm],
        // Lower right of z.r.
        ["M", zoomedMax, lineBtm],
        // Upper right of z.r.
        ["L", zoomedMax, lineTop],
        // Right
        [
          "L",
          left + navigatorSize + scrollButtonSize * 2,
          lineTop
        ]
      ];
      if (maskInside) {
        path.push(
          // Upper left of zoomed range
          ["M", zoomedMin - halfOutline, lineTop],
          // Upper right of z.r.
          ["L", zoomedMax + halfOutline, lineTop]
        );
      }
    }
    navigator.outline[verb]({
      d: path
    });
  }
  /**
   * Render outline around the zoomed range
   *
   * @private
   * @function Highcharts.Navigator#drawMasks
   *
   * @param {number} zoomedMin
   *        in pixels position where zoomed range starts
   *
   * @param {number} zoomedMax
   *        in pixels position where zoomed range ends
   *
   * @param {boolean|undefined} inverted
   *        flag if chart is inverted
   *
   * @param {string} verb
   *        use 'animate' or 'attr'
   */
  drawMasks(zoomedMin, zoomedMax, inverted, verb) {
    const navigator = this, left = navigator.left, top = navigator.top, navigatorHeight = navigator.height;
    let height, width, x, y;
    if (inverted) {
      x = [left, left, left];
      y = [top, top + zoomedMin, top + zoomedMax];
      width = [navigatorHeight, navigatorHeight, navigatorHeight];
      height = [
        zoomedMin,
        zoomedMax - zoomedMin,
        navigator.size - zoomedMax
      ];
    } else {
      x = [left, left + zoomedMin, left + zoomedMax];
      y = [top, top, top];
      width = [
        zoomedMin,
        zoomedMax - zoomedMin,
        navigator.size - zoomedMax
      ];
      height = [navigatorHeight, navigatorHeight, navigatorHeight];
    }
    navigator.shades.forEach((shade, i) => {
      shade[verb]({
        x: x[i],
        y: y[i],
        width: width[i],
        height: height[i]
      });
    });
  }
  /**
   * Generate and update DOM elements for a navigator:
   *
   * - main navigator group
   *
   * - all shades
   *
   * - outline
   *
   * - handles
   *
   * @private
   * @function Highcharts.Navigator#renderElements
   */
  renderElements() {
    const navigator = this, navigatorOptions = navigator.navigatorOptions, maskInside = navigatorOptions.maskInside, chart = navigator.chart, inverted = chart.inverted, renderer = chart.renderer, mouseCursor = {
      cursor: inverted ? "ns-resize" : "ew-resize"
    }, navigatorGroup = navigator.navigatorGroup ?? (navigator.navigatorGroup = renderer.g("navigator").attr({
      zIndex: 8,
      visibility: "hidden"
    }).add());
    [
      !maskInside,
      maskInside,
      !maskInside
    ].forEach((hasMask, index) => {
      const shade = navigator.shades[index] ?? (navigator.shades[index] = renderer.rect().addClass("highcharts-navigator-mask" + (index === 1 ? "-inside" : "-outside")).add(navigatorGroup));
      if (!chart.styledMode) {
        shade.attr({
          fill: hasMask ? navigatorOptions.maskFill : "rgba(0,0,0,0)"
        });
        if (index === 1) {
          shade.css(mouseCursor);
        }
      }
    });
    if (!navigator.outline) {
      navigator.outline = renderer.path().addClass("highcharts-navigator-outline").add(navigatorGroup);
    }
    if (!chart.styledMode) {
      navigator.outline.attr({
        "stroke-width": navigatorOptions.outlineWidth,
        stroke: navigatorOptions.outlineColor
      });
    }
    if (navigatorOptions.handles?.enabled) {
      const handlesOptions = navigatorOptions.handles, { height, width } = handlesOptions;
      [0, 1].forEach((index) => {
        const symbolName = handlesOptions.symbols[index];
        if (!navigator.handles[index] || navigator.handles[index].symbolUrl !== symbolName) {
          navigator.handles[index]?.destroy();
          navigator.handles[index] = renderer.symbol(symbolName, -width / 2 - 1, 0, width, height, handlesOptions);
          navigator.handles[index].attr({ zIndex: 7 - index }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][index]).add(navigatorGroup);
          navigator.addMouseEvents();
        } else if (!navigator.handles[index].isImg && navigator.handles[index].symbolName !== symbolName) {
          const symbolFn = symbols[symbolName], path = symbolFn.call(symbols, -width / 2 - 1, 0, width, height);
          navigator.handles[index].attr({
            d: path
          });
          navigator.handles[index].symbolName = symbolName;
        }
        if (chart.inverted) {
          navigator.handles[index].attr({
            rotation: 90,
            rotationOriginX: Math.floor(-width / 2),
            rotationOriginY: (height + width) / 2
          });
        }
        if (!chart.styledMode) {
          navigator.handles[index].attr({
            fill: handlesOptions.backgroundColor,
            stroke: handlesOptions.borderColor,
            "stroke-width": handlesOptions.lineWidth,
            width: handlesOptions.width,
            height: handlesOptions.height,
            x: -width / 2 - 1,
            y: 0
          }).css(mouseCursor);
        }
      });
    }
  }
  /**
   * Update navigator
   *
   * @private
   * @function Highcharts.Navigator#update
   *
   * @param {Highcharts.NavigatorOptions} options
   *        Options to merge in when updating navigator
   */
  update(options2, redraw = false) {
    const chart = this.chart, invertedUpdate = chart.options.chart.inverted !== chart.scrollbar?.options.vertical;
    merge34(true, chart.options.navigator, options2);
    this.navigatorOptions = chart.options.navigator || {};
    this.setOpposite();
    if (defined29(options2.enabled) || invertedUpdate) {
      this.destroy();
      this.navigatorEnabled = options2.enabled || this.navigatorEnabled;
      return this.init(chart);
    }
    if (this.navigatorEnabled) {
      this.isDirty = true;
      if (options2.adaptToUpdatedData === false) {
        this.baseSeries.forEach((series) => {
          removeEvent9(series, "updatedData", this.updatedDataHandler);
        }, this);
      }
      if (options2.adaptToUpdatedData) {
        this.baseSeries.forEach((series) => {
          series.eventsToUnbind.push(addEvent25(series, "updatedData", this.updatedDataHandler));
        }, this);
      }
      if (options2.series || options2.baseSeries) {
        this.setBaseSeries(void 0, false);
      }
      if (options2.height || options2.xAxis || options2.yAxis) {
        this.height = options2.height ?? this.height;
        const offsets = this.getXAxisOffsets();
        this.xAxis.update({
          ...options2.xAxis,
          offsets,
          [chart.inverted ? "width" : "height"]: this.height,
          [chart.inverted ? "height" : "width"]: void 0
        }, false);
        this.yAxis.update({
          ...options2.yAxis,
          [chart.inverted ? "width" : "height"]: this.height
        }, false);
      }
    }
    if (redraw) {
      chart.redraw();
    }
  }
  /**
   * Render the navigator
   *
   * @private
   * @function Highcharts.Navigator#render
   * @param {number} min
   *        X axis value minimum
   * @param {number} max
   *        X axis value maximum
   * @param {number} [pxMin]
   *        Pixel value minimum
   * @param {number} [pxMax]
   *        Pixel value maximum
   */
  render(min4, max4, pxMin, pxMax) {
    const navigator = this, chart = navigator.chart, xAxis2 = navigator.xAxis, pointRange = xAxis2.pointRange || 0, scrollbarXAxis = xAxis2.navigatorAxis.fake ? chart.xAxis[0] : xAxis2, navigatorEnabled = navigator.navigatorEnabled, rendered = navigator.rendered, inverted = chart.inverted, minRange = chart.xAxis[0].minRange, maxRange = chart.xAxis[0].options.maxRange, scrollButtonSize = navigator.scrollButtonSize;
    let navigatorWidth, scrollbarLeft, scrollbarTop, scrollbarHeight = navigator.scrollbarHeight, navigatorSize, verb;
    if (this.hasDragged && !defined29(pxMin)) {
      return;
    }
    if (this.isDirty) {
      this.renderElements();
    }
    min4 = correctFloat9(min4 - pointRange / 2);
    max4 = correctFloat9(max4 + pointRange / 2);
    if (!isNumber28(min4) || !isNumber28(max4)) {
      if (rendered) {
        pxMin = 0;
        pxMax = pick38(xAxis2.width, scrollbarXAxis.width);
      } else {
        return;
      }
    }
    navigator.left = pick38(
      xAxis2.left,
      // In case of scrollbar only, without navigator
      chart.plotLeft + scrollButtonSize + (inverted ? chart.plotWidth : 0)
    );
    let zoomedMax = navigator.size = navigatorSize = pick38(xAxis2.len, (inverted ? chart.plotHeight : chart.plotWidth) - 2 * scrollButtonSize);
    if (inverted) {
      navigatorWidth = scrollbarHeight;
    } else {
      navigatorWidth = navigatorSize + 2 * scrollButtonSize;
    }
    pxMin = pick38(pxMin, xAxis2.toPixels(min4, true));
    pxMax = pick38(pxMax, xAxis2.toPixels(max4, true));
    if (!isNumber28(pxMin) || Math.abs(pxMin) === Infinity) {
      pxMin = 0;
      pxMax = navigatorWidth;
    }
    const newMin = xAxis2.toValue(pxMin, true), newMax = xAxis2.toValue(pxMax, true), currentRange = Math.abs(correctFloat9(newMax - newMin));
    if (currentRange < minRange) {
      if (this.grabbedLeft) {
        pxMin = xAxis2.toPixels(newMax - minRange - pointRange, true);
      } else if (this.grabbedRight) {
        pxMax = xAxis2.toPixels(newMin + minRange + pointRange, true);
      }
    } else if (defined29(maxRange) && correctFloat9(currentRange - pointRange) > maxRange) {
      if (this.grabbedLeft) {
        pxMin = xAxis2.toPixels(newMax - maxRange - pointRange, true);
      } else if (this.grabbedRight) {
        pxMax = xAxis2.toPixels(newMin + maxRange + pointRange, true);
      }
    }
    navigator.zoomedMax = clamp10(Math.max(pxMin, pxMax), 0, zoomedMax);
    navigator.zoomedMin = clamp10(navigator.fixedWidth ? navigator.zoomedMax - navigator.fixedWidth : Math.min(pxMin, pxMax), 0, zoomedMax);
    navigator.range = navigator.zoomedMax - navigator.zoomedMin;
    zoomedMax = Math.round(navigator.zoomedMax);
    const zoomedMin = Math.round(navigator.zoomedMin);
    if (navigatorEnabled) {
      navigator.navigatorGroup.attr({
        visibility: "inherit"
      });
      verb = rendered && !navigator.hasDragged ? "animate" : "attr";
      navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
      navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);
      if (navigator.navigatorOptions.handles.enabled) {
        navigator.drawHandle(zoomedMin, 0, inverted, verb);
        navigator.drawHandle(zoomedMax, 1, inverted, verb);
      }
    }
    if (navigator.scrollbar) {
      if (inverted) {
        scrollbarTop = navigator.top - scrollButtonSize;
        scrollbarLeft = navigator.left - scrollbarHeight + (navigatorEnabled || !scrollbarXAxis.opposite ? 0 : (
          // Multiple axes has offsets:
          (scrollbarXAxis.titleOffset || 0) + // Self margin from the axis.title
          scrollbarXAxis.axisTitleMargin
        ));
        scrollbarHeight = navigatorSize + 2 * scrollButtonSize;
      } else {
        scrollbarTop = navigator.top + (navigatorEnabled ? navigator.height : -scrollbarHeight);
        scrollbarLeft = navigator.left - scrollButtonSize;
      }
      navigator.scrollbar.position(scrollbarLeft, scrollbarTop, navigatorWidth, scrollbarHeight);
      navigator.scrollbar.setRange(
        // Use real value, not rounded because range can be very small
        // (#1716)
        navigator.zoomedMin / (navigatorSize || 1),
        navigator.zoomedMax / (navigatorSize || 1)
      );
    }
    navigator.rendered = true;
    this.isDirty = false;
    fireEvent23(this, "afterRender");
  }
  /**
   * Set up the mouse and touch events for the navigator
   *
   * @private
   * @function Highcharts.Navigator#addMouseEvents
   */
  addMouseEvents() {
    const navigator = this, chart = navigator.chart, container = chart.container;
    let eventsToUnbind = [], mouseMoveHandler, mouseUpHandler;
    navigator.mouseMoveHandler = mouseMoveHandler = function(e) {
      navigator.onMouseMove(e);
    };
    navigator.mouseUpHandler = mouseUpHandler = function(e) {
      navigator.onMouseUp(e);
    };
    eventsToUnbind = navigator.getPartsEvents("mousedown");
    eventsToUnbind.push(
      // Add mouse move and mouseup events. These are bind to doc/div,
      // because Navigator.grabbedSomething flags are stored in mousedown
      // events
      addEvent25(chart.renderTo, "mousemove", mouseMoveHandler),
      addEvent25(container.ownerDocument, "mouseup", mouseUpHandler),
      // Touch events
      addEvent25(chart.renderTo, "touchmove", mouseMoveHandler),
      addEvent25(container.ownerDocument, "touchend", mouseUpHandler)
    );
    eventsToUnbind.concat(navigator.getPartsEvents("touchstart"));
    navigator.eventsToUnbind = eventsToUnbind;
    if (navigator.series && navigator.series[0]) {
      eventsToUnbind.push(addEvent25(navigator.series[0].xAxis, "foundExtremes", function() {
        chart.navigator.modifyNavigatorAxisExtremes();
      }));
    }
  }
  /**
   * Generate events for handles and masks
   *
   * @private
   * @function Highcharts.Navigator#getPartsEvents
   *
   * @param {string} eventName
   *        Event name handler, 'mousedown' or 'touchstart'
   *
   * @return {Array<Function>}
   *         An array of functions to remove navigator functions from the
   *         events again.
   */
  getPartsEvents(eventName) {
    const navigator = this, events = [];
    ["shades", "handles"].forEach(function(name) {
      navigator[name].forEach(function(navigatorItem, index) {
        events.push(addEvent25(navigatorItem.element, eventName, function(e) {
          navigator[name + "Mousedown"](e, index);
        }));
      });
    });
    return events;
  }
  /**
   * Mousedown on a shaded mask, either:
   *
   * - will be stored for future drag&drop
   *
   * - will directly shift to a new range
   *
   * @private
   * @function Highcharts.Navigator#shadesMousedown
   *
   * @param {Highcharts.PointerEventObject} e
   *        Mouse event
   *
   * @param {number} index
   *        Index of a mask in Navigator.shades array
   */
  shadesMousedown(e, index) {
    e = this.chart.pointer?.normalize(e) || e;
    const navigator = this, chart = navigator.chart, xAxis2 = navigator.xAxis, zoomedMin = navigator.zoomedMin, navigatorSize = navigator.size, range2 = navigator.range;
    let navigatorPosition = navigator.left, chartX = e.chartX, fixedMax, fixedMin, ext, left;
    if (chart.inverted) {
      chartX = e.chartY;
      navigatorPosition = navigator.top;
    }
    if (index === 1) {
      navigator.grabbedCenter = chartX;
      navigator.fixedWidth = range2;
      navigator.dragOffset = chartX - zoomedMin;
    } else {
      left = chartX - navigatorPosition - range2 / 2;
      if (index === 0) {
        left = Math.max(0, left);
      } else if (index === 2 && left + range2 >= navigatorSize) {
        left = navigatorSize - range2;
        if (navigator.reversedExtremes) {
          left -= range2;
          fixedMin = navigator.getUnionExtremes().dataMin;
        } else {
          fixedMax = navigator.getUnionExtremes().dataMax;
        }
      }
      if (left !== zoomedMin) {
        navigator.fixedWidth = range2;
        ext = xAxis2.navigatorAxis.toFixedRange(left, left + range2, fixedMin, fixedMax);
        if (defined29(ext.min)) {
          fireEvent23(this, "setRange", {
            min: Math.min(ext.min, ext.max),
            max: Math.max(ext.min, ext.max),
            redraw: true,
            eventArguments: {
              trigger: "navigator"
            }
          });
        }
      }
    }
  }
  /**
   * Mousedown on a handle mask.
   * Will store necessary information for drag&drop.
   *
   * @private
   * @function Highcharts.Navigator#handlesMousedown
   * @param {Highcharts.PointerEventObject} e
   *        Mouse event
   * @param {number} index
   *        Index of a handle in Navigator.handles array
   */
  handlesMousedown(e, index) {
    e = this.chart.pointer?.normalize(e) || e;
    const navigator = this, chart = navigator.chart, baseXAxis = chart.xAxis[0], reverse = navigator.reversedExtremes;
    if (index === 0) {
      navigator.grabbedLeft = true;
      navigator.otherHandlePos = navigator.zoomedMax;
      navigator.fixedExtreme = reverse ? baseXAxis.min : baseXAxis.max;
    } else {
      navigator.grabbedRight = true;
      navigator.otherHandlePos = navigator.zoomedMin;
      navigator.fixedExtreme = reverse ? baseXAxis.max : baseXAxis.min;
    }
    chart.setFixedRange(void 0);
  }
  /**
   * Mouse move event based on x/y mouse position.
   *
   * @private
   * @function Highcharts.Navigator#onMouseMove
   *
   * @param {Highcharts.PointerEventObject} e
   *        Mouse event
   */
  onMouseMove(e) {
    const navigator = this, chart = navigator.chart, navigatorSize = navigator.navigatorSize, range2 = navigator.range, dragOffset = navigator.dragOffset, inverted = chart.inverted;
    let left = navigator.left, chartX;
    if (!e.touches || e.touches[0].pageX !== 0) {
      e = chart.pointer?.normalize(e) || e;
      chartX = e.chartX;
      if (inverted) {
        left = navigator.top;
        chartX = e.chartY;
      }
      if (navigator.grabbedLeft) {
        navigator.hasDragged = true;
        navigator.render(0, 0, chartX - left, navigator.otherHandlePos);
      } else if (navigator.grabbedRight) {
        navigator.hasDragged = true;
        navigator.render(0, 0, navigator.otherHandlePos, chartX - left);
      } else if (navigator.grabbedCenter) {
        navigator.hasDragged = true;
        if (chartX < dragOffset) {
          chartX = dragOffset;
        } else if (chartX > navigatorSize + dragOffset - range2) {
          chartX = navigatorSize + dragOffset - range2;
        }
        navigator.render(0, 0, chartX - dragOffset, chartX - dragOffset + range2);
      }
      if (navigator.hasDragged && navigator.scrollbar && pick38(
        navigator.scrollbar.options.liveRedraw,
        // By default, don't run live redraw on touch
        // devices or if the chart is in boost.
        !isTouchDevice5 && !this.chart.boosted
      )) {
        e.DOMType = e.type;
        setTimeout(function() {
          navigator.onMouseUp(e);
        }, 0);
      }
    }
  }
  /**
   * Mouse up event based on x/y mouse position.
   *
   * @private
   * @function Highcharts.Navigator#onMouseUp
   * @param {Highcharts.PointerEventObject} e
   *        Mouse event
   */
  onMouseUp(e) {
    const navigator = this, chart = navigator.chart, xAxis2 = navigator.xAxis, scrollbar = navigator.scrollbar, DOMEvent = e.DOMEvent || e, inverted = chart.inverted, verb = navigator.rendered && !navigator.hasDragged ? "animate" : "attr";
    let zoomedMax, zoomedMin, unionExtremes, fixedMin, fixedMax, ext;
    if (
      // MouseUp is called for both, navigator and scrollbar (that order),
      // which causes calling afterSetExtremes twice. Prevent first call
      // by checking if scrollbar is going to set new extremes (#6334)
      navigator.hasDragged && (!scrollbar || !scrollbar.hasDragged) || e.trigger === "scrollbar"
    ) {
      unionExtremes = navigator.getUnionExtremes();
      if (navigator.zoomedMin === navigator.otherHandlePos) {
        fixedMin = navigator.fixedExtreme;
      } else if (navigator.zoomedMax === navigator.otherHandlePos) {
        fixedMax = navigator.fixedExtreme;
      }
      if (navigator.zoomedMax === navigator.size) {
        fixedMax = navigator.reversedExtremes ? unionExtremes.dataMin : unionExtremes.dataMax;
      }
      if (navigator.zoomedMin === 0) {
        fixedMin = navigator.reversedExtremes ? unionExtremes.dataMax : unionExtremes.dataMin;
      }
      ext = xAxis2.navigatorAxis.toFixedRange(navigator.zoomedMin, navigator.zoomedMax, fixedMin, fixedMax);
      if (defined29(ext.min)) {
        fireEvent23(this, "setRange", {
          min: Math.min(ext.min, ext.max),
          max: Math.max(ext.min, ext.max),
          redraw: true,
          animation: navigator.hasDragged ? false : null,
          eventArguments: {
            trigger: "navigator",
            triggerOp: "navigator-drag",
            DOMEvent
            // #1838
          }
        });
      }
    }
    if (e.DOMType !== "mousemove" && e.DOMType !== "touchmove") {
      navigator.grabbedLeft = navigator.grabbedRight = navigator.grabbedCenter = navigator.fixedWidth = navigator.fixedExtreme = navigator.otherHandlePos = navigator.hasDragged = navigator.dragOffset = null;
    }
    if (navigator.navigatorEnabled && isNumber28(navigator.zoomedMin) && isNumber28(navigator.zoomedMax)) {
      zoomedMin = Math.round(navigator.zoomedMin);
      zoomedMax = Math.round(navigator.zoomedMax);
      if (navigator.shades) {
        navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
      }
      if (navigator.outline) {
        navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);
      }
      if (navigator.navigatorOptions.handles.enabled && Object.keys(navigator.handles).length === navigator.handles.length) {
        navigator.drawHandle(zoomedMin, 0, inverted, verb);
        navigator.drawHandle(zoomedMax, 1, inverted, verb);
      }
    }
  }
  /**
   * Removes the event handlers attached previously with addEvents.
   *
   * @private
   * @function Highcharts.Navigator#removeEvents
   */
  removeEvents() {
    if (this.eventsToUnbind) {
      this.eventsToUnbind.forEach(function(unbind) {
        unbind();
      });
      this.eventsToUnbind = void 0;
    }
    this.removeBaseSeriesEvents();
  }
  /**
   * Remove data events.
   *
   * @private
   * @function Highcharts.Navigator#removeBaseSeriesEvents
   */
  removeBaseSeriesEvents() {
    const baseSeries = this.baseSeries || [];
    if (this.navigatorEnabled && baseSeries[0]) {
      if (this.navigatorOptions.adaptToUpdatedData !== false) {
        baseSeries.forEach(function(series) {
          removeEvent9(series, "updatedData", this.updatedDataHandler);
        }, this);
      }
      if (baseSeries[0].xAxis) {
        removeEvent9(baseSeries[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes);
      }
    }
  }
  /**
   * Calculate the navigator xAxis offsets
   *
   * @private
   */
  getXAxisOffsets() {
    return this.chart.inverted ? [this.scrollButtonSize, 0, -this.scrollButtonSize, 0] : [0, -this.scrollButtonSize, 0, this.scrollButtonSize];
  }
  /**
   * Initialize the Navigator object
   *
   * @private
   * @function Highcharts.Navigator#init
   */
  init(chart) {
    const chartOptions = chart.options, navigatorOptions = chartOptions.navigator || {}, navigatorEnabled = navigatorOptions.enabled, scrollbarOptions = chartOptions.scrollbar || {}, scrollbarEnabled = scrollbarOptions.enabled, height = navigatorEnabled && navigatorOptions.height || 0, scrollbarHeight = scrollbarEnabled && scrollbarOptions.height || 0, scrollButtonSize = scrollbarOptions.buttonsEnabled && scrollbarHeight || 0;
    this.handles = [];
    this.shades = [];
    this.chart = chart;
    this.setBaseSeries();
    this.height = height;
    this.scrollbarHeight = scrollbarHeight;
    this.scrollButtonSize = scrollButtonSize;
    this.scrollbarEnabled = scrollbarEnabled;
    this.navigatorEnabled = navigatorEnabled;
    this.navigatorOptions = navigatorOptions;
    this.scrollbarOptions = scrollbarOptions;
    this.setOpposite();
    const navigator = this, baseSeries = navigator.baseSeries, xAxisIndex = chart.xAxis.length, yAxisIndex = chart.yAxis.length, baseXaxis = baseSeries && baseSeries[0] && baseSeries[0].xAxis || chart.xAxis[0] || { options: {} };
    chart.isDirtyBox = true;
    if (navigator.navigatorEnabled) {
      const offsets = this.getXAxisOffsets();
      navigator.xAxis = new Axis_default(chart, merge34({
        // Inherit base xAxis' break, ordinal options and overscroll
        breaks: baseXaxis.options.breaks,
        ordinal: baseXaxis.options.ordinal,
        overscroll: baseXaxis.options.overscroll
      }, navigatorOptions.xAxis, {
        type: "datetime",
        yAxis: navigatorOptions.yAxis?.id,
        index: xAxisIndex,
        isInternal: true,
        offset: 0,
        keepOrdinalPadding: true,
        // #2436
        startOnTick: false,
        endOnTick: false,
        // Inherit base xAxis' padding when ordinal is false (#16915).
        minPadding: baseXaxis.options.ordinal ? 0 : baseXaxis.options.minPadding,
        maxPadding: baseXaxis.options.ordinal ? 0 : baseXaxis.options.maxPadding,
        zoomEnabled: false
      }, chart.inverted ? {
        offsets,
        width: height
      } : {
        offsets,
        height
      }), "xAxis");
      navigator.yAxis = new Axis_default(chart, merge34(navigatorOptions.yAxis, {
        alignTicks: false,
        offset: 0,
        index: yAxisIndex,
        isInternal: true,
        reversed: pick38(navigatorOptions.yAxis && navigatorOptions.yAxis.reversed, chart.yAxis[0] && chart.yAxis[0].reversed, false),
        // #14060
        zoomEnabled: false
      }, chart.inverted ? {
        width: height
      } : {
        height
      }), "yAxis");
      if (baseSeries || navigatorOptions.series.data) {
        navigator.updateNavigatorSeries(false);
      } else if (chart.series.length === 0) {
        navigator.unbindRedraw = addEvent25(chart, "beforeRedraw", function() {
          if (chart.series.length > 0 && !navigator.series) {
            navigator.setBaseSeries();
            navigator.unbindRedraw();
          }
        });
      }
      navigator.reversedExtremes = chart.inverted && !navigator.xAxis.reversed || !chart.inverted && navigator.xAxis.reversed;
      navigator.renderElements();
      navigator.addMouseEvents();
    } else {
      navigator.xAxis = {
        chart,
        navigatorAxis: {
          fake: true
        },
        translate: function(value, reverse) {
          const axis = chart.xAxis[0], ext = axis.getExtremes(), scrollTrackWidth = axis.len - 2 * scrollButtonSize, min4 = numExt("min", axis.options.min, ext.dataMin), valueRange = numExt("max", axis.options.max, ext.dataMax) - min4;
          return reverse ? (
            // From pixel to value
            value * valueRange / scrollTrackWidth + min4
          ) : (
            // From value to pixel
            scrollTrackWidth * (value - min4) / valueRange
          );
        },
        toPixels: function(value) {
          return this.translate(value);
        },
        toValue: function(value) {
          return this.translate(value, true);
        }
      };
      navigator.xAxis.navigatorAxis.axis = navigator.xAxis;
      navigator.xAxis.navigatorAxis.toFixedRange = NavigatorAxisComposition_default.prototype.toFixedRange.bind(navigator.xAxis.navigatorAxis);
    }
    if (chart.options.scrollbar?.enabled) {
      const options2 = merge34(chart.options.scrollbar, { vertical: chart.inverted });
      if (!isNumber28(options2.margin)) {
        options2.margin = chart.inverted ? -3 : 3;
      }
      chart.scrollbar = navigator.scrollbar = new Scrollbar_default(chart.renderer, options2, chart);
      addEvent25(navigator.scrollbar, "changed", function(e) {
        const range2 = navigator.size, to = range2 * this.to, from = range2 * this.from;
        navigator.hasDragged = navigator.scrollbar.hasDragged;
        navigator.render(0, 0, from, to);
        if (this.shouldUpdateExtremes(e.DOMType)) {
          setTimeout(function() {
            navigator.onMouseUp(e);
          });
        }
      });
    }
    navigator.addBaseSeriesEvents();
    navigator.addChartEvents();
  }
  /**
   * Set the opposite property on navigator
   *
   * @private
   */
  setOpposite() {
    const navigatorOptions = this.navigatorOptions, navigatorEnabled = this.navigatorEnabled, chart = this.chart;
    this.opposite = pick38(navigatorOptions.opposite, Boolean(!navigatorEnabled && chart.inverted));
  }
  /**
   * Get the union data extremes of the chart - the outer data extremes of the
   * base X axis and the navigator axis.
   *
   * @private
   * @function Highcharts.Navigator#getUnionExtremes
   */
  getUnionExtremes(returnFalseOnNoBaseSeries) {
    const baseAxis = this.chart.xAxis[0], time = this.chart.time, navAxis = this.xAxis, navAxisOptions = navAxis.options, baseAxisOptions = baseAxis.options;
    let ret;
    if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {
      ret = {
        dataMin: pick38(
          // #4053
          time.parse(navAxisOptions?.min),
          numExt("min", time.parse(baseAxisOptions.min), baseAxis.dataMin, navAxis.dataMin, navAxis.min)
        ),
        dataMax: pick38(time.parse(navAxisOptions?.max), numExt("max", time.parse(baseAxisOptions.max), baseAxis.dataMax, navAxis.dataMax, navAxis.max))
      };
    }
    return ret;
  }
  /**
   * Set the base series and update the navigator series from this. With a bit
   * of modification we should be able to make this an API method to be called
   * from the outside
   *
   * @private
   * @function Highcharts.Navigator#setBaseSeries
   * @param {Highcharts.SeriesOptionsType} [baseSeriesOptions]
   *        Additional series options for a navigator
   * @param {boolean} [redraw]
   *        Whether to redraw after update.
   */
  setBaseSeries(baseSeriesOptions, redraw) {
    const chart = this.chart, baseSeries = this.baseSeries = [];
    baseSeriesOptions = baseSeriesOptions || chart.options && chart.options.navigator.baseSeries || (chart.series.length ? (
      // Find the first non-navigator series (#8430)
      find7(chart.series, (s) => !s.options.isInternal).index
    ) : 0);
    (chart.series || []).forEach((series, i) => {
      if (
        // Don't include existing nav series
        !series.options.isInternal && (series.options.showInNavigator || (i === baseSeriesOptions || series.options.id === baseSeriesOptions) && series.options.showInNavigator !== false)
      ) {
        baseSeries.push(series);
      }
    });
    if (this.xAxis && !this.xAxis.navigatorAxis.fake) {
      this.updateNavigatorSeries(true, redraw);
    }
  }
  /**
   * Update series in the navigator from baseSeries, adding new if does not
   * exist.
   *
   * @private
   * @function Highcharts.Navigator.updateNavigatorSeries
   */
  updateNavigatorSeries(addEvents4, redraw) {
    const navigator = this, chart = navigator.chart, baseSeries = navigator.baseSeries, navSeriesMixin = {
      enableMouseTracking: false,
      index: null,
      // #6162
      linkedTo: null,
      // #6734
      group: "nav",
      // For columns
      padXAxis: false,
      xAxis: this.navigatorOptions.xAxis?.id,
      yAxis: this.navigatorOptions.yAxis?.id,
      showInLegend: false,
      stacking: void 0,
      // #4823
      isInternal: true,
      states: {
        inactive: {
          opacity: 1
        }
      }
    }, navigatorSeries = navigator.series = (navigator.series || []).filter((navSeries) => {
      const base = navSeries.baseSeries;
      if (baseSeries.indexOf(base) < 0) {
        if (base) {
          removeEvent9(base, "updatedData", navigator.updatedDataHandler);
          delete base.navigatorSeries;
        }
        if (navSeries.chart) {
          navSeries.destroy();
        }
        return false;
      }
      return true;
    });
    let baseOptions, mergedNavSeriesOptions, chartNavigatorSeriesOptions = navigator.navigatorOptions.series, baseNavigatorOptions;
    if (baseSeries && baseSeries.length) {
      baseSeries.forEach((base) => {
        const linkedNavSeries = base.navigatorSeries, userNavOptions = extend31(
          // Grab color and visibility from base as default
          {
            color: base.color,
            visible: base.visible
          },
          !isArray14(chartNavigatorSeriesOptions) ? chartNavigatorSeriesOptions : defaultOptions11.navigator.series
        );
        if (linkedNavSeries && navigator.navigatorOptions.adaptToUpdatedData === false) {
          return;
        }
        navSeriesMixin.name = "Navigator " + baseSeries.length;
        baseOptions = base.options || {};
        baseNavigatorOptions = baseOptions.navigatorOptions || {};
        userNavOptions.dataLabels = splat9(userNavOptions.dataLabels);
        mergedNavSeriesOptions = merge34(baseOptions, navSeriesMixin, userNavOptions, baseNavigatorOptions);
        mergedNavSeriesOptions.pointRange = pick38(
          // Stricte set pointRange in options
          userNavOptions.pointRange,
          baseNavigatorOptions.pointRange,
          // Fallback to default values, e.g. `null` for column
          defaultOptions11.plotOptions[mergedNavSeriesOptions.type || "line"].pointRange
        );
        const navigatorSeriesData = baseNavigatorOptions.data || userNavOptions.data;
        navigator.hasNavigatorData = navigator.hasNavigatorData || !!navigatorSeriesData;
        mergedNavSeriesOptions.data = navigatorSeriesData || baseOptions.data?.slice(0);
        if (linkedNavSeries && linkedNavSeries.options) {
          linkedNavSeries.update(mergedNavSeriesOptions, redraw);
        } else {
          base.navigatorSeries = chart.initSeries(mergedNavSeriesOptions);
          chart.setSortedData();
          base.navigatorSeries.baseSeries = base;
          navigatorSeries.push(base.navigatorSeries);
        }
      });
    }
    if (chartNavigatorSeriesOptions.data && !(baseSeries && baseSeries.length) || isArray14(chartNavigatorSeriesOptions)) {
      navigator.hasNavigatorData = false;
      chartNavigatorSeriesOptions = splat9(chartNavigatorSeriesOptions);
      chartNavigatorSeriesOptions.forEach((userSeriesOptions, i) => {
        navSeriesMixin.name = "Navigator " + (navigatorSeries.length + 1);
        mergedNavSeriesOptions = merge34(defaultOptions11.navigator.series, {
          // Since we don't have a base series to pull color from,
          // try to fake it by using color from series with same
          // index. Otherwise pull from the colors array. We need
          // an explicit color as otherwise updates will increment
          // color counter and we'll get a new color for each
          // update of the nav series.
          color: chart.series[i] && !chart.series[i].options.isInternal && chart.series[i].color || chart.options.colors[i] || chart.options.colors[0]
        }, navSeriesMixin, userSeriesOptions);
        mergedNavSeriesOptions.data = userSeriesOptions.data;
        if (mergedNavSeriesOptions.data) {
          navigator.hasNavigatorData = true;
          navigatorSeries.push(chart.initSeries(mergedNavSeriesOptions));
        }
      });
    }
    if (addEvents4) {
      this.addBaseSeriesEvents();
    }
  }
  /**
   * Add data events.
   * For example when main series is updated we need to recalculate extremes
   *
   * @private
   * @function Highcharts.Navigator#addBaseSeriesEvent
   */
  addBaseSeriesEvents() {
    const navigator = this, baseSeries = navigator.baseSeries || [];
    if (baseSeries[0] && baseSeries[0].xAxis) {
      baseSeries[0].eventsToUnbind.push(addEvent25(baseSeries[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
    }
    baseSeries.forEach((base) => {
      base.eventsToUnbind.push(addEvent25(base, "show", function() {
        if (this.navigatorSeries) {
          this.navigatorSeries.setVisible(true, false);
        }
      }));
      base.eventsToUnbind.push(addEvent25(base, "hide", function() {
        if (this.navigatorSeries) {
          this.navigatorSeries.setVisible(false, false);
        }
      }));
      if (this.navigatorOptions.adaptToUpdatedData !== false) {
        if (base.xAxis) {
          base.eventsToUnbind.push(addEvent25(base, "updatedData", this.updatedDataHandler));
        }
      }
      base.eventsToUnbind.push(addEvent25(base, "remove", function() {
        if (baseSeries) {
          erase10(baseSeries, base);
        }
        if (this.navigatorSeries && navigator.series) {
          erase10(navigator.series, this.navigatorSeries);
          if (defined29(this.navigatorSeries.options)) {
            this.navigatorSeries.remove(false);
          }
          delete this.navigatorSeries;
        }
      }));
    });
  }
  /**
   * Get minimum from all base series connected to the navigator
   * @private
   * @param {number} currentSeriesMin
   *        Minium from the current series
   * @return {number}
   *         Minimum from all series
   */
  getBaseSeriesMin(currentSeriesMin) {
    return this.baseSeries.reduce(function(min4, series) {
      return Math.min(min4, series.getColumn("x")[0] ?? min4);
    }, currentSeriesMin);
  }
  /**
   * Set the navigator x axis extremes to reflect the total. The navigator
   * extremes should always be the extremes of the union of all series in the
   * chart as well as the navigator series.
   *
   * @private
   * @function Highcharts.Navigator#modifyNavigatorAxisExtremes
   */
  modifyNavigatorAxisExtremes() {
    const xAxis2 = this.xAxis;
    if (typeof xAxis2.getExtremes !== "undefined") {
      const unionExtremes = this.getUnionExtremes(true);
      if (unionExtremes && (unionExtremes.dataMin !== xAxis2.min || unionExtremes.dataMax !== xAxis2.max)) {
        xAxis2.min = unionExtremes.dataMin;
        xAxis2.max = unionExtremes.dataMax;
      }
    }
  }
  /**
   * Hook to modify the base axis extremes with information from the Navigator
   *
   * @private
   * @function Highcharts.Navigator#modifyBaseAxisExtremes
   */
  modifyBaseAxisExtremes() {
    const baseXAxis = this, navigator = baseXAxis.chart.navigator, baseExtremes = baseXAxis.getExtremes(), baseMin = baseExtremes.min, baseMax = baseExtremes.max, baseDataMin = baseExtremes.dataMin, baseDataMax = baseExtremes.dataMax, range2 = baseMax - baseMin, stickToMin = navigator.stickToMin, stickToMax = navigator.stickToMax, overscroll = pick38(baseXAxis.ordinal?.convertOverscroll(baseXAxis.options.overscroll), 0), navigatorSeries = navigator.series && navigator.series[0], hasSetExtremes = !!baseXAxis.setExtremes, unmutable = baseXAxis.eventArgs && baseXAxis.eventArgs.trigger === "rangeSelectorButton";
    let newMax, newMin;
    if (!unmutable) {
      if (stickToMin) {
        newMin = baseDataMin;
        newMax = newMin + range2;
      }
      if (stickToMax) {
        newMax = baseDataMax + overscroll;
        if (!stickToMin) {
          newMin = Math.max(
            baseDataMin,
            // Don't go below data extremes (#13184)
            newMax - range2,
            navigator.getBaseSeriesMin(navigatorSeries && navigatorSeries.xData ? navigatorSeries.xData[0] : -Number.MAX_VALUE)
          );
        }
      }
      if (hasSetExtremes && (stickToMin || stickToMax)) {
        if (isNumber28(newMin)) {
          baseXAxis.min = baseXAxis.userMin = newMin;
          baseXAxis.max = baseXAxis.userMax = newMax;
        }
      }
    }
    navigator.stickToMin = navigator.stickToMax = null;
  }
  /**
   * Handler for updated data on the base series. When data is modified, the
   * navigator series must reflect it. This is called from the Chart.redraw
   * function before axis and series extremes are computed.
   *
   * @private
   * @function Highcharts.Navigator#updateDataHandler
   */
  updatedDataHandler() {
    const navigator = this.chart.navigator, baseSeries = this, navigatorSeries = this.navigatorSeries, shouldStickToMax = navigator.reversedExtremes ? Math.round(navigator.zoomedMin) === 0 : Math.round(navigator.zoomedMax) >= Math.round(navigator.size);
    navigator.stickToMax = pick38(this.chart.options.navigator && this.chart.options.navigator.stickToMax, shouldStickToMax);
    navigator.stickToMin = navigator.shouldStickToMin(baseSeries, navigator);
    if (navigatorSeries && !navigator.hasNavigatorData) {
      navigatorSeries.options.pointStart = baseSeries.getColumn("x")[0];
      navigatorSeries.setData(baseSeries.options.data, false, null, false);
    }
  }
  /**
   * Detect if the zoomed area should stick to the minimum, #14742.
   *
   * @private
   * @function Highcharts.Navigator#shouldStickToMin
   */
  shouldStickToMin(baseSeries, navigator) {
    const xDataMin = navigator.getBaseSeriesMin(baseSeries.getColumn("x")[0]), xAxis2 = baseSeries.xAxis, max4 = xAxis2.max, min4 = xAxis2.min, range2 = xAxis2.options.range;
    let stickToMin = true;
    if (isNumber28(max4) && isNumber28(min4)) {
      if (range2 && max4 - xDataMin > 0) {
        stickToMin = max4 - xDataMin < range2;
      } else {
        stickToMin = min4 <= xDataMin;
      }
    } else {
      stickToMin = false;
    }
    return stickToMin;
  }
  /**
   * Add chart events, like redrawing navigator, when chart requires that.
   *
   * @private
   * @function Highcharts.Navigator#addChartEvents
   */
  addChartEvents() {
    if (!this.eventsToUnbind) {
      this.eventsToUnbind = [];
    }
    this.eventsToUnbind.push(
      // Move the scrollbar after redraw, like after data updata even if
      // axes don't redraw
      addEvent25(this.chart, "redraw", function() {
        const navigator = this.navigator, xAxis2 = navigator && (navigator.baseSeries && navigator.baseSeries[0] && navigator.baseSeries[0].xAxis || this.xAxis[0]);
        if (xAxis2) {
          navigator.render(xAxis2.min, xAxis2.max);
        }
      }),
      // Make room for the navigator, can be placed around the chart:
      addEvent25(this.chart, "getMargins", function() {
        const chart = this, navigator = chart.navigator;
        let marginName = navigator.opposite ? "plotTop" : "marginBottom";
        if (chart.inverted) {
          marginName = navigator.opposite ? "marginRight" : "plotLeft";
        }
        chart[marginName] = (chart[marginName] || 0) + (navigator.navigatorEnabled || !chart.inverted ? navigator.height + (this.scrollbar?.options.margin || 0) + navigator.scrollbarHeight : 0) + (navigator.navigatorOptions.margin || 0);
      }),
      addEvent25(_Navigator, "setRange", function(e) {
        this.chart.xAxis[0].setExtremes(e.min, e.max, e.redraw, e.animation, e.eventArguments);
      })
    );
  }
  /**
   * Destroys allocated elements.
   *
   * @private
   * @function Highcharts.Navigator#destroy
   */
  destroy() {
    this.removeEvents();
    if (this.xAxis) {
      erase10(this.chart.xAxis, this.xAxis);
      erase10(this.chart.axes, this.xAxis);
    }
    if (this.yAxis) {
      erase10(this.chart.yAxis, this.yAxis);
      erase10(this.chart.axes, this.yAxis);
    }
    (this.series || []).forEach((s) => {
      if (s.destroy) {
        s.destroy();
      }
    });
    [
      "series",
      "xAxis",
      "yAxis",
      "shades",
      "outline",
      "scrollbarTrack",
      "scrollbarRifles",
      "scrollbarGroup",
      "scrollbar",
      "navigatorGroup",
      "rendered"
    ].forEach((prop) => {
      if (this[prop] && this[prop].destroy) {
        this[prop].destroy();
      }
      this[prop] = null;
    });
    [this.handles].forEach((coll) => {
      destroyObjectProperties10(coll);
    });
    this.baseSeries.forEach((s) => {
      s.navigatorSeries = void 0;
    });
    this.navigatorEnabled = false;
  }
};
var Navigator_default = Navigator;

// node_modules/highcharts/es-modules/Core/Axis/OrdinalAxis.js
var { addEvent: addEvent26, correctFloat: correctFloat10, css: css12, defined: defined30, error: error7, isNumber: isNumber29, pick: pick39, timeUnits: timeUnits5, isString: isString15 } = Utilities_default;
var OrdinalAxis;
(function(OrdinalAxis2) {
  function compose27(AxisClass, SeriesClass, ChartClass) {
    const axisProto = AxisClass.prototype;
    if (!axisProto.ordinal2lin) {
      axisProto.getTimeTicks = getTimeTicks;
      axisProto.index2val = index2val;
      axisProto.lin2val = lin2val;
      axisProto.val2lin = val2lin;
      axisProto.ordinal2lin = axisProto.val2lin;
      addEvent26(AxisClass, "afterInit", onAxisAfterInit);
      addEvent26(AxisClass, "foundExtremes", onAxisFoundExtremes2);
      addEvent26(AxisClass, "afterSetScale", onAxisAfterSetScale);
      addEvent26(AxisClass, "initialAxisTranslation", onAxisInitialAxisTranslation);
      addEvent26(ChartClass, "pan", onChartPan);
      addEvent26(ChartClass, "touchpan", onChartPan);
      addEvent26(SeriesClass, "updatedData", onSeriesUpdatedData);
    }
    return AxisClass;
  }
  OrdinalAxis2.compose = compose27;
  function getTimeTicks(normalizedInterval, min4, max4, startOfWeek, positions = [], closestDistance = 0, findHigherRanks) {
    const higherRanks = {}, tickPixelIntervalOption = this.options.tickPixelInterval, time = this.chart.time, segmentStarts = [];
    let end, segmentPositions, hasCrossedHigherRank, info, outsideMax, start = 0, groupPositions = [], lastGroupPosition = -Number.MAX_VALUE;
    if (!this.options.ordinal && !this.options.breaks || !positions || positions.length < 3 || typeof min4 === "undefined") {
      return time.getTimeTicks.apply(time, arguments);
    }
    const posLength = positions.length;
    for (end = 0; end < posLength; end++) {
      outsideMax = end && positions[end - 1] > max4;
      if (positions[end] < min4) {
        start = end;
      }
      if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {
        if (positions[end] > lastGroupPosition) {
          segmentPositions = time.getTimeTicks(normalizedInterval, positions[start], positions[end], startOfWeek);
          while (segmentPositions.length && segmentPositions[0] <= lastGroupPosition) {
            segmentPositions.shift();
          }
          if (segmentPositions.length) {
            lastGroupPosition = segmentPositions[segmentPositions.length - 1];
          }
          segmentStarts.push(groupPositions.length);
          groupPositions = groupPositions.concat(segmentPositions);
        }
        start = end + 1;
      }
      if (outsideMax) {
        break;
      }
    }
    if (segmentPositions) {
      info = segmentPositions.info;
      if (findHigherRanks && info.unitRange <= timeUnits5.hour) {
        end = groupPositions.length - 1;
        for (start = 1; start < end; start++) {
          if (time.dateFormat("%d", groupPositions[start]) !== time.dateFormat("%d", groupPositions[start - 1])) {
            higherRanks[groupPositions[start]] = "day";
            hasCrossedHigherRank = true;
          }
        }
        if (hasCrossedHigherRank) {
          higherRanks[groupPositions[0]] = "day";
        }
        info.higherRanks = higherRanks;
      }
      info.segmentStarts = segmentStarts;
      groupPositions.info = info;
    } else {
      error7(12, false, this.chart);
    }
    if (findHigherRanks && defined30(tickPixelIntervalOption)) {
      const length = groupPositions.length, translatedArr = [], distances = [];
      let itemToRemove, translated, lastTranslated, medianDistance, distance, i = length;
      while (i--) {
        translated = this.translate(groupPositions[i]);
        if (lastTranslated) {
          distances[i] = lastTranslated - translated;
        }
        translatedArr[i] = lastTranslated = translated;
      }
      distances.sort((a, b) => a - b);
      medianDistance = distances[Math.floor(distances.length / 2)];
      if (medianDistance < tickPixelIntervalOption * 0.6) {
        medianDistance = null;
      }
      i = groupPositions[length - 1] > max4 ? length - 1 : length;
      lastTranslated = void 0;
      while (i--) {
        translated = translatedArr[i];
        distance = Math.abs(lastTranslated - translated);
        if (lastTranslated && distance < tickPixelIntervalOption * 0.8 && (medianDistance === null || distance < medianDistance * 0.8)) {
          if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {
            itemToRemove = i + 1;
            lastTranslated = translated;
          } else {
            itemToRemove = i;
          }
          groupPositions.splice(itemToRemove, 1);
        } else {
          lastTranslated = translated;
        }
      }
    }
    return groupPositions;
  }
  function index2val(index) {
    const axis = this, ordinal = axis.ordinal, ordinalPositions = ordinal.positions;
    if (!ordinalPositions) {
      return index;
    }
    let i = ordinalPositions.length - 1, distance;
    if (index < 0) {
      index = ordinalPositions[0];
    } else if (index > i) {
      index = ordinalPositions[i];
    } else {
      i = Math.floor(index);
      distance = index - i;
    }
    if (typeof distance !== "undefined" && typeof ordinalPositions[i] !== "undefined") {
      return ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0);
    }
    return index;
  }
  function lin2val(val) {
    const axis = this, ordinal = axis.ordinal, localMin = axis.old ? axis.old.min : axis.min, localA = axis.old ? axis.old.transA : axis.transA;
    const positions = ordinal.getExtendedPositions();
    if (positions?.length) {
      const pixelVal = correctFloat10((val - localMin) * localA + axis.minPixelPadding), index = correctFloat10(ordinal.getIndexOfPoint(pixelVal, positions)), mantissa = correctFloat10(index % 1);
      if (index >= 0 && index <= positions.length - 1) {
        const leftNeighbour = positions[Math.floor(index)], rightNeighbour = positions[Math.ceil(index)], distance = rightNeighbour - leftNeighbour;
        return positions[Math.floor(index)] + mantissa * distance;
      }
    }
    return val;
  }
  function getIndexInArray(ordinalPositions, val) {
    const index = OrdinalAxis2.Additions.findIndexOf(ordinalPositions, val, true);
    if (ordinalPositions[index] === val) {
      return index;
    }
    const percent = (val - ordinalPositions[index]) / (ordinalPositions[index + 1] - ordinalPositions[index]);
    return index + percent;
  }
  function onAxisAfterInit() {
    const axis = this;
    if (!axis.ordinal) {
      axis.ordinal = new OrdinalAxis2.Additions(axis);
    }
  }
  function onAxisFoundExtremes2() {
    const axis = this, { eventArgs, options: options2 } = axis;
    if (axis.isXAxis && defined30(options2.overscroll) && options2.overscroll !== 0 && isNumber29(axis.max) && isNumber29(axis.min)) {
      if (axis.options.ordinal && !axis.ordinal.originalOrdinalRange) {
        axis.ordinal.getExtendedPositions(false);
      }
      if (axis.max === axis.dataMax && // Panning is an exception. We don't want to apply
      // overscroll when panning over the dataMax
      (eventArgs?.trigger !== "pan" || axis.isInternal) && // Scrollbar buttons are the other execption
      eventArgs?.trigger !== "navigator") {
        const overscroll = axis.ordinal.convertOverscroll(options2.overscroll);
        axis.max += overscroll;
        if (!axis.isInternal && defined30(axis.userMin) && eventArgs?.trigger !== "mousewheel") {
          axis.min += overscroll;
        }
      }
    }
  }
  function onAxisAfterSetScale() {
    const axis = this;
    if (axis.horiz && !axis.isDirty) {
      axis.isDirty = axis.isOrdinal && axis.chart.navigator && !axis.chart.navigator.adaptToUpdatedData;
    }
  }
  function onAxisInitialAxisTranslation() {
    const axis = this;
    if (axis.ordinal) {
      axis.ordinal.beforeSetTickPositions();
      axis.tickInterval = axis.ordinal.postProcessTickInterval(axis.tickInterval);
    }
  }
  function onChartPan(e) {
    const chart = this, xAxis2 = chart.xAxis[0], overscroll = xAxis2.ordinal.convertOverscroll(xAxis2.options.overscroll), chartX = e.originalEvent.chartX, panning = chart.options.chart.panning;
    let runBase = false;
    if (panning && panning.type !== "y" && xAxis2.options.ordinal && xAxis2.series.length && // On touch devices, let default function handle the pinching
    (!e.touches || e.touches.length <= 1)) {
      const mouseDownX = chart.mouseDownX, extremes = xAxis2.getExtremes(), dataMin = extremes.dataMin, dataMax = extremes.dataMax, min4 = extremes.min, max4 = extremes.max, hoverPoints = chart.hoverPoints, closestPointRange = xAxis2.closestPointRange || xAxis2.ordinal?.overscrollPointsRange, pointPixelWidth = xAxis2.translationSlope * (xAxis2.ordinal.slope || closestPointRange), movedUnits = Math.round((mouseDownX - chartX) / pointPixelWidth), extendedOrdinalPositions = xAxis2.ordinal.getExtendedPositions(), extendedAxis = {
        ordinal: {
          positions: extendedOrdinalPositions,
          extendedOrdinalPositions
        }
      }, index2val2 = xAxis2.index2val, val2lin2 = xAxis2.val2lin;
      let trimmedRange, ordinalPositions;
      if (min4 <= dataMin && movedUnits < 0 || max4 + overscroll >= dataMax && movedUnits > 0) {
        return;
      }
      if (!extendedAxis.ordinal.positions) {
        runBase = true;
      } else if (Math.abs(movedUnits) > 1) {
        if (hoverPoints) {
          hoverPoints.forEach(function(point) {
            point.setState();
          });
        }
        ordinalPositions = extendedAxis.ordinal.positions;
        if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {
          ordinalPositions.push(dataMax);
        }
        chart.setFixedRange(max4 - min4);
        trimmedRange = xAxis2.navigatorAxis.toFixedRange(void 0, void 0, index2val2.apply(extendedAxis, [
          val2lin2.apply(extendedAxis, [min4, true]) + movedUnits
        ]), index2val2.apply(extendedAxis, [
          val2lin2.apply(extendedAxis, [max4, true]) + movedUnits
        ]));
        if (trimmedRange.min >= Math.min(ordinalPositions[0], min4) && trimmedRange.max <= Math.max(ordinalPositions[ordinalPositions.length - 1], max4) + overscroll) {
          xAxis2.setExtremes(trimmedRange.min, trimmedRange.max, true, false, { trigger: "pan" });
        }
        chart.mouseDownX = chartX;
        css12(chart.container, { cursor: "move" });
      }
    } else {
      runBase = true;
    }
    if (runBase || panning && /y/.test(panning.type)) {
      if (overscroll) {
        xAxis2.max = xAxis2.dataMax + overscroll;
      }
    } else {
      e.preventDefault();
    }
  }
  function onSeriesUpdatedData() {
    const xAxis2 = this.xAxis;
    if (xAxis2?.options.ordinal) {
      delete xAxis2.ordinal.index;
      delete xAxis2.ordinal.originalOrdinalRange;
    }
  }
  function val2lin(val, toIndex) {
    const axis = this, ordinal = axis.ordinal, ordinalPositions = ordinal.positions;
    let slope = ordinal.slope, extendedOrdinalPositions;
    if (!ordinalPositions) {
      return val;
    }
    const ordinalLength = ordinalPositions.length;
    let ordinalIndex;
    if (ordinalPositions[0] <= val && ordinalPositions[ordinalLength - 1] >= val) {
      ordinalIndex = getIndexInArray(ordinalPositions, val);
    } else {
      extendedOrdinalPositions = ordinal.getExtendedPositions?.();
      if (!extendedOrdinalPositions?.length) {
        return val;
      }
      const length = extendedOrdinalPositions.length;
      if (!slope) {
        slope = (extendedOrdinalPositions[length - 1] - extendedOrdinalPositions[0]) / length;
      }
      const originalPositionsReference = getIndexInArray(extendedOrdinalPositions, ordinalPositions[0]);
      if (val >= extendedOrdinalPositions[0] && val <= extendedOrdinalPositions[length - 1]) {
        ordinalIndex = getIndexInArray(extendedOrdinalPositions, val) - originalPositionsReference;
      } else {
        if (!toIndex) {
          return val;
        }
        if (val < extendedOrdinalPositions[0]) {
          const diff = extendedOrdinalPositions[0] - val, approximateIndexOffset = diff / slope;
          ordinalIndex = -originalPositionsReference - approximateIndexOffset;
        } else {
          const diff = val - extendedOrdinalPositions[length - 1], approximateIndexOffset = diff / slope;
          ordinalIndex = approximateIndexOffset + length - originalPositionsReference;
        }
      }
    }
    return toIndex ? ordinalIndex : slope * (ordinalIndex || 0) + ordinal.offset;
  }
  class Additions {
    /* *
     *
     *  Constructors
     *
     * */
    /**
     * @private
     */
    constructor(axis) {
      this.index = {};
      this.axis = axis;
    }
    /* *
    *
    *  Functions
    *
    * */
    /**
     * Calculate the ordinal positions before tick positions are calculated.
     * @private
     */
    beforeSetTickPositions() {
      const axis = this.axis, ordinal = axis.ordinal, extremes = axis.getExtremes(), min4 = extremes.min, max4 = extremes.max, hasBreaks = axis.brokenAxis?.hasBreaks, isOrdinal = axis.options.ordinal;
      let len, uniqueOrdinalPositions, dist, minIndex, maxIndex, slope, i, ordinalPositions = [], overscrollPointsRange = Number.MAX_VALUE, useOrdinal = false, adjustOrdinalExtremesPoints = false, isBoosted = false;
      if (isOrdinal || hasBreaks) {
        let distanceBetweenPoint = 0;
        axis.series.forEach(function(series, i2) {
          const xData = series.getColumn("x", true);
          uniqueOrdinalPositions = [];
          if (i2 > 0 && series.options.id !== "highcharts-navigator-series" && xData.length > 1) {
            adjustOrdinalExtremesPoints = distanceBetweenPoint !== xData[1] - xData[0];
          }
          distanceBetweenPoint = xData[1] - xData[0];
          if (series.boosted) {
            isBoosted = series.boosted;
          }
          if (series.reserveSpace() && (series.takeOrdinalPosition !== false || hasBreaks)) {
            ordinalPositions = ordinalPositions.concat(xData);
            len = ordinalPositions.length;
            ordinalPositions.sort(function(a, b) {
              return a - b;
            });
            overscrollPointsRange = Math.min(overscrollPointsRange, pick39(
              // Check for a single-point series:
              series.closestPointRange,
              overscrollPointsRange
            ));
            if (len) {
              i2 = 0;
              while (i2 < len - 1) {
                if (ordinalPositions[i2] !== ordinalPositions[i2 + 1]) {
                  uniqueOrdinalPositions.push(ordinalPositions[i2 + 1]);
                }
                i2++;
              }
              if (uniqueOrdinalPositions[0] !== ordinalPositions[0]) {
                uniqueOrdinalPositions.unshift(ordinalPositions[0]);
              }
              ordinalPositions = uniqueOrdinalPositions;
            }
          }
        });
        if (!axis.ordinal.originalOrdinalRange) {
          axis.ordinal.originalOrdinalRange = (ordinalPositions.length - 1) * overscrollPointsRange;
        }
        if (adjustOrdinalExtremesPoints && isBoosted) {
          ordinalPositions.pop();
          ordinalPositions.shift();
        }
        len = ordinalPositions.length;
        if (len > 2) {
          dist = ordinalPositions[1] - ordinalPositions[0];
          i = len - 1;
          while (i-- && !useOrdinal) {
            if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {
              useOrdinal = true;
            }
          }
          if (!axis.options.keepOrdinalPadding && (ordinalPositions[0] - min4 > dist || max4 - ordinalPositions[ordinalPositions.length - 1] > dist)) {
            useOrdinal = true;
          }
        } else if (axis.options.overscroll) {
          if (len === 2) {
            overscrollPointsRange = ordinalPositions[1] - ordinalPositions[0];
          } else if (len === 1) {
            overscrollPointsRange = axis.ordinal.convertOverscroll(axis.options.overscroll);
            ordinalPositions = [
              ordinalPositions[0],
              ordinalPositions[0] + overscrollPointsRange
            ];
          } else {
            overscrollPointsRange = ordinal.overscrollPointsRange;
          }
        }
        if (useOrdinal || axis.forceOrdinal) {
          if (axis.options.overscroll) {
            ordinal.overscrollPointsRange = overscrollPointsRange;
            ordinalPositions = ordinalPositions.concat(ordinal.getOverscrollPositions());
          }
          ordinal.positions = ordinalPositions;
          minIndex = axis.ordinal2lin(
            // #5979
            Math.max(min4, ordinalPositions[0]),
            true
          );
          maxIndex = Math.max(axis.ordinal2lin(Math.min(max4, ordinalPositions[ordinalPositions.length - 1]), true), 1);
          ordinal.slope = slope = (max4 - min4) / (maxIndex - minIndex);
          ordinal.offset = min4 - minIndex * slope;
        } else {
          ordinal.overscrollPointsRange = pick39(axis.closestPointRange, ordinal.overscrollPointsRange);
          ordinal.positions = axis.ordinal.slope = ordinal.offset = void 0;
        }
      }
      axis.isOrdinal = isOrdinal && useOrdinal;
      ordinal.groupIntervalFactor = null;
    }
    /**
     * Faster way of using the Array.indexOf method.
     * Works for sorted arrays only with unique values.
     *
     * @param {Array} sortedArray
     *        The sorted array inside which we are looking for.
     * @param {number} key
     *        The key to being found.
     * @param {boolean} indirectSearch
     *        In case of lack of the point in the array, should return
     *        value be equal to -1 or the closest smaller index.
     *  @private
     */
    static findIndexOf(sortedArray, key, indirectSearch) {
      let start = 0, end = sortedArray.length - 1, middle;
      while (start < end) {
        middle = Math.ceil((start + end) / 2);
        if (sortedArray[middle] <= key) {
          start = middle;
        } else {
          end = middle - 1;
        }
      }
      if (sortedArray[start] === key) {
        return start;
      }
      return !indirectSearch ? -1 : start;
    }
    /**
     * Get the ordinal positions for the entire data set. This is necessary
     * in chart panning because we need to find out what points or data
     * groups are available outside the visible range. When a panning
     * operation starts, if an index for the given grouping does not exists,
     * it is created and cached. This index is deleted on updated data, so
     * it will be regenerated the next time a panning operation starts.
     * @private
     */
    getExtendedPositions(withOverscroll = true) {
      const ordinal = this, axis = ordinal.axis, axisProto = axis.constructor.prototype, chart = axis.chart, key = axis.series.reduce((k, series) => {
        const grouping = series.currentDataGrouping;
        return k + (grouping ? grouping.count + grouping.unitName : "raw");
      }, ""), overscroll = withOverscroll ? axis.ordinal.convertOverscroll(axis.options.overscroll) : 0, extremes = axis.getExtremes();
      let fakeAxis, fakeSeries = void 0, ordinalIndex = ordinal.index;
      if (!ordinalIndex) {
        ordinalIndex = ordinal.index = {};
      }
      if (!ordinalIndex[key]) {
        fakeAxis = {
          series: [],
          chart,
          forceOrdinal: false,
          getExtremes: function() {
            return {
              min: extremes.dataMin,
              max: extremes.dataMax + overscroll
            };
          },
          applyGrouping: axisProto.applyGrouping,
          getGroupPixelWidth: axisProto.getGroupPixelWidth,
          getTimeTicks: axisProto.getTimeTicks,
          options: {
            ordinal: true
          },
          ordinal: {
            getGroupIntervalFactor: this.getGroupIntervalFactor
          },
          ordinal2lin: axisProto.ordinal2lin,
          // #6276
          getIndexOfPoint: axisProto.getIndexOfPoint,
          val2lin: axisProto.val2lin
          // #2590
        };
        fakeAxis.ordinal.axis = fakeAxis;
        axis.series.forEach((series) => {
          fakeSeries = {
            xAxis: fakeAxis,
            chart,
            groupPixelWidth: series.groupPixelWidth,
            destroyGroupedData: Globals_default.noop,
            getColumn: series.getColumn,
            applyGrouping: series.applyGrouping,
            getProcessedData: series.getProcessedData,
            reserveSpace: series.reserveSpace,
            visible: series.visible
          };
          const xData = series.getColumn("x").concat(withOverscroll ? ordinal.getOverscrollPositions() : []);
          fakeSeries.dataTable = new DataTableCore_default({
            columns: {
              x: xData
            }
          });
          fakeSeries.options = {
            ...series.options,
            dataGrouping: series.currentDataGrouping ? {
              firstAnchor: series.options.dataGrouping?.firstAnchor,
              anchor: series.options.dataGrouping?.anchor,
              lastAnchor: series.options.dataGrouping?.firstAnchor,
              enabled: true,
              forced: true,
              approximation: "open",
              units: [[
                series.currentDataGrouping.unitName,
                [series.currentDataGrouping.count]
              ]]
            } : {
              enabled: false
            }
          };
          fakeAxis.series.push(fakeSeries);
          series.processData.apply(fakeSeries);
        });
        fakeAxis.applyGrouping({ hasExtremesChanged: true });
        if (fakeSeries?.closestPointRange !== fakeSeries?.basePointRange && fakeSeries.currentDataGrouping) {
          fakeAxis.forceOrdinal = true;
        }
        axis.ordinal.beforeSetTickPositions.apply({ axis: fakeAxis });
        if (!axis.ordinal.originalOrdinalRange && fakeAxis.ordinal.originalOrdinalRange) {
          axis.ordinal.originalOrdinalRange = fakeAxis.ordinal.originalOrdinalRange;
        }
        if (fakeAxis.ordinal.positions) {
          ordinalIndex[key] = fakeAxis.ordinal.positions;
        }
      }
      return ordinalIndex[key];
    }
    /**
     * Find the factor to estimate how wide the plot area would have been if
     * ordinal gaps were included. This value is used to compute an imagined
     * plot width in order to establish the data grouping interval.
     *
     * A real world case is the intraday-candlestick example. Without this
     * logic, it would show the correct data grouping when viewing a range
     * within each day, but once moving the range to include the gap between
     * two days, the interval would include the cut-away night hours and the
     * data grouping would be wrong. So the below method tries to compensate
     * by identifying the most common point interval, in this case days.
     *
     * An opposite case is presented in issue #718. We have a long array of
     * daily data, then one point is appended one hour after the last point.
     * We expect the data grouping not to change.
     *
     * In the future, if we find cases where this estimation doesn't work
     * optimally, we might need to add a second pass to the data grouping
     * logic, where we do another run with a greater interval if the number
     * of data groups is more than a certain fraction of the desired group
     * count.
     * @private
     */
    getGroupIntervalFactor(xMin, xMax, series) {
      const ordinal = this, processedXData = series.getColumn("x", true), len = processedXData.length, distances = [];
      let median, i, groupIntervalFactor = ordinal.groupIntervalFactor;
      if (!groupIntervalFactor) {
        for (i = 0; i < len - 1; i++) {
          distances[i] = processedXData[i + 1] - processedXData[i];
        }
        distances.sort(function(a, b) {
          return a - b;
        });
        median = distances[Math.floor(len / 2)];
        xMin = Math.max(xMin, processedXData[0]);
        xMax = Math.min(xMax, processedXData[len - 1]);
        ordinal.groupIntervalFactor = groupIntervalFactor = len * median / (xMax - xMin);
      }
      return groupIntervalFactor;
    }
    /**
     * Get index of point inside the ordinal positions array.
     *
     * @private
     * @param {number} pixelVal
     * The pixel value of a point.
     *
     * @param {Array<number>} [ordinalArray]
     * An array of all points available on the axis for the given data set.
     * Either ordinalPositions if the value is inside the plotArea or
     * extendedOrdinalPositions if not.
     */
    getIndexOfPoint(pixelVal, ordinalArray) {
      const ordinal = this, axis = ordinal.axis, min4 = axis.min, minX = axis.minPixelPadding, indexOfMin = getIndexInArray(ordinalArray, min4);
      const ordinalPointPixelInterval = axis.translationSlope * (ordinal.slope || axis.closestPointRange || ordinal.overscrollPointsRange);
      const shiftIndex = correctFloat10((pixelVal - minX) / ordinalPointPixelInterval);
      return indexOfMin + shiftIndex;
    }
    /**
     * Get ticks for an ordinal axis within a range where points don't
     * exist. It is required when overscroll is enabled. We can't base on
     * points, because we may not have any, so we use approximated
     * pointRange and generate these ticks between Axis.dataMax,
     * Axis.dataMax + Axis.overscroll evenly spaced. Used in panning and
     * navigator scrolling.
     * @private
     */
    getOverscrollPositions() {
      const ordinal = this, axis = ordinal.axis, extraRange = ordinal.convertOverscroll(axis.options.overscroll), distance = ordinal.overscrollPointsRange, positions = [];
      let max4 = axis.dataMax;
      if (defined30(distance)) {
        while (max4 < axis.dataMax + extraRange) {
          max4 += distance;
          positions.push(max4);
        }
      }
      return positions;
    }
    /**
     * Make the tick intervals closer because the ordinal gaps make the
     * ticks spread out or cluster.
     * @private
     */
    postProcessTickInterval(tickInterval) {
      const ordinal = this, axis = ordinal.axis, ordinalSlope = ordinal.slope, closestPointRange = axis.closestPointRange;
      let ret;
      if (ordinalSlope && closestPointRange) {
        if (!axis.options.breaks) {
          ret = tickInterval / (ordinalSlope / closestPointRange);
        } else {
          ret = closestPointRange || tickInterval;
        }
      } else {
        ret = tickInterval;
      }
      return ret;
    }
    /**
     * If overscroll is pixel or percentage value, convert it to axis range.
     *
     * @private
     * @param {number | string} overscroll
     * Overscroll value in axis range, pixels or percentage value.
     * @return {number}
     * Overscroll value in axis range.
     */
    convertOverscroll(overscroll = 0) {
      const ordinal = this, axis = ordinal.axis, calculateOverscroll = function(overscrollPercentage) {
        return pick39(ordinal.originalOrdinalRange, defined30(axis.dataMax) && defined30(axis.dataMin) ? axis.dataMax - axis.dataMin : 0) * overscrollPercentage;
      };
      if (isString15(overscroll)) {
        const overscrollValue = parseInt(overscroll, 10);
        let isFullRange;
        if (defined30(axis.min) && defined30(axis.max) && defined30(axis.dataMin) && defined30(axis.dataMax)) {
          isFullRange = axis.max - axis.min === axis.dataMax - axis.dataMin;
          if (!isFullRange) {
            this.originalOrdinalRange = axis.max - axis.min;
          }
        }
        if (/%$/.test(overscroll)) {
          return calculateOverscroll(overscrollValue / 100);
        }
        if (/px/.test(overscroll)) {
          const limitedOverscrollValue = Math.min(overscrollValue, axis.len * 0.9), pixelToPercent = limitedOverscrollValue / axis.len;
          return calculateOverscroll(pixelToPercent / (isFullRange ? 1 - pixelToPercent : 1));
        }
        return 0;
      }
      return overscroll;
    }
  }
  OrdinalAxis2.Additions = Additions;
})(OrdinalAxis || (OrdinalAxis = {}));
var OrdinalAxis_default = OrdinalAxis;

// node_modules/highcharts/es-modules/Stock/RangeSelector/RangeSelectorDefaults.js
var lang = {
  /**
   * The text for the label for the range selector buttons.
   *
   * @product highstock gantt
   */
  rangeSelectorZoom: "Zoom",
  /**
   * The text for the label for the "from" input box in the range
   * selector. Since v9.0, this string is empty as the label is not
   * rendered by default.
   *
   * @product highstock gantt
   */
  rangeSelectorFrom: "",
  /**
   * The text for the label for the "to" input box in the range selector.
   *
   * @product highstock gantt
   */
  rangeSelectorTo: "",
  /**
   * The default text for the rangeselector buttons.
   *
   * @since 12.2.0
   */
  rangeSelector: {
    allText: "All",
    allTitle: "View all",
    monthText: "{count}m",
    monthTitle: "View {count} {#eq count 1}month{else}months{/eq}",
    yearText: "{count}y",
    yearTitle: "View {count} {#eq count 1}year{else}years{/eq}",
    ytdText: "YTD",
    ytdTitle: "View year to date"
  }
};
var rangeSelector = {
  /**
   * Whether to enable all buttons from the start. By default buttons are
   * only enabled if the corresponding time range exists on the X axis,
   * but enabling all buttons allows for dynamically loading different
   * time ranges.
   *
   * @sample {highstock} stock/rangeselector/allbuttonsenabled-true/
   *         All buttons enabled
   *
   * @since     2.0.3
   */
  allButtonsEnabled: false,
  /**
   * An array of configuration objects for the buttons.
   *
   * Defaults to:
   * ```js
   * buttons: [{
   *     type: 'month',
   *     count: 1,
   *     text: '1m',
   *     title: 'View 1 month'
   * }, {
   *     type: 'month',
   *     count: 3,
   *     text: '3m',
   *     title: 'View 3 months'
   * }, {
   *     type: 'month',
   *     count: 6,
   *     text: '6m',
   *     title: 'View 6 months'
   * }, {
   *     type: 'ytd',
   *     text: 'YTD',
   *     title: 'View year to date'
   * }, {
   *     type: 'year',
   *     count: 1,
   *     text: '1y',
   *     title: 'View 1 year'
   * }, {
   *     type: 'all',
   *     text: 'All',
   *     title: 'View all'
   * }]
   * ```
   *
   * @sample {highstock} stock/demo/rangeselector-datagrouping/
   *         Data grouping by buttons
   *
   * @type      {Array<*>}
   */
  buttons: [{
    type: "month",
    count: 1
  }, {
    type: "month",
    count: 3
  }, {
    type: "month",
    count: 6
  }, {
    type: "ytd"
  }, {
    type: "year",
    count: 1
  }, {
    type: "all"
  }],
  /**
   * How many units of the defined type the button should span. If `type`
   * is "month" and `count` is 3, the button spans three months.
   *
   * @type      {number}
   * @default   1
   * @apioption rangeSelector.buttons.count
   */
  /**
   * Fires when clicking on the rangeSelector button. One parameter,
   * event, is passed to the function, containing common event
   * information.
   *
   * ```js
   * click: function(e) {
   *   console.log(this);
   * }
   * ```
   *
   * Return false to stop default button's click action.
   *
   * @sample {highstock} stock/rangeselector/button-click/
   *         Click event on the button
   *
   * @type      {Highcharts.RangeSelectorClickCallbackFunction}
   * @apioption rangeSelector.buttons.events.click
   */
  /**
   * Additional range (in milliseconds) added to the end of the calculated
   * time span.
   *
   * @sample {highstock} stock/rangeselector/min-max-offsets/
   *         Button offsets
   *
   * @type      {number}
   * @default   0
   * @since     6.0.0
   * @apioption rangeSelector.buttons.offsetMax
   */
  /**
   * Additional range (in milliseconds) added to the start of the
   * calculated time span.
   *
   * @sample {highstock} stock/rangeselector/min-max-offsets/
   *         Button offsets
   *
   * @type      {number}
   * @default   0
   * @since     6.0.0
   * @apioption rangeSelector.buttons.offsetMin
   */
  /**
   * When buttons apply dataGrouping on a series, by default zooming
   * in/out will deselect buttons and unset dataGrouping. Enable this
   * option to keep buttons selected when extremes change.
   *
   * @sample {highstock} stock/rangeselector/preserve-datagrouping/
   *         Different preserveDataGrouping settings
   *
   * @type      {boolean}
   * @default   false
   * @since     6.1.2
   * @apioption rangeSelector.buttons.preserveDataGrouping
   */
  /**
   * A custom data grouping object for each button.
   *
   * @see [series.dataGrouping](#plotOptions.series.dataGrouping)
   *
   * @sample {highstock} stock/demo/rangeselector-datagrouping/
   *         Data grouping by range selector buttons
   *
   * @type      {*}
   * @extends   plotOptions.series.dataGrouping
   * @apioption rangeSelector.buttons.dataGrouping
   */
  /**
   * The text for the button itself.
   *
   * @type      {string}
   * @apioption rangeSelector.buttons.text
   */
  /**
   * Explanation for the button, shown as a tooltip on hover, and used by
   * assistive technology.
   *
   * @type      {string}
   * @apioption rangeSelector.buttons.title
   */
  /**
   * Defined the time span for the button. Can be one of `millisecond`,
   * `second`, `minute`, `hour`, `day`, `week`, `month`, `year`, `ytd`,
   * and `all`.
   *
   * @type       {Highcharts.RangeSelectorButtonTypeValue}
   * @apioption  rangeSelector.buttons.type
   */
  /**
   * The space in pixels between the buttons in the range selector.
   */
  buttonSpacing: 5,
  /**
   * Whether to collapse the range selector buttons into a dropdown when
   * there is not enough room to show everything in a single row, instead
   * of dividing the range selector into multiple rows.
   * Can be one of the following:
   *  - `always`: Always collapse
   *  - `responsive`: Only collapse when there is not enough room
   *  - `never`: Never collapse
   *
   * @sample {highstock} stock/rangeselector/dropdown/
   *         Dropdown option
   *
   * @validvalue ["always", "responsive", "never"]
   * @since 9.0.0
   */
  dropdown: "responsive",
  /**
   * Enable or disable the range selector. Default to `true` for stock
   * charts, using the `stockChart` factory.
   *
   * @sample {highstock} stock/rangeselector/enabled/
   *         Disable the range selector
   *
   * @type {boolean|undefined}
   * @default {highstock} true
   */
  enabled: void 0,
  /**
   * The vertical alignment of the rangeselector box. Allowed properties
   * are `top`, `middle`, `bottom`.
   *
   * @sample {highstock} stock/rangeselector/vertical-align-middle/
   *         Middle
   * @sample {highstock} stock/rangeselector/vertical-align-bottom/
   *         Bottom
   *
   * @type  {Highcharts.VerticalAlignValue}
   * @since 6.0.0
   */
  verticalAlign: "top",
  /**
   * A collection of attributes for the buttons. The object takes SVG
   * attributes like `fill`, `stroke`, `stroke-width`, as well as `style`,
   * a collection of CSS properties for the text.
   *
   * The object can also be extended with states, so you can set
   * presentational options for `hover`, `select` or `disabled` button
   * states.
   *
   * CSS styles for the text label.
   *
   * In styled mode, the buttons are styled by the
   * `.highcharts-range-selector-buttons .highcharts-button` rule with its
   * different states.
   *
   * @sample {highstock} stock/rangeselector/styling/
   *         Styling the buttons and inputs
   *
   * @type {Highcharts.SVGAttributes}
   */
  buttonTheme: {
    /** @ignore */
    width: 28,
    /** @ignore */
    height: 18,
    /** @ignore */
    padding: 2,
    /** @ignore */
    zIndex: 7
    // #484, #852
  },
  /**
   * When the rangeselector is floating, the plot area does not reserve
   * space for it. This opens for positioning anywhere on the chart.
   *
   * @sample {highstock} stock/rangeselector/floating/
   *         Placing the range selector between the plot area and the
   *         navigator
   *
   * @since 6.0.0
   */
  floating: false,
  /**
   * The x offset of the range selector relative to its horizontal
   * alignment within `chart.spacingLeft` and `chart.spacingRight`.
   *
   * @since 6.0.0
   */
  x: 0,
  /**
   * The y offset of the range selector relative to its horizontal
   * alignment within `chart.spacingLeft` and `chart.spacingRight`.
   *
   * @since 6.0.0
   */
  y: 0,
  /**
   * Deprecated. The height of the range selector. Currently it is
   * calculated dynamically.
   *
   * @deprecated
   * @type  {number|undefined}
   * @since 2.1.9
   */
  height: void 0,
  // Reserved space for buttons and input
  /**
   * The border color of the date input boxes.
   *
   * @sample {highstock} stock/rangeselector/styling/
   *         Styling the buttons and inputs
   *
   * @type      {Highcharts.ColorString}
   * @since     1.3.7
   */
  inputBoxBorderColor: "none",
  /**
   * The pixel height of the date input boxes.
   *
   * @sample {highstock} stock/rangeselector/styling/
   *         Styling the buttons and inputs
   *
   * @since     1.3.7
   */
  inputBoxHeight: 17,
  /**
   * The pixel width of the date input boxes. When `undefined`, the width
   * is fitted to the rendered content.
   *
   * @sample {highstock} stock/rangeselector/styling/
   *         Styling the buttons and inputs
   *
   * @type   {number|undefined}
   * @since  1.3.7
   */
  inputBoxWidth: void 0,
  /**
   * The date format in the input boxes when not selected for editing.
   * Defaults to `%e %b %Y`.
   *
   * This is used to determine which type of input to show,
   * `datetime-local`, `date` or `time` and falling back to `text` when
   * the browser does not support the input type or the format contains
   * milliseconds.
   *
   * @sample {highstock} stock/rangeselector/input-type/
   *         Input types
   * @sample {highstock} stock/rangeselector/input-format/
   *         Milliseconds in the range selector
   *
   */
  inputDateFormat: "%[ebY]",
  /**
   * A custom callback function to parse values entered in the input boxes and
   * return a valid JavaScript time as milliseconds since 1970. The first
   * argument passed is the value to parse, second is a boolean indicating use
   * of UTC time. The third is a reference to the `time` object. Time zone can
   * be read from `time.timezone`.
   *
   * This will only get called for inputs of type `text`. Since v8.2.3, the
   * input type is dynamically determined based on the granularity of the
   * `inputDateFormat` and the browser support.
   *
   * @sample {highstock} stock/rangeselector/input-format/
   *         Milliseconds in the range selector
   *
   * @type      {Highcharts.RangeSelectorParseCallbackFunction}
   * @since     1.3.3
   */
  inputDateParser: void 0,
  /**
   * The date format in the input boxes when they are selected for
   * editing. This must be a format that is recognized by JavaScript
   * Date.parse.
   *
   * This will only be used for inputs of type `text`. Since v8.2.3,
   * the input type is dynamically determined based on the granularity
   * of the `inputDateFormat` and the browser support.
   *
   * @sample {highstock} stock/rangeselector/input-format/
   *         Milliseconds in the range selector
   *
   */
  inputEditDateFormat: "%Y-%m-%d",
  /**
   * Enable or disable the date input boxes.
   */
  inputEnabled: true,
  /**
   * Positioning for the input boxes. Allowed properties are `align`,
   *  `x` and `y`.
   *
   * @since 1.2.4
   */
  inputPosition: {
    /**
     * The alignment of the input box. Allowed properties are `left`,
     * `center`, `right`.
     *
     * @sample {highstock} stock/rangeselector/input-button-opposite-alignment/
     *         Opposite alignment
     *
     * @sample {highstock} stock/rangeselector/input-button-same-alignment/
     *         Same alignment for buttons and input
     *
     * @type  {Highcharts.AlignValue}
     * @since 6.0.0
     */
    align: "right",
    /**
     * X offset of the input row.
     */
    x: 0,
    /**
     * Y offset of the input row.
     */
    y: 0
  },
  /**
   * The space in pixels between the labels and the date input boxes in
   * the range selector.
   *
   * @since 9.0.0
   */
  inputSpacing: 5,
  /**
   * The index of the button to appear pre-selected. If the selected range
   * exceeds the total data range and the 'all' option is available,
   * the 'all' option, showing the full range, is automatically selected.
   *
   * @type      {number}
   */
  selected: void 0,
  /**
   * Positioning for the button row.
   *
   * @since 1.2.4
   */
  buttonPosition: {
    /**
     * The alignment of the input box. Allowed properties are `left`,
     * `center`, `right`.
     *
     * @sample {highstock} stock/rangeselector/input-button-opposite-alignment/
     *         Opposite alignment
     *
     * @sample {highstock} stock/rangeselector/input-button-same-alignment/
     *         Same alignment for buttons and input
     *
     * @type  {Highcharts.AlignValue}
     * @since 6.0.0
     */
    align: "left",
    /**
     * X offset of the button row.
     */
    x: 0,
    /**
     * Y offset of the button row.
     */
    y: 0
  },
  /**
   * CSS for the HTML inputs in the range selector.
   *
   * In styled mode, the inputs are styled by the
   * `.highcharts-range-input text` rule in SVG mode, and
   * `input.highcharts-range-selector` when active.
   *
   * @sample {highstock} stock/rangeselector/styling/
   *         Styling the buttons and inputs
   *
   * @type      {Highcharts.CSSObject}
   * @apioption rangeSelector.inputStyle
   */
  inputStyle: {
    /** @ignore */
    color: "#334eff",
    /** @ignore */
    cursor: "pointer",
    /** @ignore */
    fontSize: "0.8em"
  },
  /**
   * CSS styles for the labels - the Zoom, From and To texts.
   *
   * In styled mode, the labels are styled by the
   * `.highcharts-range-label` class.
   *
   * @sample {highstock} stock/rangeselector/styling/
   *         Styling the buttons and inputs
   *
   * @type {Highcharts.CSSObject}
   */
  labelStyle: {
    /** @ignore */
    color: "#666666",
    /** @ignore */
    fontSize: "0.8em"
  }
};
var RangeSelectorDefaults = {
  lang,
  rangeSelector
};
var RangeSelectorDefaults_default = RangeSelectorDefaults;

// node_modules/highcharts/es-modules/Stock/RangeSelector/RangeSelectorComposition.js
var { defaultOptions: defaultOptions12 } = Defaults_default;
var { composed: composed10 } = Globals_default;
var { addEvent: addEvent27, defined: defined31, extend: extend32, isNumber: isNumber30, merge: merge35, pick: pick40, pushUnique: pushUnique13 } = Utilities_default;
var chartDestroyEvents = [];
var RangeSelectorConstructor;
function axisMinFromRange() {
  const rangeOptions = this.range, type = rangeOptions.type, max4 = this.max, time = this.chart.time, getTrueRange = function(base, count) {
    const original = time.toParts(base), modified = original.slice();
    if (type === "year") {
      modified[0] += count;
    } else {
      modified[1] += count;
    }
    let d = time.makeTime.apply(time, modified);
    const numbers = time.toParts(d);
    if (type === "month" && original[1] === numbers[1] && Math.abs(count) === 1) {
      modified[0] = original[0];
      modified[1] = original[1];
      modified[2] = 0;
    }
    d = time.makeTime.apply(time, modified);
    return d - base;
  };
  let min4, range2;
  if (isNumber30(rangeOptions)) {
    min4 = max4 - rangeOptions;
    range2 = rangeOptions;
  } else if (rangeOptions) {
    min4 = max4 + getTrueRange(max4, -(rangeOptions.count || 1));
    if (this.chart) {
      this.chart.setFixedRange(max4 - min4);
    }
  }
  const dataMin = pick40(this.dataMin, Number.MIN_VALUE);
  if (!isNumber30(min4)) {
    min4 = dataMin;
  }
  if (min4 <= dataMin) {
    min4 = dataMin;
    if (typeof range2 === "undefined") {
      range2 = getTrueRange(min4, rangeOptions.count);
    }
    this.newMax = Math.min(min4 + range2, pick40(this.dataMax, Number.MAX_VALUE));
  }
  if (!isNumber30(max4)) {
    min4 = void 0;
  } else if (!isNumber30(rangeOptions) && rangeOptions && rangeOptions._offsetMin) {
    min4 += rangeOptions._offsetMin;
  }
  return min4;
}
function updateRangeSelectorButtons() {
  this.rangeSelector?.redrawElements();
}
function compose5(AxisClass, ChartClass, RangeSelectorClass) {
  RangeSelectorConstructor = RangeSelectorClass;
  if (pushUnique13(composed10, "RangeSelector")) {
    const chartProto = ChartClass.prototype;
    AxisClass.prototype.minFromRange = axisMinFromRange;
    addEvent27(ChartClass, "afterGetContainer", createRangeSelector);
    addEvent27(ChartClass, "beforeRender", onChartBeforeRender2);
    addEvent27(ChartClass, "destroy", onChartDestroy);
    addEvent27(ChartClass, "getMargins", onChartGetMargins);
    addEvent27(ChartClass, "redraw", redrawRangeSelector);
    addEvent27(ChartClass, "update", onChartUpdate2);
    addEvent27(ChartClass, "beforeRedraw", updateRangeSelectorButtons);
    chartProto.callbacks.push(redrawRangeSelector);
    extend32(defaultOptions12, { rangeSelector: RangeSelectorDefaults_default.rangeSelector });
    extend32(defaultOptions12.lang, RangeSelectorDefaults_default.lang);
  }
}
function createRangeSelector() {
  if (this.options.rangeSelector && this.options.rangeSelector.enabled) {
    this.rangeSelector = new RangeSelectorConstructor(this);
  }
}
function onChartBeforeRender2() {
  const chart = this, rangeSelector2 = chart.rangeSelector;
  if (rangeSelector2) {
    if (isNumber30(rangeSelector2.deferredYTDClick)) {
      rangeSelector2.clickButton(rangeSelector2.deferredYTDClick);
      delete rangeSelector2.deferredYTDClick;
    }
    const verticalAlign = rangeSelector2.options.verticalAlign;
    if (!rangeSelector2.options.floating) {
      if (verticalAlign === "bottom") {
        this.extraBottomMargin = true;
      } else if (verticalAlign === "top") {
        this.extraTopMargin = true;
      }
    }
  }
}
function redrawRangeSelector() {
  const chart = this;
  const rangeSelector2 = this.rangeSelector;
  if (!rangeSelector2) {
    return;
  }
  let alignTo;
  const extremes = chart.xAxis[0].getExtremes();
  const legend = chart.legend;
  const verticalAlign = rangeSelector2 && rangeSelector2.options.verticalAlign;
  if (isNumber30(extremes.min)) {
    rangeSelector2.render(extremes.min, extremes.max);
  }
  if (legend.display && verticalAlign === "top" && verticalAlign === legend.options.verticalAlign) {
    alignTo = merge35(chart.spacingBox);
    if (legend.options.layout === "vertical") {
      alignTo.y = chart.plotTop;
    } else {
      alignTo.y += rangeSelector2.getHeight();
    }
    legend.group.placed = false;
    legend.align(alignTo);
  }
}
function onChartDestroy() {
  for (let i = 0, iEnd = chartDestroyEvents.length; i < iEnd; ++i) {
    const events = chartDestroyEvents[i];
    if (events[0] === this) {
      events[1].forEach((unbind) => unbind());
      chartDestroyEvents.splice(i, 1);
      return;
    }
  }
}
function onChartGetMargins() {
  const rangeSelector2 = this.rangeSelector;
  if (rangeSelector2?.options?.enabled) {
    const rangeSelectorHeight = rangeSelector2.getHeight();
    const verticalAlign = rangeSelector2.options.verticalAlign;
    if (!rangeSelector2.options.floating) {
      if (verticalAlign === "bottom") {
        this.marginBottom += rangeSelectorHeight;
      } else if (verticalAlign !== "middle") {
        this.plotTop += rangeSelectorHeight;
      }
    }
  }
}
function onChartUpdate2(e) {
  const chart = this, options2 = e.options, optionsRangeSelector = options2.rangeSelector, extraBottomMarginWas = this.extraBottomMargin, extraTopMarginWas = this.extraTopMargin;
  let rangeSelector2 = chart.rangeSelector;
  if (optionsRangeSelector && optionsRangeSelector.enabled && !defined31(rangeSelector2) && this.options.rangeSelector) {
    this.options.rangeSelector.enabled = true;
    this.rangeSelector = rangeSelector2 = new RangeSelectorConstructor(this);
  }
  this.extraBottomMargin = false;
  this.extraTopMargin = false;
  if (rangeSelector2) {
    const verticalAlign = optionsRangeSelector && optionsRangeSelector.verticalAlign || rangeSelector2.options && rangeSelector2.options.verticalAlign;
    if (!rangeSelector2.options.floating) {
      if (verticalAlign === "bottom") {
        this.extraBottomMargin = true;
      } else if (verticalAlign !== "middle") {
        this.extraTopMargin = true;
      }
    }
    if (this.extraBottomMargin !== extraBottomMarginWas || this.extraTopMargin !== extraTopMarginWas) {
      this.isDirtyBox = true;
    }
  }
}
var RangeSelectorComposition = {
  compose: compose5
};
var RangeSelectorComposition_default = RangeSelectorComposition;

// node_modules/highcharts/es-modules/Stock/RangeSelector/RangeSelector.js
var { defaultOptions: defaultOptions13 } = Defaults_default;
var { format: format8 } = Templating_default;
var { addEvent: addEvent28, createElement: createElement9, css: css13, defined: defined32, destroyObjectProperties: destroyObjectProperties11, diffObjects: diffObjects5, discardElement: discardElement5, extend: extend33, fireEvent: fireEvent24, isNumber: isNumber31, isString: isString16, merge: merge36, objectEach: objectEach21, pick: pick41, splat: splat10 } = Utilities_default;
function preferredInputType(format18) {
  const hasTimeKey = (char) => new RegExp(`%[[a-zA-Z]*${char}`).test(format18);
  const ms = isString16(format18) ? format18.indexOf("%L") !== -1 : (
    // Implemented but not typed as of 2024
    format18.fractionalSecondDigits
  );
  if (ms) {
    return "text";
  }
  const date = isString16(format18) ? ["a", "A", "d", "e", "w", "b", "B", "m", "o", "y", "Y"].some(hasTimeKey) : format18.dateStyle || format18.day || format18.month || format18.year;
  const time = isString16(format18) ? ["H", "k", "I", "l", "M", "S"].some(hasTimeKey) : format18.timeStyle || format18.hour || format18.minute || format18.second;
  if (date && time) {
    return "datetime-local";
  }
  if (date) {
    return "date";
  }
  if (time) {
    return "time";
  }
  return "text";
}
var RangeSelector = class _RangeSelector {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * @private
   */
  static compose(AxisClass, ChartClass) {
    RangeSelectorComposition_default.compose(AxisClass, ChartClass, _RangeSelector);
  }
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart) {
    this.isDirty = false;
    this.buttonOptions = [];
    this.initialButtonGroupWidth = 0;
    this.maxButtonWidth = () => {
      let buttonWidth = 0;
      this.buttons.forEach((button) => {
        const bBox = button.getBBox();
        if (bBox.width > buttonWidth) {
          buttonWidth = bBox.width;
        }
      });
      return buttonWidth;
    };
    this.init(chart);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * The method to run when one of the buttons in the range selectors is
   * clicked
   *
   * @private
   * @function Highcharts.RangeSelector#clickButton
   * @param {number} i
   *        The index of the button
   * @param {boolean} [redraw]
   */
  clickButton(i, redraw) {
    const rangeSelector2 = this, chart = rangeSelector2.chart, rangeOptions = rangeSelector2.buttonOptions[i], baseAxis = chart.xAxis[0], unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || baseAxis || {}, type = rangeOptions.type, dataGrouping = rangeOptions.dataGrouping;
    let dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, newMin, newMax = isNumber31(baseAxis?.max) ? Math.round(Math.min(baseAxis.max, dataMax ?? baseAxis.max)) : void 0, baseXAxisOptions, range2 = rangeOptions._range, rangeMin, ctx, ytdExtremes, addOffsetMin = true;
    if (dataMin === null || dataMax === null) {
      return;
    }
    rangeSelector2.setSelected(i);
    if (dataGrouping) {
      this.forcedDataGrouping = true;
      Axis_default.prototype.setDataGrouping.call(baseAxis || { chart: this.chart }, dataGrouping, false);
      this.frozenStates = rangeOptions.preserveDataGrouping;
    }
    if (type === "month" || type === "year") {
      if (!baseAxis) {
        range2 = rangeOptions;
      } else {
        ctx = {
          range: rangeOptions,
          max: newMax,
          chart,
          dataMin,
          dataMax
        };
        newMin = baseAxis.minFromRange.call(ctx);
        if (isNumber31(ctx.newMax)) {
          newMax = ctx.newMax;
        }
        addOffsetMin = false;
      }
    } else if (range2) {
      if (isNumber31(newMax)) {
        newMin = Math.max(newMax - range2, dataMin);
        newMax = Math.min(newMin + range2, dataMax);
        addOffsetMin = false;
      }
    } else if (type === "ytd") {
      if (baseAxis) {
        if (baseAxis.hasData() && (!isNumber31(dataMax) || !isNumber31(dataMin))) {
          dataMin = Number.MAX_VALUE;
          dataMax = -Number.MAX_VALUE;
          chart.series.forEach((series) => {
            const xData = series.getColumn("x");
            if (xData.length) {
              dataMin = Math.min(xData[0], dataMin);
              dataMax = Math.max(xData[xData.length - 1], dataMax);
            }
          });
          redraw = false;
        }
        if (isNumber31(dataMax) && isNumber31(dataMin)) {
          ytdExtremes = rangeSelector2.getYTDExtremes(dataMax, dataMin);
          newMin = rangeMin = ytdExtremes.min;
          newMax = ytdExtremes.max;
        }
      } else {
        rangeSelector2.deferredYTDClick = i;
        return;
      }
    } else if (type === "all" && baseAxis) {
      if (chart.navigator && chart.navigator.baseSeries[0]) {
        chart.navigator.baseSeries[0].xAxis.options.range = void 0;
      }
      newMin = dataMin;
      newMax = dataMax;
    }
    if (addOffsetMin && rangeOptions._offsetMin && defined32(newMin)) {
      newMin += rangeOptions._offsetMin;
    }
    if (rangeOptions._offsetMax && defined32(newMax)) {
      newMax += rangeOptions._offsetMax;
    }
    if (this.dropdown) {
      this.dropdown.selectedIndex = i + 1;
    }
    if (!baseAxis) {
      baseXAxisOptions = splat10(chart.options.xAxis || {})[0];
      const axisRangeUpdateEvent = addEvent28(chart, "afterCreateAxes", function() {
        const xAxis2 = chart.xAxis[0];
        xAxis2.range = xAxis2.options.range = range2;
        xAxis2.min = xAxis2.options.min = rangeMin;
      });
      addEvent28(chart, "load", function resetMinAndRange() {
        const xAxis2 = chart.xAxis[0];
        chart.setFixedRange(rangeOptions._range);
        xAxis2.options.range = baseXAxisOptions.range;
        xAxis2.options.min = baseXAxisOptions.min;
        axisRangeUpdateEvent();
      });
    } else if (isNumber31(newMin) && isNumber31(newMax)) {
      baseAxis.setExtremes(
        newMin,
        newMax,
        pick41(redraw, true),
        void 0,
        // Auto animation
        {
          trigger: "rangeSelectorButton",
          rangeSelectorButton: rangeOptions
        }
      );
      chart.setFixedRange(rangeOptions._range);
    }
    fireEvent24(this, "afterBtnClick");
  }
  /**
   * Set the selected option. This method only sets the internal flag, it
   * doesn't update the buttons or the actual zoomed range.
   *
   * @private
   * @function Highcharts.RangeSelector#setSelected
   * @param {number} [selected]
   */
  setSelected(selected) {
    this.selected = this.options.selected = selected;
  }
  /**
   * Initialize the range selector
   *
   * @private
   * @function Highcharts.RangeSelector#init
   * @param {Highcharts.Chart} chart
   */
  init(chart) {
    const rangeSelector2 = this, options2 = chart.options.rangeSelector, langOptions2 = chart.options.lang, buttonOptions = options2.buttons, selectedOption = options2.selected, blurInputs = function() {
      const minInput = rangeSelector2.minInput, maxInput = rangeSelector2.maxInput;
      if (minInput && !!minInput.blur) {
        fireEvent24(minInput, "blur");
      }
      if (maxInput && !!maxInput.blur) {
        fireEvent24(maxInput, "blur");
      }
    };
    rangeSelector2.chart = chart;
    rangeSelector2.options = options2;
    rangeSelector2.buttons = [];
    rangeSelector2.buttonOptions = buttonOptions.map((opt) => {
      if (opt.type && langOptions2.rangeSelector) {
        opt.text ?? (opt.text = langOptions2.rangeSelector[`${opt.type}Text`]);
        opt.title ?? (opt.title = langOptions2.rangeSelector[`${opt.type}Title`]);
      }
      opt.text = format8(opt.text, {
        count: opt.count || 1
      });
      opt.title = format8(opt.title, {
        count: opt.count || 1
      });
      return opt;
    });
    this.eventsToUnbind = [];
    this.eventsToUnbind.push(addEvent28(chart.container, "mousedown", blurInputs));
    this.eventsToUnbind.push(addEvent28(chart, "resize", blurInputs));
    buttonOptions.forEach(rangeSelector2.computeButtonRange);
    if (typeof selectedOption !== "undefined" && buttonOptions[selectedOption]) {
      this.clickButton(selectedOption, false);
    }
    this.eventsToUnbind.push(addEvent28(chart, "load", function() {
      if (chart.xAxis && chart.xAxis[0]) {
        addEvent28(chart.xAxis[0], "setExtremes", function(e) {
          if (isNumber31(this.max) && isNumber31(this.min) && this.max - this.min !== chart.fixedRange && e.trigger !== "rangeSelectorButton" && e.trigger !== "updatedData" && rangeSelector2.forcedDataGrouping && !rangeSelector2.frozenStates) {
            this.setDataGrouping(false, false);
          }
        });
      }
    }));
    this.createElements();
  }
  /**
   * Dynamically update the range selector buttons after a new range has been
   * set
   *
   * @private
   * @function Highcharts.RangeSelector#updateButtonStates
   */
  updateButtonStates() {
    const rangeSelector2 = this, chart = this.chart, dropdown = this.dropdown, dropdownLabel = this.dropdownLabel, baseAxis = chart.xAxis[0], actualRange = Math.round(baseAxis.max - baseAxis.min), hasNoData = !baseAxis.hasVisibleSeries, day = 24 * 36e5, unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || baseAxis, dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, ytdExtremes = rangeSelector2.getYTDExtremes(dataMax, dataMin), ytdMin = ytdExtremes.min, ytdMax = ytdExtremes.max, selected = rangeSelector2.selected, allButtonsEnabled = rangeSelector2.options.allButtonsEnabled, buttonStates = new Array(rangeSelector2.buttonOptions.length).fill(0), selectedExists = isNumber31(selected), buttons = rangeSelector2.buttons;
    let isSelectedTooGreat = false, selectedIndex = null;
    rangeSelector2.buttonOptions.forEach((rangeOptions, i) => {
      const range2 = rangeOptions._range, type = rangeOptions.type, count = rangeOptions.count || 1, offsetRange = rangeOptions._offsetMax - rangeOptions._offsetMin, isSelected = i === selected, isTooGreatRange = range2 > dataMax - dataMin, isTooSmallRange = range2 < baseAxis.minRange;
      let isYTDButNotSelected = false, isSameRange = range2 === actualRange;
      if (isSelected && isTooGreatRange) {
        isSelectedTooGreat = true;
      }
      if (baseAxis.isOrdinal && baseAxis.ordinal?.positions && range2 && actualRange < range2) {
        const positions = baseAxis.ordinal.positions, prevOrdinalPosition = OrdinalAxis_default.Additions.findIndexOf(positions, baseAxis.min, true), nextOrdinalPosition = Math.min(OrdinalAxis_default.Additions.findIndexOf(positions, baseAxis.max, true) + 1, positions.length - 1);
        if (positions[nextOrdinalPosition] - positions[prevOrdinalPosition] > range2) {
          isSameRange = true;
        }
      } else if (
        // Months and years have variable range so we check the extremes
        (type === "month" || type === "year") && actualRange + 36e5 >= { month: 28, year: 365 }[type] * day * count - offsetRange && actualRange - 36e5 <= { month: 31, year: 366 }[type] * day * count + offsetRange
      ) {
        isSameRange = true;
      } else if (type === "ytd") {
        isSameRange = ytdMax - ytdMin + offsetRange === actualRange;
        isYTDButNotSelected = !isSelected;
      } else if (type === "all") {
        isSameRange = baseAxis.max - baseAxis.min >= dataMax - dataMin;
      }
      const disable = !allButtonsEnabled && !(isSelectedTooGreat && type === "all") && (isTooGreatRange || isTooSmallRange || hasNoData);
      const select = isSelectedTooGreat && type === "all" || (isYTDButNotSelected ? false : isSameRange) || isSelected && rangeSelector2.frozenStates;
      if (disable) {
        buttonStates[i] = 3;
      } else if (select) {
        if (!selectedExists || i === selected) {
          selectedIndex = i;
        }
      }
    });
    if (selectedIndex !== null) {
      buttonStates[selectedIndex] = 2;
      rangeSelector2.setSelected(selectedIndex);
      if (this.dropdown) {
        this.dropdown.selectedIndex = selectedIndex + 1;
      }
    } else {
      rangeSelector2.setSelected();
      if (this.dropdown) {
        this.dropdown.selectedIndex = -1;
      }
      if (dropdownLabel) {
        dropdownLabel.setState(0);
        dropdownLabel.attr({
          text: (defaultOptions13.lang.rangeSelectorZoom || "") + " "
        });
      }
    }
    for (let i = 0; i < buttonStates.length; i++) {
      const state = buttonStates[i];
      const button = buttons[i];
      if (button.state !== state) {
        button.setState(state);
        if (dropdown) {
          dropdown.options[i + 1].disabled = state === 3;
          if (state === 2) {
            if (dropdownLabel) {
              dropdownLabel.setState(2);
              dropdownLabel.attr({
                text: rangeSelector2.buttonOptions[i].text + " "
              });
            }
            dropdown.selectedIndex = i + 1;
          }
          const bbox = dropdownLabel.getBBox();
          css13(dropdown, {
            width: `${bbox.width}px`,
            height: `${bbox.height}px`
          });
        }
      }
    }
  }
  /**
   * Compute and cache the range for an individual button
   *
   * @private
   * @function Highcharts.RangeSelector#computeButtonRange
   * @param {Highcharts.RangeSelectorButtonsOptions} rangeOptions
   */
  computeButtonRange(rangeOptions) {
    const type = rangeOptions.type, count = rangeOptions.count || 1, fixedTimes = {
      millisecond: 1,
      second: 1e3,
      minute: 60 * 1e3,
      hour: 3600 * 1e3,
      day: 24 * 3600 * 1e3,
      week: 7 * 24 * 3600 * 1e3
    };
    if (fixedTimes[type]) {
      rangeOptions._range = fixedTimes[type] * count;
    } else if (type === "month" || type === "year") {
      rangeOptions._range = {
        month: 30,
        year: 365
      }[type] * 24 * 36e5 * count;
    }
    rangeOptions._offsetMin = pick41(rangeOptions.offsetMin, 0);
    rangeOptions._offsetMax = pick41(rangeOptions.offsetMax, 0);
    rangeOptions._range += rangeOptions._offsetMax - rangeOptions._offsetMin;
  }
  /**
   * Get the unix timestamp of a HTML input for the dates
   *
   * @private
   * @function Highcharts.RangeSelector#getInputValue
   */
  getInputValue(name) {
    const input = name === "min" ? this.minInput : this.maxInput;
    const options2 = this.chart.options.rangeSelector;
    const time = this.chart.time;
    if (input) {
      return (input.type === "text" && options2.inputDateParser || this.defaultInputDateParser)(input.value, time.timezone === "UTC", time);
    }
    return 0;
  }
  /**
   * Set the internal and displayed value of a HTML input for the dates
   *
   * @private
   * @function Highcharts.RangeSelector#setInputValue
   */
  setInputValue(name, inputTime) {
    const options2 = this.options, time = this.chart.time, input = name === "min" ? this.minInput : this.maxInput, dateBox = name === "min" ? this.minDateBox : this.maxDateBox;
    if (input) {
      input.setAttribute("type", preferredInputType(options2.inputDateFormat || "%e %b %Y"));
      const hcTimeAttr = input.getAttribute("data-hc-time");
      let updatedTime = defined32(hcTimeAttr) ? Number(hcTimeAttr) : void 0;
      if (defined32(inputTime)) {
        const previousTime = updatedTime;
        if (defined32(previousTime)) {
          input.setAttribute("data-hc-time-previous", previousTime);
        }
        input.setAttribute("data-hc-time", inputTime);
        updatedTime = inputTime;
      }
      input.value = time.dateFormat(this.inputTypeFormats[input.type] || options2.inputEditDateFormat, updatedTime);
      if (dateBox) {
        dateBox.attr({
          text: time.dateFormat(options2.inputDateFormat, updatedTime)
        });
      }
    }
  }
  /**
   * Set the min and max value of a HTML input for the dates
   *
   * @private
   * @function Highcharts.RangeSelector#setInputExtremes
   */
  setInputExtremes(name, min4, max4) {
    const input = name === "min" ? this.minInput : this.maxInput;
    if (input) {
      const format18 = this.inputTypeFormats[input.type];
      const time = this.chart.time;
      if (format18) {
        const newMin = time.dateFormat(format18, min4);
        if (input.min !== newMin) {
          input.min = newMin;
        }
        const newMax = time.dateFormat(format18, max4);
        if (input.max !== newMax) {
          input.max = newMax;
        }
      }
    }
  }
  /**
   * @private
   * @function Highcharts.RangeSelector#showInput
   * @param {string} name
   */
  showInput(name) {
    const dateBox = name === "min" ? this.minDateBox : this.maxDateBox, input = name === "min" ? this.minInput : this.maxInput;
    if (input && dateBox && this.inputGroup) {
      const isTextInput = input.type === "text", { translateX = 0, translateY = 0 } = this.inputGroup, { x = 0, width = 0, height = 0 } = dateBox, { inputBoxWidth } = this.options;
      css13(input, {
        width: isTextInput ? width + (inputBoxWidth ? -2 : 20) + "px" : "auto",
        height: height - 2 + "px",
        border: "2px solid silver"
      });
      if (isTextInput && inputBoxWidth) {
        css13(input, {
          left: translateX + x + "px",
          top: translateY + "px"
        });
      } else {
        css13(input, {
          left: Math.min(Math.round(x + translateX - (input.offsetWidth - width) / 2), this.chart.chartWidth - input.offsetWidth) + "px",
          top: translateY - (input.offsetHeight - height) / 2 + "px"
        });
      }
    }
  }
  /**
   * @private
   * @function Highcharts.RangeSelector#hideInput
   * @param {string} name
   */
  hideInput(name) {
    const input = name === "min" ? this.minInput : this.maxInput;
    if (input) {
      css13(input, {
        top: "-9999em",
        border: 0,
        width: "1px",
        height: "1px"
      });
    }
  }
  /**
   * @private
   * @function Highcharts.RangeSelector#defaultInputDateParser
   */
  defaultInputDateParser(inputDate, useUTC, time) {
    return time?.parse(inputDate) || 0;
  }
  /**
   * Draw either the 'from' or the 'to' HTML input box of the range selector
   *
   * @private
   * @function Highcharts.RangeSelector#drawInput
   */
  drawInput(name) {
    const { chart, div, inputGroup } = this;
    const rangeSelector2 = this, chartStyle = chart.renderer.style || {}, renderer = chart.renderer, options2 = chart.options.rangeSelector, lang6 = defaultOptions13.lang, isMin = name === "min";
    function updateExtremes(name2) {
      const { maxInput, minInput } = rangeSelector2, chartAxis = chart.xAxis[0], unionExtremes = chart.scroller?.getUnionExtremes() || chartAxis, dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, currentExtreme = chart.xAxis[0].getExtremes()[name2];
      let value = rangeSelector2.getInputValue(name2);
      if (isNumber31(value) && value !== currentExtreme) {
        if (isMin && maxInput && isNumber31(dataMin)) {
          if (value > Number(maxInput.getAttribute("data-hc-time"))) {
            value = void 0;
          } else if (value < dataMin) {
            value = dataMin;
          }
        } else if (minInput && isNumber31(dataMax)) {
          if (value < Number(minInput.getAttribute("data-hc-time"))) {
            value = void 0;
          } else if (value > dataMax) {
            value = dataMax;
          }
        }
        if (typeof value !== "undefined") {
          chartAxis.setExtremes(isMin ? value : chartAxis.min, isMin ? chartAxis.max : value, void 0, void 0, { trigger: "rangeSelectorInput" });
        }
      }
    }
    const text = lang6[isMin ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
    const label = renderer.label(text, 0).addClass("highcharts-range-label").attr({
      padding: text ? 2 : 0,
      height: text ? options2.inputBoxHeight : 0
    }).add(inputGroup);
    const dateBox = renderer.label("", 0).addClass("highcharts-range-input").attr({
      padding: 2,
      width: options2.inputBoxWidth,
      height: options2.inputBoxHeight,
      "text-align": "center"
    }).on("click", function() {
      rangeSelector2.showInput(name);
      rangeSelector2[name + "Input"].focus();
    });
    if (!chart.styledMode) {
      dateBox.attr({
        stroke: options2.inputBoxBorderColor,
        "stroke-width": 1
      });
    }
    dateBox.add(inputGroup);
    const input = createElement9("input", {
      name,
      className: "highcharts-range-selector"
    }, void 0, div);
    input.setAttribute("type", preferredInputType(options2.inputDateFormat || "%e %b %Y"));
    if (!chart.styledMode) {
      label.css(merge36(chartStyle, options2.labelStyle));
      dateBox.css(merge36({
        color: "#333333"
        /* Palette.neutralColor80 */
      }, chartStyle, options2.inputStyle));
      css13(input, extend33({
        position: "absolute",
        border: 0,
        boxShadow: "0 0 15px rgba(0,0,0,0.3)",
        width: "1px",
        // Chrome needs a pixel to see it
        height: "1px",
        padding: 0,
        textAlign: "center",
        fontSize: chartStyle.fontSize,
        fontFamily: chartStyle.fontFamily,
        top: "-9999em"
        // #4798
      }, options2.inputStyle));
    }
    input.onfocus = () => {
      rangeSelector2.showInput(name);
    };
    input.onblur = () => {
      if (input === Globals_default.doc.activeElement) {
        updateExtremes(name);
      }
      rangeSelector2.hideInput(name);
      rangeSelector2.setInputValue(name);
      input.blur();
    };
    let keyDown = false;
    input.onchange = () => {
      if (!keyDown) {
        updateExtremes(name);
        rangeSelector2.hideInput(name);
        input.blur();
      }
    };
    input.onkeypress = (event) => {
      if (event.keyCode === 13) {
        updateExtremes(name);
      }
    };
    input.onkeydown = (event) => {
      keyDown = true;
      if (event.key === "ArrowUp" || event.key === "ArrowDown" || event.key === "Tab") {
        updateExtremes(name);
      }
    };
    input.onkeyup = () => {
      keyDown = false;
    };
    return { dateBox, input, label };
  }
  /**
   * Get the position of the range selector buttons and inputs. This can be
   * overridden from outside for custom positioning.
   *
   * @private
   * @function Highcharts.RangeSelector#getPosition
   */
  getPosition() {
    const chart = this.chart, options2 = chart.options.rangeSelector, top = options2.verticalAlign === "top" ? chart.plotTop - chart.axisOffset[0] : 0;
    return {
      buttonTop: top + options2.buttonPosition.y,
      inputTop: top + options2.inputPosition.y - 10
    };
  }
  /**
   * Get the extremes of YTD. Will choose dataMax if its value is lower than
   * the current timestamp. Will choose dataMin if its value is higher than
   * the timestamp for the start of current year.
   *
   * @private
   * @function Highcharts.RangeSelector#getYTDExtremes
   * @return {*}
   * Returns min and max for the YTD
   */
  getYTDExtremes(dataMax, dataMin) {
    const time = this.chart.time, year = time.toParts(dataMax)[0], startOfYear = time.makeTime(year, 0);
    return {
      max: dataMax,
      min: Math.max(dataMin, startOfYear)
    };
  }
  createElements() {
    const chart = this.chart, renderer = chart.renderer, container = chart.container, chartOptions = chart.options, options2 = chartOptions.rangeSelector, inputEnabled = options2.inputEnabled, inputsZIndex = pick41(chartOptions.chart.style?.zIndex, 0) + 1;
    if (options2.enabled === false) {
      return;
    }
    this.group = renderer.g("range-selector-group").attr({
      zIndex: 7
    }).add();
    this.div = createElement9("div", void 0, {
      position: "relative",
      height: 0,
      zIndex: inputsZIndex
    });
    if (this.buttonOptions.length) {
      this.renderButtons();
    }
    if (container.parentNode) {
      container.parentNode.insertBefore(this.div, container);
    }
    if (inputEnabled) {
      this.createInputs();
    }
  }
  /**
   * Create the input elements and its group.
   *
   */
  createInputs() {
    this.inputGroup = this.chart.renderer.g("input-group").add(this.group);
    const minElems = this.drawInput("min");
    this.minDateBox = minElems.dateBox;
    this.minLabel = minElems.label;
    this.minInput = minElems.input;
    const maxElems = this.drawInput("max");
    this.maxDateBox = maxElems.dateBox;
    this.maxLabel = maxElems.label;
    this.maxInput = maxElems.input;
  }
  /**
   * Render the range selector including the buttons and the inputs. The first
   * time render is called, the elements are created and positioned. On
   * subsequent calls, they are moved and updated.
   *
   * @private
   * @function Highcharts.RangeSelector#render
   * @param {number} [min]
   *        X axis minimum
   * @param {number} [max]
   *        X axis maximum
   */
  render(min4, max4) {
    if (this.options.enabled === false) {
      return;
    }
    const chart = this.chart, chartOptions = chart.options, options2 = chartOptions.rangeSelector, inputEnabled = options2.inputEnabled;
    if (inputEnabled) {
      if (!this.inputGroup) {
        this.createInputs();
      }
      this.setInputValue("min", min4);
      this.setInputValue("max", max4);
      if (!this.chart.styledMode) {
        this.maxLabel?.css(options2.labelStyle);
        this.minLabel?.css(options2.labelStyle);
      }
      const unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || chart.xAxis[0] || {};
      if (defined32(unionExtremes.dataMin) && defined32(unionExtremes.dataMax)) {
        const minRange = chart.xAxis[0].minRange || 0;
        this.setInputExtremes("min", unionExtremes.dataMin, Math.min(unionExtremes.dataMax, this.getInputValue("max")) - minRange);
        this.setInputExtremes("max", Math.max(unionExtremes.dataMin, this.getInputValue("min")) + minRange, unionExtremes.dataMax);
      }
      if (this.inputGroup) {
        let x = 0;
        [
          this.minLabel,
          this.minDateBox,
          this.maxLabel,
          this.maxDateBox
        ].forEach((label) => {
          if (label) {
            const { width } = label.getBBox();
            if (width) {
              label.attr({ x });
              x += width + options2.inputSpacing;
            }
          }
        });
      }
    } else {
      if (this.inputGroup) {
        this.inputGroup.destroy();
        delete this.inputGroup;
      }
    }
    if (!this.chart.styledMode) {
      if (this.zoomText) {
        this.zoomText.css(options2.labelStyle);
      }
    }
    this.alignElements();
    this.updateButtonStates();
  }
  /**
   * Render the range buttons. This only runs the first time, later the
   * positioning is laid out in alignElements.
   *
   * @private
   * @function Highcharts.RangeSelector#renderButtons
   */
  renderButtons() {
    var _a;
    const { chart, options: options2 } = this;
    const lang6 = defaultOptions13.lang;
    const renderer = chart.renderer;
    const buttonTheme = merge36(options2.buttonTheme);
    const states = buttonTheme && buttonTheme.states;
    delete buttonTheme.width;
    delete buttonTheme.states;
    this.buttonGroup = renderer.g("range-selector-buttons").add(this.group);
    const dropdown = this.dropdown = createElement9("select", void 0, {
      position: "absolute",
      padding: 0,
      border: 0,
      cursor: "pointer",
      opacity: 1e-4
    }, this.div);
    const userButtonTheme = chart.userOptions.rangeSelector?.buttonTheme;
    this.dropdownLabel = renderer.button("", 0, 0, () => {
    }, merge36(buttonTheme, {
      "stroke-width": pick41(buttonTheme["stroke-width"], 0),
      width: "auto",
      paddingLeft: pick41(options2.buttonTheme.paddingLeft, userButtonTheme?.padding, 8),
      paddingRight: pick41(options2.buttonTheme.paddingRight, userButtonTheme?.padding, 8)
    }), states && states.hover, states && states.select, states && states.disabled).hide().add(this.group);
    addEvent28(dropdown, "touchstart", () => {
      dropdown.style.fontSize = "16px";
    });
    const mouseOver2 = Globals_default.isMS ? "mouseover" : "mouseenter", mouseOut2 = Globals_default.isMS ? "mouseout" : "mouseleave";
    addEvent28(dropdown, mouseOver2, () => {
      fireEvent24(this.dropdownLabel.element, mouseOver2);
    });
    addEvent28(dropdown, mouseOut2, () => {
      fireEvent24(this.dropdownLabel.element, mouseOut2);
    });
    addEvent28(dropdown, "change", () => {
      const button = this.buttons[dropdown.selectedIndex - 1];
      fireEvent24(button.element, "click");
    });
    this.zoomText = renderer.label(lang6.rangeSelectorZoom || "", 0).attr({
      padding: options2.buttonTheme.padding,
      height: options2.buttonTheme.height,
      paddingLeft: 0,
      paddingRight: 0
    }).add(this.buttonGroup);
    if (!this.chart.styledMode) {
      this.zoomText.css(options2.labelStyle);
      (_a = options2.buttonTheme)["stroke-width"] ?? (_a["stroke-width"] = 0);
    }
    createElement9("option", {
      textContent: this.zoomText.textStr,
      disabled: true
    }, void 0, dropdown);
    this.createButtons();
  }
  createButtons() {
    const { options: options2 } = this;
    const buttonTheme = merge36(options2.buttonTheme);
    const states = buttonTheme && buttonTheme.states;
    const width = buttonTheme.width || 28;
    delete buttonTheme.width;
    delete buttonTheme.states;
    this.buttonOptions.forEach((rangeOptions, i) => {
      this.createButton(rangeOptions, i, width, states);
    });
  }
  createButton(rangeOptions, i, width, states) {
    const { dropdown, buttons, chart, options: options2 } = this;
    const renderer = chart.renderer;
    const buttonTheme = merge36(options2.buttonTheme);
    dropdown?.add(createElement9("option", {
      textContent: rangeOptions.title || rangeOptions.text
    }), i + 2);
    buttons[i] = renderer.button(rangeOptions.text ?? "", 0, 0, (e) => {
      const buttonEvents = rangeOptions.events && rangeOptions.events.click;
      let callDefaultEvent;
      if (buttonEvents) {
        callDefaultEvent = buttonEvents.call(rangeOptions, e);
      }
      if (callDefaultEvent !== false) {
        this.clickButton(i);
      }
      this.isActive = true;
    }, buttonTheme, states && states.hover, states && states.select, states && states.disabled).attr({
      "text-align": "center",
      width
    }).add(this.buttonGroup);
    if (rangeOptions.title) {
      buttons[i].attr("title", rangeOptions.title);
    }
  }
  /**
   * Align the elements horizontally and vertically.
   *
   * @private
   * @function Highcharts.RangeSelector#alignElements
   */
  alignElements() {
    const { buttonGroup, buttons, chart, group, inputGroup, options: options2, zoomText } = this;
    const chartOptions = chart.options;
    const navButtonOptions = chartOptions.exporting && chartOptions.exporting.enabled !== false && chartOptions.navigation && chartOptions.navigation.buttonOptions;
    const { buttonPosition, inputPosition, verticalAlign } = options2;
    const getXOffsetForExportButton = (group2, position, rightAligned) => {
      if (navButtonOptions && this.titleCollision(chart) && verticalAlign === "top" && rightAligned && position.y - group2.getBBox().height - 12 < (navButtonOptions.y || 0) + (navButtonOptions.height || 0) + chart.spacing[0]) {
        return -40;
      }
      return 0;
    };
    let plotLeft = chart.plotLeft;
    if (group && buttonPosition && inputPosition) {
      let translateX = buttonPosition.x - chart.spacing[3];
      if (buttonGroup) {
        this.positionButtons();
        if (!this.initialButtonGroupWidth) {
          let width = 0;
          if (zoomText) {
            width += zoomText.getBBox().width + 5;
          }
          buttons.forEach((button, i) => {
            width += button.width || 0;
            if (i !== buttons.length - 1) {
              width += options2.buttonSpacing;
            }
          });
          this.initialButtonGroupWidth = width;
        }
        plotLeft -= chart.spacing[3];
        const xOffsetForExportButton2 = getXOffsetForExportButton(buttonGroup, buttonPosition, buttonPosition.align === "right" || inputPosition.align === "right");
        this.alignButtonGroup(xOffsetForExportButton2);
        if (this.buttonGroup?.translateY) {
          this.dropdownLabel.attr({ y: this.buttonGroup.translateY });
        }
        group.placed = buttonGroup.placed = chart.hasLoaded;
      }
      let xOffsetForExportButton = 0;
      if (options2.inputEnabled && inputGroup) {
        xOffsetForExportButton = getXOffsetForExportButton(inputGroup, inputPosition, buttonPosition.align === "right" || inputPosition.align === "right");
        if (inputPosition.align === "left") {
          translateX = plotLeft;
        } else if (inputPosition.align === "right") {
          translateX = -Math.max(chart.axisOffset[1], -xOffsetForExportButton);
        }
        inputGroup.align({
          y: inputPosition.y,
          width: inputGroup.getBBox().width,
          align: inputPosition.align,
          // Fix wrong getBBox() value on right align
          x: inputPosition.x + translateX - 2
        }, true, chart.spacingBox);
        inputGroup.placed = chart.hasLoaded;
      }
      this.handleCollision(xOffsetForExportButton);
      group.align({
        verticalAlign
      }, true, chart.spacingBox);
      const alignTranslateY = group.alignAttr.translateY;
      let groupHeight = group.getBBox().height + 20;
      let translateY = 0;
      if (verticalAlign === "bottom") {
        const legendOptions = chart.legend && chart.legend.options;
        const legendHeight = legendOptions && legendOptions.verticalAlign === "bottom" && legendOptions.enabled && !legendOptions.floating ? chart.legend.legendHeight + pick41(legendOptions.margin, 10) : 0;
        groupHeight = groupHeight + legendHeight - 20;
        translateY = alignTranslateY - groupHeight - (options2.floating ? 0 : options2.y) - (chart.titleOffset ? chart.titleOffset[2] : 0) - 10;
      }
      if (verticalAlign === "top") {
        if (options2.floating) {
          translateY = 0;
        }
        if (chart.titleOffset && chart.titleOffset[0]) {
          translateY = chart.titleOffset[0];
        }
        translateY += chart.margin[0] - chart.spacing[0] || 0;
      } else if (verticalAlign === "middle") {
        if (inputPosition.y === buttonPosition.y) {
          translateY = alignTranslateY;
        } else if (inputPosition.y || buttonPosition.y) {
          if (inputPosition.y < 0 || buttonPosition.y < 0) {
            translateY -= Math.min(inputPosition.y, buttonPosition.y);
          } else {
            translateY = alignTranslateY - groupHeight;
          }
        }
      }
      group.translate(options2.x, options2.y + Math.floor(translateY));
      const { minInput, maxInput, dropdown } = this;
      if (options2.inputEnabled && minInput && maxInput) {
        minInput.style.marginTop = group.translateY + "px";
        maxInput.style.marginTop = group.translateY + "px";
      }
      if (dropdown) {
        dropdown.style.marginTop = group.translateY + "px";
      }
    }
  }
  /**
   * @private
   */
  redrawElements() {
    const chart = this.chart, { inputBoxHeight, inputBoxBorderColor } = this.options;
    this.maxDateBox?.attr({
      height: inputBoxHeight
    });
    this.minDateBox?.attr({
      height: inputBoxHeight
    });
    if (!chart.styledMode) {
      this.maxDateBox?.attr({
        stroke: inputBoxBorderColor
      });
      this.minDateBox?.attr({
        stroke: inputBoxBorderColor
      });
    }
    if (this.isDirty) {
      this.isDirty = false;
      this.isCollapsed = void 0;
      const newButtonsOptions = this.options.buttons ?? [];
      const btnLength = Math.min(newButtonsOptions.length, this.buttonOptions.length);
      const { dropdown, options: options2 } = this;
      const buttonTheme = merge36(options2.buttonTheme);
      const states = buttonTheme && buttonTheme.states;
      const width = buttonTheme.width || 28;
      if (newButtonsOptions.length < this.buttonOptions.length) {
        for (let i = this.buttonOptions.length - 1; i >= newButtonsOptions.length; i--) {
          const btn = this.buttons.pop();
          btn?.destroy();
          this.dropdown?.options.remove(i + 1);
        }
      }
      for (let i = btnLength - 1; i >= 0; i--) {
        const diff = diffObjects5(newButtonsOptions[i], this.buttonOptions[i]);
        if (Object.keys(diff).length !== 0) {
          const rangeOptions = newButtonsOptions[i];
          this.buttons[i].destroy();
          dropdown?.options.remove(i + 1);
          this.createButton(rangeOptions, i, width, states);
          this.computeButtonRange(rangeOptions);
        }
      }
      if (newButtonsOptions.length > this.buttonOptions.length) {
        for (let i = this.buttonOptions.length; i < newButtonsOptions.length; i++) {
          this.createButton(newButtonsOptions[i], i, width, states);
          this.computeButtonRange(newButtonsOptions[i]);
        }
      }
      this.buttonOptions = this.options.buttons ?? [];
      if (defined32(this.options.selected) && this.buttons.length) {
        this.clickButton(this.options.selected, false);
      }
    }
  }
  /**
   * Align the button group horizontally and vertically.
   *
   * @private
   * @function Highcharts.RangeSelector#alignButtonGroup
   * @param {number} xOffsetForExportButton
   * @param {number} [width]
   */
  alignButtonGroup(xOffsetForExportButton, width) {
    const { chart, options: options2, buttonGroup, dropdown, dropdownLabel } = this;
    const { buttonPosition } = options2;
    const plotLeft = chart.plotLeft - chart.spacing[3];
    let translateX = buttonPosition.x - chart.spacing[3];
    let dropdownTranslateX = chart.plotLeft;
    if (buttonPosition.align === "right") {
      translateX += xOffsetForExportButton - plotLeft;
      if (this.hasVisibleDropdown) {
        dropdownTranslateX = chart.chartWidth + xOffsetForExportButton - this.maxButtonWidth() - 20;
      }
    } else if (buttonPosition.align === "center") {
      translateX -= plotLeft / 2;
      if (this.hasVisibleDropdown) {
        dropdownTranslateX = chart.chartWidth / 2 - this.maxButtonWidth();
      }
    }
    if (dropdown) {
      css13(dropdown, {
        left: dropdownTranslateX + "px",
        top: buttonGroup?.translateY + "px"
      });
    }
    dropdownLabel?.attr({
      x: dropdownTranslateX
    });
    if (buttonGroup) {
      buttonGroup.align({
        y: buttonPosition.y,
        width: pick41(width, this.initialButtonGroupWidth),
        align: buttonPosition.align,
        x: translateX
      }, true, chart.spacingBox);
    }
  }
  /**
   * @private
   * @function Highcharts.RangeSelector#positionButtons
   */
  positionButtons() {
    const { buttons, chart, options: options2, zoomText } = this;
    const verb = chart.hasLoaded ? "animate" : "attr";
    const { buttonPosition } = options2;
    const plotLeft = chart.plotLeft;
    let buttonLeft = plotLeft;
    if (zoomText && zoomText.visibility !== "hidden") {
      zoomText[verb]({
        x: pick41(plotLeft + buttonPosition.x, plotLeft)
      });
      buttonLeft += buttonPosition.x + zoomText.getBBox().width + 5;
    }
    for (let i = 0, iEnd = this.buttonOptions.length; i < iEnd; ++i) {
      if (buttons[i].visibility !== "hidden") {
        buttons[i][verb]({ x: buttonLeft });
        buttonLeft += (buttons[i].width || 0) + options2.buttonSpacing;
      } else {
        buttons[i][verb]({ x: plotLeft });
      }
    }
  }
  /**
   * Handle collision between the button group and the input group
   *
   * @private
   * @function Highcharts.RangeSelector#handleCollision
   *
   * @param  {number} xOffsetForExportButton
   *                  The X offset of the group required to make room for the
   *                  exporting button
   */
  handleCollision(xOffsetForExportButton) {
    const { chart, buttonGroup, inputGroup, initialButtonGroupWidth } = this;
    const { buttonPosition, dropdown, inputPosition } = this.options;
    const moveInputsDown = () => {
      if (inputGroup && buttonGroup) {
        inputGroup.attr({
          translateX: inputGroup.alignAttr.translateX + (chart.axisOffset[1] >= -xOffsetForExportButton ? 0 : -xOffsetForExportButton),
          translateY: inputGroup.alignAttr.translateY + buttonGroup.getBBox().height + 10
        });
      }
    };
    if (inputGroup && buttonGroup) {
      if (inputPosition.align === buttonPosition.align) {
        moveInputsDown();
        if (initialButtonGroupWidth > chart.plotWidth + xOffsetForExportButton - 20) {
          this.collapseButtons();
        } else {
          this.expandButtons();
        }
      } else if (initialButtonGroupWidth - xOffsetForExportButton + inputGroup.getBBox().width > chart.plotWidth) {
        if (dropdown === "responsive") {
          this.collapseButtons();
        } else {
          moveInputsDown();
        }
      } else {
        this.expandButtons();
      }
    } else if (buttonGroup && dropdown === "responsive") {
      if (initialButtonGroupWidth > chart.plotWidth) {
        this.collapseButtons();
      } else {
        this.expandButtons();
      }
    }
    if (buttonGroup) {
      if (dropdown === "always") {
        this.collapseButtons();
      }
      if (dropdown === "never") {
        this.expandButtons();
      }
    }
    this.alignButtonGroup(xOffsetForExportButton);
  }
  /**
   * Collapse the buttons and show the select element.
   *
   * @private
   * @function Highcharts.RangeSelector#collapseButtons
   * @param {number} xOffsetForExportButton
   */
  collapseButtons() {
    const { buttons, zoomText } = this;
    if (this.isCollapsed === true) {
      return;
    }
    this.isCollapsed = true;
    zoomText.hide();
    buttons.forEach((button) => void button.hide());
    this.showDropdown();
  }
  /**
   * Show all the buttons and hide the select element.
   *
   * @private
   * @function Highcharts.RangeSelector#expandButtons
   */
  expandButtons() {
    const { buttons, zoomText } = this;
    if (this.isCollapsed === false) {
      return;
    }
    this.isCollapsed = false;
    this.hideDropdown();
    zoomText.show();
    buttons.forEach((button) => void button.show());
    this.positionButtons();
  }
  /**
   * Position the select element on top of the button.
   *
   * @private
   * @function Highcharts.RangeSelector#showDropdown
   */
  showDropdown() {
    const { buttonGroup, dropdownLabel, dropdown } = this;
    if (buttonGroup && dropdown) {
      dropdownLabel.show();
      css13(dropdown, { visibility: "inherit" });
      this.hasVisibleDropdown = true;
    }
  }
  /**
   * @private
   * @function Highcharts.RangeSelector#hideDropdown
   */
  hideDropdown() {
    const { dropdown } = this;
    if (dropdown) {
      this.dropdownLabel.hide();
      css13(dropdown, {
        visibility: "hidden",
        width: "1px",
        height: "1px"
      });
      this.hasVisibleDropdown = false;
    }
  }
  /**
   * Extracts height of range selector
   *
   * @private
   * @function Highcharts.RangeSelector#getHeight
   * @return {number}
   * Returns rangeSelector height
   */
  getHeight() {
    const rangeSelector2 = this, options2 = rangeSelector2.options, rangeSelectorGroup = rangeSelector2.group, inputPosition = options2.inputPosition, buttonPosition = options2.buttonPosition, yPosition = options2.y, buttonPositionY = buttonPosition.y, inputPositionY = inputPosition.y;
    let rangeSelectorHeight = 0;
    if (options2.height) {
      return options2.height;
    }
    this.alignElements();
    rangeSelectorHeight = rangeSelectorGroup ? (
      // 13px to keep back compatibility
      rangeSelectorGroup.getBBox(true).height + 13 + yPosition
    ) : 0;
    const minPosition = Math.min(inputPositionY, buttonPositionY);
    if (inputPositionY < 0 && buttonPositionY < 0 || inputPositionY > 0 && buttonPositionY > 0) {
      rangeSelectorHeight += Math.abs(minPosition);
    }
    return rangeSelectorHeight;
  }
  /**
   * Detect collision with title or subtitle
   *
   * @private
   * @function Highcharts.RangeSelector#titleCollision
   * @return {boolean}
   * Returns collision status
   */
  titleCollision(chart) {
    return !(chart.options.title.text || chart.options.subtitle.text);
  }
  /**
   * Update the range selector with new options
   *
   * @private
   * @function Highcharts.RangeSelector#update
   * @param {Highcharts.RangeSelectorOptions} options
   */
  update(options2, redraw = true) {
    const chart = this.chart;
    merge36(true, this.options, options2);
    if (this.options.selected && this.options.selected >= this.options.buttons.length) {
      this.options.selected = void 0;
      chart.options.rangeSelector.selected = void 0;
    }
    if (defined32(options2.enabled)) {
      this.destroy();
      return this.init(chart);
    }
    this.isDirty = !!options2.buttons;
    if (redraw) {
      this.render();
    }
  }
  /**
   * Destroys allocated elements.
   *
   * @private
   * @function Highcharts.RangeSelector#destroy
   */
  destroy() {
    const rSelector = this, minInput = rSelector.minInput, maxInput = rSelector.maxInput;
    if (rSelector.eventsToUnbind) {
      rSelector.eventsToUnbind.forEach((unbind) => unbind());
      rSelector.eventsToUnbind = void 0;
    }
    destroyObjectProperties11(rSelector.buttons);
    if (minInput) {
      minInput.onfocus = minInput.onblur = minInput.onchange = null;
    }
    if (maxInput) {
      maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;
    }
    objectEach21(rSelector, function(val, key) {
      if (val && key !== "chart") {
        if (val instanceof SVGElement_default) {
          val.destroy();
        } else if (val instanceof window.HTMLElement) {
          discardElement5(val);
        }
        delete rSelector[key];
      }
      if (val !== _RangeSelector.prototype[key]) {
        rSelector[key] = null;
      }
    }, this);
    this.buttons = [];
  }
};
extend33(RangeSelector.prototype, {
  /**
   * The date formats to use when setting min, max and value on date inputs.
   * @private
   */
  inputTypeFormats: {
    "datetime-local": "%Y-%m-%dT%H:%M:%S",
    "date": "%Y-%m-%d",
    "time": "%H:%M:%S"
  }
});
var RangeSelector_default = RangeSelector;

// node_modules/highcharts/es-modules/Core/Chart/StockChart.js
var { format: format9 } = Templating_default;
var { getOptions: getOptions2 } = Defaults_default;
var { setFixedRange: setFixedRange3 } = StockUtilities_default;
var { addEvent: addEvent29, clamp: clamp11, crisp: crisp8, defined: defined33, extend: extend34, find: find8, isNumber: isNumber32, isString: isString17, merge: merge37, pick: pick42, splat: splat11 } = Utilities_default;
function getDefaultAxisOptions(coll, options2, defaultOptions24) {
  if (coll === "xAxis") {
    return {
      minPadding: 0,
      maxPadding: 0,
      overscroll: 0,
      ordinal: true
    };
  }
  if (coll === "yAxis") {
    return {
      labels: {
        y: -2
      },
      opposite: defaultOptions24.opposite ?? options2.opposite ?? true,
      showLastLabel: !!// #6104, show last label by default for category axes
      (options2.categories || options2.type === "category"),
      title: {
        text: void 0
      }
    };
  }
  return {};
}
function getForcedAxisOptions(type, chartOptions) {
  if (type === "xAxis") {
    const navigatorEnabled = pick42(chartOptions.navigator?.enabled, NavigatorDefaults_default.enabled, true);
    const axisOptions = {
      type: "datetime",
      categories: void 0
    };
    if (navigatorEnabled) {
      axisOptions.startOnTick = false;
      axisOptions.endOnTick = false;
    }
    return axisOptions;
  }
  return {};
}
var StockChart = class extends Chart_default {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Initializes the chart. The constructor's arguments are passed on
   * directly.
   *
   * @function Highcharts.StockChart#init
   *
   * @param {Highcharts.Options} userOptions
   *        Custom options.
   *
   * @param {Function} [callback]
   *        Function to run when the chart has loaded and all external
   *        images are loaded.
   *
   *
   * @emits Highcharts.StockChart#event:init
   * @emits Highcharts.StockChart#event:afterInit
   */
  init(userOptions, callback) {
    const defaultOptions24 = getOptions2(), xAxisOptions = userOptions.xAxis, yAxisOptions = userOptions.yAxis, navigatorEnabled = pick42(userOptions.navigator?.enabled, NavigatorDefaults_default.enabled, true);
    userOptions.xAxis = userOptions.yAxis = void 0;
    const options2 = merge37(
      {
        chart: {
          panning: {
            enabled: true,
            type: "x"
          },
          zooming: {
            pinchType: "x",
            mouseWheel: {
              type: "x"
            }
          }
        },
        navigator: {
          enabled: navigatorEnabled
        },
        scrollbar: {
          // #4988 - check if setOptions was called
          enabled: pick42(ScrollbarDefaults_default.enabled, true)
        },
        rangeSelector: {
          // #4988 - check if setOptions was called
          enabled: pick42(RangeSelectorDefaults_default.rangeSelector.enabled, true)
        },
        title: {
          text: null
        },
        tooltip: {
          split: pick42(defaultOptions24.tooltip?.split, true),
          crosshairs: true
        },
        legend: {
          enabled: false
        }
      },
      userOptions,
      // User's options
      {
        isStock: true
        // Internal flag
      }
    );
    userOptions.xAxis = xAxisOptions;
    userOptions.yAxis = yAxisOptions;
    options2.xAxis = splat11(userOptions.xAxis || {}).map((xAxisOptions2) => merge37(
      getDefaultAxisOptions("xAxis", xAxisOptions2, defaultOptions24.xAxis),
      // #7690
      xAxisOptions2,
      // User options
      getForcedAxisOptions("xAxis", userOptions)
    ));
    options2.yAxis = splat11(userOptions.yAxis || {}).map((yAxisOptions2) => merge37(
      getDefaultAxisOptions("yAxis", yAxisOptions2, defaultOptions24.yAxis),
      // #7690
      yAxisOptions2
      // User options
    ));
    super.init(options2, callback);
  }
  /**
   * Factory for creating different axis types.
   * Extended to add stock defaults.
   *
   * @private
   * @function Highcharts.StockChart#createAxis
   * @param {string} coll
   * An axis type.
   * @param {Chart.CreateAxisOptionsObject} options
   * The axis creation options.
   */
  createAxis(coll, options2) {
    options2.axis = merge37(getDefaultAxisOptions(coll, options2.axis, getOptions2()[coll]), options2.axis, getForcedAxisOptions(coll, this.userOptions));
    return super.createAxis(coll, options2);
  }
};
addEvent29(Chart_default, "update", function(e) {
  const chart = this, options2 = e.options;
  if ("scrollbar" in options2 && chart.navigator) {
    merge37(true, chart.options.scrollbar, options2.scrollbar);
    chart.navigator.update({ enabled: !!chart.navigator.navigatorEnabled });
    delete options2.scrollbar;
  }
});
(function(StockChart2) {
  function compose27(ChartClass, AxisClass, SeriesClass, SVGRendererClass) {
    const seriesProto7 = SeriesClass.prototype;
    if (!seriesProto7.forceCropping) {
      addEvent29(AxisClass, "afterDrawCrosshair", onAxisAfterDrawCrosshair);
      addEvent29(AxisClass, "afterHideCrosshair", onAxisAfterHideCrosshair);
      addEvent29(AxisClass, "autoLabelAlign", onAxisAutoLabelAlign);
      addEvent29(AxisClass, "destroy", onAxisDestroy2);
      addEvent29(AxisClass, "getPlotLinePath", onAxisGetPlotLinePath);
      ChartClass.prototype.setFixedRange = setFixedRange3;
      seriesProto7.forceCropping = seriesForceCropping;
      addEvent29(SeriesClass, "setOptions", onSeriesSetOptions);
      SVGRendererClass.prototype.crispPolyLine = svgRendererCrispPolyLine;
    }
  }
  StockChart2.compose = compose27;
  function onAxisAfterDrawCrosshair(event) {
    const axis = this;
    if (!(axis.crosshair?.label?.enabled && axis.cross && isNumber32(axis.min) && isNumber32(axis.max))) {
      return;
    }
    const chart = axis.chart, log = axis.logarithmic, options2 = axis.crosshair.label, horiz = axis.horiz, opposite = axis.opposite, left = axis.left, top = axis.top, width = axis.width, tickInside = axis.options.tickPosition === "inside", snap = axis.crosshair.snap !== false, e = event.e || axis.cross?.e, point = event.point;
    let crossLabel = axis.crossLabel, posx, posy, formatOption = options2.format, formatFormat = "", limit, offset3 = 0, min4 = axis.min, max4 = axis.max;
    if (log) {
      min4 = log.lin2log(axis.min);
      max4 = log.lin2log(axis.max);
    }
    const align = horiz ? "center" : opposite ? axis.labelAlign === "right" ? "right" : "left" : axis.labelAlign === "left" ? "left" : "center";
    if (!crossLabel) {
      crossLabel = axis.crossLabel = chart.renderer.label("", 0, void 0, options2.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (point?.series ? point.series.colorIndex : axis.series[0] && this.series[0].colorIndex)).attr({
        align: options2.align || align,
        padding: pick42(options2.padding, 8),
        r: pick42(options2.borderRadius, 3),
        zIndex: 2
      }).add(axis.labelGroup);
      if (!chart.styledMode) {
        crossLabel.attr({
          fill: options2.backgroundColor || point?.series?.color || // #14888
          "#666666",
          stroke: options2.borderColor || "",
          "stroke-width": options2.borderWidth || 0
        }).css(extend34({
          color: "#ffffff",
          fontWeight: "normal",
          fontSize: "0.7em",
          textAlign: "center"
        }, options2.style || {}));
      }
    }
    if (horiz) {
      posx = snap ? (point.plotX || 0) + left : e.chartX;
      posy = top + (opposite ? 0 : axis.height);
    } else {
      posx = left + axis.offset + (opposite ? width : 0);
      posy = snap ? (point.plotY || 0) + top : e.chartY;
    }
    if (!formatOption && !options2.formatter) {
      if (axis.dateTime) {
        formatFormat = "%b %d, %Y";
      }
      formatOption = "{value" + (formatFormat ? ":" + formatFormat : "") + "}";
    }
    const value = snap ? axis.isXAxis ? point.x : point.y : axis.toValue(horiz ? e.chartX : e.chartY);
    const isInside = point?.series ? point.series.isPointInside(point) : isNumber32(value) && value > min4 && value < max4;
    let text = "";
    if (formatOption) {
      text = format9(formatOption, { value }, chart);
    } else if (options2.formatter && isNumber32(value)) {
      text = options2.formatter.call(axis, value);
    }
    crossLabel.attr({
      text,
      x: posx,
      y: posy,
      visibility: isInside ? "inherit" : "hidden"
    });
    const crossBox = crossLabel.getBBox();
    if (isNumber32(crossLabel.x) && !horiz && !opposite) {
      posx = crossLabel.x - crossBox.width / 2;
    }
    if (isNumber32(crossLabel.y)) {
      if (horiz) {
        if (tickInside && !opposite || !tickInside && opposite) {
          posy = crossLabel.y - crossBox.height;
        }
      } else {
        posy = crossLabel.y - crossBox.height / 2;
      }
    }
    if (horiz) {
      limit = {
        left,
        right: left + axis.width
      };
    } else {
      limit = {
        left: axis.labelAlign === "left" ? left : 0,
        right: axis.labelAlign === "right" ? left + axis.width : chart.chartWidth
      };
    }
    const translateX = crossLabel.translateX || 0;
    if (translateX < limit.left) {
      offset3 = limit.left - translateX;
    }
    if (translateX + crossBox.width >= limit.right) {
      offset3 = -(translateX + crossBox.width - limit.right);
    }
    crossLabel.attr({
      x: Math.max(0, posx + offset3),
      y: Math.max(0, posy),
      // First set x and y, then anchorX and anchorY, when box is actually
      // calculated, #5702
      anchorX: horiz ? posx : axis.opposite ? 0 : chart.chartWidth,
      anchorY: horiz ? axis.opposite ? chart.chartHeight : 0 : posy + crossBox.height / 2
    });
  }
  function onAxisAfterHideCrosshair() {
    const axis = this;
    if (axis.crossLabel) {
      axis.crossLabel = axis.crossLabel.hide();
    }
  }
  function onAxisAutoLabelAlign(e) {
    const axis = this, chart = axis.chart, options2 = axis.options, panes = chart._labelPanes = chart._labelPanes || {}, labelOptions = options2.labels;
    if (chart.options.isStock && axis.coll === "yAxis") {
      const key = options2.top + "," + options2.height;
      if (!panes[key] && labelOptions.enabled) {
        if (labelOptions.distance === 15 && // Default
        axis.side === 1) {
          labelOptions.distance = 0;
        }
        if (typeof labelOptions.align === "undefined") {
          labelOptions.align = "right";
        }
        panes[key] = axis;
        e.align = "right";
        e.preventDefault();
      }
    }
  }
  function onAxisDestroy2() {
    const axis = this, chart = axis.chart, key = axis.options && axis.options.top + "," + axis.options.height;
    if (key && chart._labelPanes && chart._labelPanes[key] === axis) {
      delete chart._labelPanes[key];
    }
  }
  function onAxisGetPlotLinePath(e) {
    const axis = this, series = axis.isLinked && !axis.series && axis.linkedParent ? axis.linkedParent.series : axis.series, chart = axis.chart, renderer = chart.renderer, axisLeft = axis.left, axisTop = axis.top, result = [], translatedValue = e.translatedValue, value = e.value, force = e.force, getAxis = (coll) => {
      const otherColl = coll === "xAxis" ? "yAxis" : "xAxis", opt = axis.options[otherColl];
      if (isNumber32(opt)) {
        return [chart[otherColl][opt]];
      }
      if (isString17(opt)) {
        return [chart.get(opt)];
      }
      return series.map((s) => s[otherColl]);
    };
    let x1, y1, x2, y2, axes = [], axes2, uniqueAxes, transVal;
    if (
      // For stock chart, by default render paths across the panes
      // except the case when `acrossPanes` is disabled by user (#6644)
      chart.options.isStock && e.acrossPanes !== false && // Ignore in case of colorAxis or zAxis. #3360, #3524, #6720
      axis.coll === "xAxis" || axis.coll === "yAxis"
    ) {
      e.preventDefault();
      axes = getAxis(axis.coll);
      axes2 = axis.isXAxis ? chart.yAxis : chart.xAxis;
      for (const A of axes2) {
        if (!A.options.isInternal) {
          const a = A.isXAxis ? "yAxis" : "xAxis", relatedAxis = defined33(A.options[a]) ? chart[a][A.options[a]] : chart[a][0];
          if (axis === relatedAxis) {
            axes.push(A);
          }
        }
      }
      uniqueAxes = axes.length ? [] : [axis.isXAxis ? chart.yAxis[0] : chart.xAxis[0]];
      for (const axis2 of axes) {
        if (uniqueAxes.indexOf(axis2) === -1 && // Do not draw on axis which overlap completely. #5424
        !find8(uniqueAxes, (unique) => unique.pos === axis2.pos && unique.len === axis2.len)) {
          uniqueAxes.push(axis2);
        }
      }
      transVal = pick42(translatedValue, axis.translate(value || 0, void 0, void 0, e.old));
      if (isNumber32(transVal)) {
        if (axis.horiz) {
          for (const axis2 of uniqueAxes) {
            let skip;
            y1 = axis2.pos;
            y2 = y1 + axis2.len;
            x1 = x2 = Math.round(transVal + axis.transB);
            if (force !== "pass" && (x1 < axisLeft || x1 > axisLeft + axis.width)) {
              if (force) {
                x1 = x2 = clamp11(x1, axisLeft, axisLeft + axis.width);
              } else {
                skip = true;
              }
            }
            if (!skip) {
              result.push(["M", x1, y1], ["L", x2, y2]);
            }
          }
        } else {
          for (const axis2 of uniqueAxes) {
            let skip;
            x1 = axis2.pos;
            x2 = x1 + axis2.len;
            y1 = y2 = Math.round(axisTop + axis.height - transVal);
            if (force !== "pass" && (y1 < axisTop || y1 > axisTop + axis.height)) {
              if (force) {
                y1 = y2 = clamp11(y1, axisTop, axisTop + axis.height);
              } else {
                skip = true;
              }
            }
            if (!skip) {
              result.push(["M", x1, y1], ["L", x2, y2]);
            }
          }
        }
      }
      e.path = result.length > 0 ? renderer.crispPolyLine(result, e.lineWidth || 1) : (
        // #3557 getPlotLinePath in regular Highcharts also returns null
        void 0
      );
    }
  }
  function onSeriesSetOptions(e) {
    const series = this;
    if (series.chart.options.isStock) {
      let overrides;
      if (series.is("column") || series.is("columnrange")) {
        overrides = {
          borderWidth: 0,
          shadow: false
        };
      } else if (!series.is("scatter") && !series.is("sma")) {
        overrides = {
          marker: {
            enabled: false,
            radius: 2
          }
        };
      }
      if (overrides) {
        e.plotOptions[series.type] = merge37(e.plotOptions[series.type], overrides);
      }
    }
  }
  function seriesForceCropping() {
    const series = this, chart = series.chart, options2 = series.options, dataGroupingOptions = options2.dataGrouping, groupingEnabled = series.allowDG !== false && dataGroupingOptions && pick42(dataGroupingOptions.enabled, chart.options.isStock);
    return groupingEnabled;
  }
  function stockChart(a, b, c) {
    return new StockChart2(a, b, c);
  }
  StockChart2.stockChart = stockChart;
  function svgRendererCrispPolyLine(points, width) {
    for (let i = 0; i < points.length; i = i + 2) {
      const start = points[i], end = points[i + 1];
      if (defined33(start[1]) && start[1] === end[1]) {
        start[1] = end[1] = crisp8(start[1], width);
      }
      if (defined33(start[2]) && start[2] === end[2]) {
        start[2] = end[2] = crisp8(start[2], width);
      }
    }
    return points;
  }
})(StockChart || (StockChart = {}));
var StockChart_default = StockChart;

// node_modules/highcharts/es-modules/Series/HLC/HLCPoint.js
var { column: { prototype: { pointClass: ColumnPoint } } } = SeriesRegistry_default.seriesTypes;
var HLCPoint = class extends ColumnPoint {
};
var HLCPoint_default = HLCPoint;

// node_modules/highcharts/es-modules/Series/HLC/HLCSeriesDefaults.js
var HLCSeriesDefaults = {
  /**
   * The approximate pixel width of each group. If for example a series
   * with 30 points is displayed over a 600 pixel wide plot area, no
   * grouping is performed. If however the series contains so many points
   * that the spacing is less than the groupPixelWidth, Highcharts will
   * try to group it into appropriate groups so that each is more or less
   * two pixels wide. Defaults to `5`.
   *
   * @type      {number}
   * @default   5
   * @product   highstock
   * @apioption plotOptions.hlc.dataGrouping.groupPixelWidth
   */
  /**
   * @type      {Highcharts.DataGroupingApproximationValue|Function}
   * @default   hlc
   * @product   highstock
   * @apioption plotOptions.hlc.dataGrouping.approximation
   */
  /**
   * @default   close
   * @apioption plotOptions.hlc.colorKey
   */
  /**
   * The pixel width of the line/border. Defaults to `1`.
   *
   * @sample {highstock} stock/plotoptions/hlc-linewidth/
   *         A greater line width
   *
   * @type    {number}
   * @default 1
   * @product highstock
   *
   * @public
   */
  lineWidth: 1,
  tooltip: {
    pointFormat: '<span style="color:{point.color}"></span> <b> {series.name}</b><br/>{series.chart.options.lang.stockHigh}: {point.high}<br/>{series.chart.options.lang.stockLow}: {point.low}<br/>{series.chart.options.lang.stockClose}: {point.close}<br/>'
  },
  /**
   * @type {number|null}
   */
  threshold: null,
  states: {
    /**
     * @extends plotOptions.column.states.hover
     * @product highstock
     */
    hover: {
      /**
       * The pixel width of the line representing the HLC point.
       *
       * @type    {number}
       * @default 3
       * @product highstock
       */
      lineWidth: 3
    }
  },
  /**
   * Determines which one of  `high`, `low`, `close` values should
   * be represented as `point.y`, which is later used to set dataLabel
   * position and [compare](#plotOptions.series.compare).
   *
   * @sample {highstock} stock/plotoptions/hlc-pointvalkey/
   *         Possible values
   *
   * @declare    Highcharts.OptionsHLCPointValKeyValue
   * @type       {string}
   * @default    close
   * @validvalue ["high", "low", "close"]
   * @product    highstock
   * @apioption  plotOptions.hlc.pointValKey
   */
  /**
   * @default   close
   * @apioption plotOptions.hlc.colorKey
   */
  stickyTracking: true
};
var HLCSeriesDefaults_default = HLCSeriesDefaults;

// node_modules/highcharts/es-modules/Series/HLC/HLCSeries.js
var { column: ColumnSeries3 } = SeriesRegistry_default.seriesTypes;
var { crisp: crisp9, extend: extend35, merge: merge38 } = Utilities_default;
var { defaultOptions: defaultOptions14 } = Defaults_default;
var HLCSeries = class extends ColumnSeries3 {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Extend the path if close is not between high and low.
   *
   * @param {SVGPath} path the path array of the point
   * @param {number} halfStrokeWidth
   * @param {number} value value of the point to which the stem should be extended
   */
  extendStem(path, halfStrokeWidth, value) {
    const start = path[0];
    const end = path[1];
    if (typeof start[2] === "number") {
      start[2] = Math.max(value + halfStrokeWidth, start[2]);
    }
    if (typeof end[2] === "number") {
      end[2] = Math.min(value - halfStrokeWidth, end[2]);
    }
  }
  /**
   * Function to create SVGPath of the point based on the
   * plot positions of this point.
   * @private
   */
  getPointPath(point, graphic) {
    const strokeWidth = graphic.strokeWidth(), series = point.series, crispX = crisp9(point.plotX || 0, strokeWidth), halfWidth = Math.round(point.shapeArgs.width / 2);
    const path = [
      ["M", crispX, Math.round(point.yBottom)],
      ["L", crispX, Math.round(point.plotHigh)]
    ];
    if (point.close !== null) {
      const plotClose = crisp9(point.plotClose, strokeWidth);
      path.push(["M", crispX, plotClose], ["L", crispX + halfWidth, plotClose]);
      series.extendStem(path, strokeWidth / 2, plotClose);
    }
    return path;
  }
  /**
   * Draw single point
   * @private
   */
  drawSinglePoint(point) {
    const series = point.series, chart = series.chart;
    let path, graphic = point.graphic;
    if (typeof point.plotY !== "undefined") {
      if (!graphic) {
        point.graphic = graphic = chart.renderer.path().add(series.group);
      }
      if (!chart.styledMode) {
        graphic.attr(series.pointAttribs(point, point.selected && "select"));
      }
      path = series.getPointPath(point, graphic);
      graphic[!graphic ? "attr" : "animate"]({ d: path }).addClass(point.getClassName(), true);
    }
  }
  /**
   * Draw the data points
   * @private
   */
  drawPoints() {
    this.points.forEach(this.drawSinglePoint);
  }
  /**
   * @private
   * @function Highcharts.seriesTypes.hlc#init
   */
  init() {
    super.init.apply(this, arguments);
    this.options.stacking = void 0;
  }
  /**
   * Postprocess mapping between options and SVG attributes
   * @private
   */
  pointAttribs(point, state) {
    const attribs = super.pointAttribs.call(this, point, state);
    delete attribs.fill;
    return attribs;
  }
  toYData(point) {
    return [point.high, point.low, point.close];
  }
  /**
   * Translate data points from raw values x and y to plotX and plotY
   *
   * @private
   * @function Highcharts.seriesTypes.hlc#translate
   */
  translate() {
    const series = this, yAxis2 = series.yAxis, names = this.pointArrayMap && this.pointArrayMap.slice() || [], translated = names.map((name) => `plot${name.charAt(0).toUpperCase() + name.slice(1)}`);
    translated.push("yBottom");
    names.push("low");
    super.translate.apply(series);
    series.points.forEach(function(point) {
      names.forEach(function(name, i) {
        let value = point[name];
        if (value !== null) {
          if (series.dataModify) {
            value = series.dataModify.modifyValue(value);
          }
          point[translated[i]] = yAxis2.toPixels(value, true);
        }
      });
      point.tooltipPos[1] = point.plotHigh + yAxis2.pos - series.chart.plotTop;
    });
  }
};
HLCSeries.defaultOptions = merge38(ColumnSeries3.defaultOptions, HLCSeriesDefaults_default);
extend35(HLCSeries.prototype, {
  pointClass: HLCPoint_default,
  animate: null,
  // Disable animation
  directTouch: false,
  keysAffectYAxis: ["low", "high"],
  pointArrayMap: ["high", "low", "close"],
  pointAttrToOptions: {
    stroke: "color",
    "stroke-width": "lineWidth"
  },
  pointValKey: "close"
});
var HLCDefaultLangOptions = {
  stockOpen: "Open",
  stockHigh: "High",
  stockLow: "Low",
  stockClose: "Close"
};
extend35(defaultOptions14.lang, HLCDefaultLangOptions);
SeriesRegistry_default.registerSeriesType("hlc", HLCSeries);

// node_modules/highcharts/es-modules/Series/OHLC/OHLCPoint.js
var { seriesTypes: { hlc: HLCSeries2 } } = SeriesRegistry_default;
var OHLCPoint = class extends HLCSeries2.prototype.pointClass {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Extend the parent method by adding up or down to the class name.
   * @private
   * @function Highcharts.seriesTypes.ohlc#getClassName
   */
  getClassName() {
    return super.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
  }
  /**
   * Save upColor as point color (#14826).
   * @private
   * @function Highcharts.seriesTypes.ohlc#resolveUpColor
   */
  resolveUpColor() {
    if (this.open < this.close && !this.options.color && this.series.options.upColor) {
      this.color = this.series.options.upColor;
    }
  }
  /**
   * Extend the parent method by saving upColor.
   * @private
   * @function Highcharts.seriesTypes.ohlc#resolveColor
   */
  resolveColor() {
    super.resolveColor();
    if (!this.series.is("heikinashi")) {
      this.resolveUpColor();
    }
  }
  /**
   * Extend the parent method by saving upColor.
   * @private
   * @function Highcharts.seriesTypes.ohlc#getZone
   *
   * @return {Highcharts.SeriesZonesOptionsObject}
   *         The zone item.
   */
  getZone() {
    const zone = super.getZone();
    this.resolveUpColor();
    return zone;
  }
  /**
   * Extend the parent method by resolving up/down colors (#15849)
   * @private
   **/
  applyOptions() {
    super.applyOptions.apply(this, arguments);
    if (this.resolveColor) {
      this.resolveColor();
    }
    return this;
  }
};
var OHLCPoint_default = OHLCPoint;

// node_modules/highcharts/es-modules/Series/OHLC/OHLCSeriesDefaults.js
var OHLCSeriesDefaults = {
  /**
   * @type      {Highcharts.DataGroupingApproximationValue|Function}
   * @default   ohlc
   * @product   highstock
   * @apioption plotOptions.ohlc.dataGrouping.approximation
   */
  /**
   * Determines which one of  `open`, `high`, `low`, `close` values should
   * be represented as `point.y`, which is later used to set dataLabel
   * position and [compare](#plotOptions.series.compare).
   *
   * @declare    Highcharts.OptionsPointValKeyValue
   * @default    close
   * @validvalue ["open", "high", "low", "close"]
   * @product    highstock
   * @apioption  plotOptions.ohlc.pointValKey
   */
  /**
   * Line color for up points.
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product   highstock
   * @apioption plotOptions.ohlc.upColor
   */
  tooltip: {
    pointFormat: '<span style="color:{point.color}"></span> <b> {series.name}</b><br/>{series.chart.options.lang.stockOpen}: {point.open}<br/>{series.chart.options.lang.stockHigh}: {point.high}<br/>{series.chart.options.lang.stockLow}: {point.low}<br/>{series.chart.options.lang.stockClose}: {point.close}<br/>'
  }
};
var OHLCSeriesDefaults_default = OHLCSeriesDefaults;

// node_modules/highcharts/es-modules/Series/OHLC/OHLCSeries.js
var { composed: composed11 } = Globals_default;
var { hlc: HLCSeries3 } = SeriesRegistry_default.seriesTypes;
var { addEvent: addEvent30, crisp: crisp10, extend: extend36, merge: merge39, pushUnique: pushUnique14 } = Utilities_default;
function onSeriesAfterSetOptions(e) {
  const options2 = e.options, dataGrouping = options2.dataGrouping;
  if (dataGrouping && options2.useOhlcData && options2.id !== "highcharts-navigator-series") {
    dataGrouping.approximation = "ohlc";
  }
}
function onSeriesInit(eventOptions) {
  const series = this, options2 = eventOptions.options;
  if (options2.useOhlcData && options2.id !== "highcharts-navigator-series") {
    extend36(series, {
      pointValKey: OHLCSeries.prototype.pointValKey,
      // Keys: ohlcProto.keys, // @todo potentially nonsense
      pointArrayMap: OHLCSeries.prototype.pointArrayMap,
      toYData: OHLCSeries.prototype.toYData
    });
  }
}
var OHLCSeries = class extends HLCSeries3 {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(SeriesClass, ..._args) {
    if (pushUnique14(composed11, "OHLCSeries")) {
      addEvent30(SeriesClass, "afterSetOptions", onSeriesAfterSetOptions);
      addEvent30(SeriesClass, "init", onSeriesInit);
    }
  }
  /* *
   *
   *  Functions
   *
   * */
  getPointPath(point, graphic) {
    const path = super.getPointPath(point, graphic), strokeWidth = graphic.strokeWidth(), crispX = crisp10(point.plotX || 0, strokeWidth), halfWidth = Math.round(point.shapeArgs.width / 2);
    if (point.open !== null) {
      const plotOpen = crisp10(point.plotOpen, strokeWidth);
      path.push(["M", crispX, plotOpen], ["L", crispX - halfWidth, plotOpen]);
      super.extendStem(path, strokeWidth / 2, plotOpen);
    }
    return path;
  }
  /**
   * Postprocess mapping between options and SVG attributes
   * @private
   */
  pointAttribs(point, state) {
    const attribs = super.pointAttribs.call(this, point, state), options2 = this.options;
    delete attribs.fill;
    if (!point.options.color && options2.upColor && point.open < point.close) {
      attribs.stroke = options2.upColor;
    }
    return attribs;
  }
  toYData(point) {
    return [point.open, point.high, point.low, point.close];
  }
};
OHLCSeries.defaultOptions = merge39(HLCSeries3.defaultOptions, OHLCSeriesDefaults_default);
extend36(OHLCSeries.prototype, {
  pointClass: OHLCPoint_default,
  pointArrayMap: ["open", "high", "low", "close"]
});
SeriesRegistry_default.registerSeriesType("ohlc", OHLCSeries);
var OHLCSeries_default = OHLCSeries;

// node_modules/highcharts/es-modules/Series/Candlestick/CandlestickSeriesDefaults.js
var CandlestickSeriesDefaults = {
  /**
   * The specific line color for up candle sticks. The default is to
   * inherit the general `lineColor` setting.
   *
   * @sample {highstock} stock/plotoptions/candlestick-linecolor/
   *         Candlestick line colors
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     1.3.6
   * @product   highstock
   * @apioption plotOptions.candlestick.upLineColor
   */
  states: {
    /**
     * @extends plotOptions.column.states.hover
     * @product highstock
     */
    hover: {
      /**
       * The pixel width of the line/border around the
       * candlestick.
       *
       * @product highstock
       */
      lineWidth: 2
    }
  },
  /**
   * @type    {number|null}
   * @product highstock
   */
  threshold: null,
  /**
   * The color of the line/border of the candlestick.
   *
   * In styled mode, the line stroke can be set with the
   * `.highcharts-candlestick-series .highcahrts-point` rule.
   *
   * @see [upLineColor](#plotOptions.candlestick.upLineColor)
   *
   * @sample {highstock} stock/plotoptions/candlestick-linecolor/
   *         Candlestick line colors
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default #000000
   * @product highstock
   */
  lineColor: "#000000",
  /**
   * The pixel width of the candlestick line/border. Defaults to `1`.
   *
   *
   * In styled mode, the line stroke width can be set with the
   * `.highcharts-candlestick-series .highcahrts-point` rule.
   *
   * @product highstock
   */
  lineWidth: 1,
  /**
   * The fill color of the candlestick when values are rising.
   *
   * In styled mode, the up color can be set with the
   * `.highcharts-candlestick-series .highcharts-point-up` rule.
   *
   * @sample {highstock} stock/plotoptions/candlestick-color/
   *         Custom colors
   * @sample {highstock} highcharts/css/candlestick/
   *         Colors in styled mode
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default #ffffff
   * @product highstock
  */
  upColor: "#ffffff",
  /**
   * @product highstock
   */
  stickyTracking: true
};
var CandlestickSeriesDefaults_default = CandlestickSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Candlestick/CandlestickSeries.js
var { column: ColumnSeries4, ohlc: OHLCSeries2 } = SeriesRegistry_default.seriesTypes;
var { crisp: crisp11, merge: merge40 } = Utilities_default;
var CandlestickSeries = class extends OHLCSeries2 {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Postprocess mapping between options and SVG attributes
   *
   * @private
   * @function Highcharts.seriesTypes.candlestick#pointAttribs
   */
  pointAttribs(point, state) {
    const attribs = ColumnSeries4.prototype.pointAttribs.call(this, point, state), options2 = this.options, isUp = point.open < point.close, stroke = options2.lineColor || this.color, color14 = point.color || this.color;
    attribs["stroke-width"] = options2.lineWidth;
    attribs.fill = point.options.color || (isUp ? options2.upColor || color14 : color14);
    attribs.stroke = point.options.lineColor || (isUp ? options2.upLineColor || stroke : stroke);
    if (state) {
      const stateOptions = options2.states[state];
      attribs.fill = stateOptions.color || attribs.fill;
      attribs.stroke = stateOptions.lineColor || attribs.stroke;
      attribs["stroke-width"] = stateOptions.lineWidth || attribs["stroke-width"];
    }
    return attribs;
  }
  /**
   * Draw the data points.
   *
   * @private
   * @function Highcharts.seriesTypes.candlestick#drawPoints
   */
  drawPoints() {
    const series = this, points = series.points, chart = series.chart, reversedYAxis = series.yAxis.reversed;
    for (const point of points) {
      let graphic = point.graphic, plotOpen, plotClose, topBox, bottomBox, hasTopWhisker, hasBottomWhisker, crispX, path, halfWidth;
      const isNew = !graphic;
      if (typeof point.plotY !== "undefined") {
        if (!graphic) {
          point.graphic = graphic = chart.renderer.path().add(series.group);
        }
        if (!series.chart.styledMode) {
          graphic.attr(series.pointAttribs(point, point.selected && "select")).shadow(series.options.shadow);
        }
        const strokeWidth = graphic.strokeWidth();
        crispX = crisp11(point.plotX || 0, strokeWidth);
        plotOpen = point.plotOpen;
        plotClose = point.plotClose;
        topBox = Math.min(plotOpen, plotClose);
        bottomBox = Math.max(plotOpen, plotClose);
        halfWidth = Math.round(point.shapeArgs.width / 2);
        hasTopWhisker = reversedYAxis ? bottomBox !== point.yBottom : Math.round(topBox) !== Math.round(point.plotHigh || 0);
        hasBottomWhisker = reversedYAxis ? Math.round(topBox) !== Math.round(point.plotHigh || 0) : bottomBox !== point.yBottom;
        topBox = crisp11(topBox, strokeWidth);
        bottomBox = crisp11(bottomBox, strokeWidth);
        path = [];
        path.push(
          ["M", crispX - halfWidth, bottomBox],
          ["L", crispX - halfWidth, topBox],
          ["L", crispX + halfWidth, topBox],
          ["L", crispX + halfWidth, bottomBox],
          ["Z"],
          // Ensure a nice rectangle #2602
          ["M", crispX, topBox],
          [
            "L",
            // #460, #2094
            crispX,
            hasTopWhisker ? Math.round(reversedYAxis ? point.yBottom : point.plotHigh) : topBox
          ],
          ["M", crispX, bottomBox],
          [
            "L",
            // #460, #2094
            crispX,
            hasBottomWhisker ? Math.round(reversedYAxis ? point.plotHigh : point.yBottom) : bottomBox
          ]
        );
        graphic[isNew ? "attr" : "animate"]({ d: path }).addClass(point.getClassName(), true);
      }
    }
  }
};
CandlestickSeries.defaultOptions = merge40(OHLCSeries2.defaultOptions, { tooltip: OHLCSeries2.defaultOptions.tooltip }, CandlestickSeriesDefaults_default);
SeriesRegistry_default.registerSeriesType("candlestick", CandlestickSeries);

// node_modules/highcharts/es-modules/Series/Flags/FlagsPoint.js
var { column: { prototype: { pointClass: ColumnPoint2 } } } = SeriesRegistry_default.seriesTypes;
var { isNumber: isNumber33 } = Utilities_default;
var FlagsPoint = class extends ColumnPoint2 {
  constructor() {
    super(...arguments);
    this.ttBelow = false;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  isValid() {
    return isNumber33(this.y) || typeof this.y === "undefined";
  }
  /**
   * @private
   */
  hasNewShapeType() {
    const shape = this.options.shape || this.series.options.shape;
    return this.graphic && shape && shape !== this.graphic.symbolKey;
  }
};
var FlagsPoint_default = FlagsPoint;

// node_modules/highcharts/es-modules/Series/Flags/FlagsSeriesDefaults.js
var FlagsSeriesDefaults = {
  /**
   * The corner radius of the border surrounding each flag. For `squarepin`
   * shaped flags only. A number signifies pixels. A percentage string, like
   * for example 50%, signifies a relative size.
   */
  borderRadius: 0,
  /**
   * In case the flag is placed on a series, on what point key to place
   * it. Line and columns have one key, `y`. In range or OHLC-type series,
   * however, the flag can optionally be placed on the `open`, `high`,
   * `low` or `close` key.
   *
   * @sample {highstock} stock/plotoptions/flags-onkey/
   *         Range series, flag on high
   *
   * @type       {string}
   * @default    y
   * @since      4.2.2
   * @product    highstock
   * @validvalue ["y", "open", "high", "low", "close"]
   * @apioption  plotOptions.flags.onKey
   */
  /**
   * The id of the series that the flags should be drawn on. If no id
   * is given, the flags are drawn on the x axis.
   *
   * @sample {highstock} stock/plotoptions/flags/
   *         Flags on series and on x axis
   *
   * @type      {string}
   * @product   highstock
   * @apioption plotOptions.flags.onSeries
   */
  pointRange: 0,
  // #673
  /**
   * Whether the flags are allowed to overlap sideways. If `false`, the
   * flags are moved sideways using an algorithm that seeks to place every
   * flag as close as possible to its original position.
   *
   * @sample {highstock} stock/plotoptions/flags-allowoverlapx
   *         Allow sideways overlap
   *
   * @since 6.0.4
   */
  allowOverlapX: false,
  /**
   * The shape of the marker. Can be one of "flag", "circlepin",
   * "squarepin", or an image of the format `url(/path-to-image.jpg)`.
   * Individual shapes can also be set for each point.
   *
   * @sample {highstock} stock/plotoptions/flags/
   *         Different shapes
   *
   * @type    {Highcharts.FlagsShapeValue}
   * @product highstock
   */
  shape: "flag",
  /**
   * When multiple flags in the same series fall on the same value, this
   * number determines the vertical offset between them.
   *
   * @sample {highstock} stock/plotoptions/flags-stackdistance/
   *         A greater stack distance
   *
   * @product highstock
   */
  stackDistance: 12,
  /**
   * Text alignment for the text inside the flag.
   *
   * @since      5.0.0
   * @product    highstock
   * @validvalue ["left", "center", "right"]
   */
  textAlign: "center",
  /**
   * Specific tooltip options for flag series. Flag series tooltips are
   * different from most other types in that a flag doesn't have a data
   * value, so the tooltip rather displays the `text` option for each
   * point.
   *
   * @extends   plotOptions.series.tooltip
   * @excluding changeDecimals, valueDecimals, valuePrefix, valueSuffix
   * @product   highstock
   */
  tooltip: {
    pointFormat: "{point.text}"
  },
  /**
   * @type {number|null}
   */
  threshold: null,
  /**
   * The text to display on each flag. This can be defined on series
   * level, or individually for each point. Defaults to `"A"`.
   *
   * @type      {string}
   * @default   A
   * @product   highstock
   * @apioption plotOptions.flags.title
   */
  /**
   * The y position of the top left corner of the flag relative to either
   * the series (if onSeries is defined), or the x axis. Defaults to
   * `-30`.
   *
   * @product highstock
   */
  y: -30,
  /**
   * Whether to use HTML to render the flag texts. Using HTML allows for
   * advanced formatting, images and reliable bi-directional text
   * rendering. Note that exported images won't respect the HTML, and that
   * HTML won't respect Z-index settings.
   *
   * @type      {boolean}
   * @default   false
   * @since     1.3
   * @product   highstock
   * @apioption plotOptions.flags.useHTML
   */
  /**
   * Fixed width of the flag's shape. By default, width is autocalculated
   * according to the flag's title.
   *
   * @sample {highstock} stock/demo/flags-shapes/
   *         Flags with fixed width
   *
   * @type      {number}
   * @product   highstock
   * @apioption plotOptions.flags.width
   */
  /**
   * Fixed height of the flag's shape. By default, height is
   * autocalculated according to the flag's title.
   *
   * @type      {number}
   * @product   highstock
   * @apioption plotOptions.flags.height
   */
  /**
   * The fill color for the flags.
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product highstock
   */
  fillColor: "#ffffff",
  /**
   * The color of the line/border of the flag.
   *
   * In styled mode, the stroke is set in the
   * `.highcharts-flag-series.highcharts-point` rule.
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default   #000000
   * @product   highstock
   * @apioption plotOptions.flags.lineColor
   */
  /**
   * The pixel width of the flag's line/border.
   *
   * @product highstock
   */
  lineWidth: 1,
  states: {
    /**
     * @extends plotOptions.column.states.hover
     * @product highstock
     */
    hover: {
      /**
       * The color of the line/border of the flag.
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product highstock
       */
      lineColor: "#000000",
      /**
       * The fill or background color of the flag.
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product highstock
       */
      fillColor: "#ccd3ff"
      /* Palette.highlightColor20 */
    }
  },
  /**
   * The text styles of the flag.
   *
   * In styled mode, the styles are set in the
   * `.highcharts-flag-series .highcharts-point` rule.
   *
   * @type    {Highcharts.CSSObject}
   * @default {"fontSize": "11px", "fontWeight": "bold"}
   * @product highstock
   */
  style: {
    /** @ignore-option */
    fontSize: "0.7em",
    /** @ignore-option */
    fontWeight: "bold"
  }
};
var FlagsSeriesDefaults_default = FlagsSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Flags/FlagsSymbols.js
var FlagsSymbols;
(function(FlagsSymbols2) {
  const modifiedMembers = [];
  function compose27(SVGRendererClass) {
    if (modifiedMembers.indexOf(SVGRendererClass) === -1) {
      modifiedMembers.push(SVGRendererClass);
      const symbols3 = SVGRendererClass.prototype.symbols;
      symbols3.flag = flag;
      createPinSymbol(symbols3, "circle");
      createPinSymbol(symbols3, "square");
    }
    const RendererClass = RendererRegistry_default.getRendererType();
    if (modifiedMembers.indexOf(RendererClass)) {
      modifiedMembers.push(RendererClass);
    }
  }
  FlagsSymbols2.compose = compose27;
  function flag(x, y, w, h, options2) {
    const anchorX = options2 && options2.anchorX || x, anchorY = options2 && options2.anchorY || y;
    const path = this.circle(anchorX - 1, anchorY - 1, 2, 2);
    path.push(["M", anchorX, anchorY], ["L", x, y + h], ["L", x, y], ["L", x + w, y], ["L", x + w, y + h], ["L", x, y + h], ["Z"]);
    return path;
  }
  function createPinSymbol(symbols3, shape) {
    symbols3[shape + "pin"] = function(x, y, w, h, options2) {
      const anchorX = options2 && options2.anchorX, anchorY = options2 && options2.anchorY;
      let path;
      if (shape === "circle" && h > w) {
        x -= Math.round((h - w) / 2);
        w = h;
      }
      path = symbols3[shape](x, y, w, h, options2);
      if (anchorX && anchorY) {
        let labelX = anchorX;
        if (shape === "circle") {
          labelX = x + w / 2;
        } else {
          const startSeg = path[0];
          const endSeg = path[1];
          if (startSeg[0] === "M" && endSeg[0] === "L") {
            labelX = (startSeg[1] + endSeg[1]) / 2;
          }
        }
        const labelY = y > anchorY ? y : y + h;
        path.push([
          "M",
          labelX,
          labelY
        ], [
          "L",
          anchorX,
          anchorY
        ]);
        path = path.concat(symbols3.circle(anchorX - 1, anchorY - 1, 2, 2));
      }
      return path;
    };
  }
})(FlagsSymbols || (FlagsSymbols = {}));
var FlagsSymbols_default = FlagsSymbols;

// node_modules/highcharts/es-modules/Series/OnSeriesComposition.js
var { composed: composed12 } = Globals_default;
var { prototype: columnProto } = ColumnSeries_default;
var { prototype: seriesProto2 } = Series_default;
var { defined: defined34, pushUnique: pushUnique15, stableSort: stableSort4 } = Utilities_default;
var OnSeriesComposition;
(function(OnSeriesComposition2) {
  function compose27(SeriesClass) {
    if (pushUnique15(composed12, "OnSeries")) {
      const seriesProto7 = SeriesClass.prototype;
      seriesProto7.getPlotBox = getPlotBox;
      seriesProto7.translate = translate;
    }
    return SeriesClass;
  }
  OnSeriesComposition2.compose = compose27;
  function getPlotBox(name) {
    return seriesProto2.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this, name);
  }
  OnSeriesComposition2.getPlotBox = getPlotBox;
  function translate() {
    columnProto.translate.apply(this);
    const series = this, options2 = series.options, chart = series.chart, points = series.points, optionsOnSeries = options2.onSeries, onSeries = optionsOnSeries && chart.get(optionsOnSeries), step = onSeries && onSeries.options.step, onData = onSeries && onSeries.points, inverted = chart.inverted, xAxis2 = series.xAxis, yAxis2 = series.yAxis;
    let cursor = points.length - 1, point, lastPoint, onKey = options2.onKey || "y", i = onData && onData.length, xOffset = 0, leftPoint, lastX, rightPoint, currentDataGrouping, distanceRatio;
    if (onSeries && onSeries.visible && i) {
      xOffset = (onSeries.pointXOffset || 0) + (onSeries.barW || 0) / 2;
      currentDataGrouping = onSeries.currentDataGrouping;
      lastX = onData[i - 1].x + (currentDataGrouping ? currentDataGrouping.totalRange : 0);
      stableSort4(points, (a, b) => a.x - b.x);
      onKey = "plot" + onKey[0].toUpperCase() + onKey.substr(1);
      while (i-- && points[cursor]) {
        leftPoint = onData[i];
        point = points[cursor];
        point.y = leftPoint.y;
        if (leftPoint.x <= point.x && typeof leftPoint[onKey] !== "undefined") {
          if (point.x <= lastX) {
            point.plotY = leftPoint[onKey];
            if (leftPoint.x < point.x && !step) {
              rightPoint = onData[i + 1];
              if (rightPoint && typeof rightPoint[onKey] !== "undefined") {
                if (defined34(point.plotX) && onSeries.is("spline")) {
                  leftPoint = leftPoint;
                  rightPoint = rightPoint;
                  const p0 = [
                    leftPoint.plotX || 0,
                    leftPoint.plotY || 0
                  ], p3 = [
                    rightPoint.plotX || 0,
                    rightPoint.plotY || 0
                  ], p1 = leftPoint.controlPoints?.high || p0, p2 = rightPoint.controlPoints?.low || p3, pixelThreshold = 0.25, maxIterations = 100, calculateCoord = (t2, key) => (
                    // The parametric formula for the
                    // cubic Bezier curve.
                    Math.pow(1 - t2, 3) * p0[key] + 3 * (1 - t2) * (1 - t2) * t2 * p1[key] + 3 * (1 - t2) * t2 * t2 * p2[key] + t2 * t2 * t2 * p3[key]
                  );
                  let tMin = 0, tMax = 1, t;
                  for (let i2 = 0; i2 < maxIterations; i2++) {
                    const tMid = (tMin + tMax) / 2;
                    const xMid = calculateCoord(tMid, 0);
                    if (xMid === null) {
                      break;
                    }
                    if (Math.abs(xMid - point.plotX) < pixelThreshold) {
                      t = tMid;
                      break;
                    }
                    if (xMid < point.plotX) {
                      tMin = tMid;
                    } else {
                      tMax = tMid;
                    }
                  }
                  if (defined34(t)) {
                    point.plotY = calculateCoord(t, 1);
                    point.y = yAxis2.toValue(point.plotY, true);
                  }
                } else {
                  distanceRatio = (point.x - leftPoint.x) / (rightPoint.x - leftPoint.x);
                  point.plotY += distanceRatio * // The plotY distance
                  (rightPoint[onKey] - leftPoint[onKey]);
                  point.y += distanceRatio * (rightPoint.y - leftPoint.y);
                }
              }
            }
          }
          cursor--;
          i++;
          if (cursor < 0) {
            break;
          }
        }
      }
    }
    points.forEach((point2, i2) => {
      let stackIndex;
      point2.plotX += xOffset;
      if (typeof point2.plotY === "undefined" || inverted) {
        if (point2.plotX >= 0 && point2.plotX <= xAxis2.len) {
          if (inverted) {
            point2.plotY = xAxis2.translate(point2.x, 0, 1, 0, 1);
            point2.plotX = defined34(point2.y) ? yAxis2.translate(point2.y, 0, 0, 0, 1) : 0;
          } else {
            point2.plotY = (xAxis2.opposite ? 0 : series.yAxis.len) + xAxis2.offset;
          }
        } else {
          point2.shapeArgs = {};
        }
      }
      lastPoint = points[i2 - 1];
      if (lastPoint && lastPoint.plotX === point2.plotX) {
        if (typeof lastPoint.stackIndex === "undefined") {
          lastPoint.stackIndex = 0;
        }
        stackIndex = lastPoint.stackIndex + 1;
      }
      point2.stackIndex = stackIndex;
    });
    this.onSeries = onSeries;
  }
  OnSeriesComposition2.translate = translate;
})(OnSeriesComposition || (OnSeriesComposition = {}));
var OnSeriesComposition_default = OnSeriesComposition;

// node_modules/highcharts/es-modules/Series/Flags/FlagsSeries.js
var { noop: noop6 } = Globals_default;
var { distribute: distribute4 } = RendererUtilities_default;
var { series: Series5, seriesTypes: { column: ColumnSeries5 } } = SeriesRegistry_default;
var { addEvent: addEvent31, defined: defined35, extend: extend37, isNumber: isNumber34, merge: merge41, objectEach: objectEach22, wrap: wrap2 } = Utilities_default;
var FlagsSeries = class extends ColumnSeries5 {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Disable animation, but keep clipping (#8546).
   * @private
   */
  animate(init3) {
    if (init3) {
      this.setClip();
    }
  }
  /**
   * Draw the markers.
   * @private
   */
  drawPoints() {
    const series = this, points = series.points, chart = series.chart, renderer = chart.renderer, inverted = chart.inverted, options2 = series.options, optionsY = options2.y, yAxis2 = series.yAxis, boxesMap = {}, boxes = [], borderRadius = isNumber34(options2.borderRadius) ? options2.borderRadius : 0;
    let plotX, plotY, shape, i, point, graphic, stackIndex, anchorY, attribs, outsideRight, centered;
    i = points.length;
    while (i--) {
      point = points[i];
      outsideRight = (inverted ? point.plotY : point.plotX) > series.xAxis.len;
      plotX = point.plotX;
      stackIndex = point.stackIndex;
      shape = point.options.shape || options2.shape;
      plotY = point.plotY;
      if (typeof plotY !== "undefined") {
        plotY = point.plotY + optionsY - (typeof stackIndex !== "undefined" && stackIndex * options2.stackDistance);
      }
      point.anchorX = stackIndex ? void 0 : point.plotX;
      anchorY = stackIndex ? void 0 : point.plotY;
      centered = shape !== "flag";
      graphic = point.graphic;
      if (typeof plotY !== "undefined" && plotX >= 0 && !outsideRight) {
        if (graphic && point.hasNewShapeType()) {
          graphic = graphic.destroy();
        }
        if (!graphic) {
          graphic = point.graphic = renderer.label("", 0, void 0, shape, void 0, void 0, options2.useHTML).addClass("highcharts-point").add(series.markerGroup);
          if (point.graphic.div) {
            point.graphic.div.point = point;
          }
          graphic.isNew = true;
        }
        graphic.attr({
          align: centered ? "center" : "left",
          width: options2.width,
          height: options2.height,
          "text-align": options2.textAlign,
          r: borderRadius
        });
        if (!chart.styledMode) {
          graphic.attr(series.pointAttribs(point)).css(merge41(options2.style, point.style)).shadow(options2.shadow);
        }
        if (plotX > 0) {
          plotX -= graphic.strokeWidth() % 2;
        }
        attribs = {
          y: plotY,
          anchorY
        };
        if (options2.allowOverlapX) {
          attribs.x = plotX;
          attribs.anchorX = point.anchorX;
        }
        graphic.attr({
          // Allow empty string as a flag title (#20549)
          text: point.options.title ?? options2.title ?? "A"
        })[graphic.isNew ? "attr" : "animate"](attribs);
        if (!options2.allowOverlapX) {
          if (!boxesMap[point.plotX]) {
            boxesMap[point.plotX] = {
              align: centered ? 0.5 : 0,
              size: graphic.width || 0,
              target: plotX,
              anchorX: plotX
            };
          } else {
            boxesMap[point.plotX].size = Math.max(boxesMap[point.plotX].size, graphic.width || 0);
          }
        }
        point.tooltipPos = [
          plotX,
          plotY + yAxis2.pos - chart.plotTop
        ];
      } else if (graphic) {
        point.graphic = graphic.destroy();
      }
    }
    if (!options2.allowOverlapX) {
      let maxDistance = 100;
      objectEach22(boxesMap, function(box) {
        box.plotX = box.anchorX;
        boxes.push(box);
        maxDistance = Math.max(box.size, maxDistance);
      });
      distribute4(boxes, inverted ? yAxis2.len : this.xAxis.len, maxDistance);
      for (const point2 of points) {
        const plotX2 = point2.plotX, graphic2 = point2.graphic, box = graphic2 && boxesMap[plotX2];
        if (box && graphic2) {
          if (!defined35(box.pos)) {
            graphic2.hide().isNew = true;
          } else {
            graphic2[graphic2.isNew ? "attr" : "animate"]({
              x: box.pos + (box.align || 0) * box.size,
              anchorX: point2.anchorX
            }).show().isNew = false;
          }
        }
      }
    }
    if (options2.useHTML && series.markerGroup) {
      wrap2(series.markerGroup, "on", function(proceed) {
        return SVGElement_default.prototype.on.apply(
          // For HTML
          // eslint-disable-next-line no-invalid-this
          proceed.apply(this, [].slice.call(arguments, 1)),
          // And for SVG
          [].slice.call(arguments, 1)
        );
      });
    }
  }
  /**
   * Extend the column trackers with listeners to expand and contract
   * stacks.
   * @private
   */
  drawTracker() {
    const series = this, points = series.points;
    super.drawTracker();
    for (const point of points) {
      const graphic = point.graphic;
      if (graphic) {
        if (point.unbindMouseOver) {
          point.unbindMouseOver();
        }
        point.unbindMouseOver = addEvent31(graphic.element, "mouseover", function() {
          if (point.stackIndex > 0 && !point.raised) {
            point._y = graphic.y;
            graphic.attr({
              y: point._y - 8
            });
            point.raised = true;
          }
          for (const otherPoint of points) {
            if (otherPoint !== point && otherPoint.raised && otherPoint.graphic) {
              otherPoint.graphic.attr({
                y: otherPoint._y
              });
              otherPoint.raised = false;
            }
          }
        });
      }
    }
  }
  /**
   * Get presentational attributes
   * @private
   */
  pointAttribs(point, state) {
    const options2 = this.options, color14 = point && point.color || this.color;
    let lineColor = options2.lineColor, lineWidth = point && point.lineWidth, fill = point && point.fillColor || options2.fillColor;
    if (state) {
      fill = options2.states[state].fillColor;
      lineColor = options2.states[state].lineColor;
      lineWidth = options2.states[state].lineWidth;
    }
    return {
      fill: fill || color14,
      stroke: lineColor || color14,
      "stroke-width": lineWidth || options2.lineWidth || 0
    };
  }
  /**
   * @private
   */
  setClip() {
    Series5.prototype.setClip.apply(this, arguments);
    if (this.options.clip !== false && this.sharedClipKey && this.markerGroup) {
      this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);
    }
  }
};
FlagsSeries.compose = FlagsSymbols_default.compose;
FlagsSeries.defaultOptions = merge41(ColumnSeries5.defaultOptions, FlagsSeriesDefaults_default);
OnSeriesComposition_default.compose(FlagsSeries);
extend37(FlagsSeries.prototype, {
  allowDG: false,
  forceCrop: true,
  invertible: false,
  // Flags series group should not be invertible (#14063).
  noSharedTooltip: true,
  pointClass: FlagsPoint_default,
  sorted: false,
  takeOrdinalPosition: false,
  // #1074
  trackerGroups: ["markerGroup"],
  buildKDTree: noop6,
  /**
   * Inherit the initialization from base Series.
   * @private
   */
  init: Series5.prototype.init
});
SeriesRegistry_default.registerSeriesType("flags", FlagsSeries);
var FlagsSeries_default = FlagsSeries;

// node_modules/highcharts/es-modules/Core/Axis/BrokenAxis.js
var { addEvent: addEvent32, find: find9, fireEvent: fireEvent25, isArray: isArray15, isNumber: isNumber35, pick: pick43 } = Utilities_default;
var BrokenAxis;
(function(BrokenAxis2) {
  function compose27(AxisClass, SeriesClass) {
    if (!AxisClass.keepProps.includes("brokenAxis")) {
      AxisClass.keepProps.push("brokenAxis");
      addEvent32(AxisClass, "init", onAxisInit4);
      addEvent32(AxisClass, "afterInit", onAxisAfterInit);
      addEvent32(AxisClass, "afterSetTickPositions", onAxisAfterSetTickPositions);
      addEvent32(AxisClass, "afterSetOptions", onAxisAfterSetOptions4);
      const seriesProto7 = SeriesClass.prototype;
      seriesProto7.drawBreaks = seriesDrawBreaks;
      seriesProto7.gappedPath = seriesGappedPath;
      addEvent32(SeriesClass, "afterGeneratePoints", onSeriesAfterGeneratePoints);
      addEvent32(SeriesClass, "afterRender", onSeriesAfterRender);
    }
    return AxisClass;
  }
  BrokenAxis2.compose = compose27;
  function onAxisAfterInit() {
    if (typeof this.brokenAxis !== "undefined") {
      this.brokenAxis.setBreaks(this.options.breaks, false);
    }
  }
  function onAxisAfterSetOptions4() {
    const axis = this;
    if (axis.brokenAxis?.hasBreaks) {
      axis.options.ordinal = false;
    }
  }
  function onAxisAfterSetTickPositions() {
    const axis = this, brokenAxis = axis.brokenAxis;
    if (brokenAxis?.hasBreaks) {
      const tickPositions = axis.tickPositions, info = axis.tickPositions.info, newPositions = [];
      for (let i = 0; i < tickPositions.length; i++) {
        if (!brokenAxis.isInAnyBreak(tickPositions[i])) {
          newPositions.push(tickPositions[i]);
        }
      }
      axis.tickPositions = newPositions;
      axis.tickPositions.info = info;
    }
  }
  function onAxisInit4() {
    const axis = this;
    if (!axis.brokenAxis) {
      axis.brokenAxis = new Additions(axis);
    }
  }
  function onSeriesAfterGeneratePoints() {
    const { isDirty, options: { connectNulls }, points, xAxis: xAxis2, yAxis: yAxis2 } = this;
    if (isDirty) {
      let i = points.length;
      while (i--) {
        const point = points[i];
        const nullGap = point.y === null && connectNulls === false;
        const isPointInBreak = !nullGap && (xAxis2?.brokenAxis?.isInAnyBreak(point.x, true) || yAxis2?.brokenAxis?.isInAnyBreak(point.y, true));
        point.visible = isPointInBreak ? false : point.options.visible !== false;
      }
    }
  }
  function onSeriesAfterRender() {
    this.drawBreaks(this.xAxis, ["x"]);
    this.drawBreaks(this.yAxis, pick43(this.pointArrayMap, ["y"]));
  }
  function seriesDrawBreaks(axis, keys) {
    const series = this, points = series.points;
    let breaks, threshold, y;
    if (axis?.brokenAxis?.hasBreaks) {
      const brokenAxis = axis.brokenAxis;
      keys.forEach(function(key) {
        breaks = brokenAxis?.breakArray || [];
        threshold = axis.isXAxis ? axis.min : pick43(series.options.threshold, axis.min);
        const breaksOutOfRange = axis?.options?.breaks?.filter(function(brk) {
          let isOut = true;
          for (let i = 0; i < breaks.length; i++) {
            const otherBreak = breaks[i];
            if (otherBreak.from === brk.from && otherBreak.to === brk.to) {
              isOut = false;
              break;
            }
          }
          return isOut;
        });
        points.forEach(function(point) {
          y = pick43(point["stack" + key.toUpperCase()], point[key]);
          breaks.forEach(function(brk) {
            if (isNumber35(threshold) && isNumber35(y)) {
              let eventName = "";
              if (threshold < brk.from && y > brk.to || threshold > brk.from && y < brk.from) {
                eventName = "pointBreak";
              } else if (threshold < brk.from && y > brk.from && y < brk.to || threshold > brk.from && y > brk.to && y < brk.from) {
                eventName = "pointInBreak";
              }
              if (eventName) {
                fireEvent25(axis, eventName, { point, brk });
              }
            }
          });
          breaksOutOfRange?.forEach(function(brk) {
            fireEvent25(axis, "pointOutsideOfBreak", { point, brk });
          });
        });
      });
    }
  }
  function seriesGappedPath() {
    const currentDataGrouping = this.currentDataGrouping, groupingSize = currentDataGrouping?.gapSize, points = this.points.slice(), yAxis2 = this.yAxis;
    let gapSize = this.options.gapSize, i = points.length - 1, stack;
    if (gapSize && i > 0) {
      if (this.options.gapUnit !== "value") {
        gapSize *= this.basePointRange;
      }
      if (groupingSize && groupingSize > gapSize && // Except when DG is forced (e.g. from other series)
      // and has lower granularity than actual points (#11351)
      groupingSize >= this.basePointRange) {
        gapSize = groupingSize;
      }
      let current, next;
      while (i--) {
        if (!(next && next.visible !== false)) {
          next = points[i + 1];
        }
        current = points[i];
        if (next.visible === false || current.visible === false) {
          continue;
        }
        if (next.x - current.x > gapSize) {
          const xRange = (current.x + next.x) / 2;
          points.splice(
            // Insert after this one
            i + 1,
            0,
            {
              isNull: true,
              x: xRange
            }
          );
          if (yAxis2.stacking && this.options.stacking) {
            stack = yAxis2.stacking.stacks[this.stackKey][xRange] = new StackItem_default(yAxis2, yAxis2.options.stackLabels, false, xRange, this.stack);
            stack.total = 0;
          }
        }
        next = current;
      }
    }
    return this.getGraphPath(points);
  }
  class Additions {
    /* *
     *
     *  Static Functions
     *
     * */
    /**
     * @private
     */
    static isInBreak(brk, val) {
      const repeat = brk.repeat || Infinity, from = brk.from, length = brk.to - brk.from, test = val >= from ? (val - from) % repeat : repeat - (from - val) % repeat;
      let ret;
      if (!brk.inclusive) {
        ret = test < length && test !== 0;
      } else {
        ret = test <= length;
      }
      return ret;
    }
    /**
     * @private
     */
    static lin2Val(val) {
      const axis = this;
      const brokenAxis = axis.brokenAxis;
      const breakArray = brokenAxis?.breakArray;
      if (!breakArray || !isNumber35(val)) {
        return val;
      }
      let nval = val, brk, i;
      for (i = 0; i < breakArray.length; i++) {
        brk = breakArray[i];
        if (brk.from >= nval) {
          break;
        } else if (brk.to < nval) {
          nval += brk.len;
        } else if (Additions.isInBreak(brk, nval)) {
          nval += brk.len;
        }
      }
      return nval;
    }
    /**
     * @private
     */
    static val2Lin(val) {
      const axis = this;
      const brokenAxis = axis.brokenAxis;
      const breakArray = brokenAxis?.breakArray;
      if (!breakArray || !isNumber35(val)) {
        return val;
      }
      let nval = val, brk, i;
      for (i = 0; i < breakArray.length; i++) {
        brk = breakArray[i];
        if (brk.to <= val) {
          nval -= brk.len;
        } else if (brk.from >= val) {
          break;
        } else if (Additions.isInBreak(brk, val)) {
          nval -= val - brk.from;
          break;
        }
      }
      return nval;
    }
    /* *
     *
     *  Constructors
     *
     * */
    constructor(axis) {
      this.hasBreaks = false;
      this.axis = axis;
    }
    /* *
     *
     *  Functions
     *
     * */
    /**
     * Returns the first break found where the x is larger then break.from
     * and smaller then break.to.
     *
     * @param {number} x
     * The number which should be within a break.
     *
     * @param {Array<Highcharts.XAxisBreaksOptions>} breaks
     * The array of breaks to search within.
     *
     * @return {Highcharts.XAxisBreaksOptions|undefined}
     * Returns the first break found that matches, returns false if no break
     * is found.
     */
    findBreakAt(x, breaks) {
      return find9(breaks, function(b) {
        return b.from < x && x < b.to;
      });
    }
    /**
     * @private
     */
    isInAnyBreak(val, testKeep) {
      const brokenAxis = this, axis = brokenAxis.axis, breaks = axis.options.breaks || [];
      let i = breaks.length, inbrk, keep, ret;
      if (i && isNumber35(val)) {
        while (i--) {
          if (Additions.isInBreak(breaks[i], val)) {
            inbrk = true;
            if (!keep) {
              keep = pick43(breaks[i].showPoints, !axis.isXAxis);
            }
          }
        }
        if (inbrk && testKeep) {
          ret = inbrk && !keep;
        } else {
          ret = inbrk;
        }
      }
      return ret;
    }
    /**
     * Dynamically set or unset breaks in an axis. This function in lighter
     * than using Axis.update, and it also preserves animation.
     *
     * @private
     * @function Highcharts.Axis#setBreaks
     *
     * @param {Array<Highcharts.XAxisBreaksOptions>} [breaks]
     * The breaks to add. When `undefined` it removes existing breaks.
     *
     * @param {boolean} [redraw=true]
     * Whether to redraw the chart immediately.
     */
    setBreaks(breaks, redraw) {
      const brokenAxis = this, axis = brokenAxis.axis, time = axis.chart.time, hasBreaks = isArray15(breaks) && !!breaks.length && !!Object.keys(breaks[0]).length;
      axis.isDirty = brokenAxis.hasBreaks !== hasBreaks;
      brokenAxis.hasBreaks = hasBreaks;
      breaks?.forEach((brk) => {
        brk.from = time.parse(brk.from) || 0;
        brk.to = time.parse(brk.to) || 0;
      });
      if (breaks !== axis.options.breaks) {
        axis.options.breaks = axis.userOptions.breaks = breaks;
      }
      axis.forceRedraw = true;
      axis.series.forEach(function(series) {
        series.isDirty = true;
      });
      if (!hasBreaks && axis.val2lin === Additions.val2Lin) {
        delete axis.val2lin;
        delete axis.lin2val;
      }
      if (hasBreaks) {
        axis.userOptions.ordinal = false;
        axis.lin2val = Additions.lin2Val;
        axis.val2lin = Additions.val2Lin;
        axis.setExtremes = function(newMin, newMax, redraw2, animation, eventArguments) {
          if (brokenAxis.hasBreaks) {
            const breaks2 = this.options.breaks || [];
            let axisBreak;
            while (axisBreak = brokenAxis.findBreakAt(newMin, breaks2)) {
              newMin = axisBreak.to;
            }
            while (axisBreak = brokenAxis.findBreakAt(newMax, breaks2)) {
              newMax = axisBreak.from;
            }
            if (newMax < newMin) {
              newMax = newMin;
            }
          }
          axis.constructor.prototype.setExtremes.call(this, newMin, newMax, redraw2, animation, eventArguments);
        };
        axis.setAxisTranslation = function() {
          axis.constructor.prototype.setAxisTranslation.call(this);
          brokenAxis.unitLength = void 0;
          if (brokenAxis.hasBreaks) {
            const breaks2 = axis.options.breaks || [], breakArrayT = [], breakArray = [], pointRangePadding = pick43(axis.pointRangePadding, 0);
            let length = 0, inBrk, repeat, min4 = axis.userMin || axis.min, max4 = axis.userMax || axis.max, start, i;
            breaks2.forEach(function(brk) {
              repeat = brk.repeat || Infinity;
              if (isNumber35(min4) && isNumber35(max4)) {
                if (Additions.isInBreak(brk, min4)) {
                  min4 += brk.to % repeat - min4 % repeat;
                }
                if (Additions.isInBreak(brk, max4)) {
                  max4 -= max4 % repeat - brk.from % repeat;
                }
              }
            });
            breaks2.forEach(function(brk) {
              start = brk.from;
              repeat = brk.repeat || Infinity;
              if (isNumber35(min4) && isNumber35(max4)) {
                while (start - repeat > min4) {
                  start -= repeat;
                }
                while (start < min4) {
                  start += repeat;
                }
                for (i = start; i < max4; i += repeat) {
                  breakArrayT.push({
                    value: i,
                    move: "in"
                  });
                  breakArrayT.push({
                    value: i + brk.to - brk.from,
                    move: "out",
                    size: brk.breakSize
                  });
                }
              }
            });
            breakArrayT.sort(function(a, b) {
              return a.value === b.value ? (a.move === "in" ? 0 : 1) - (b.move === "in" ? 0 : 1) : a.value - b.value;
            });
            inBrk = 0;
            start = min4;
            breakArrayT.forEach(function(brk) {
              inBrk += brk.move === "in" ? 1 : -1;
              if (inBrk === 1 && brk.move === "in") {
                start = brk.value;
              }
              if (inBrk === 0 && isNumber35(start)) {
                breakArray.push({
                  from: start,
                  to: brk.value,
                  len: brk.value - start - (brk.size || 0)
                });
                length += brk.value - start - (brk.size || 0);
              }
            });
            brokenAxis.breakArray = breakArray;
            if (isNumber35(min4) && isNumber35(max4) && isNumber35(axis.min)) {
              brokenAxis.unitLength = max4 - min4 - length + pointRangePadding;
              fireEvent25(axis, "afterBreaks");
              if (axis.staticScale) {
                axis.transA = axis.staticScale;
              } else if (brokenAxis.unitLength) {
                axis.transA *= (max4 - axis.min + pointRangePadding) / brokenAxis.unitLength;
              }
              if (pointRangePadding) {
                axis.minPixelPadding = axis.transA * (axis.minPointOffset || 0);
              }
              axis.min = min4;
              axis.max = max4;
            }
          }
        };
      }
      if (pick43(redraw, true)) {
        axis.chart.redraw();
      }
    }
  }
  BrokenAxis2.Additions = Additions;
})(BrokenAxis || (BrokenAxis = {}));
var BrokenAxis_default = BrokenAxis;

// node_modules/highcharts/es-modules/masters/modules/broken-axis.src.js
var G2 = Globals_default;
G2.BrokenAxis = G2.BrokenAxis || BrokenAxis_default;
G2.BrokenAxis.compose(G2.Axis, G2.Series);

// node_modules/highcharts/es-modules/Extensions/DataGrouping/ApproximationRegistry.js
var ApproximationRegistry = {
  // Approximations added programmatically
};
var ApproximationRegistry_default = ApproximationRegistry;

// node_modules/highcharts/es-modules/Extensions/DataGrouping/ApproximationDefaults.js
var { arrayMax: arrayMax7, arrayMin: arrayMin6, correctFloat: correctFloat11, extend: extend38, isNumber: isNumber36 } = Utilities_default;
function average(arr) {
  const len = arr.length;
  let ret = sum(arr);
  if (isNumber36(ret) && len) {
    ret = correctFloat11(ret / len);
  }
  return ret;
}
function averages() {
  const ret = [];
  [].forEach.call(arguments, function(arr) {
    ret.push(average(arr));
  });
  return typeof ret[0] === "undefined" ? void 0 : ret;
}
function close(arr) {
  return arr.length ? arr[arr.length - 1] : arr.hasNulls ? null : void 0;
}
function high(arr) {
  return arr.length ? arrayMax7(arr) : arr.hasNulls ? null : void 0;
}
function hlc(high2, low2, close2) {
  high2 = ApproximationRegistry_default.high(high2);
  low2 = ApproximationRegistry_default.low(low2);
  close2 = ApproximationRegistry_default.close(close2);
  if (isNumber36(high2) || isNumber36(low2) || isNumber36(close2)) {
    return [high2, low2, close2];
  }
}
function low(arr) {
  return arr.length ? arrayMin6(arr) : arr.hasNulls ? null : void 0;
}
function ohlc(open2, high2, low2, close2) {
  open2 = ApproximationRegistry_default.open(open2);
  high2 = ApproximationRegistry_default.high(high2);
  low2 = ApproximationRegistry_default.low(low2);
  close2 = ApproximationRegistry_default.close(close2);
  if (isNumber36(open2) || isNumber36(high2) || isNumber36(low2) || isNumber36(close2)) {
    return [open2, high2, low2, close2];
  }
}
function open(arr) {
  return arr.length ? arr[0] : arr.hasNulls ? null : void 0;
}
function range(low2, high2) {
  low2 = ApproximationRegistry_default.low(low2);
  high2 = ApproximationRegistry_default.high(high2);
  if (isNumber36(low2) || isNumber36(high2)) {
    return [low2, high2];
  }
  if (low2 === null && high2 === null) {
    return null;
  }
}
function sum(arr) {
  let len = arr.length, ret;
  if (!len && arr.hasNulls) {
    ret = null;
  } else if (len) {
    ret = 0;
    while (len--) {
      ret += arr[len];
    }
  }
  return ret;
}
var ApproximationDefaults = {
  average,
  averages,
  close,
  high,
  hlc,
  low,
  ohlc,
  open,
  range,
  sum
};
extend38(ApproximationRegistry_default, ApproximationDefaults);
var ApproximationDefaults_default = ApproximationDefaults;

// node_modules/highcharts/es-modules/Extensions/DataGrouping/DataGroupingDefaults.js
var common = {
  /// enabled: null, // (true for stock charts, false for basic),
  // forced: undefined,
  groupPixelWidth: 2,
  // The first one is the point or start value, the second is the start
  // value if we're dealing with range, the third one is the end value if
  // dealing with a range
  dateTimeLabelFormats: {
    millisecond: [
      "%[AebHMSL]",
      "%[AebHMSL]",
      "-%[HMSL]"
    ],
    second: [
      "%[AebHMS]",
      "%[AebHMS]",
      "-%[HMS]"
    ],
    minute: [
      "%[AebHM]",
      "%[AebHM]",
      "-%[HM]"
    ],
    hour: [
      "%[AebHM]",
      "%[AebHM]",
      "-%[HM]"
    ],
    day: [
      "%[AebY]",
      "%[Aeb]",
      "-%[AebY]"
    ],
    week: [
      "%v %[AebY]",
      "%[Aeb]",
      "-%[AebY]"
    ],
    month: [
      "%[BY]",
      "%[B]",
      "-%[BY]"
    ],
    year: [
      "%Y",
      "%Y",
      "-%Y"
    ]
  }
  /// smoothed = false, // enable this for navigator series only
};
var seriesSpecific = {
  line: {},
  spline: {},
  area: {},
  areaspline: {},
  arearange: {},
  column: {
    groupPixelWidth: 10
  },
  columnrange: {
    groupPixelWidth: 10
  },
  candlestick: {
    groupPixelWidth: 10
  },
  ohlc: {
    groupPixelWidth: 5
  },
  hlc: {
    groupPixelWidth: 5
    // Move to HeikinAshiSeries.ts after refactoring data grouping.
  },
  heikinashi: {
    groupPixelWidth: 10
  }
};
var units = [
  [
    "millisecond",
    // Unit name
    [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]
    // Allowed multiples
  ],
  [
    "second",
    [1, 2, 5, 10, 15, 30]
  ],
  [
    "minute",
    [1, 2, 5, 10, 15, 30]
  ],
  [
    "hour",
    [1, 2, 3, 4, 6, 8, 12]
  ],
  [
    "day",
    [1]
  ],
  [
    "week",
    [1]
  ],
  [
    "month",
    [1, 3, 6]
  ],
  [
    "year",
    null
  ]
];
var DataGroupingDefaults = {
  common,
  seriesSpecific,
  units
};
var DataGroupingDefaults_default = DataGroupingDefaults;

// node_modules/highcharts/es-modules/Extensions/DataGrouping/DataGroupingAxisComposition.js
var { addEvent: addEvent33, extend: extend39, merge: merge42, pick: pick44 } = Utilities_default;
var AxisConstructor;
function applyGrouping(e) {
  const axis = this, series = axis.series;
  series.forEach(function(series2) {
    series2.groupPixelWidth = void 0;
  });
  series.forEach(function(series2) {
    series2.groupPixelWidth = axis.getGroupPixelWidth && axis.getGroupPixelWidth();
    if (series2.groupPixelWidth) {
      series2.hasProcessed = true;
    }
    series2.applyGrouping(!!e.hasExtremesChanged);
  });
}
function compose6(AxisClass) {
  AxisConstructor = AxisClass;
  const axisProto = AxisClass.prototype;
  if (!axisProto.applyGrouping) {
    addEvent33(AxisClass, "afterSetScale", onAfterSetScale);
    addEvent33(AxisClass, "postProcessData", applyGrouping);
    extend39(axisProto, {
      applyGrouping,
      getGroupPixelWidth,
      setDataGrouping
    });
  }
}
function getGroupPixelWidth() {
  const series = this.series;
  let i = series.length, groupPixelWidth = 0, doGrouping = false, dataLength, dgOptions;
  while (i--) {
    dgOptions = series[i].options.dataGrouping;
    if (dgOptions) {
      groupPixelWidth = Math.max(
        groupPixelWidth,
        // Fallback to commonOptions (#9693)
        pick44(dgOptions.groupPixelWidth, DataGroupingDefaults_default.common.groupPixelWidth)
      );
      dataLength = (series[i].dataTable.modified || series[i].dataTable).rowCount;
      if (series[i].groupPixelWidth || dataLength > this.chart.plotSizeX / groupPixelWidth || dataLength && dgOptions.forced) {
        doGrouping = true;
      }
    }
  }
  return doGrouping ? groupPixelWidth : 0;
}
function onAfterSetScale() {
  this.series.forEach(function(series) {
    series.hasProcessed = false;
  });
}
function setDataGrouping(dataGrouping, redraw) {
  const axis = this;
  let i;
  redraw = pick44(redraw, true);
  if (!dataGrouping) {
    dataGrouping = {
      forced: false,
      units: null
    };
  }
  if (this instanceof AxisConstructor) {
    i = this.series.length;
    while (i--) {
      this.series[i].update({
        dataGrouping
      }, false);
    }
  } else {
    this.chart.options.series.forEach(function(seriesOptions) {
      seriesOptions.dataGrouping = typeof dataGrouping === "boolean" ? dataGrouping : merge42(dataGrouping, seriesOptions.dataGrouping);
    });
  }
  if (axis.ordinal) {
    axis.ordinal.slope = void 0;
  }
  if (redraw) {
    this.chart.redraw();
  }
}
var DataGroupingAxisComposition = {
  compose: compose6
};
var DataGroupingAxisComposition_default = DataGroupingAxisComposition;

// node_modules/highcharts/es-modules/Extensions/DataGrouping/DataGroupingSeriesComposition.js
var { series: { prototype: seriesProto3 } } = SeriesRegistry_default;
var { addEvent: addEvent34, defined: defined36, error: error8, extend: extend40, isNumber: isNumber37, merge: merge43, pick: pick45, splat: splat12 } = Utilities_default;
var baseGeneratePoints = seriesProto3.generatePoints;
function adjustExtremes(xAxis2, groupedXData) {
  if (defined36(groupedXData[0]) && isNumber37(xAxis2.min) && isNumber37(xAxis2.dataMin) && groupedXData[0] < xAxis2.min) {
    if (!defined36(xAxis2.options.min) && xAxis2.min <= xAxis2.dataMin || xAxis2.min === xAxis2.dataMin) {
      xAxis2.min = Math.min(groupedXData[0], xAxis2.min);
    }
    xAxis2.dataMin = Math.min(groupedXData[0], xAxis2.dataMin);
  }
  if (defined36(groupedXData[groupedXData.length - 1]) && isNumber37(xAxis2.max) && isNumber37(xAxis2.dataMax) && groupedXData[groupedXData.length - 1] > xAxis2.max) {
    if (!defined36(xAxis2.options.max) && isNumber37(xAxis2.dataMax) && xAxis2.max >= xAxis2.dataMax || xAxis2.max === xAxis2.dataMax) {
      xAxis2.max = Math.max(groupedXData[groupedXData.length - 1], xAxis2.max);
    }
    xAxis2.dataMax = Math.max(groupedXData[groupedXData.length - 1], xAxis2.dataMax);
  }
}
function anchorPoints(series, groupedXData, xMax) {
  const options2 = series.options, dataGroupingOptions = options2.dataGrouping, totalRange = series.currentDataGrouping && series.currentDataGrouping.gapSize, xData = series.getColumn("x");
  if (!(dataGroupingOptions && xData.length && totalRange && series.groupMap)) {
    return;
  }
  const groupedDataLastIndex = groupedXData.length - 1, anchor = dataGroupingOptions.anchor, firstAnchor = dataGroupingOptions.firstAnchor, lastAnchor = dataGroupingOptions.lastAnchor;
  let anchorIndexIterator = groupedXData.length - 1, anchorFirstIndex = 0;
  if (firstAnchor && xData[0] >= groupedXData[0]) {
    anchorFirstIndex++;
    const groupStart = series.groupMap[0].start, groupLength = series.groupMap[0].length;
    let firstGroupEnd;
    if (isNumber37(groupStart) && isNumber37(groupLength)) {
      firstGroupEnd = groupStart + (groupLength - 1);
    }
    groupedXData[0] = {
      start: groupedXData[0],
      middle: groupedXData[0] + 0.5 * totalRange,
      end: groupedXData[0] + totalRange,
      firstPoint: xData[0],
      lastPoint: firstGroupEnd && xData[firstGroupEnd]
    }[firstAnchor];
  }
  if (groupedDataLastIndex > 0 && lastAnchor && totalRange && groupedXData[groupedDataLastIndex] >= xMax - totalRange) {
    anchorIndexIterator--;
    const lastGroupStart = series.groupMap[series.groupMap.length - 1].start;
    groupedXData[groupedDataLastIndex] = {
      start: groupedXData[groupedDataLastIndex],
      middle: groupedXData[groupedDataLastIndex] + 0.5 * totalRange,
      end: groupedXData[groupedDataLastIndex] + totalRange,
      firstPoint: lastGroupStart && xData[lastGroupStart],
      lastPoint: xData[xData.length - 1]
    }[lastAnchor];
  }
  if (anchor && anchor !== "start") {
    const shiftInterval = totalRange * { middle: 0.5, end: 1 }[anchor];
    while (anchorIndexIterator >= anchorFirstIndex) {
      groupedXData[anchorIndexIterator] += shiftInterval;
      anchorIndexIterator--;
    }
  }
}
function applyGrouping2(hasExtremesChanged) {
  const series = this, chart = series.chart, options2 = series.options, dataGroupingOptions = options2.dataGrouping, groupingEnabled = series.allowDG !== false && dataGroupingOptions && pick45(dataGroupingOptions.enabled, chart.options.isStock), reserveSpace = series.reserveSpace(), lastDataGrouping = this.currentDataGrouping;
  let currentDataGrouping, croppedData, revertRequireSorting = false;
  if (groupingEnabled && !series.requireSorting) {
    series.requireSorting = revertRequireSorting = true;
  }
  const skip = skipDataGrouping(series, hasExtremesChanged) === false || !groupingEnabled;
  if (revertRequireSorting) {
    series.requireSorting = false;
  }
  if (skip) {
    return;
  }
  series.destroyGroupedData();
  const table = dataGroupingOptions.groupAll ? series.dataTable : series.dataTable.modified || series.dataTable, processedXData = series.getColumn("x", !dataGroupingOptions.groupAll), xData = processedXData, plotSizeX = chart.plotSizeX, xAxis2 = series.xAxis, extremes = xAxis2.getExtremes(), ordinal = xAxis2.options.ordinal, groupPixelWidth = series.groupPixelWidth;
  let i, hasGroupedData;
  if (groupPixelWidth && xData && table.rowCount && plotSizeX && isNumber37(extremes.min)) {
    hasGroupedData = true;
    series.isDirty = true;
    series.points = null;
    const xMin = extremes.min, xMax = extremes.max, groupIntervalFactor = ordinal && xAxis2.ordinal && xAxis2.ordinal.getGroupIntervalFactor(xMin, xMax, series) || 1, interval = groupPixelWidth * (xMax - xMin) / plotSizeX * groupIntervalFactor, groupPositions = xAxis2.getTimeTicks(
      DateTimeAxis_default.Additions.prototype.normalizeTimeTickInterval(interval, dataGroupingOptions.units || DataGroupingDefaults_default.units),
      // Processed data may extend beyond axis (#4907)
      Math.min(xMin, xData[0]),
      Math.max(xMax, xData[xData.length - 1]),
      xAxis2.options.startOfWeek,
      processedXData,
      series.closestPointRange
    ), groupedData = seriesProto3.groupData.apply(series, [
      table,
      groupPositions,
      dataGroupingOptions.approximation
    ]);
    let modified = groupedData.modified, groupedXData = modified.getColumn("x", true), gapSize = 0;
    if (dataGroupingOptions?.smoothed && modified.rowCount) {
      dataGroupingOptions.firstAnchor = "firstPoint";
      dataGroupingOptions.anchor = "middle";
      dataGroupingOptions.lastAnchor = "lastPoint";
      error8(32, false, chart, {
        "dataGrouping.smoothed": "use dataGrouping.anchor"
      });
    }
    for (i = 1; i < groupPositions.length; i++) {
      if (!groupPositions.info.segmentStarts || groupPositions.info.segmentStarts.indexOf(i) === -1) {
        gapSize = Math.max(groupPositions[i] - groupPositions[i - 1], gapSize);
      }
    }
    currentDataGrouping = groupPositions.info;
    currentDataGrouping.gapSize = gapSize;
    series.closestPointRange = groupPositions.info.totalRange;
    series.groupMap = groupedData.groupMap;
    series.currentDataGrouping = currentDataGrouping;
    anchorPoints(series, groupedXData || [], xMax);
    if (reserveSpace && groupedXData) {
      adjustExtremes(xAxis2, groupedXData);
    }
    if (dataGroupingOptions.groupAll) {
      series.allGroupedTable = modified;
      croppedData = series.cropData(modified, xAxis2.min || 0, xAxis2.max || 0);
      modified = croppedData.modified;
      groupedXData = modified.getColumn("x");
      series.cropStart = croppedData.start;
    }
    series.dataTable.modified = modified;
  } else {
    series.groupMap = void 0;
    series.currentDataGrouping = void 0;
  }
  series.hasGroupedData = hasGroupedData;
  series.preventGraphAnimation = (lastDataGrouping && lastDataGrouping.totalRange) !== (currentDataGrouping && currentDataGrouping.totalRange);
}
function compose7(SeriesClass) {
  const seriesProto7 = SeriesClass.prototype;
  if (!seriesProto7.applyGrouping) {
    const PointClass = SeriesClass.prototype.pointClass;
    addEvent34(PointClass, "update", function() {
      if (this.dataGroup) {
        error8(24, false, this.series.chart);
        return false;
      }
    });
    addEvent34(SeriesClass, "afterSetOptions", onAfterSetOptions);
    addEvent34(SeriesClass, "destroy", destroyGroupedData);
    extend40(seriesProto7, {
      applyGrouping: applyGrouping2,
      destroyGroupedData,
      generatePoints,
      getDGApproximation,
      groupData
    });
  }
}
function destroyGroupedData() {
  if (this.groupedData) {
    this.groupedData.forEach(function(point, i) {
      if (point) {
        this.groupedData[i] = point.destroy ? point.destroy() : null;
      }
    }, this);
    this.groupedData.length = 0;
    delete this.allGroupedTable;
  }
}
function generatePoints() {
  baseGeneratePoints.apply(this);
  this.destroyGroupedData();
  this.groupedData = this.hasGroupedData ? this.points : null;
}
function getDGApproximation() {
  if (this.is("arearange")) {
    return "range";
  }
  if (this.is("ohlc")) {
    return "ohlc";
  }
  if (this.is("hlc")) {
    return "hlc";
  }
  if (
    // #18974, default approximation for cumulative
    // should be `sum` when `dataGrouping` is enabled
    this.is("column") || this.options.cumulative
  ) {
    return "sum";
  }
  return "average";
}
function groupData(table, groupPositions, approximation) {
  const xData = table.getColumn("x", true) || [], yData = table.getColumn("y", true), series = this, data = series.data, dataOptions = series.options && series.options.data, groupedXData = [], modified = new DataTableCore_default(), groupMap = [], dataLength = table.rowCount, handleYData = !!yData, values = [], pointArrayMap = series.pointArrayMap, pointArrayMapLength = pointArrayMap && pointArrayMap.length, extendedPointArrayMap = ["x"].concat(pointArrayMap || ["y"]), valueColumns = (pointArrayMap || ["y"]).map(() => []), groupAll = this.options.dataGrouping && this.options.dataGrouping.groupAll;
  let pointX, pointY, groupedY, pos = 0, start = 0;
  const approximationFn = typeof approximation === "function" ? approximation : approximation && ApproximationRegistry_default[approximation] ? ApproximationRegistry_default[approximation] : ApproximationRegistry_default[series.getDGApproximation && series.getDGApproximation() || "average"];
  if (pointArrayMapLength) {
    let len = pointArrayMap.length;
    while (len--) {
      values.push([]);
    }
  } else {
    values.push([]);
  }
  const valuesLen = pointArrayMapLength || 1;
  for (let i = 0; i <= dataLength; i++) {
    if (xData[i] < groupPositions[0]) {
      continue;
    }
    while (typeof groupPositions[pos + 1] !== "undefined" && xData[i] >= groupPositions[pos + 1] || i === dataLength) {
      pointX = groupPositions[pos];
      series.dataGroupInfo = {
        start: groupAll ? start : series.cropStart + start,
        length: values[0].length,
        groupStart: pointX
      };
      groupedY = approximationFn.apply(series, values);
      if (series.pointClass && !defined36(series.dataGroupInfo.options)) {
        series.dataGroupInfo.options = merge43(series.pointClass.prototype.optionsToObject.call({ series }, series.options.data[series.cropStart + start]));
        extendedPointArrayMap.forEach(function(key) {
          delete series.dataGroupInfo.options[key];
        });
      }
      if (typeof groupedY !== "undefined") {
        groupedXData.push(pointX);
        const groupedValuesArr = splat12(groupedY);
        for (let j = 0; j < groupedValuesArr.length; j++) {
          valueColumns[j].push(groupedValuesArr[j]);
        }
        groupMap.push(series.dataGroupInfo);
      }
      start = i;
      for (let j = 0; j < valuesLen; j++) {
        values[j].length = 0;
        values[j].hasNulls = false;
      }
      pos += 1;
      if (i === dataLength) {
        break;
      }
    }
    if (i === dataLength) {
      break;
    }
    if (pointArrayMap) {
      const index = groupAll ? i : series.cropStart + i, point = data && data[index] || series.pointClass.prototype.applyOptions.apply({
        series
      }, [dataOptions[index]]);
      let val;
      for (let j = 0; j < pointArrayMapLength; j++) {
        val = point[pointArrayMap[j]];
        if (isNumber37(val)) {
          values[j].push(val);
        } else if (val === null) {
          values[j].hasNulls = true;
        }
      }
    } else {
      pointY = handleYData ? yData[i] : null;
      if (isNumber37(pointY)) {
        values[0].push(pointY);
      } else if (pointY === null) {
        values[0].hasNulls = true;
      }
    }
  }
  const columns = {
    x: groupedXData
  };
  (pointArrayMap || ["y"]).forEach((key, i) => {
    columns[key] = valueColumns[i];
  });
  modified.setColumns(columns);
  return {
    groupMap,
    modified
  };
}
function onAfterSetOptions(e) {
  const options2 = e.options, type = this.type, plotOptions = this.chart.options.plotOptions, baseOptions = this.useCommonDataGrouping && DataGroupingDefaults_default.common, seriesSpecific2 = DataGroupingDefaults_default.seriesSpecific;
  let defaultOptions24 = Defaults_default.defaultOptions.plotOptions[type].dataGrouping;
  if (plotOptions && (seriesSpecific2[type] || baseOptions)) {
    const rangeSelector2 = this.chart.rangeSelector;
    if (!defaultOptions24) {
      defaultOptions24 = merge43(DataGroupingDefaults_default.common, seriesSpecific2[type]);
    }
    options2.dataGrouping = merge43(
      baseOptions,
      defaultOptions24,
      plotOptions.series && plotOptions.series.dataGrouping,
      // #1228
      // Set by the StockChart constructor:
      plotOptions[type].dataGrouping,
      this.userOptions.dataGrouping,
      !options2.isInternal && rangeSelector2 && isNumber37(rangeSelector2.selected) && rangeSelector2.buttonOptions[rangeSelector2.selected].dataGrouping
    );
  }
}
function skipDataGrouping(series, force) {
  return !(series.isCartesian && !series.isDirty && !series.xAxis.isDirty && !series.yAxis.isDirty && !force);
}
var DataGroupingSeriesComposition = {
  compose: compose7,
  groupData
};
var DataGroupingSeriesComposition_default = DataGroupingSeriesComposition;

// node_modules/highcharts/es-modules/Extensions/DataGrouping/DataGrouping.js
var { format: format10 } = Templating_default;
var { composed: composed13 } = Globals_default;
var { addEvent: addEvent35, extend: extend41, isNumber: isNumber38, pick: pick46, pushUnique: pushUnique16 } = Utilities_default;
function compose8(AxisClass, SeriesClass, TooltipClass) {
  DataGroupingAxisComposition_default.compose(AxisClass);
  DataGroupingSeriesComposition_default.compose(SeriesClass);
  if (TooltipClass && pushUnique16(composed13, "DataGrouping")) {
    addEvent35(TooltipClass, "headerFormatter", onTooltipHeaderFormatter);
  }
}
function onTooltipHeaderFormatter(e) {
  const chart = this.chart, time = chart.time, point = e.point, series = point.series, options2 = series.options, tooltipOptions = series.tooltipOptions, dataGroupingOptions = options2.dataGrouping, xAxis2 = series.xAxis;
  let xDateFormat = tooltipOptions.xDateFormat || "", xDateFormatEnd, currentDataGrouping, dateTimeLabelFormats, labelFormats, formattedKey, formatString = tooltipOptions[e.isFooter ? "footerFormat" : "headerFormat"];
  if (xAxis2 && xAxis2.options.type === "datetime" && dataGroupingOptions && isNumber38(point.key)) {
    currentDataGrouping = series.currentDataGrouping;
    dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats || // Fallback to commonOptions (#9693)
    DataGroupingDefaults_default.common.dateTimeLabelFormats;
    if (currentDataGrouping) {
      labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];
      if (currentDataGrouping.count === 1) {
        xDateFormat = labelFormats[0];
      } else {
        xDateFormat = labelFormats[1];
        xDateFormatEnd = labelFormats[2];
      }
    } else if (!xDateFormat && dateTimeLabelFormats && xAxis2.dateTime) {
      xDateFormat = xAxis2.dateTime.getXDateFormat(point.x, tooltipOptions.dateTimeLabelFormats);
    }
    const groupStart = pick46(series.groupMap?.[point.index].groupStart, point.key), groupEnd = groupStart + (currentDataGrouping?.totalRange || 0) - 1;
    formattedKey = time.dateFormat(xDateFormat, groupStart);
    if (xDateFormatEnd) {
      formattedKey += time.dateFormat(xDateFormatEnd, groupEnd);
    }
    if (series.chart.styledMode) {
      formatString = this.styledModeFormat(formatString);
    }
    e.text = format10(formatString, {
      point: extend41(point, { key: formattedKey }),
      series
    }, chart);
    e.preventDefault();
  }
}
var DataGroupingComposition = {
  compose: compose8,
  groupData: DataGroupingSeriesComposition_default.groupData
};
var DataGrouping_default = DataGroupingComposition;

// node_modules/highcharts/es-modules/masters/modules/datagrouping.src.js
var G3 = Globals_default;
G3.dataGrouping = G3.dataGrouping || {};
G3.dataGrouping.approximationDefaults = G3.dataGrouping.approximationDefaults || ApproximationDefaults_default;
G3.dataGrouping.approximations = G3.dataGrouping.approximations || ApproximationRegistry_default;
DataGrouping_default.compose(G3.Axis, G3.Series, G3.Tooltip);

// node_modules/highcharts/es-modules/Extensions/Annotations/NavigationBindingsUtilities.js
var { defined: defined37, isNumber: isNumber39, pick: pick47 } = Utilities_default;
var annotationsFieldsTypes = {
  backgroundColor: "string",
  borderColor: "string",
  borderRadius: "string",
  color: "string",
  fill: "string",
  fontSize: "string",
  labels: "string",
  name: "string",
  stroke: "string",
  title: "string"
};
function getAssignedAxis(coords) {
  return coords.filter((coord) => {
    const extremes = coord.axis.getExtremes(), axisMin = extremes.min, axisMax2 = extremes.max, minPointOffset = pick47(coord.axis.minPointOffset, 0);
    return isNumber39(axisMin) && isNumber39(axisMax2) && coord.value >= axisMin - minPointOffset && coord.value <= axisMax2 + minPointOffset && // Don't count navigator axis
    !coord.axis.options.isInternal;
  })[0];
}
function getFieldType(key, value) {
  const predefinedType = annotationsFieldsTypes[key];
  let fieldType = typeof value;
  if (defined37(predefinedType)) {
    fieldType = predefinedType;
  }
  return {
    "string": "text",
    "number": "number",
    "boolean": "checkbox"
  }[fieldType];
}
var NavigationBindingUtilities = {
  annotationsFieldsTypes,
  getAssignedAxis,
  getFieldType
};
var NavigationBindingsUtilities_default = NavigationBindingUtilities;

// node_modules/highcharts/es-modules/Extensions/MouseWheelZoom/MouseWheelZoom.js
var { addEvent: addEvent36, isObject: isObject13, pick: pick48, defined: defined38, merge: merge44 } = Utilities_default;
var { getAssignedAxis: getAssignedAxis2 } = NavigationBindingsUtilities_default;
var composedClasses = [];
var defaultOptions15 = {
  enabled: true,
  sensitivity: 1.1
};
var wheelTimer;
var optionsToObject2 = (options2) => {
  if (!isObject13(options2)) {
    options2 = {
      enabled: options2 ?? true
    };
  }
  return merge44(defaultOptions15, options2);
};
var zoomBy = function(chart, howMuch, xAxis2, yAxis2, mouseX, mouseY, options2) {
  const type = pick48(options2.type, chart.zooming.type, "");
  let axes = [];
  if (type === "x") {
    axes = xAxis2;
  } else if (type === "y") {
    axes = yAxis2;
  } else if (type === "xy") {
    axes = chart.axes;
  }
  const hasZoomed = chart.transform({
    axes,
    // Create imaginary reference and target rectangles around the mouse
    // point that scales up or down with `howMuch`;
    to: {
      x: mouseX - 5,
      y: mouseY - 5,
      // Must use 10 to get passed the limit for too small reference.
      // Below this, the transform will default to a pan.
      width: 10,
      height: 10
    },
    from: {
      x: mouseX - 5 * howMuch,
      y: mouseY - 5 * howMuch,
      width: 10 * howMuch,
      height: 10 * howMuch
    },
    trigger: "mousewheel"
  });
  if (hasZoomed) {
    if (defined38(wheelTimer)) {
      clearTimeout(wheelTimer);
    }
    wheelTimer = setTimeout(() => {
      chart.pointer?.drop();
    }, 400);
  }
  return hasZoomed;
};
function onAfterGetContainer() {
  const wheelZoomOptions = optionsToObject2(this.zooming.mouseWheel);
  if (wheelZoomOptions.enabled) {
    addEvent36(this.container, "wheel", (e) => {
      e = this.pointer?.normalize(e) || e;
      const { pointer } = this, allowZoom = pointer && !pointer.inClass(e.target, "highcharts-no-mousewheel");
      if (this.isInsidePlot(e.chartX - this.plotLeft, e.chartY - this.plotTop) && allowZoom) {
        const wheelSensitivity = wheelZoomOptions.sensitivity || 1.1, delta = e.detail || (e.deltaY || 0) / 120, xAxisCoords = getAssignedAxis2(pointer.getCoordinates(e).xAxis), yAxisCoords = getAssignedAxis2(pointer.getCoordinates(e).yAxis);
        const hasZoomed = zoomBy(this, Math.pow(wheelSensitivity, delta), xAxisCoords ? [xAxisCoords.axis] : this.xAxis, yAxisCoords ? [yAxisCoords.axis] : this.yAxis, e.chartX, e.chartY, wheelZoomOptions);
        if (hasZoomed) {
          e.preventDefault?.();
        }
      }
    });
  }
}
function compose9(ChartClass) {
  if (composedClasses.indexOf(ChartClass) === -1) {
    composedClasses.push(ChartClass);
    addEvent36(ChartClass, "afterGetContainer", onAfterGetContainer);
  }
}
var MouseWheelZoomComposition = {
  compose: compose9
};
var MouseWheelZoom_default = MouseWheelZoomComposition;

// node_modules/highcharts/es-modules/masters/modules/mouse-wheel-zoom.src.js
var G4 = Globals_default;
G4.MouseWheelZoom = G4.MouseWheelZoom || MouseWheelZoom_default;
G4.MouseWheelZoom.compose(G4.Chart);

// node_modules/highcharts/es-modules/masters/modules/stock.src.js
var G5 = Globals_default;
G5.Navigator = G5.Navigator || Navigator_default;
G5.OrdinalAxis = G5.OrdinalAxis || OrdinalAxis_default;
G5.RangeSelector = G5.RangeSelector || RangeSelector_default;
G5.Scrollbar = G5.Scrollbar || Scrollbar_default;
G5.stockChart = G5.stockChart || StockChart_default.stockChart;
G5.StockChart = G5.StockChart || G5.stockChart;
G5.extend(G5.StockChart, StockChart_default);
DataModifyComposition_default.compose(G5.Series, G5.Axis, G5.Point);
FlagsSeries_default.compose(G5.Renderer);
OHLCSeries_default.compose(G5.Series);
G5.Navigator.compose(G5.Chart, G5.Axis, G5.Series);
G5.OrdinalAxis.compose(G5.Axis, G5.Series, G5.Chart);
G5.RangeSelector.compose(G5.Axis, G5.Chart);
G5.Scrollbar.compose(G5.Axis);
G5.StockChart.compose(G5.Chart, G5.Axis, G5.Series, G5.SVGRenderer);

// node_modules/highcharts/es-modules/masters/highstock.src.js
highcharts_src_default.product = "Highstock";
var highstock_src_default = highcharts_src_default;

// node_modules/highcharts/es-modules/Accessibility/Utils/HTMLUtilities.js
var { doc: doc7, win: win11 } = Globals_default;
var { css: css14 } = Utilities_default;
var simulatedEventTarget = win11.EventTarget && new win11.EventTarget() || "none";
function addClass(el, className) {
  if (el.classList) {
    el.classList.add(className);
  } else if (el.className.indexOf(className) < 0) {
    el.className += " " + className;
  }
}
function removeClass(el, className) {
  if (el.classList) {
    el.classList.remove(className);
  } else {
    el.className = el.className.replace(new RegExp(className, "g"), "");
  }
}
function cloneMouseEvent(e) {
  if (typeof win11.MouseEvent === "function") {
    return new win11.MouseEvent(e.type, e);
  }
  if (doc7?.createEvent) {
    const evt = doc7.createEvent("MouseEvent");
    if (evt.initMouseEvent) {
      evt.initMouseEvent(
        e.type,
        e.bubbles,
        // #10561, #12161
        e.cancelable,
        e.view || win11,
        e.detail,
        e.screenX,
        e.screenY,
        e.clientX,
        e.clientY,
        e.ctrlKey,
        e.altKey,
        e.shiftKey,
        e.metaKey,
        e.button,
        e.relatedTarget
      );
      return evt;
    }
  }
  return getFakeMouseEvent(e.type);
}
function cloneTouchEvent(e) {
  const touchListToTouchArray = (l) => {
    const touchArray = [];
    for (let i = 0; i < l.length; ++i) {
      const item = l.item(i);
      if (item) {
        touchArray.push(item);
      }
    }
    return touchArray;
  };
  if (typeof win11.TouchEvent === "function") {
    const newEvent = new win11.TouchEvent(e.type, {
      touches: touchListToTouchArray(e.touches),
      targetTouches: touchListToTouchArray(e.targetTouches),
      changedTouches: touchListToTouchArray(e.changedTouches),
      ctrlKey: e.ctrlKey,
      shiftKey: e.shiftKey,
      altKey: e.altKey,
      metaKey: e.metaKey,
      bubbles: e.bubbles,
      cancelable: e.cancelable,
      composed: e.composed,
      detail: e.detail,
      view: e.view
    });
    if (e.defaultPrevented) {
      newEvent.preventDefault();
    }
    return newEvent;
  }
  const fakeEvt = cloneMouseEvent(e);
  fakeEvt.touches = e.touches;
  fakeEvt.changedTouches = e.changedTouches;
  fakeEvt.targetTouches = e.targetTouches;
  return fakeEvt;
}
function escapeStringForHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
}
function getElement(id) {
  return doc7.getElementById(id);
}
function getFakeMouseEvent(type, position, relatedTarget) {
  const pos = position || {
    x: 0,
    y: 0
  };
  if (typeof win11.MouseEvent === "function") {
    return new win11.MouseEvent(type, {
      bubbles: true,
      cancelable: true,
      composed: true,
      button: 0,
      buttons: 1,
      relatedTarget: relatedTarget || simulatedEventTarget,
      view: win11,
      detail: type === "click" ? 1 : 0,
      screenX: pos.x,
      screenY: pos.y,
      clientX: pos.x,
      clientY: pos.y
    });
  }
  if (doc7?.createEvent) {
    const evt = doc7.createEvent("MouseEvent");
    if (evt.initMouseEvent) {
      evt.initMouseEvent(
        type,
        true,
        // Bubble
        true,
        // Cancel
        win11,
        // View
        type === "click" ? 1 : 0,
        // Detail
        // Coords
        pos.x,
        pos.y,
        pos.x,
        pos.y,
        // Pressed keys
        false,
        false,
        false,
        false,
        0,
        // Button
        null
        // Related target
      );
      return evt;
    }
  }
  return { type };
}
function getHeadingTagNameForElement(element) {
  const getIncreasedHeadingLevel = (tagName) => {
    const headingLevel = parseInt(tagName.slice(1), 10), newLevel = Math.min(6, headingLevel + 1);
    return "h" + newLevel;
  };
  const isHeading = (tagName) => /^H[1-6]$/i.test(tagName);
  const getPreviousSiblingsHeading = (el) => {
    let sibling = el;
    while (sibling = sibling.previousSibling) {
      const tagName = sibling.tagName || "";
      if (isHeading(tagName)) {
        return tagName;
      }
    }
    return "";
  };
  const getHeadingRecursive = (el) => {
    const prevSiblingsHeading = getPreviousSiblingsHeading(el);
    if (prevSiblingsHeading) {
      return getIncreasedHeadingLevel(prevSiblingsHeading);
    }
    const parent = el.parentElement;
    if (!parent) {
      return "h6";
    }
    const parentTagName = parent.tagName;
    if (isHeading(parentTagName)) {
      return getIncreasedHeadingLevel(parentTagName);
    }
    return getHeadingRecursive(parent);
  };
  return getHeadingRecursive(element);
}
function removeElement(element) {
  if (element && element.parentNode) {
    element.parentNode.removeChild(element);
  }
}
function removeChildNodes(element) {
  while (element.lastChild) {
    element.removeChild(element.lastChild);
  }
}
function reverseChildNodes(node) {
  let i = node.childNodes.length;
  while (i--) {
    node.appendChild(node.childNodes[i]);
  }
}
function stripHTMLTagsFromString(str, isForExport = false) {
  return typeof str === "string" ? isForExport ? str.replace(/<\/?[^>]+(>|$)/g, "") : str.replace(/<\/?(?!\s)[^>]+(>|$)/g, "") : str;
}
function visuallyHideElement(element) {
  css14(element, {
    position: "absolute",
    width: "1px",
    height: "1px",
    overflow: "hidden",
    whiteSpace: "nowrap",
    clip: "rect(1px, 1px, 1px, 1px)",
    marginTop: "-3px",
    "-ms-filter": "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)",
    filter: "alpha(opacity=1)",
    opacity: 0.01
  });
}
var HTMLUtilities = {
  addClass,
  cloneMouseEvent,
  cloneTouchEvent,
  escapeStringForHTML,
  getElement,
  getFakeMouseEvent,
  getHeadingTagNameForElement,
  removeChildNodes,
  removeClass,
  removeElement,
  reverseChildNodes,
  simulatedEventTarget,
  stripHTMLTagsFromString,
  visuallyHideElement
};
var HTMLUtilities_default = HTMLUtilities;

// node_modules/highcharts/es-modules/Accessibility/A11yI18n.js
var { format: format11 } = Templating_default;
var { getNestedProperty: getNestedProperty5, pick: pick49 } = Utilities_default;
var A11yI18nComposition;
(function(A11yI18nComposition2) {
  function compose27(ChartClass) {
    const chartProto = ChartClass.prototype;
    if (!chartProto.langFormat) {
      chartProto.langFormat = langFormat;
    }
  }
  A11yI18nComposition2.compose = compose27;
  function formatExtendedStatement(statement, ctx) {
    const eachStart = statement.indexOf("#each("), pluralStart = statement.indexOf("#plural("), indexStart = statement.indexOf("["), indexEnd = statement.indexOf("]");
    let arr, result;
    if (eachStart > -1) {
      const eachEnd = statement.slice(eachStart).indexOf(")") + eachStart, preEach = statement.substring(0, eachStart), postEach = statement.substring(eachEnd + 1), eachStatement = statement.substring(eachStart + 6, eachEnd), eachArguments = eachStatement.split(",");
      let lenArg = Number(eachArguments[1]), len;
      result = "";
      arr = getNestedProperty5(eachArguments[0], ctx);
      if (arr) {
        lenArg = isNaN(lenArg) ? arr.length : lenArg;
        len = lenArg < 0 ? arr.length + lenArg : Math.min(lenArg, arr.length);
        for (let i = 0; i < len; ++i) {
          result += preEach + arr[i] + postEach;
        }
      }
      return result.length ? result : "";
    }
    if (pluralStart > -1) {
      const pluralEnd = statement.slice(pluralStart).indexOf(")") + pluralStart, pluralStatement = statement.substring(pluralStart + 8, pluralEnd), pluralArguments = pluralStatement.split(","), num = Number(getNestedProperty5(pluralArguments[0], ctx));
      switch (num) {
        case 0:
          result = pick49(pluralArguments[4], pluralArguments[1]);
          break;
        case 1:
          result = pick49(pluralArguments[2], pluralArguments[1]);
          break;
        case 2:
          result = pick49(pluralArguments[3], pluralArguments[1]);
          break;
        default:
          result = pluralArguments[1];
      }
      return result ? stringTrim(result) : "";
    }
    if (indexStart > -1) {
      const arrayName = statement.substring(0, indexStart), ix = Number(statement.substring(indexStart + 1, indexEnd));
      let val;
      arr = getNestedProperty5(arrayName, ctx);
      if (!isNaN(ix) && arr) {
        if (ix < 0) {
          val = arr[arr.length + ix];
          if (typeof val === "undefined") {
            val = arr[0];
          }
        } else {
          val = arr[ix];
          if (typeof val === "undefined") {
            val = arr[arr.length - 1];
          }
        }
      }
      return typeof val !== "undefined" ? val : "";
    }
    return "{" + statement + "}";
  }
  function i18nFormat(formatString, context, chart) {
    const getFirstBracketStatement = (sourceStr, offset3) => {
      const str = sourceStr.slice(offset3 || 0), startBracket = str.indexOf("{"), endBracket = str.indexOf("}");
      if (startBracket > -1 && endBracket > startBracket) {
        return {
          statement: str.substring(startBracket + 1, endBracket),
          begin: offset3 + startBracket + 1,
          end: offset3 + endBracket
        };
      }
    }, tokens = [];
    let bracketRes, constRes, cursor = 0;
    do {
      bracketRes = getFirstBracketStatement(formatString, cursor);
      constRes = formatString.substring(cursor, bracketRes && bracketRes.begin - 1);
      if (constRes.length) {
        tokens.push({
          value: constRes,
          type: "constant"
        });
      }
      if (bracketRes) {
        tokens.push({
          value: bracketRes.statement,
          type: "statement"
        });
      }
      cursor = bracketRes ? bracketRes.end + 1 : cursor + 1;
    } while (bracketRes);
    tokens.forEach((token) => {
      if (token.type === "statement") {
        token.value = formatExtendedStatement(token.value, context);
      }
    });
    return format11(tokens.reduce((acc, cur) => acc + cur.value, ""), context, chart);
  }
  A11yI18nComposition2.i18nFormat = i18nFormat;
  function langFormat(langKey, context) {
    const keys = langKey.split(".");
    let formatString = this.options.lang, i = 0;
    for (; i < keys.length; ++i) {
      formatString = formatString && formatString[keys[i]];
    }
    return typeof formatString === "string" ? i18nFormat(formatString, context, this) : "";
  }
  function stringTrim(str) {
    return str.trim && str.trim() || str.replace(/^\s+|\s+$/g, "");
  }
})(A11yI18nComposition || (A11yI18nComposition = {}));
var A11yI18n_default = A11yI18nComposition;

// node_modules/highcharts/es-modules/Accessibility/Utils/ChartUtilities.js
var { doc: doc8 } = Globals_default;
var { stripHTMLTagsFromString: stripHTMLTags } = HTMLUtilities_default;
var { defined: defined39, find: find10, fireEvent: fireEvent26 } = Utilities_default;
function fireEventOnWrappedOrUnwrappedElement(el, eventObject) {
  const type = eventObject.type;
  const hcEvents = el.hcEvents;
  if (!!doc8?.createEvent && (el.dispatchEvent || el.fireEvent)) {
    if (el.dispatchEvent) {
      el.dispatchEvent(eventObject);
    } else {
      el.fireEvent(type, eventObject);
    }
  } else if (hcEvents && hcEvents[type]) {
    fireEvent26(el, type, eventObject);
  } else if (el.element) {
    fireEventOnWrappedOrUnwrappedElement(el.element, eventObject);
  }
}
function getChartTitle(chart) {
  return stripHTMLTags(chart.options.title.text || chart.langFormat("accessibility.defaultChartTitle", { chart }), chart.renderer.forExport);
}
function getAxisDescription(axis) {
  return axis && (axis.options.accessibility?.description || axis.axisTitle?.textStr || axis.options.id || axis.categories && "categories" || axis.dateTime && "Time" || "values");
}
function getAxisRangeDescription(axis) {
  const axisOptions = axis.options || {};
  if (axisOptions.accessibility && typeof axisOptions.accessibility.rangeDescription !== "undefined") {
    return axisOptions.accessibility.rangeDescription;
  }
  if (axis.categories) {
    return getCategoryAxisRangeDesc(axis);
  }
  if (axis.dateTime && (axis.min === 0 || axis.dataMin === 0)) {
    return getAxisTimeLengthDesc(axis);
  }
  return getAxisFromToDescription(axis);
}
function getCategoryAxisRangeDesc(axis) {
  const chart = axis.chart;
  if (axis.dataMax && axis.dataMin) {
    return chart.langFormat("accessibility.axis.rangeCategories", {
      chart,
      axis,
      numCategories: axis.dataMax - axis.dataMin + 1
    });
  }
  return "";
}
function getAxisTimeLengthDesc(axis) {
  const chart = axis.chart, range2 = {}, min4 = axis.dataMin || axis.min || 0, max4 = axis.dataMax || axis.max || 0;
  let rangeUnit = "Seconds";
  range2.Seconds = (max4 - min4) / 1e3;
  range2.Minutes = range2.Seconds / 60;
  range2.Hours = range2.Minutes / 60;
  range2.Days = range2.Hours / 24;
  ["Minutes", "Hours", "Days"].forEach(function(unit) {
    if (range2[unit] > 2) {
      rangeUnit = unit;
    }
  });
  const rangeValue = range2[rangeUnit].toFixed(
    rangeUnit !== "Seconds" && rangeUnit !== "Minutes" ? 1 : 0
    // Use decimals for days/hours
  );
  return chart.langFormat("accessibility.axis.timeRange" + rangeUnit, {
    chart,
    axis,
    range: rangeValue.replace(".0", "")
  });
}
function getAxisFromToDescription(axis) {
  const chart = axis.chart, options2 = chart.options, dateRangeFormat = options2 && options2.accessibility && options2.accessibility.screenReaderSection.axisRangeDateFormat || "", extremes = {
    min: axis.dataMin || axis.min || 0,
    max: axis.dataMax || axis.max || 0
  }, format18 = function(key) {
    return axis.dateTime ? chart.time.dateFormat(dateRangeFormat, extremes[key]) : extremes[key].toString();
  };
  return chart.langFormat("accessibility.axis.rangeFromTo", {
    chart,
    axis,
    rangeFrom: format18("min"),
    rangeTo: format18("max")
  });
}
function getSeriesFirstPointElement(series) {
  if (series.points && series.points.length) {
    const firstPointWithGraphic = find10(series.points, (p) => !!p.graphic);
    return firstPointWithGraphic && firstPointWithGraphic.graphic && firstPointWithGraphic.graphic.element;
  }
}
function getSeriesA11yElement(series) {
  const firstPointEl = getSeriesFirstPointElement(series);
  return firstPointEl && firstPointEl.parentNode || series.graph && series.graph.element || series.group && series.group.element;
}
function unhideChartElementFromAT(chart, element) {
  element.setAttribute("aria-hidden", false);
  if (element === chart.renderTo || !element.parentNode || element.parentNode === doc8.body) {
    return;
  }
  Array.prototype.forEach.call(element.parentNode.childNodes, function(node) {
    if (!node.hasAttribute("aria-hidden")) {
      node.setAttribute("aria-hidden", true);
    }
  });
  unhideChartElementFromAT(chart, element.parentNode);
}
function hideSeriesFromAT(series) {
  const seriesEl = getSeriesA11yElement(series);
  if (seriesEl) {
    seriesEl.setAttribute("aria-hidden", true);
  }
}
function getSeriesFromName(chart, name) {
  if (!name) {
    return chart.series;
  }
  return (chart.series || []).filter(function(s) {
    return s.name === name;
  });
}
function getPointFromXY(series, x, y) {
  let i = series.length, res;
  while (i--) {
    res = find10(series[i].points || [], function(p) {
      return p.x === x && p.y === y;
    });
    if (res) {
      return res;
    }
  }
}
function getRelativePointAxisPosition(axis, point) {
  if (!defined39(axis.dataMin) || !defined39(axis.dataMax)) {
    return 0;
  }
  const axisStart = axis.toPixels(axis.dataMin), axisEnd = axis.toPixels(axis.dataMax), positionProp = axis.coll === "xAxis" ? "x" : "y", pointPos = axis.toPixels(point[positionProp] || 0);
  return (pointPos - axisStart) / (axisEnd - axisStart);
}
function scrollAxisToPoint(point) {
  const xAxis2 = point.series.xAxis, yAxis2 = point.series.yAxis, axis = xAxis2 && xAxis2.scrollbar ? xAxis2 : yAxis2, scrollbar = axis && axis.scrollbar;
  if (scrollbar && defined39(scrollbar.to) && defined39(scrollbar.from)) {
    const range2 = scrollbar.to - scrollbar.from;
    const pos = getRelativePointAxisPosition(axis, point);
    scrollbar.updatePosition(pos - range2 / 2, pos + range2 / 2);
    fireEvent26(scrollbar, "changed", {
      from: scrollbar.from,
      to: scrollbar.to,
      trigger: "scrollbar",
      DOMEvent: null
    });
  }
}
var ChartUtilities = {
  fireEventOnWrappedOrUnwrappedElement,
  getChartTitle,
  getAxisDescription,
  getAxisRangeDescription,
  getPointFromXY,
  getSeriesFirstPointElement,
  getSeriesFromName,
  getSeriesA11yElement,
  unhideChartElementFromAT,
  hideSeriesFromAT,
  scrollAxisToPoint
};
var ChartUtilities_default = ChartUtilities;

// node_modules/highcharts/es-modules/Accessibility/Utils/DOMElementProvider.js
var { doc: doc9 } = Globals_default;
var { removeElement: removeElement2 } = HTMLUtilities_default;
var DOMElementProvider = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor() {
    this.elements = [];
  }
  /**
   * Create an element and keep track of it for later removal.
   * Same args as document.createElement
   * @private
   */
  createElement() {
    const el = doc9.createElement.apply(doc9, arguments);
    this.elements.push(el);
    return el;
  }
  /**
   * Destroy created element, removing it from the DOM.
   * @private
   */
  removeElement(element) {
    removeElement2(element);
    this.elements.splice(this.elements.indexOf(element), 1);
  }
  /**
   * Destroy all created elements, removing them from the DOM.
   * @private
   */
  destroyCreatedElements() {
    this.elements.forEach(function(element) {
      removeElement2(element);
    });
    this.elements = [];
  }
};
var DOMElementProvider_default = DOMElementProvider;

// node_modules/highcharts/es-modules/Accessibility/Utils/EventProvider.js
var { addEvent: addEvent37 } = Utilities_default;
var EventProvider = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor() {
    this.eventRemovers = [];
  }
  /**
   * Add an event to an element and keep track of it for later removal.
   * Same args as Highcharts.addEvent.
   * @private
   */
  addEvent() {
    const remover = addEvent37.apply(Globals_default, arguments);
    this.eventRemovers.push({
      element: arguments[0],
      // HTML element
      remover
    });
    return remover;
  }
  /**
   * Remove added event.
   * @private
   */
  removeEvent(event) {
    const pos = this.eventRemovers.map((e) => e.remover).indexOf(event);
    this.eventRemovers[pos].remover();
    this.eventRemovers.splice(pos, 1);
  }
  /**
   * Remove all added events.
   * @private
   */
  removeAddedEvents() {
    this.eventRemovers.map((e) => e.remover).forEach((remover) => remover());
    this.eventRemovers = [];
  }
};
var EventProvider_default = EventProvider;

// node_modules/highcharts/es-modules/Accessibility/AccessibilityComponent.js
var { fireEventOnWrappedOrUnwrappedElement: fireEventOnWrappedOrUnwrappedElement2 } = ChartUtilities_default;
var { getFakeMouseEvent: getFakeMouseEvent2 } = HTMLUtilities_default;
var AccessibilityComponent = class {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Called when accessibility is disabled or chart is destroyed.
   *
   * @function Highcharts.AccessibilityComponent#destroy
   */
  destroy() {
  }
  /**
   * Get keyboard navigation handler for this component.
   *
   * @function Highcharts.AccessibilityComponent#getKeyboardNavigation
   * @return   {Highcharts.KeyboardNavigationHandler|Array<Highcharts.KeyboardNavigationHandler>}
   *           The keyboard navigation handler(s) for this component.
   */
  getKeyboardNavigation() {
    return [];
  }
  /**
   * Called on component initialization.
   *
   * @function Highcharts.AccessibilityComponent#init
   */
  init() {
  }
  /**
   * Called on every chart render.
   *
   * @function Highcharts.AccessibilityComponent#onChartRender
   */
  onChartRender() {
  }
  /**
   * Called on updates to the chart, including options changes.
   * Note that this is also called on first render of chart.
   *
   * @function Highcharts.AccessibilityComponent#onChartUpdate
   */
  onChartUpdate() {
  }
  /**
   * Initialize the class
   * @private
   * @param {Highcharts.Chart} chart The chart object
   * @param {Highcharts.ProxyProvider} proxyProvider The proxy provider of the accessibility module
   */
  initBase(chart, proxyProvider) {
    this.chart = chart;
    this.eventProvider = new EventProvider_default();
    this.domElementProvider = new DOMElementProvider_default();
    this.proxyProvider = proxyProvider;
    this.keyCodes = {
      left: 37,
      right: 39,
      up: 38,
      down: 40,
      enter: 13,
      space: 32,
      esc: 27,
      tab: 9,
      pageUp: 33,
      pageDown: 34,
      end: 35,
      home: 36
    };
  }
  /**
   * Add an event to an element and keep track of it for later removal.
   * See EventProvider for details.
   * @private
   */
  addEvent(el, type, fn, options2) {
    return this.eventProvider.addEvent(el, type, fn, options2);
  }
  /**
   * Create an element and keep track of it for later removal.
   * See DOMElementProvider for details.
   * @private
   */
  createElement(tagName, options2) {
    return this.domElementProvider.createElement(tagName, options2);
  }
  /**
   * Fire a fake click event on an element. It is useful to have this on
   * AccessibilityComponent for users of custom components.
   * @private
   */
  fakeClickEvent(el) {
    const fakeEvent = getFakeMouseEvent2("click");
    fireEventOnWrappedOrUnwrappedElement2(el, fakeEvent);
  }
  /**
   * Remove traces of the component.
   * @private
   */
  destroyBase() {
    this.domElementProvider.destroyCreatedElements();
    this.eventProvider.removeAddedEvents();
  }
};
var AccessibilityComponent_default = AccessibilityComponent;

// node_modules/highcharts/es-modules/Accessibility/KeyboardNavigationHandler.js
var { find: find11 } = Utilities_default;
var KeyboardNavigationHandler = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart, options2) {
    this.chart = chart;
    this.keyCodeMap = options2.keyCodeMap || [];
    this.validate = options2.validate;
    this.init = options2.init;
    this.terminate = options2.terminate;
    this.response = {
      success: 1,
      // Keycode was handled
      prev: 2,
      // Move to prev module
      next: 3,
      // Move to next module
      noHandler: 4,
      // There is no handler for this keycode
      fail: 5
      // Handler failed
    };
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Find handler function(s) for key code in the keyCodeMap and run it.
   *
   * @function KeyboardNavigationHandler#run
   * @param {global.KeyboardEvent} e
   * @return {number} Returns a response code indicating whether the run was
   *      a success/fail/unhandled, or if we should move to next/prev module.
   */
  run(e) {
    const keyCode = e.which || e.keyCode;
    let response = this.response.noHandler;
    const handlerCodeSet = find11(this.keyCodeMap, function(codeSet) {
      return codeSet[0].indexOf(keyCode) > -1;
    });
    if (handlerCodeSet) {
      response = handlerCodeSet[1].call(this, keyCode, e);
    } else if (keyCode === 9) {
      response = this.response[e.shiftKey ? "prev" : "next"];
    }
    return response;
  }
};
var KeyboardNavigationHandler_default = KeyboardNavigationHandler;

// node_modules/highcharts/es-modules/Accessibility/Components/ContainerComponent.js
var { unhideChartElementFromAT: unhideChartElementFromAT2, getChartTitle: getChartTitle2 } = ChartUtilities_default;
var { doc: doc10 } = Globals_default;
var { stripHTMLTagsFromString: stripHTMLTags2 } = HTMLUtilities_default;
var ContainerComponent = class extends AccessibilityComponent_default {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Called on first render/updates to the chart, including options changes.
   */
  onChartUpdate() {
    this.handleSVGTitleElement();
    this.setSVGContainerLabel();
    this.setGraphicContainerAttrs();
    this.setRenderToAttrs();
    this.makeCreditsAccessible();
  }
  /**
   * @private
   */
  handleSVGTitleElement() {
    const chart = this.chart, titleId = "highcharts-title-" + chart.index, titleContents = stripHTMLTags2(chart.langFormat("accessibility.svgContainerTitle", {
      chartTitle: getChartTitle2(chart)
    }));
    if (titleContents.length) {
      const titleElement = this.svgTitleElement = this.svgTitleElement || doc10.createElementNS("http://www.w3.org/2000/svg", "title");
      titleElement.textContent = titleContents;
      titleElement.id = titleId;
      chart.renderTo.insertBefore(titleElement, chart.renderTo.firstChild);
    }
  }
  /**
   * @private
   */
  setSVGContainerLabel() {
    const chart = this.chart, svgContainerLabel = chart.langFormat("accessibility.svgContainerLabel", {
      chartTitle: getChartTitle2(chart)
    });
    if (chart.renderer.box && svgContainerLabel.length) {
      chart.renderer.box.setAttribute("aria-label", svgContainerLabel);
    }
  }
  /**
   * @private
   */
  setGraphicContainerAttrs() {
    const chart = this.chart, label = chart.langFormat("accessibility.graphicContainerLabel", {
      chartTitle: getChartTitle2(chart)
    });
    if (label.length) {
      chart.container.setAttribute("aria-label", label);
    }
  }
  /**
   * Set attributes on the chart container element.
   * @private
   */
  setRenderToAttrs() {
    const chart = this.chart, shouldHaveLandmark = chart.options.accessibility.landmarkVerbosity !== "disabled", containerLabel = chart.langFormat("accessibility.chartContainerLabel", {
      title: getChartTitle2(chart),
      chart
    });
    if (containerLabel) {
      chart.renderTo.setAttribute("role", shouldHaveLandmark ? "region" : "group");
      chart.renderTo.setAttribute("aria-label", containerLabel);
    }
  }
  /**
   * @private
   */
  makeCreditsAccessible() {
    const chart = this.chart, credits = chart.credits;
    if (credits) {
      if (credits.textStr) {
        credits.element.setAttribute("aria-label", chart.langFormat("accessibility.credits", {
          creditsStr: stripHTMLTags2(credits.textStr, chart.renderer.forExport)
        }));
      }
      unhideChartElementFromAT2(chart, credits.element);
    }
  }
  /**
   * Empty handler to just set focus on chart
   * @private
   */
  getKeyboardNavigation() {
    const chart = this.chart;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [],
      validate: function() {
        return true;
      },
      init: function() {
        const a11y = chart.accessibility;
        if (a11y) {
          a11y.keyboardNavigation.tabindexContainer.focus();
        }
      }
    });
  }
  /**
   * Accessibility disabled/chart destroyed.
   */
  destroy() {
    this.chart.renderTo.setAttribute("aria-hidden", true);
  }
};
var ContainerComponent_default = ContainerComponent;

// node_modules/highcharts/es-modules/Accessibility/FocusBorder.js
var { addEvent: addEvent38, pick: pick50 } = Utilities_default;
var FocusBorderComposition;
(function(FocusBorderComposition2) {
  const svgElementBorderUpdateTriggers = [
    "x",
    "y",
    "transform",
    "width",
    "height",
    "r",
    "d",
    "stroke-width"
  ];
  function compose27(ChartClass, SVGElementClass) {
    const chartProto = ChartClass.prototype, svgElementProto = SVGElementClass.prototype;
    if (!chartProto.renderFocusBorder) {
      chartProto.renderFocusBorder = chartRenderFocusBorder;
      chartProto.setFocusToElement = chartSetFocusToElement;
    }
    if (!svgElementProto.addFocusBorder) {
      svgElementProto.addFocusBorder = svgElementAddFocusBorder;
      svgElementProto.removeFocusBorder = svgElementRemoveFocusBorder;
    }
  }
  FocusBorderComposition2.compose = compose27;
  function chartRenderFocusBorder() {
    const focusElement = this.focusElement, focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder;
    if (focusElement) {
      focusElement.removeFocusBorder();
      if (focusBorderOptions.enabled) {
        focusElement.addFocusBorder(focusBorderOptions.margin, {
          stroke: focusBorderOptions.style.color,
          strokeWidth: focusBorderOptions.style.lineWidth,
          r: focusBorderOptions.style.borderRadius
        });
      }
    }
  }
  function chartSetFocusToElement(svgElement, focusElement) {
    const focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder, browserFocusElement = focusElement || svgElement.element;
    if (browserFocusElement && browserFocusElement.focus) {
      if (!(browserFocusElement.hcEvents && browserFocusElement.hcEvents.focusin)) {
        addEvent38(browserFocusElement, "focusin", function() {
        });
      }
      browserFocusElement.focus();
      if (focusBorderOptions.hideBrowserFocusOutline) {
        browserFocusElement.style.outline = "none";
      }
    }
    if (this.focusElement) {
      this.focusElement.removeFocusBorder();
    }
    this.focusElement = svgElement;
    this.renderFocusBorder();
  }
  function svgElementAddDestroyFocusBorderHook(el) {
    if (el.focusBorderDestroyHook) {
      return;
    }
    const origDestroy = el.destroy;
    el.destroy = function() {
      if (el.focusBorder && el.focusBorder.destroy) {
        el.focusBorder.destroy();
      }
      return origDestroy.apply(el, arguments);
    };
    el.focusBorderDestroyHook = origDestroy;
  }
  function svgElementAddFocusBorder(margin, attribs) {
    if (this.focusBorder) {
      this.removeFocusBorder();
    }
    const bb = this.getBBox(), pad3 = pick50(margin, 3), parent = this.parentGroup, scaleX = this.scaleX || parent && parent.scaleX, scaleY = this.scaleY || parent && parent.scaleY, oneDefined = scaleX ? !scaleY : scaleY, scaleBoth = oneDefined ? Math.abs(scaleX || scaleY || 1) : (Math.abs(scaleX || 1) + Math.abs(scaleY || 1)) / 2, lineHeight = this.renderer.fontMetrics(this).h;
    bb.x += this.translateX ? this.translateX : 0;
    bb.y += this.translateY ? this.translateY : 0;
    let borderPosX = bb.x - pad3, borderPosY = bb.y - pad3, borderWidth = bb.width + 2 * pad3, borderHeight = bb.height + 2 * pad3;
    function getTextAnchorCorrection(text) {
      let posXCorrection = 0, posYCorrection = 0;
      if (text.attr("text-anchor") === "middle") {
        posXCorrection = posYCorrection = 0.5;
      } else if (!text.rotation) {
        posYCorrection = 0.75;
      } else {
        posXCorrection = 0.25;
      }
      return {
        x: posXCorrection,
        y: posYCorrection
      };
    }
    const isLabel = !!this.text;
    if (this.element.nodeName === "text" || isLabel) {
      const isRotated = !!this.rotation;
      const correction = !isLabel ? getTextAnchorCorrection(this) : {
        x: isRotated ? 1 : 0,
        y: 0
      };
      const attrX = +this.attr("x");
      const attrY = +this.attr("y");
      if (!isNaN(attrX)) {
        borderPosX = attrX - bb.width * correction.x - pad3;
      }
      if (!isNaN(attrY)) {
        const dim = this.attr("text-anchor") === "start" ? lineHeight : bb.height;
        borderPosY = attrY - dim * correction.y - pad3;
      }
      if (isLabel && isRotated) {
        const temp = borderWidth;
        borderWidth = borderHeight;
        borderHeight = temp;
        if (!isNaN(attrX)) {
          borderPosX = attrX - bb.height * correction.x - pad3;
        }
        if (!isNaN(attrY)) {
          borderPosY = attrY - bb.width * correction.y - pad3;
        }
      }
    }
    this.focusBorder = this.renderer.rect(borderPosX, borderPosY, borderWidth, borderHeight, parseInt((attribs && attribs.r || 0).toString(), 10) / scaleBoth).addClass("highcharts-focus-border").attr({
      zIndex: 99
    }).add(parent);
    if (!this.renderer.styledMode) {
      this.focusBorder.attr({
        stroke: attribs && attribs.stroke,
        "stroke-width": (attribs && attribs.strokeWidth || 0) / scaleBoth
      });
    }
    avgElementAddUpdateFocusBorderHooks(this, margin, attribs);
    svgElementAddDestroyFocusBorderHook(this);
  }
  function avgElementAddUpdateFocusBorderHooks(el, ...updateParams) {
    if (el.focusBorderUpdateHooks) {
      return;
    }
    el.focusBorderUpdateHooks = {};
    svgElementBorderUpdateTriggers.forEach((trigger) => {
      const setterKey = trigger + "Setter";
      const origSetter = el[setterKey] || el._defaultSetter;
      el.focusBorderUpdateHooks[setterKey] = origSetter;
      el[setterKey] = function() {
        const ret = origSetter.apply(el, arguments);
        el.addFocusBorder.apply(el, updateParams);
        return ret;
      };
    });
  }
  function svgElementRemoveDestroyFocusBorderHook(el) {
    if (!el.focusBorderDestroyHook) {
      return;
    }
    el.destroy = el.focusBorderDestroyHook;
    delete el.focusBorderDestroyHook;
  }
  function svgElementRemoveFocusBorder() {
    svgElementRemoveUpdateFocusBorderHooks(this);
    svgElementRemoveDestroyFocusBorderHook(this);
    if (this.focusBorder) {
      this.focusBorder.destroy();
      delete this.focusBorder;
    }
  }
  function svgElementRemoveUpdateFocusBorderHooks(el) {
    if (!el.focusBorderUpdateHooks) {
      return;
    }
    Object.keys(el.focusBorderUpdateHooks).forEach((setterKey) => {
      const origSetter = el.focusBorderUpdateHooks[setterKey];
      if (origSetter === el._defaultSetter) {
        delete el[setterKey];
      } else {
        el[setterKey] = origSetter;
      }
    });
    delete el.focusBorderUpdateHooks;
  }
})(FocusBorderComposition || (FocusBorderComposition = {}));
var FocusBorder_default = FocusBorderComposition;

// node_modules/highcharts/es-modules/Accessibility/Utils/Announcer.js
var { doc: doc11 } = Globals_default;
var { addClass: addClass2, visuallyHideElement: visuallyHideElement2 } = HTMLUtilities_default;
var { attr: attr10 } = Utilities_default;
var Announcer = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart, type) {
    this.chart = chart;
    this.domElementProvider = new DOMElementProvider_default();
    this.announceRegion = this.addAnnounceRegion(type);
  }
  /* *
   *
   *  Functions
   *
   * */
  destroy() {
    this.domElementProvider.destroyCreatedElements();
  }
  announce(message) {
    AST_default.setElementHTML(this.announceRegion, message);
    if (this.clearAnnouncementRegionTimer) {
      clearTimeout(this.clearAnnouncementRegionTimer);
    }
    this.clearAnnouncementRegionTimer = setTimeout(() => {
      this.announceRegion.innerHTML = AST_default.emptyHTML;
      delete this.clearAnnouncementRegionTimer;
    }, 3e3);
  }
  addAnnounceRegion(type) {
    const chartContainer = this.chart.announcerContainer || this.createAnnouncerContainer(), div = this.domElementProvider.createElement("div");
    attr10(div, {
      "aria-hidden": false,
      "aria-live": type,
      "aria-atomic": true
    });
    if (this.chart.styledMode) {
      addClass2(div, "highcharts-visually-hidden");
    } else {
      visuallyHideElement2(div);
    }
    chartContainer.appendChild(div);
    return div;
  }
  createAnnouncerContainer() {
    const chart = this.chart, container = doc11.createElement("div");
    attr10(container, {
      "aria-hidden": false,
      "class": "highcharts-announcer-container"
    });
    container.style.position = "relative";
    chart.renderTo.insertBefore(container, chart.renderTo.firstChild);
    chart.announcerContainer = container;
    return container;
  }
};
var Announcer_default = Announcer;

// node_modules/highcharts/es-modules/Accessibility/Components/AnnotationsA11y.js
var { escapeStringForHTML: escapeStringForHTML2, stripHTMLTagsFromString: stripHTMLTagsFromString2 } = HTMLUtilities_default;
function getChartAnnotationLabels(chart) {
  const annotations = chart.annotations || [];
  return annotations.reduce((acc, cur) => {
    if (cur.options && cur.options.visible !== false) {
      acc = acc.concat(cur.labels);
    }
    return acc;
  }, []);
}
function getLabelText(label) {
  return label.options && label.options.accessibility && label.options.accessibility.description || label.graphic && label.graphic.text && label.graphic.text.textStr || "";
}
function getAnnotationLabelDescription(label) {
  const a11yDesc = label.options && label.options.accessibility && label.options.accessibility.description;
  if (a11yDesc) {
    return a11yDesc;
  }
  const chart = label.chart;
  const labelText = getLabelText(label);
  const points = label.points;
  const getAriaLabel = (point) => point.graphic && point.graphic.element && point.graphic.element.getAttribute("aria-label") || "";
  const getValueDesc = (point) => {
    const valDesc = point.accessibility && point.accessibility.valueDescription || getAriaLabel(point);
    const seriesName = point && point.series.name || "";
    return (seriesName ? seriesName + ", " : "") + "data point " + valDesc;
  };
  const pointValueDescriptions = points.filter((p) => !!p.graphic).map(getValueDesc).filter((desc) => !!desc);
  const numPoints = pointValueDescriptions.length;
  const pointsSelector = numPoints > 1 ? "MultiplePoints" : numPoints ? "SinglePoint" : "NoPoints";
  const langFormatStr = "accessibility.screenReaderSection.annotations.description" + pointsSelector;
  const context = {
    annotationText: labelText,
    annotation: label,
    numPoints,
    annotationPoint: pointValueDescriptions[0],
    additionalAnnotationPoints: pointValueDescriptions.slice(1)
  };
  return chart.langFormat(langFormatStr, context);
}
function getAnnotationListItems(chart) {
  const labels = getChartAnnotationLabels(chart);
  return labels.map((label) => {
    const desc = escapeStringForHTML2(stripHTMLTagsFromString2(getAnnotationLabelDescription(label), chart.renderer.forExport));
    return desc ? `<li>${desc}</li>` : "";
  });
}
function getAnnotationsInfoHTML(chart) {
  const annotations = chart.annotations;
  if (!(annotations && annotations.length)) {
    return "";
  }
  const annotationItems = getAnnotationListItems(chart);
  return `<ul style="list-style-type: none">${annotationItems.join(" ")}</ul>`;
}
function getPointAnnotationTexts(point) {
  const labels = getChartAnnotationLabels(point.series.chart);
  const pointLabels = labels.filter((label) => label.points.indexOf(point) > -1);
  if (!pointLabels.length) {
    return [];
  }
  return pointLabels.map((label) => `${getLabelText(label)}`);
}
var AnnotationsA11y = {
  getAnnotationsInfoHTML,
  getAnnotationLabelDescription,
  getAnnotationListItems,
  getPointAnnotationTexts
};
var AnnotationsA11y_default = AnnotationsA11y;

// node_modules/highcharts/es-modules/Accessibility/Components/InfoRegionsComponent.js
var { getAnnotationsInfoHTML: getAnnotationsInfoHTML2 } = AnnotationsA11y_default;
var { getAxisDescription: getAxisDescription2, getAxisRangeDescription: getAxisRangeDescription2, getChartTitle: getChartTitle3, unhideChartElementFromAT: unhideChartElementFromAT3 } = ChartUtilities_default;
var { format: format12 } = Templating_default;
var { doc: doc12 } = Globals_default;
var { addClass: addClass3, getElement: getElement2, getHeadingTagNameForElement: getHeadingTagNameForElement2, stripHTMLTagsFromString: stripHTMLTagsFromString3, visuallyHideElement: visuallyHideElement3 } = HTMLUtilities_default;
var { attr: attr11, pick: pick51, replaceNested: replaceNested4 } = Utilities_default;
function getTableSummary(chart) {
  return chart.langFormat("accessibility.table.tableSummary", { chart });
}
function getTypeDescForMapChart(chart, formatContext) {
  return formatContext.mapTitle ? chart.langFormat("accessibility.chartTypes.mapTypeDescription", formatContext) : chart.langFormat("accessibility.chartTypes.unknownMap", formatContext);
}
function getTypeDescForCombinationChart(chart, formatContext) {
  return chart.langFormat("accessibility.chartTypes.combinationChart", formatContext);
}
function getTypeDescForEmptyChart(chart, formatContext) {
  return chart.langFormat("accessibility.chartTypes.emptyChart", formatContext);
}
function buildTypeDescriptionFromSeries(chart, types, context) {
  const firstType = types[0], typeExplanation = chart.langFormat("accessibility.seriesTypeDescriptions." + firstType, context), multi = chart.series && chart.series.length < 2 ? "Single" : "Multiple";
  return (chart.langFormat("accessibility.chartTypes." + firstType + multi, context) || chart.langFormat("accessibility.chartTypes.default" + multi, context)) + (typeExplanation ? " " + typeExplanation : "");
}
function getTypeDescription(chart, types) {
  const firstType = types[0], firstSeries = chart.series && chart.series[0] || {}, mapTitle = chart.mapView && chart.mapView.geoMap && chart.mapView.geoMap.title, formatContext = {
    numSeries: chart.series.length,
    numPoints: firstSeries.points && firstSeries.points.length,
    chart,
    mapTitle
  };
  if (!firstType) {
    return getTypeDescForEmptyChart(chart, formatContext);
  }
  if (firstType === "map" || firstType === "tiledwebmap") {
    return getTypeDescForMapChart(chart, formatContext);
  }
  if (chart.types.length > 1) {
    return getTypeDescForCombinationChart(chart, formatContext);
  }
  return buildTypeDescriptionFromSeries(chart, types, formatContext);
}
function stripEmptyHTMLTags(str) {
  return replaceNested4(str, [/<([\w\-.:!]+)\b[^<>]*>\s*<\/\1>/g, ""]);
}
var InfoRegionsComponent = class extends AccessibilityComponent_default {
  constructor() {
    super(...arguments);
    this.screenReaderSections = {};
  }
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Init the component
   * @private
   */
  init() {
    const chart = this.chart;
    const component = this;
    this.initRegionsDefinitions();
    this.addEvent(chart, "aftergetTableAST", function(e) {
      component.onDataTableCreated(e);
    });
    this.addEvent(chart, "afterViewData", function(e) {
      if (e.wasHidden) {
        component.dataTableDiv = e.element;
        setTimeout(function() {
          component.focusDataTable();
        }, 300);
      }
    });
    this.addEvent(chart, "afterHideData", function() {
      if (component.viewDataTableButton) {
        component.viewDataTableButton.setAttribute("aria-expanded", "false");
      }
    });
    if (chart.exporting) {
      this.addEvent(chart, "afterPrint", function() {
        component.updateAllScreenReaderSections();
      });
    }
    this.announcer = new Announcer_default(chart, "assertive");
  }
  /**
   * @private
   */
  initRegionsDefinitions() {
    const component = this, accessibilityOptions = this.chart.options.accessibility;
    this.screenReaderSections = {
      before: {
        element: null,
        buildContent: function(chart) {
          const formatter = accessibilityOptions.screenReaderSection.beforeChartFormatter;
          return formatter ? formatter(chart) : component.defaultBeforeChartFormatter(chart);
        },
        insertIntoDOM: function(el, chart) {
          chart.renderTo.insertBefore(el, chart.renderTo.firstChild);
        },
        afterInserted: function() {
          if (typeof component.sonifyButtonId !== "undefined") {
            component.initSonifyButton(component.sonifyButtonId);
          }
          if (typeof component.dataTableButtonId !== "undefined") {
            component.initDataTableButton(component.dataTableButtonId);
          }
        }
      },
      after: {
        element: null,
        buildContent: function(chart) {
          const formatter = accessibilityOptions.screenReaderSection.afterChartFormatter;
          return formatter ? formatter(chart) : component.defaultAfterChartFormatter();
        },
        insertIntoDOM: function(el, chart) {
          chart.renderTo.insertBefore(el, chart.container.nextSibling);
        },
        afterInserted: function() {
          if (component.chart.accessibility && accessibilityOptions.keyboardNavigation.enabled) {
            component.chart.accessibility.keyboardNavigation.updateExitAnchor();
          }
        }
      }
    };
  }
  /**
   * Called on chart render. Have to update the sections on render, in order
   * to get a11y info from series.
   */
  onChartRender() {
    this.linkedDescriptionElement = this.getLinkedDescriptionElement();
    this.setLinkedDescriptionAttrs();
    this.updateAllScreenReaderSections();
  }
  updateAllScreenReaderSections() {
    const component = this;
    Object.keys(this.screenReaderSections).forEach(function(regionKey) {
      component.updateScreenReaderSection(regionKey);
    });
  }
  /**
   * @private
   */
  getLinkedDescriptionElement() {
    const chartOptions = this.chart.options, linkedDescOption = chartOptions.accessibility.linkedDescription;
    if (!linkedDescOption) {
      return;
    }
    if (typeof linkedDescOption !== "string") {
      return linkedDescOption;
    }
    const query = format12(linkedDescOption, this.chart), queryMatch = doc12.querySelectorAll(query);
    if (queryMatch.length === 1) {
      return queryMatch[0];
    }
  }
  /**
   * @private
   */
  setLinkedDescriptionAttrs() {
    const el = this.linkedDescriptionElement;
    if (el) {
      el.setAttribute("aria-hidden", "true");
      addClass3(el, "highcharts-linked-description");
    }
  }
  /**
   * @private
   * @param {string} regionKey
   * The name/key of the region to update
   */
  updateScreenReaderSection(regionKey) {
    const chart = this.chart;
    const region = this.screenReaderSections[regionKey];
    const content = region.buildContent(chart);
    const sectionDiv = region.element = region.element || this.createElement("div");
    const hiddenDiv = sectionDiv.firstChild || this.createElement("div");
    if (content) {
      this.setScreenReaderSectionAttribs(sectionDiv, regionKey);
      AST_default.setElementHTML(hiddenDiv, content);
      sectionDiv.appendChild(hiddenDiv);
      region.insertIntoDOM(sectionDiv, chart);
      if (chart.styledMode) {
        addClass3(hiddenDiv, "highcharts-visually-hidden");
      } else {
        visuallyHideElement3(hiddenDiv);
      }
      unhideChartElementFromAT3(chart, hiddenDiv);
      if (region.afterInserted) {
        region.afterInserted();
      }
    } else {
      if (sectionDiv.parentNode) {
        sectionDiv.parentNode.removeChild(sectionDiv);
      }
      region.element = null;
    }
  }
  /**
   * Apply a11y attributes to a screen reader info section
   * @private
   * @param {Highcharts.HTMLDOMElement} sectionDiv The section element
   * @param {string} regionKey Name/key of the region we are setting attrs for
   */
  setScreenReaderSectionAttribs(sectionDiv, regionKey) {
    const chart = this.chart, labelText = chart.langFormat("accessibility.screenReaderSection." + regionKey + "RegionLabel", { chart, chartTitle: getChartTitle3(chart) }), sectionId = `highcharts-screen-reader-region-${regionKey}-${chart.index}`;
    attr11(sectionDiv, {
      id: sectionId,
      "aria-label": labelText || void 0
    });
    sectionDiv.style.position = "relative";
    if (labelText) {
      sectionDiv.setAttribute("role", chart.options.accessibility.landmarkVerbosity === "all" ? "region" : "group");
    }
  }
  /**
   * @private
   */
  defaultBeforeChartFormatter() {
    const chart = this.chart, format18 = chart.options.accessibility.screenReaderSection.beforeChartFormat;
    if (!format18) {
      return "";
    }
    const axesDesc = this.getAxesDescription(), shouldHaveSonifyBtn = chart.sonify && chart.options.sonification && chart.options.sonification.enabled, sonifyButtonId = "highcharts-a11y-sonify-data-btn-" + chart.index, dataTableButtonId = "hc-linkto-highcharts-data-table-" + chart.index, annotationsList = getAnnotationsInfoHTML2(chart), annotationsTitleStr = chart.langFormat("accessibility.screenReaderSection.annotations.heading", { chart }), context = {
      headingTagName: getHeadingTagNameForElement2(chart.renderTo),
      chartTitle: getChartTitle3(chart),
      typeDescription: this.getTypeDescriptionText(),
      chartSubtitle: this.getSubtitleText(),
      chartLongdesc: this.getLongdescText(),
      xAxisDescription: axesDesc.xAxis,
      yAxisDescription: axesDesc.yAxis,
      playAsSoundButton: shouldHaveSonifyBtn ? this.getSonifyButtonText(sonifyButtonId) : "",
      viewTableButton: chart.getCSV ? this.getDataTableButtonText(dataTableButtonId) : "",
      annotationsTitle: annotationsList ? annotationsTitleStr : "",
      annotationsList
    }, formattedString = A11yI18n_default.i18nFormat(format18, context, chart);
    this.dataTableButtonId = dataTableButtonId;
    this.sonifyButtonId = sonifyButtonId;
    return stripEmptyHTMLTags(formattedString);
  }
  /**
   * @private
   */
  defaultAfterChartFormatter() {
    const chart = this.chart;
    const format18 = chart.options.accessibility.screenReaderSection.afterChartFormat;
    if (!format18) {
      return "";
    }
    const context = { endOfChartMarker: this.getEndOfChartMarkerText() };
    const formattedString = A11yI18n_default.i18nFormat(format18, context, chart);
    return stripEmptyHTMLTags(formattedString);
  }
  /**
   * @private
   */
  getLinkedDescription() {
    const el = this.linkedDescriptionElement, content = el && el.innerHTML || "";
    return stripHTMLTagsFromString3(content, this.chart.renderer.forExport);
  }
  /**
   * @private
   */
  getLongdescText() {
    const chartOptions = this.chart.options, captionOptions = chartOptions.caption, captionText = captionOptions && captionOptions.text, linkedDescription = this.getLinkedDescription();
    return chartOptions.accessibility.description || linkedDescription || captionText || "";
  }
  /**
   * @private
   */
  getTypeDescriptionText() {
    const chart = this.chart;
    return chart.types ? chart.options.accessibility.typeDescription || getTypeDescription(chart, chart.types) : "";
  }
  /**
   * @private
   */
  getDataTableButtonText(buttonId) {
    const chart = this.chart, buttonText = chart.langFormat("accessibility.table.viewAsDataTableButtonText", { chart, chartTitle: getChartTitle3(chart) });
    return '<button id="' + buttonId + '">' + buttonText + "</button>";
  }
  /**
   * @private
   */
  getSonifyButtonText(buttonId) {
    const chart = this.chart;
    if (chart.options.sonification && chart.options.sonification.enabled === false) {
      return "";
    }
    const buttonText = chart.langFormat("accessibility.sonification.playAsSoundButtonText", { chart, chartTitle: getChartTitle3(chart) });
    return '<button id="' + buttonId + '">' + buttonText + "</button>";
  }
  /**
   * @private
   */
  getSubtitleText() {
    const subtitle = this.chart.options.subtitle;
    return stripHTMLTagsFromString3(subtitle && subtitle.text || "", this.chart.renderer.forExport);
  }
  /**
   * @private
   */
  getEndOfChartMarkerText() {
    const endMarkerId = `highcharts-end-of-chart-marker-${this.chart.index}`, endMarker = getElement2(endMarkerId);
    if (endMarker) {
      return endMarker.outerHTML;
    }
    const chart = this.chart, markerText = chart.langFormat("accessibility.screenReaderSection.endOfChartMarker", { chart }), id = "highcharts-end-of-chart-marker-" + chart.index;
    return '<div id="' + id + '">' + markerText + "</div>";
  }
  /**
   * @private
   * @param {Highcharts.Dictionary<string>} e
   */
  onDataTableCreated(e) {
    const chart = this.chart;
    if (chart.options.accessibility.enabled) {
      if (this.viewDataTableButton) {
        this.viewDataTableButton.setAttribute("aria-expanded", "true");
      }
      const attributes = e.tree.attributes || {};
      attributes.tabindex = -1;
      attributes.summary = getTableSummary(chart);
      e.tree.attributes = attributes;
    }
  }
  /**
   * @private
   */
  focusDataTable() {
    const tableDiv = this.dataTableDiv, table = tableDiv && tableDiv.getElementsByTagName("table")[0];
    if (table && table.focus) {
      table.focus();
    }
  }
  /**
   * @private
   * @param {string} sonifyButtonId
   */
  initSonifyButton(sonifyButtonId) {
    const el = this.sonifyButton = getElement2(sonifyButtonId);
    const chart = this.chart;
    const defaultHandler = (e) => {
      if (el) {
        el.setAttribute("aria-hidden", "true");
        el.setAttribute("aria-label", "");
      }
      e.preventDefault();
      e.stopPropagation();
      const announceMsg = chart.langFormat("accessibility.sonification.playAsSoundClickAnnouncement", { chart });
      this.announcer.announce(announceMsg);
      setTimeout(() => {
        if (el) {
          el.removeAttribute("aria-hidden");
          el.removeAttribute("aria-label");
        }
        if (chart.sonify) {
          chart.sonify();
        }
      }, 1e3);
    };
    if (el && chart) {
      el.setAttribute("tabindex", -1);
      el.onclick = function(e) {
        const onPlayAsSoundClick = chart.options.accessibility && chart.options.accessibility.screenReaderSection.onPlayAsSoundClick;
        (onPlayAsSoundClick || defaultHandler).call(this, e, chart);
      };
    }
  }
  /**
   * Set attribs and handlers for default viewAsDataTable button if exists.
   * @private
   * @param {string} tableButtonId
   */
  initDataTableButton(tableButtonId) {
    const el = this.viewDataTableButton = getElement2(tableButtonId), chart = this.chart, tableId = tableButtonId.replace("hc-linkto-", "");
    if (el) {
      attr11(el, {
        tabindex: -1,
        "aria-expanded": !!getElement2(tableId)
      });
      el.onclick = chart.options.accessibility.screenReaderSection.onViewDataTableClick || function() {
        chart.viewData();
      };
    }
  }
  /**
   * Return object with text description of each of the chart's axes.
   * @private
   */
  getAxesDescription() {
    const chart = this.chart, shouldDescribeColl = function(collectionKey, defaultCondition) {
      const axes = chart[collectionKey];
      return axes.length > 1 || axes[0] && pick51(axes[0].options.accessibility && axes[0].options.accessibility.enabled, defaultCondition);
    }, hasNoMap = !!chart.types && chart.types.indexOf("map") < 0 && chart.types.indexOf("treemap") < 0 && chart.types.indexOf("tilemap") < 0, hasCartesian = !!chart.hasCartesianSeries, showXAxes = shouldDescribeColl("xAxis", !chart.angular && hasCartesian && hasNoMap), showYAxes = shouldDescribeColl("yAxis", hasCartesian && hasNoMap), desc = {};
    if (showXAxes) {
      desc.xAxis = this.getAxisDescriptionText("xAxis");
    }
    if (showYAxes) {
      desc.yAxis = this.getAxisDescriptionText("yAxis");
    }
    return desc;
  }
  /**
   * @private
   */
  getAxisDescriptionText(collectionKey) {
    const chart = this.chart;
    const axes = chart[collectionKey];
    return chart.langFormat("accessibility.axis." + collectionKey + "Description" + (axes.length > 1 ? "Plural" : "Singular"), {
      chart,
      names: axes.map(function(axis) {
        return getAxisDescription2(axis);
      }),
      ranges: axes.map(function(axis) {
        return getAxisRangeDescription2(axis);
      }),
      numAxes: axes.length
    });
  }
  /**
   * Remove component traces
   */
  destroy() {
    if (this.announcer) {
      this.announcer.destroy();
    }
  }
};
var InfoRegionsComponent_default = InfoRegionsComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/MenuComponent.js
var { attr: attr12 } = Utilities_default;
var { getChartTitle: getChartTitle4, unhideChartElementFromAT: unhideChartElementFromAT4 } = ChartUtilities_default;
var { getFakeMouseEvent: getFakeMouseEvent3 } = HTMLUtilities_default;
function getExportMenuButtonElement(chart) {
  return chart.exportSVGElements && chart.exportSVGElements[0];
}
function exportingShouldHaveA11y(chart) {
  const exportingOpts = chart.options.exporting, exportButton = getExportMenuButtonElement(chart);
  return !!(exportingOpts && exportingOpts.enabled !== false && exportingOpts.accessibility && exportingOpts.accessibility.enabled && exportButton && exportButton.element);
}
var MenuComponent = class extends AccessibilityComponent_default {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Init the component
   */
  init() {
    const chart = this.chart, component = this;
    this.addEvent(chart, "exportMenuShown", function() {
      component.onMenuShown();
    });
    this.addEvent(chart, "exportMenuHidden", function() {
      component.onMenuHidden();
    });
    this.createProxyGroup();
  }
  /**
   * @private
   */
  onMenuHidden() {
    const menu = this.chart.exportContextMenu;
    if (menu) {
      menu.setAttribute("aria-hidden", "true");
    }
    this.setExportButtonExpandedState("false");
  }
  /**
   * @private
   */
  onMenuShown() {
    const chart = this.chart, menu = chart.exportContextMenu;
    if (menu) {
      this.addAccessibleContextMenuAttribs();
      unhideChartElementFromAT4(chart, menu);
    }
    this.setExportButtonExpandedState("true");
  }
  /**
   * @private
   * @param {string} stateStr
   */
  setExportButtonExpandedState(stateStr) {
    if (this.exportButtonProxy) {
      this.exportButtonProxy.innerElement.setAttribute("aria-expanded", stateStr);
    }
  }
  /**
   * Called on each render of the chart. We need to update positioning of the
   * proxy overlay.
   */
  onChartRender() {
    const chart = this.chart, focusEl = chart.focusElement, a11y = chart.accessibility;
    this.proxyProvider.clearGroup("chartMenu");
    this.proxyMenuButton();
    if (this.exportButtonProxy && focusEl && focusEl === chart.exportingGroup) {
      if (focusEl.focusBorder) {
        chart.setFocusToElement(focusEl, this.exportButtonProxy.innerElement);
      } else if (a11y) {
        a11y.keyboardNavigation.tabindexContainer.focus();
      }
    }
  }
  /**
   * @private
   */
  proxyMenuButton() {
    const chart = this.chart;
    const proxyProvider = this.proxyProvider;
    const buttonEl = getExportMenuButtonElement(chart);
    if (exportingShouldHaveA11y(chart) && buttonEl) {
      this.exportButtonProxy = proxyProvider.addProxyElement("chartMenu", { click: buttonEl }, "button", {
        "aria-label": chart.langFormat("accessibility.exporting.menuButtonLabel", {
          chart,
          chartTitle: getChartTitle4(chart)
        }),
        "aria-expanded": false,
        title: chart.options.lang.contextButtonTitle || null
      });
    }
  }
  /**
   * @private
   */
  createProxyGroup() {
    const chart = this.chart;
    if (chart && this.proxyProvider) {
      this.proxyProvider.addGroup("chartMenu");
    }
  }
  /**
   * @private
   */
  addAccessibleContextMenuAttribs() {
    const chart = this.chart, exportList = chart.exportDivElements;
    if (exportList && exportList.length) {
      exportList.forEach((item) => {
        if (item) {
          if (item.tagName === "LI" && !(item.children && item.children.length)) {
            item.setAttribute("tabindex", -1);
          } else {
            item.setAttribute("aria-hidden", "true");
          }
        }
      });
      const parentDiv = exportList[0] && exportList[0].parentNode;
      if (parentDiv) {
        attr12(parentDiv, {
          "aria-hidden": void 0,
          "aria-label": chart.langFormat("accessibility.exporting.chartMenuLabel", { chart }),
          role: "list"
          // Needed for webkit/VO
        });
      }
    }
  }
  /**
   * Get keyboard navigation handler for this component.
   * @private
   */
  getKeyboardNavigation() {
    const keys = this.keyCodes, chart = this.chart, component = this;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [
        // Arrow prev handler
        [
          [keys.left, keys.up],
          function() {
            return component.onKbdPrevious(this);
          }
        ],
        // Arrow next handler
        [
          [keys.right, keys.down],
          function() {
            return component.onKbdNext(this);
          }
        ],
        // Click handler
        [
          [keys.enter, keys.space],
          function() {
            return component.onKbdClick(this);
          }
        ]
      ],
      // Only run exporting navigation if exporting support exists and is
      // enabled on chart
      validate: function() {
        return !!chart.exporting && chart.options.exporting?.buttons?.contextButton.enabled !== false && chart.options.exporting.enabled !== false && chart.options.exporting.accessibility.enabled !== false;
      },
      // Focus export menu button
      init: function() {
        const proxy = component.exportButtonProxy;
        const svgEl = component.chart.exportingGroup;
        if (proxy && svgEl) {
          chart.setFocusToElement(svgEl, proxy.innerElement);
        }
      },
      // Hide the menu
      terminate: function() {
        chart.hideExportMenu();
      }
    });
  }
  /**
   * @private
   * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
   * @return {number} Response code
   */
  onKbdPrevious(keyboardNavigationHandler) {
    const chart = this.chart;
    const a11yOptions = chart.options.accessibility;
    const response = keyboardNavigationHandler.response;
    let i = chart.highlightedExportItemIx || 0;
    while (i--) {
      if (chart.highlightExportItem(i)) {
        return response.success;
      }
    }
    if (a11yOptions.keyboardNavigation.wrapAround) {
      chart.highlightLastExportItem();
      return response.success;
    }
    return response.prev;
  }
  /**
   * @private
   * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
   * @return {number} Response code
   */
  onKbdNext(keyboardNavigationHandler) {
    const chart = this.chart;
    const a11yOptions = chart.options.accessibility;
    const response = keyboardNavigationHandler.response;
    for (let i = (chart.highlightedExportItemIx || 0) + 1; i < chart.exportDivElements.length; ++i) {
      if (chart.highlightExportItem(i)) {
        return response.success;
      }
    }
    if (a11yOptions.keyboardNavigation.wrapAround) {
      chart.highlightExportItem(0);
      return response.success;
    }
    return response.next;
  }
  /**
   * @private
   * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
   * @return {number} Response code
   */
  onKbdClick(keyboardNavigationHandler) {
    const chart = this.chart;
    const curHighlightedItem = chart.exportDivElements[chart.highlightedExportItemIx];
    const exportButtonElement = getExportMenuButtonElement(chart).element;
    if (chart.openMenu) {
      this.fakeClickEvent(curHighlightedItem);
    } else {
      this.fakeClickEvent(exportButtonElement);
      chart.highlightExportItem(0);
    }
    return keyboardNavigationHandler.response.success;
  }
};
(function(MenuComponent2) {
  function compose27(ChartClass) {
    const chartProto = ChartClass.prototype;
    if (!chartProto.hideExportMenu) {
      chartProto.hideExportMenu = chartHideExportMenu;
      chartProto.highlightExportItem = chartHighlightExportItem;
      chartProto.highlightLastExportItem = chartHighlightLastExportItem;
      chartProto.showExportMenu = chartShowExportMenu;
    }
  }
  MenuComponent2.compose = compose27;
  function chartShowExportMenu() {
    const exportButton = getExportMenuButtonElement(this);
    if (exportButton) {
      const el = exportButton.element;
      if (el.onclick) {
        el.onclick(getFakeMouseEvent3("click"));
      }
    }
  }
  function chartHideExportMenu() {
    const chart = this, exportList = chart.exportDivElements;
    if (exportList && chart.exportContextMenu && chart.openMenu) {
      exportList.forEach((el) => {
        if (el && el.className === "highcharts-menu-item" && el.onmouseout) {
          el.onmouseout(getFakeMouseEvent3("mouseout"));
        }
      });
      chart.highlightedExportItemIx = 0;
      chart.exportContextMenu.hideMenu();
      chart.container.focus();
    }
  }
  function chartHighlightExportItem(ix) {
    const listItem = this.exportDivElements && this.exportDivElements[ix];
    const curHighlighted = this.exportDivElements && this.exportDivElements[this.highlightedExportItemIx];
    if (listItem && listItem.tagName === "LI" && !(listItem.children && listItem.children.length)) {
      const hasSVGFocusSupport = !!(this.renderTo.getElementsByTagName("g")[0] || {}).focus;
      if (listItem.focus && hasSVGFocusSupport) {
        listItem.focus();
      }
      if (curHighlighted && curHighlighted.onmouseout) {
        curHighlighted.onmouseout(getFakeMouseEvent3("mouseout"));
      }
      if (listItem.onmouseover) {
        listItem.onmouseover(getFakeMouseEvent3("mouseover"));
      }
      this.highlightedExportItemIx = ix;
      return true;
    }
    return false;
  }
  function chartHighlightLastExportItem() {
    const chart = this;
    if (chart.exportDivElements) {
      let i = chart.exportDivElements.length;
      while (i--) {
        if (chart.highlightExportItem(i)) {
          return true;
        }
      }
    }
    return false;
  }
})(MenuComponent || (MenuComponent = {}));
var MenuComponent_default = MenuComponent;

// node_modules/highcharts/es-modules/Accessibility/KeyboardNavigation.js
var { doc: doc13, win: win12 } = Globals_default;
var { addEvent: addEvent39, defined: defined40, fireEvent: fireEvent27 } = Utilities_default;
var { getElement: getElement3, simulatedEventTarget: simulatedEventTarget2 } = HTMLUtilities_default;
var KeyboardNavigation = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart, components) {
    this.currentModuleIx = NaN;
    this.modules = [];
    this.init(chart, components);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Initialize the class
   * @private
   * @param {Highcharts.Chart} chart
   *        Chart object
   * @param {Object} components
   *        Map of component names to AccessibilityComponent objects.
   */
  init(chart, components) {
    const ep = this.eventProvider = new EventProvider_default();
    this.chart = chart;
    this.components = components;
    this.modules = [];
    this.currentModuleIx = 0;
    this.update();
    ep.addEvent(this.tabindexContainer, "keydown", (e) => this.onKeydown(e));
    ep.addEvent(this.tabindexContainer, "focus", (e) => this.onFocus(e));
    ["mouseup", "touchend"].forEach((eventName) => ep.addEvent(doc13, eventName, (e) => this.onMouseUp(e)));
    ["mousedown", "touchstart"].forEach((eventName) => ep.addEvent(chart.renderTo, eventName, () => {
      this.isClickingChart = true;
    }));
  }
  /**
   * Update the modules for the keyboard navigation.
   * @param {Array<string>} [order]
   *        Array specifying the tab order of the components.
   */
  update(order) {
    const a11yOptions = this.chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, components = this.components;
    this.updateContainerTabindex();
    if (keyboardOptions && keyboardOptions.enabled && order && order.length) {
      this.modules = order.reduce(function(modules, componentName) {
        const navModules = components[componentName].getKeyboardNavigation();
        return modules.concat(navModules);
      }, []);
      this.updateExitAnchor();
    } else {
      this.modules = [];
      this.currentModuleIx = 0;
      this.removeExitAnchor();
    }
  }
  /**
   * We use an exit anchor to move focus out of chart whenever we want, by
   * setting focus to this div and not preventing the default tab action. We
   * also use this when users come back into the chart by tabbing back, in
   * order to navigate from the end of the chart.
   * @private
   */
  updateExitAnchor() {
    const endMarkerId = `highcharts-end-of-chart-marker-${this.chart.index}`, endMarker = getElement3(endMarkerId);
    this.removeExitAnchor();
    if (endMarker) {
      this.makeElementAnExitAnchor(endMarker);
      this.exitAnchor = endMarker;
    } else {
      this.createExitAnchor();
    }
  }
  /**
   * Move to prev/next module.
   * @private
   * @param {number} direction
   * Direction to move. +1 for next, -1 for prev.
   * @return {boolean}
   * True if there was a valid module in direction.
   */
  move(direction) {
    const curModule = this.modules && this.modules[this.currentModuleIx];
    if (curModule && curModule.terminate) {
      curModule.terminate(direction);
    }
    if (this.chart.focusElement) {
      this.chart.focusElement.removeFocusBorder();
    }
    this.currentModuleIx += direction;
    const newModule = this.modules && this.modules[this.currentModuleIx];
    if (newModule) {
      if (newModule.validate && !newModule.validate()) {
        return this.move(direction);
      }
      if (newModule.init) {
        newModule.init(direction);
        return true;
      }
    }
    this.currentModuleIx = 0;
    this.exiting = true;
    if (direction > 0) {
      this.exitAnchor && this.exitAnchor.focus();
    } else {
      this.tabindexContainer.focus();
    }
    return false;
  }
  /**
   * Function to run on container focus
   * @private
   * @param {global.FocusEvent} e Browser focus event.
   */
  onFocus(e) {
    const chart = this.chart, focusComesFromChart = e.relatedTarget && chart.container.contains(e.relatedTarget), a11yOptions = chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, enabled = keyboardOptions && keyboardOptions.enabled;
    if (enabled && !this.exiting && !this.tabbingInBackwards && !this.isClickingChart && !focusComesFromChart) {
      const ix = this.getFirstValidModuleIx();
      if (ix !== null) {
        this.currentModuleIx = ix;
        this.modules[ix].init(1);
      }
    }
    this.keyboardReset = false;
    this.exiting = false;
  }
  /**
   * Reset chart navigation state if we mouse click and it's not already
   * reset. Reset fully if outside the chart, otherwise just hide focus
   * indicator.
   * @private
   */
  onMouseUp(e) {
    delete this.isClickingChart;
    if (!this.keyboardReset && e.relatedTarget !== simulatedEventTarget2) {
      const chart = this.chart;
      if (!e.target || !chart.container.contains(e.target)) {
        const curMod = this.modules && this.modules[this.currentModuleIx || 0];
        if (curMod && curMod.terminate) {
          curMod.terminate();
        }
        this.currentModuleIx = 0;
      }
      if (chart.focusElement) {
        chart.focusElement.removeFocusBorder();
        delete chart.focusElement;
      }
      this.keyboardReset = true;
    }
  }
  /**
   * Function to run on keydown
   * @private
   * @param {global.KeyboardEvent} ev Browser keydown event.
   */
  onKeydown(ev) {
    const e = ev || win12.event, curNavModule = this.modules && this.modules.length && this.modules[this.currentModuleIx];
    let preventDefault;
    const target = e.target;
    if (target && target.nodeName === "INPUT" && !target.classList.contains("highcharts-a11y-proxy-element")) {
      return;
    }
    this.keyboardReset = false;
    this.exiting = false;
    if (curNavModule) {
      const response = curNavModule.run(e);
      if (response === curNavModule.response.success) {
        preventDefault = true;
      } else if (response === curNavModule.response.prev) {
        preventDefault = this.move(-1);
      } else if (response === curNavModule.response.next) {
        preventDefault = this.move(1);
      }
      if (preventDefault) {
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }
  /**
   * Chart container should have tabindex if navigation is enabled.
   * @private
   */
  updateContainerTabindex() {
    const a11yOptions = this.chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, shouldHaveTabindex = !(keyboardOptions && keyboardOptions.enabled === false), chart = this.chart, container = chart.container;
    let tabindexContainer;
    if (chart.renderTo.hasAttribute("tabindex")) {
      container.removeAttribute("tabindex");
      tabindexContainer = chart.renderTo;
    } else {
      tabindexContainer = container;
    }
    this.tabindexContainer = tabindexContainer;
    const curTabindex = tabindexContainer.getAttribute("tabindex");
    if (shouldHaveTabindex && !curTabindex) {
      tabindexContainer.setAttribute("tabindex", "0");
    } else if (!shouldHaveTabindex) {
      chart.container.removeAttribute("tabindex");
    }
  }
  /**
   * Add new exit anchor to the chart.
   * @private
   */
  createExitAnchor() {
    const chart = this.chart, exitAnchor = this.exitAnchor = doc13.createElement("div");
    chart.renderTo.appendChild(exitAnchor);
    this.makeElementAnExitAnchor(exitAnchor);
  }
  /**
   * Add attributes and events to an element to make it function as an
   * exit anchor.
   * @private
   */
  makeElementAnExitAnchor(el) {
    const chartTabindex = this.tabindexContainer.getAttribute("tabindex") || 0;
    el.setAttribute("class", "highcharts-exit-anchor");
    el.setAttribute("tabindex", chartTabindex);
    el.setAttribute("aria-hidden", false);
    this.addExitAnchorEventsToEl(el);
  }
  /**
   * Destroy the exit anchor and remove from DOM.
   * @private
   */
  removeExitAnchor() {
    if (this.exitAnchor) {
      const el = this.eventProvider.eventRemovers.find((el2) => el2.element === this.exitAnchor);
      if (el && defined40(el.remover)) {
        this.eventProvider.removeEvent(el.remover);
      }
      if (this.exitAnchor.parentNode) {
        this.exitAnchor.parentNode.removeChild(this.exitAnchor);
      }
      delete this.exitAnchor;
    }
  }
  /**
   * Add focus handler to exit anchor element.
   * @private
   */
  addExitAnchorEventsToEl(element) {
    const chart = this.chart, keyboardNavigation = this;
    this.eventProvider.addEvent(element, "focus", function(ev) {
      const e = ev || win12.event, focusComesFromChart = e.relatedTarget && chart.container.contains(e.relatedTarget), comingInBackwards = !(focusComesFromChart || keyboardNavigation.exiting);
      if (chart.focusElement) {
        delete chart.focusElement;
      }
      if (comingInBackwards) {
        keyboardNavigation.tabbingInBackwards = true;
        keyboardNavigation.tabindexContainer.focus();
        delete keyboardNavigation.tabbingInBackwards;
        e.preventDefault();
        if (keyboardNavigation.modules && keyboardNavigation.modules.length) {
          keyboardNavigation.currentModuleIx = keyboardNavigation.modules.length - 1;
          const curModule = keyboardNavigation.modules[keyboardNavigation.currentModuleIx];
          if (curModule && curModule.validate && !curModule.validate()) {
            keyboardNavigation.move(-1);
          } else if (curModule) {
            curModule.init(-1);
          }
        }
      } else {
        keyboardNavigation.exiting = false;
      }
    });
  }
  /**
   * Get the ix of the first module that either does not require validation or
   * validates positively.
   * @private
   */
  getFirstValidModuleIx() {
    const len = this.modules.length;
    for (let i = 0; i < len; ++i) {
      const mod = this.modules[i];
      if (!mod.validate || mod.validate()) {
        return i;
      }
    }
    return null;
  }
  /**
   * Remove all traces of keyboard navigation.
   * @private
   */
  destroy() {
    this.removeExitAnchor();
    this.eventProvider.removeAddedEvents();
    this.chart.container.removeAttribute("tabindex");
  }
};
(function(KeyboardNavigation2) {
  function compose27(ChartClass) {
    MenuComponent_default.compose(ChartClass);
    const chartProto = ChartClass.prototype;
    if (!chartProto.dismissPopupContent) {
      chartProto.dismissPopupContent = chartDismissPopupContent;
      if (doc13) {
        addEvent39(doc13, "keydown", documentOnKeydown);
      }
    }
    return ChartClass;
  }
  KeyboardNavigation2.compose = compose27;
  function chartDismissPopupContent() {
    const chart = this;
    fireEvent27(this, "dismissPopupContent", {}, function() {
      if (chart.tooltip) {
        chart.tooltip.hide(0);
      }
      chart.hideExportMenu();
    });
  }
  function documentOnKeydown(e) {
    const keycode = e.which || e.keyCode;
    const esc = 27;
    if (keycode === esc && Globals_default.charts) {
      Globals_default.charts.forEach((chart) => {
        if (chart && chart.dismissPopupContent) {
          chart.dismissPopupContent();
        }
      });
    }
  }
})(KeyboardNavigation || (KeyboardNavigation = {}));
var KeyboardNavigation_default = KeyboardNavigation;

// node_modules/highcharts/es-modules/Accessibility/Components/LegendComponent.js
var { animObject: animObject10 } = AnimationUtilities_default;
var { doc: doc14 } = Globals_default;
var { addEvent: addEvent40, fireEvent: fireEvent28, isNumber: isNumber40, pick: pick52, syncTimeout: syncTimeout9 } = Utilities_default;
var { getChartTitle: getChartTitle5 } = ChartUtilities_default;
var { stripHTMLTagsFromString: stripHTMLTags3, addClass: addClass4, removeClass: removeClass2 } = HTMLUtilities_default;
function scrollLegendToItem(legend, itemIx) {
  const itemPage = (legend.allItems[itemIx].legendItem || {}).pageIx, curPage = legend.currentPage;
  if (typeof itemPage !== "undefined" && itemPage + 1 !== curPage) {
    legend.scroll(1 + itemPage - curPage);
  }
}
function shouldDoLegendA11y(chart) {
  const items = chart.legend && chart.legend.allItems, legendA11yOptions = chart.options.legend.accessibility || {}, unsupportedColorAxis = chart.colorAxis && chart.colorAxis.some((c) => !c.dataClasses || !c.dataClasses.length);
  return !!(items && items.length && !unsupportedColorAxis && legendA11yOptions.enabled !== false);
}
function setLegendItemHoverState(hoverActive, item) {
  const legendItem = item.legendItem || {};
  item.setState(hoverActive ? "hover" : "", true);
  for (const key of ["group", "label", "symbol"]) {
    const svgElement = legendItem[key];
    const element = svgElement && svgElement.element || svgElement;
    if (element) {
      fireEvent28(element, hoverActive ? "mouseover" : "mouseout");
    }
  }
}
var LegendComponent = class extends AccessibilityComponent_default {
  constructor() {
    super(...arguments);
    this.highlightedLegendItemIx = NaN;
    this.proxyGroup = null;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Init the component
   * @private
   */
  init() {
    const component = this;
    this.recreateProxies();
    this.addEvent(Legend_default, "afterScroll", function() {
      if (this.chart === component.chart) {
        component.proxyProvider.updateGroupProxyElementPositions("legend");
        component.updateLegendItemProxyVisibility();
        if (component.highlightedLegendItemIx > -1) {
          this.chart.highlightLegendItem(component.highlightedLegendItemIx);
        }
      }
    });
    this.addEvent(Legend_default, "afterPositionItem", function(e) {
      if (this.chart === component.chart && this.chart.renderer) {
        component.updateProxyPositionForItem(e.item);
      }
    });
    this.addEvent(Legend_default, "afterRender", function() {
      if (this.chart === component.chart && this.chart.renderer && component.recreateProxies()) {
        syncTimeout9(() => component.proxyProvider.updateGroupProxyElementPositions("legend"), animObject10(pick52(this.chart.renderer.globalAnimation, true)).duration);
      }
    });
  }
  /**
   * Update visibility of legend items when using paged legend
   * @private
   */
  updateLegendItemProxyVisibility() {
    const chart = this.chart;
    const legend = chart.legend;
    const items = legend.allItems || [];
    const curPage = legend.currentPage || 1;
    const clipHeight = legend.clipHeight || 0;
    let legendItem;
    items.forEach((item) => {
      if (item.a11yProxyElement) {
        const hasPages = legend.pages && legend.pages.length;
        const proxyEl = item.a11yProxyElement.element;
        let hide = false;
        legendItem = item.legendItem || {};
        if (hasPages) {
          const itemPage = legendItem.pageIx || 0;
          const y = legendItem.y || 0;
          const h = legendItem.label ? Math.round(legendItem.label.getBBox().height) : 0;
          hide = y + h - legend.pages[itemPage] > clipHeight || itemPage !== curPage - 1;
        }
        if (hide) {
          if (chart.styledMode) {
            addClass4(proxyEl, "highcharts-a11y-invisible");
          } else {
            proxyEl.style.visibility = "hidden";
          }
        } else {
          removeClass2(proxyEl, "highcharts-a11y-invisible");
          proxyEl.style.visibility = "";
        }
      }
    });
  }
  /**
   * @private
   */
  onChartRender() {
    if (!shouldDoLegendA11y(this.chart)) {
      this.removeProxies();
    }
  }
  /**
   * @private
   */
  highlightAdjacentLegendPage(direction) {
    const chart = this.chart;
    const legend = chart.legend;
    const curPageIx = legend.currentPage || 1;
    const newPageIx = curPageIx + direction;
    const pages = legend.pages || [];
    if (newPageIx > 0 && newPageIx <= pages.length) {
      let i = 0, res;
      for (const item of legend.allItems) {
        if (((item.legendItem || {}).pageIx || 0) + 1 === newPageIx) {
          res = chart.highlightLegendItem(i);
          if (res) {
            this.highlightedLegendItemIx = i;
          }
        }
        ++i;
      }
    }
  }
  /**
   * @private
   */
  updateProxyPositionForItem(item) {
    if (item.a11yProxyElement) {
      item.a11yProxyElement.refreshPosition();
    }
  }
  /**
   * Returns false if legend a11y is disabled and proxies were not created,
   * true otherwise.
   * @private
   */
  recreateProxies() {
    const focusedElement = doc14.activeElement;
    const proxyGroup = this.proxyGroup;
    const shouldRestoreFocus = focusedElement && proxyGroup && proxyGroup.contains(focusedElement);
    this.removeProxies();
    if (shouldDoLegendA11y(this.chart)) {
      this.addLegendProxyGroup();
      this.proxyLegendItems();
      this.updateLegendItemProxyVisibility();
      this.updateLegendTitle();
      if (shouldRestoreFocus) {
        this.chart.highlightLegendItem(this.highlightedLegendItemIx);
      }
      return true;
    }
    return false;
  }
  /**
   * @private
   */
  removeProxies() {
    this.proxyProvider.removeGroup("legend");
  }
  /**
   * @private
   */
  updateLegendTitle() {
    const chart = this.chart;
    const legendTitle = stripHTMLTags3((chart.legend && chart.legend.options.title && chart.legend.options.title.text || "").replace(/<br ?\/?>/g, " "), chart.renderer.forExport);
    const legendLabel = chart.langFormat("accessibility.legend.legendLabel" + (legendTitle ? "" : "NoTitle"), {
      chart,
      legendTitle,
      chartTitle: getChartTitle5(chart)
    });
    this.proxyProvider.updateGroupAttrs("legend", {
      "aria-label": legendLabel
    });
  }
  /**
   * @private
   */
  addLegendProxyGroup() {
    const a11yOptions = this.chart.options.accessibility;
    const groupRole = a11yOptions.landmarkVerbosity === "all" ? "region" : null;
    this.proxyGroup = this.proxyProvider.addGroup("legend", "ul", {
      // Filled by updateLegendTitle, to keep up to date without
      // recreating group
      "aria-label": "_placeholder_",
      role: groupRole
    });
  }
  /**
   * @private
   */
  proxyLegendItems() {
    const component = this, items = (this.chart.legend || {}).allItems || [];
    let legendItem;
    items.forEach((item) => {
      legendItem = item.legendItem || {};
      if (legendItem.label && legendItem.label.element) {
        component.proxyLegendItem(item);
      }
    });
  }
  /**
   * @private
   * @param {Highcharts.BubbleLegendItem|Point|Highcharts.Series} item
   */
  proxyLegendItem(item) {
    const legendItem = item.legendItem || {};
    if (!legendItem.label || !legendItem.group) {
      return;
    }
    const itemLabel = this.chart.langFormat("accessibility.legend.legendItem", {
      chart: this.chart,
      itemName: stripHTMLTags3(item.name, this.chart.renderer.forExport),
      item
    });
    const attribs = {
      tabindex: -1,
      "aria-pressed": item.visible,
      "aria-label": itemLabel
    };
    const proxyPositioningElement = legendItem.group.div ? legendItem.label : legendItem.group;
    item.a11yProxyElement = this.proxyProvider.addProxyElement("legend", {
      click: legendItem.label,
      visual: proxyPositioningElement.element
    }, "button", attribs);
  }
  /**
   * Get keyboard navigation handler for this component.
   * @private
   */
  getKeyboardNavigation() {
    const keys = this.keyCodes, component = this, chart = this.chart;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [
        [
          [keys.left, keys.right, keys.up, keys.down],
          function(keyCode) {
            return component.onKbdArrowKey(this, keyCode);
          }
        ],
        [
          [keys.enter, keys.space],
          function() {
            return component.onKbdClick(this);
          }
        ],
        [
          [keys.pageDown, keys.pageUp],
          function(keyCode) {
            const direction = keyCode === keys.pageDown ? 1 : -1;
            component.highlightAdjacentLegendPage(direction);
            return this.response.success;
          }
        ]
      ],
      validate: function() {
        return component.shouldHaveLegendNavigation();
      },
      init: function() {
        chart.highlightLegendItem(0);
        component.highlightedLegendItemIx = 0;
      },
      terminate: function() {
        component.highlightedLegendItemIx = -1;
        chart.legend.allItems.forEach((item) => setLegendItemHoverState(false, item));
      }
    });
  }
  /**
   * Arrow key navigation
   * @private
   */
  onKbdArrowKey(keyboardNavigationHandler, key) {
    const { keyCodes: { left, up }, highlightedLegendItemIx, chart } = this, numItems = chart.legend.allItems.length, wrapAround = chart.options.accessibility.keyboardNavigation.wrapAround, direction = key === left || key === up ? -1 : 1, res = chart.highlightLegendItem(highlightedLegendItemIx + direction);
    if (res) {
      this.highlightedLegendItemIx += direction;
    } else if (wrapAround && numItems > 1) {
      this.highlightedLegendItemIx = direction > 0 ? 0 : numItems - 1;
      chart.highlightLegendItem(this.highlightedLegendItemIx);
    }
    return keyboardNavigationHandler.response.success;
  }
  /**
   * @private
   * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
   * @return {number} Response code
   */
  onKbdClick(keyboardNavigationHandler) {
    const legendItem = this.chart.legend.allItems[this.highlightedLegendItemIx];
    if (legendItem && legendItem.a11yProxyElement) {
      legendItem.a11yProxyElement.click();
    }
    return keyboardNavigationHandler.response.success;
  }
  /**
   * @private
   */
  shouldHaveLegendNavigation() {
    if (!shouldDoLegendA11y(this.chart)) {
      return false;
    }
    const chart = this.chart, legendOptions = chart.options.legend || {}, legendA11yOptions = legendOptions.accessibility || {};
    return !!(chart.legend.display && legendA11yOptions.keyboardNavigation && legendA11yOptions.keyboardNavigation.enabled);
  }
  /**
   * Clean up
   * @private
   */
  destroy() {
    this.removeProxies();
  }
};
(function(LegendComponent2) {
  function chartHighlightLegendItem(ix) {
    const items = this.legend.allItems;
    const oldIx = this.accessibility && this.accessibility.components.legend.highlightedLegendItemIx;
    const itemToHighlight = items[ix], legendItem = itemToHighlight?.legendItem || {};
    if (itemToHighlight) {
      if (isNumber40(oldIx) && items[oldIx]) {
        setLegendItemHoverState(false, items[oldIx]);
      }
      scrollLegendToItem(this.legend, ix);
      const legendItemProp = legendItem.label;
      const proxyBtn = itemToHighlight.a11yProxyElement && itemToHighlight.a11yProxyElement.innerElement;
      if (legendItemProp && legendItemProp.element && proxyBtn) {
        this.setFocusToElement(legendItemProp, proxyBtn);
      }
      setLegendItemHoverState(true, itemToHighlight);
      return true;
    }
    return false;
  }
  function compose27(ChartClass, LegendClass) {
    const chartProto = ChartClass.prototype;
    if (!chartProto.highlightLegendItem) {
      chartProto.highlightLegendItem = chartHighlightLegendItem;
      addEvent40(LegendClass, "afterColorizeItem", legendOnAfterColorizeItem);
    }
  }
  LegendComponent2.compose = compose27;
  function legendOnAfterColorizeItem(e) {
    const chart = this.chart, a11yOptions = chart.options.accessibility, legendItem = e.item;
    if (a11yOptions.enabled && legendItem && legendItem.a11yProxyElement) {
      legendItem.a11yProxyElement.innerElement.setAttribute("aria-pressed", e.visible ? "true" : "false");
    }
  }
})(LegendComponent || (LegendComponent = {}));
var LegendComponent_default = LegendComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/NavigatorComponent.js
var { animObject: animObject11 } = AnimationUtilities_default;
var { format: format13 } = Templating_default;
var { clamp: clamp12, pick: pick53, syncTimeout: syncTimeout10 } = Utilities_default;
var { getFakeMouseEvent: getFakeMouseEvent4 } = HTMLUtilities_default;
var { getAxisRangeDescription: getAxisRangeDescription3, fireEventOnWrappedOrUnwrappedElement: fireEventOnWrappedOrUnwrappedElement3 } = ChartUtilities_default;
var NavigatorComponent = class extends AccessibilityComponent_default {
  /**
   * Init the component
   * @private
   */
  init() {
    const chart = this.chart, component = this;
    this.announcer = new Announcer_default(chart, "polite");
    this.addEvent(Navigator_default, "afterRender", function() {
      if (this.chart === component.chart && this.chart.renderer) {
        syncTimeout10(() => {
          component.proxyProvider.updateGroupProxyElementPositions("navigator");
          component.updateHandleValues();
        }, animObject11(pick53(this.chart.renderer.globalAnimation, true)).duration);
      }
    });
  }
  /**
   * Called on updates
   * @private
   */
  onChartUpdate() {
    const chart = this.chart, options2 = chart.options, navigator = options2.navigator;
    if (navigator.enabled && navigator.accessibility?.enabled) {
      const verbosity = options2.accessibility.landmarkVerbosity, groupFormatStr = options2.lang.accessibility?.navigator.groupLabel;
      this.proxyProvider.removeGroup("navigator");
      this.proxyProvider.addGroup("navigator", "div", {
        role: verbosity === "all" ? "region" : "group",
        "aria-label": format13(groupFormatStr, { chart }, chart)
      });
      const handleFormatStr = options2.lang.accessibility?.navigator.handleLabel;
      [0, 1].forEach((n) => {
        const handle = this.getHandleByIx(n);
        if (handle) {
          const proxyEl = this.proxyProvider.addProxyElement("navigator", {
            click: handle
          }, "input", {
            type: "range",
            "aria-label": format13(handleFormatStr, { handleIx: n, chart }, chart)
          });
          this[n ? "maxHandleProxy" : "minHandleProxy"] = proxyEl.innerElement;
          proxyEl.innerElement.style.pointerEvents = "none";
          proxyEl.innerElement.oninput = () => this.updateNavigator();
        }
      });
      this.updateHandleValues();
    } else {
      this.proxyProvider.removeGroup("navigator");
    }
  }
  /**
   * Get navigation for a navigator handle.
   * @private
   * @return {Highcharts.KeyboardNavigationHandler} The module object.
   */
  getNavigatorHandleNavigation(handleIx) {
    const component = this, chart = this.chart, proxyEl = handleIx ? this.maxHandleProxy : this.minHandleProxy, keys = this.keyCodes;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [[
        [keys.left, keys.right, keys.up, keys.down],
        function(keyCode) {
          if (proxyEl) {
            const delta = keyCode === keys.left || keyCode === keys.up ? -1 : 1;
            proxyEl.value = "" + clamp12(parseFloat(proxyEl.value) + delta, 0, 100);
            component.updateNavigator(() => {
              const handle = component.getHandleByIx(handleIx);
              if (handle) {
                chart.setFocusToElement(handle, proxyEl);
              }
            });
          }
          return this.response.success;
        }
      ]],
      init: () => {
        chart.setFocusToElement(this.getHandleByIx(handleIx), proxyEl);
      },
      validate: () => !!(this.getHandleByIx(handleIx) && proxyEl && chart.options.navigator.accessibility?.enabled)
    });
  }
  /**
   * Get keyboard navigation handlers for this component.
   * @return {Array<Highcharts.KeyboardNavigationHandler>}
   *         List of module objects.
   */
  getKeyboardNavigation() {
    return [
      this.getNavigatorHandleNavigation(0),
      this.getNavigatorHandleNavigation(1)
    ];
  }
  /**
   * Remove component traces
   */
  destroy() {
    if (this.updateNavigatorThrottleTimer) {
      clearTimeout(this.updateNavigatorThrottleTimer);
    }
    this.proxyProvider.removeGroup("navigator");
    if (this.announcer) {
      this.announcer.destroy();
    }
  }
  /**
   * Update the value of the handles to match current navigator pos.
   * @private
   */
  updateHandleValues() {
    const navigator = this.chart.navigator;
    if (navigator && this.minHandleProxy && this.maxHandleProxy) {
      const length = navigator.size;
      this.minHandleProxy.value = "" + Math.round(navigator.zoomedMin / length * 100);
      this.maxHandleProxy.value = "" + Math.round(navigator.zoomedMax / length * 100);
    }
  }
  /**
   * Get a navigator handle by its index
   * @private
   */
  getHandleByIx(ix) {
    const navigator = this.chart.navigator;
    return navigator && navigator.handles && navigator.handles[ix];
  }
  /**
   * Update navigator to match changed proxy values.
   * @private
   */
  updateNavigator(beforeAnnounce) {
    const performUpdate = (beforeAnnounce2) => {
      const chart = this.chart, { navigator, pointer } = chart;
      if (navigator && pointer && this.minHandleProxy && this.maxHandleProxy) {
        const chartPos = pointer.getChartPosition(), minNewX = parseFloat(this.minHandleProxy.value) / 100 * navigator.size, maxNewX = parseFloat(this.maxHandleProxy.value) / 100 * navigator.size;
        [
          [0, "mousedown", navigator.zoomedMin],
          [0, "mousemove", minNewX],
          [0, "mouseup", minNewX],
          [1, "mousedown", navigator.zoomedMax],
          [1, "mousemove", maxNewX],
          [1, "mouseup", maxNewX]
        ].forEach(([handleIx, type, x]) => {
          const handle = this.getHandleByIx(handleIx)?.element;
          if (handle) {
            fireEventOnWrappedOrUnwrappedElement3(handle, getFakeMouseEvent4(type, {
              x: chartPos.left + navigator.left + x,
              y: chartPos.top + navigator.top
            }, handle));
          }
        });
        if (beforeAnnounce2) {
          beforeAnnounce2();
        }
        const announceFormatStr = chart.options.lang.accessibility?.navigator.changeAnnouncement, axisRangeDescription = getAxisRangeDescription3(chart.xAxis[0]);
        this.announcer.announce(format13(announceFormatStr, { axisRangeDescription, chart }, chart));
      }
    };
    if (this.updateNavigatorThrottleTimer) {
      clearTimeout(this.updateNavigatorThrottleTimer);
    }
    this.updateNavigatorThrottleTimer = setTimeout(performUpdate.bind(this, beforeAnnounce), 20);
  }
};
var NavigatorComponent_default = NavigatorComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/SeriesDescriber.js
var { getPointAnnotationTexts: getPointAnnotationTexts2 } = AnnotationsA11y_default;
var { getAxisDescription: getAxisDescription3, getSeriesFirstPointElement: getSeriesFirstPointElement2, getSeriesA11yElement: getSeriesA11yElement2, unhideChartElementFromAT: unhideChartElementFromAT5 } = ChartUtilities_default;
var { format: format14, numberFormat: numberFormat3 } = Templating_default;
var { reverseChildNodes: reverseChildNodes2, stripHTMLTagsFromString: stripHTMLTags4 } = HTMLUtilities_default;
var { find: find12, isNumber: isNumber41, isString: isString18, pick: pick54, defined: defined41 } = Utilities_default;
function findFirstPointWithGraphic(point) {
  const sourcePointIndex = point.index;
  if (!point.series || !point.series.data || !defined41(sourcePointIndex)) {
    return null;
  }
  const nullInteraction = point.series.options?.nullInteraction;
  return find12(point.series.data, function(p) {
    return !!(p && typeof p.index !== "undefined" && (nullInteraction || p.index > sourcePointIndex) && p.graphic && p.graphic.element);
  }) || null;
}
function shouldAddMockPoint(point) {
  const series = point.series, chart = series && series.chart, isSunburst = series && series.is("sunburst"), isNull = point.isNull, shouldDescribeNull = chart && chart.options.accessibility.point.describeNull;
  return isNull && !isSunburst && shouldDescribeNull;
}
function makeMockElement(point, pos) {
  const renderer = point.series.chart.renderer, mock = renderer.rect(pos.x, pos.y, 1, 1);
  mock.attr({
    "class": "highcharts-a11y-mock-point",
    fill: "none",
    opacity: 0,
    "fill-opacity": 0,
    "stroke-opacity": 0
  });
  return mock;
}
function addMockPointElement(point) {
  const series = point.series, firstPointWithGraphic = findFirstPointWithGraphic(point), firstGraphic = firstPointWithGraphic && firstPointWithGraphic.graphic, parentGroup = firstGraphic ? firstGraphic.parentGroup : series.graph || series.group, mockPos = firstPointWithGraphic ? {
    x: pick54(point.plotX, firstPointWithGraphic.plotX, 0),
    y: pick54(point.plotY, firstPointWithGraphic.plotY, 0)
  } : {
    x: pick54(point.plotX, 0),
    y: pick54(point.plotY, 0)
  }, mockElement = makeMockElement(point, mockPos);
  if (parentGroup && parentGroup.element) {
    point.graphic = mockElement;
    point.hasMockGraphic = true;
    mockElement.add(parentGroup);
    parentGroup.element.insertBefore(mockElement.element, firstGraphic ? firstGraphic.element : null);
    return mockElement.element;
  }
}
function hasMorePointsThanDescriptionThreshold(series) {
  const chartA11yOptions = series.chart.options.accessibility, threshold = chartA11yOptions.series.pointDescriptionEnabledThreshold;
  return !!(threshold !== false && series.points && series.points.length >= +threshold);
}
function shouldSetScreenReaderPropsOnPoints(series) {
  const seriesA11yOptions = series.options.accessibility || {};
  return !hasMorePointsThanDescriptionThreshold(series) && !seriesA11yOptions.exposeAsGroupOnly;
}
function shouldSetKeyboardNavPropsOnPoints(series) {
  const chartA11yOptions = series.chart.options.accessibility, seriesNavOptions = chartA11yOptions.keyboardNavigation.seriesNavigation;
  return !!(series.points && (series.points.length < +seriesNavOptions.pointNavigationEnabledThreshold || seriesNavOptions.pointNavigationEnabledThreshold === false));
}
function shouldDescribeSeriesElement(series) {
  const chart = series.chart, chartOptions = chart.options.chart, chartHas3d = chartOptions.options3d && chartOptions.options3d.enabled, hasMultipleSeries = chart.series.length > 1, describeSingleSeriesOption = chart.options.accessibility.series.describeSingleSeries, exposeAsGroupOnlyOption = (series.options.accessibility || {}).exposeAsGroupOnly, noDescribe3D = chartHas3d && hasMultipleSeries;
  return !noDescribe3D && (hasMultipleSeries || describeSingleSeriesOption || exposeAsGroupOnlyOption || hasMorePointsThanDescriptionThreshold(series));
}
function pointNumberToString(point, value) {
  const series = point.series, chart = series.chart, a11yPointOptions = chart.options.accessibility.point || {}, seriesA11yPointOptions = series.options.accessibility && series.options.accessibility.point || {}, tooltipOptions = series.tooltipOptions || {}, lang6 = chart.options.lang;
  if (isNumber41(value)) {
    return numberFormat3(value, seriesA11yPointOptions.valueDecimals || a11yPointOptions.valueDecimals || tooltipOptions.valueDecimals || -1, lang6.decimalPoint, lang6.accessibility.thousandsSep || lang6.thousandsSep);
  }
  return value;
}
function getSeriesDescriptionText(series) {
  const seriesA11yOptions = series.options.accessibility || {}, descOpt = seriesA11yOptions.description;
  return descOpt && series.chart.langFormat("accessibility.series.description", {
    description: descOpt,
    series
  }) || "";
}
function getSeriesAxisDescriptionText(series, axisCollection) {
  const axis = series[axisCollection];
  return series.chart.langFormat("accessibility.series." + axisCollection + "Description", {
    name: getAxisDescription3(axis),
    series
  });
}
function getPointA11yTimeDescription(point) {
  const series = point.series, chart = series.chart, seriesA11yOptions = series.options.accessibility && series.options.accessibility.point || {}, a11yOptions = chart.options.accessibility.point || {}, dateXAxis = series.xAxis && series.xAxis.dateTime;
  if (dateXAxis) {
    const tooltipDateFormat = dateXAxis.getXDateFormat(point.x || 0, chart.options.tooltip.dateTimeLabelFormats), dateFormat2 = seriesA11yOptions.dateFormatter && seriesA11yOptions.dateFormatter(point) || a11yOptions.dateFormatter && a11yOptions.dateFormatter(point) || seriesA11yOptions.dateFormat || a11yOptions.dateFormat || tooltipDateFormat;
    return chart.time.dateFormat(dateFormat2, point.x || 0, void 0);
  }
}
function getPointXDescription(point) {
  const timeDesc = getPointA11yTimeDescription(point), xAxis2 = point.series.xAxis || {}, pointCategory = xAxis2.categories && defined41(point.category) && ("" + point.category).replace("<br/>", " "), canUseId = defined41(point.id) && ("" + point.id).indexOf("highcharts-") < 0, fallback = "x, " + point.x;
  return point.name || timeDesc || pointCategory || (canUseId ? point.id : fallback);
}
function getPointArrayMapValueDescription(point, prefix, suffix) {
  const pre = prefix || "", suf = suffix || "", keyToValStr = function(key) {
    const num = pointNumberToString(point, pick54(point[key], point.options[key]));
    return num !== void 0 ? key + ": " + pre + num + suf : num;
  }, pointArrayMap = point.series.pointArrayMap;
  return pointArrayMap.reduce(function(desc, key) {
    const propDesc = keyToValStr(key);
    return propDesc ? desc + (desc.length ? ", " : "") + propDesc : desc;
  }, "");
}
function getPointValue(point) {
  const series = point.series, a11yPointOpts = series.chart.options.accessibility.point || {}, seriesA11yPointOpts = series.chart.options.accessibility && series.chart.options.accessibility.point || {}, tooltipOptions = series.tooltipOptions || {}, valuePrefix = seriesA11yPointOpts.valuePrefix || a11yPointOpts.valuePrefix || tooltipOptions.valuePrefix || "", valueSuffix = seriesA11yPointOpts.valueSuffix || a11yPointOpts.valueSuffix || tooltipOptions.valueSuffix || "", fallbackKey = typeof point.value !== "undefined" ? "value" : "y", fallbackDesc = pointNumberToString(point, point[fallbackKey]);
  if (point.isNull) {
    return series.chart.langFormat("accessibility.series.nullPointValue", {
      point
    });
  }
  if (series.pointArrayMap) {
    return getPointArrayMapValueDescription(point, valuePrefix, valueSuffix);
  }
  return valuePrefix + fallbackDesc + valueSuffix;
}
function getPointAnnotationDescription(point) {
  const chart = point.series.chart;
  const langKey = "accessibility.series.pointAnnotationsDescription";
  const annotations = getPointAnnotationTexts2(point);
  const context = { point, annotations };
  return annotations.length ? chart.langFormat(langKey, context) : "";
}
function getPointValueDescription(point) {
  const series = point.series, chart = series.chart, seriesA11yOptions = series.options.accessibility, seriesValueDescFormat = seriesA11yOptions && seriesA11yOptions.point && seriesA11yOptions.point.valueDescriptionFormat, pointValueDescriptionFormat = seriesValueDescFormat || chart.options.accessibility.point.valueDescriptionFormat, showXDescription = pick54(series.xAxis && series.xAxis.options.accessibility && series.xAxis.options.accessibility.enabled, !chart.angular && series.type !== "flowmap"), xDesc = showXDescription ? getPointXDescription(point) : "", context = {
    point,
    index: defined41(point.index) ? point.index + 1 : "",
    xDescription: xDesc,
    value: getPointValue(point),
    separator: showXDescription ? ", " : ""
  };
  return format14(pointValueDescriptionFormat, context, chart);
}
function defaultPointDescriptionFormatter(point) {
  const series = point.series, shouldExposeSeriesName = series.chart.series.length > 1 || series.options.name, valText = getPointValueDescription(point), description = point.options && point.options.accessibility && point.options.accessibility.description, userDescText = description ? " " + description : "", seriesNameText = shouldExposeSeriesName ? " " + series.name + "." : "", annotationsDesc = getPointAnnotationDescription(point), pointAnnotationsText = annotationsDesc ? " " + annotationsDesc : "";
  point.accessibility = point.accessibility || {};
  point.accessibility.valueDescription = valText;
  return valText + userDescText + seriesNameText + pointAnnotationsText;
}
function setPointScreenReaderAttribs(point, pointElement) {
  const series = point.series, seriesPointA11yOptions = series.options.accessibility?.point || {}, a11yPointOptions = series.chart.options.accessibility.point || {}, label = stripHTMLTags4(isString18(seriesPointA11yOptions.descriptionFormat) && format14(seriesPointA11yOptions.descriptionFormat, point, series.chart) || seriesPointA11yOptions.descriptionFormatter?.(point) || isString18(a11yPointOptions.descriptionFormat) && format14(a11yPointOptions.descriptionFormat, point, series.chart) || a11yPointOptions.descriptionFormatter?.(point) || defaultPointDescriptionFormatter(point), series.chart.renderer.forExport);
  pointElement.setAttribute("role", "img");
  pointElement.setAttribute("aria-label", label);
}
function describePointsInSeries(series) {
  const setScreenReaderProps = shouldSetScreenReaderPropsOnPoints(series), setKeyboardProps = shouldSetKeyboardNavPropsOnPoints(series), shouldDescribeNullPoints = series.chart.options.accessibility.point.describeNull;
  if (setScreenReaderProps || setKeyboardProps) {
    series.points.forEach((point) => {
      const pointEl = point.graphic && point.graphic.element || shouldAddMockPoint(point) && addMockPointElement(point), pointA11yDisabled = point.options && point.options.accessibility && point.options.accessibility.enabled === false;
      if (pointEl) {
        if (point.isNull && !shouldDescribeNullPoints) {
          pointEl.setAttribute("aria-hidden", true);
          return;
        }
        pointEl.setAttribute("tabindex", "-1");
        if (!series.chart.styledMode) {
          pointEl.style.outline = "none";
        }
        if (setScreenReaderProps && !pointA11yDisabled) {
          setPointScreenReaderAttribs(point, pointEl);
        } else {
          pointEl.setAttribute("aria-hidden", true);
        }
      }
    });
  }
}
function defaultSeriesDescriptionFormatter(series) {
  const chart = series.chart, chartTypes = chart.types || [], description = getSeriesDescriptionText(series), shouldDescribeAxis = function(coll) {
    return chart[coll] && chart[coll].length > 1 && series[coll];
  }, seriesNumber = series.index + 1, xAxisInfo = getSeriesAxisDescriptionText(series, "xAxis"), yAxisInfo = getSeriesAxisDescriptionText(series, "yAxis"), summaryContext = {
    seriesNumber,
    series,
    chart
  }, combinationSuffix = chartTypes.length > 1 ? "Combination" : "", summary = chart.langFormat("accessibility.series.summary." + series.type + combinationSuffix, summaryContext) || chart.langFormat("accessibility.series.summary.default" + combinationSuffix, summaryContext), axisDescription = (shouldDescribeAxis("yAxis") ? " " + yAxisInfo + "." : "") + (shouldDescribeAxis("xAxis") ? " " + xAxisInfo + "." : ""), formatStr = pick54(series.options.accessibility && series.options.accessibility.descriptionFormat, chart.options.accessibility.series.descriptionFormat, "");
  return format14(formatStr, {
    seriesDescription: summary,
    authorDescription: description ? " " + description : "",
    axisDescription,
    series,
    chart,
    seriesNumber
  }, void 0);
}
function describeSeriesElement(series, seriesElement) {
  const seriesA11yOptions = series.options.accessibility || {}, a11yOptions = series.chart.options.accessibility, landmarkVerbosity = a11yOptions.landmarkVerbosity;
  if (seriesA11yOptions.exposeAsGroupOnly) {
    seriesElement.setAttribute("role", "img");
  } else if (landmarkVerbosity === "all") {
    seriesElement.setAttribute("role", "region");
  } else {
    seriesElement.setAttribute("role", "group");
  }
  seriesElement.setAttribute("tabindex", "-1");
  if (!series.chart.styledMode) {
    seriesElement.style.outline = "none";
  }
  seriesElement.setAttribute("aria-label", stripHTMLTags4(a11yOptions.series.descriptionFormatter && a11yOptions.series.descriptionFormatter(series) || defaultSeriesDescriptionFormatter(series), series.chart.renderer.forExport));
}
function describeSeries(series) {
  const chart = series.chart, firstPointEl = getSeriesFirstPointElement2(series), seriesEl = getSeriesA11yElement2(series), is3d = chart.is3d && chart.is3d();
  if (seriesEl) {
    if (seriesEl.lastChild === firstPointEl && !is3d) {
      reverseChildNodes2(seriesEl);
    }
    describePointsInSeries(series);
    unhideChartElementFromAT5(chart, seriesEl);
    if (shouldDescribeSeriesElement(series)) {
      describeSeriesElement(series, seriesEl);
    } else {
      seriesEl.removeAttribute("aria-label");
    }
  }
}
var SeriesDescriber = {
  defaultPointDescriptionFormatter,
  defaultSeriesDescriptionFormatter,
  describeSeries
};
var SeriesDescriber_default = SeriesDescriber;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/NewDataAnnouncer.js
var { composed: composed14 } = Globals_default;
var { addEvent: addEvent41, defined: defined42, pushUnique: pushUnique17 } = Utilities_default;
var { getChartTitle: getChartTitle6 } = ChartUtilities_default;
var { defaultPointDescriptionFormatter: defaultPointDescriptionFormatter2, defaultSeriesDescriptionFormatter: defaultSeriesDescriptionFormatter2 } = SeriesDescriber_default;
function chartHasAnnounceEnabled(chart) {
  return !!chart.options.accessibility.announceNewData.enabled;
}
function findPointInDataArray(point) {
  const candidates = point.series.data.filter((candidate) => point.x === candidate.x && point.y === candidate.y);
  return candidates.length === 1 ? candidates[0] : point;
}
function getUniqueSeries(arrayA, arrayB) {
  const uniqueSeries = (arrayA || []).concat(arrayB || []).reduce((acc, cur) => {
    acc[cur.name + cur.index] = cur;
    return acc;
  }, {});
  return Object.keys(uniqueSeries).map((ix) => uniqueSeries[ix]);
}
var NewDataAnnouncer = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart) {
    this.dirty = {
      allSeries: {}
    };
    this.lastAnnouncementTime = 0;
    this.chart = chart;
  }
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Initialize the new data announcer.
   * @private
   */
  init() {
    const chart = this.chart;
    const announceOptions = chart.options.accessibility.announceNewData;
    const announceType = announceOptions.interruptUser ? "assertive" : "polite";
    this.lastAnnouncementTime = 0;
    this.dirty = {
      allSeries: {}
    };
    this.eventProvider = new EventProvider_default();
    this.announcer = new Announcer_default(chart, announceType);
    this.addEventListeners();
  }
  /**
   * Remove traces of announcer.
   * @private
   */
  destroy() {
    this.eventProvider.removeAddedEvents();
    this.announcer.destroy();
  }
  /**
   * Add event listeners for the announcer
   * @private
   */
  addEventListeners() {
    const announcer = this, chart = this.chart, e = this.eventProvider;
    e.addEvent(chart, "afterApplyDrilldown", function() {
      announcer.lastAnnouncementTime = 0;
    });
    e.addEvent(chart, "afterAddSeries", function(e2) {
      announcer.onSeriesAdded(e2.series);
    });
    e.addEvent(chart, "redraw", function() {
      announcer.announceDirtyData();
    });
  }
  /**
   * On new data series added, update dirty list.
   * @private
   * @param {Highcharts.Series} series
   */
  onSeriesAdded(series) {
    if (chartHasAnnounceEnabled(this.chart)) {
      this.dirty.hasDirty = true;
      this.dirty.allSeries[series.name + series.index] = series;
      this.dirty.newSeries = defined42(this.dirty.newSeries) ? void 0 : series;
    }
  }
  /**
   * Gather what we know and announce the data to user.
   * @private
   */
  announceDirtyData() {
    const chart = this.chart, announcer = this;
    if (chart.options.accessibility.announceNewData && this.dirty.hasDirty) {
      let newPoint = this.dirty.newPoint;
      if (newPoint) {
        newPoint = findPointInDataArray(newPoint);
      }
      this.queueAnnouncement(Object.keys(this.dirty.allSeries).map((ix) => announcer.dirty.allSeries[ix]), this.dirty.newSeries, newPoint);
      this.dirty = {
        allSeries: {}
      };
    }
  }
  /**
   * Announce to user that there is new data.
   * @private
   * @param {Array<Highcharts.Series>} dirtySeries
   *          Array of series with new data.
   * @param {Highcharts.Series} [newSeries]
   *          If a single new series was added, a reference to this series.
   * @param {Highcharts.Point} [newPoint]
   *          If a single point was added, a reference to this point.
   */
  queueAnnouncement(dirtySeries, newSeries, newPoint) {
    const chart = this.chart;
    const annOptions = chart.options.accessibility.announceNewData;
    if (annOptions.enabled) {
      const now = +/* @__PURE__ */ new Date();
      const dTime = now - this.lastAnnouncementTime;
      const time = Math.max(0, annOptions.minAnnounceInterval - dTime);
      const allSeries = getUniqueSeries(this.queuedAnnouncement && this.queuedAnnouncement.series, dirtySeries);
      const message = this.buildAnnouncementMessage(allSeries, newSeries, newPoint);
      if (message) {
        if (this.queuedAnnouncement) {
          clearTimeout(this.queuedAnnouncementTimer);
        }
        this.queuedAnnouncement = {
          time: now,
          message,
          series: allSeries
        };
        this.queuedAnnouncementTimer = setTimeout(() => {
          if (this && this.announcer) {
            this.lastAnnouncementTime = +/* @__PURE__ */ new Date();
            this.announcer.announce(this.queuedAnnouncement.message);
            delete this.queuedAnnouncement;
            delete this.queuedAnnouncementTimer;
          }
        }, time);
      }
    }
  }
  /**
   * Get announcement message for new data.
   * @private
   * @param {Array<Highcharts.Series>} dirtySeries
   *          Array of series with new data.
   * @param {Highcharts.Series} [newSeries]
   *          If a single new series was added, a reference to this series.
   * @param {Highcharts.Point} [newPoint]
   *          If a single point was added, a reference to this point.
   *
   * @return {string|null}
   * The announcement message to give to user.
   */
  buildAnnouncementMessage(dirtySeries, newSeries, newPoint) {
    const chart = this.chart, annOptions = chart.options.accessibility.announceNewData;
    if (annOptions.announcementFormatter) {
      const formatterRes = annOptions.announcementFormatter(dirtySeries, newSeries, newPoint);
      if (formatterRes !== false) {
        return formatterRes.length ? formatterRes : null;
      }
    }
    const multiple = Globals_default.charts && Globals_default.charts.length > 1 ? "Multiple" : "Single", langKey = newSeries ? "newSeriesAnnounce" + multiple : newPoint ? "newPointAnnounce" + multiple : "newDataAnnounce", chartTitle = getChartTitle6(chart);
    return chart.langFormat("accessibility.announceNewData." + langKey, {
      chartTitle,
      seriesDesc: newSeries ? defaultSeriesDescriptionFormatter2(newSeries) : null,
      pointDesc: newPoint ? defaultPointDescriptionFormatter2(newPoint) : null,
      point: newPoint,
      series: newSeries
    });
  }
};
(function(NewDataAnnouncer2) {
  function compose27(SeriesClass) {
    if (pushUnique17(composed14, "A11y.NDA")) {
      addEvent41(SeriesClass, "addPoint", seriesOnAddPoint);
      addEvent41(SeriesClass, "updatedData", seriesOnUpdatedData);
    }
  }
  NewDataAnnouncer2.compose = compose27;
  function seriesOnAddPoint(e) {
    const chart = this.chart, newDataAnnouncer = chart.accessibility?.components.series.newDataAnnouncer;
    if (newDataAnnouncer && newDataAnnouncer.chart === chart && chartHasAnnounceEnabled(chart)) {
      newDataAnnouncer.dirty.newPoint = defined42(newDataAnnouncer.dirty.newPoint) ? void 0 : e.point;
    }
  }
  function seriesOnUpdatedData() {
    const chart = this.chart, newDataAnnouncer = chart.accessibility?.components.series.newDataAnnouncer;
    if (newDataAnnouncer && newDataAnnouncer.chart === chart && chartHasAnnounceEnabled(chart)) {
      newDataAnnouncer.dirty.hasDirty = true;
      newDataAnnouncer.dirty.allSeries[this.name + this.index] = this;
    }
  }
})(NewDataAnnouncer || (NewDataAnnouncer = {}));
var NewDataAnnouncer_default = NewDataAnnouncer;

// node_modules/highcharts/es-modules/Accessibility/ProxyElement.js
var { doc: doc15, win: win13 } = Globals_default;
var { attr: attr13, css: css15, merge: merge45 } = Utilities_default;
var { fireEventOnWrappedOrUnwrappedElement: fireEventOnWrappedOrUnwrappedElement4 } = ChartUtilities_default;
var { cloneMouseEvent: cloneMouseEvent2, cloneTouchEvent: cloneTouchEvent2, getFakeMouseEvent: getFakeMouseEvent5, removeElement: removeElement3 } = HTMLUtilities_default;
var ProxyElement = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart, target, proxyElementType = "button", wrapperElementType, attributes) {
    this.chart = chart;
    this.target = target;
    this.eventProvider = new EventProvider_default();
    const innerEl = this.innerElement = doc15.createElement(proxyElementType), wrapperEl = this.element = wrapperElementType ? doc15.createElement(wrapperElementType) : innerEl;
    if (!chart.styledMode) {
      this.hideElementVisually(innerEl);
    }
    if (wrapperElementType) {
      if (wrapperElementType === "li" && !chart.styledMode) {
        wrapperEl.style.listStyle = "none";
      }
      wrapperEl.appendChild(innerEl);
      this.element = wrapperEl;
    }
    this.updateTarget(target, attributes);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Fake a click event on the target.
   */
  click() {
    const pos = this.getTargetPosition();
    pos.x += pos.width / 2;
    pos.y += pos.height / 2;
    const fakeEventObject = getFakeMouseEvent5("click", pos);
    fireEventOnWrappedOrUnwrappedElement4(this.target.click, fakeEventObject);
  }
  /**
   * Update the target to be proxied. The position and events are updated to
   * match the new target.
   * @param target The new target definition
   * @param attributes New HTML attributes to apply to the proxy. Set an
   * attribute to null to remove.
   */
  updateTarget(target, attributes) {
    this.target = target;
    this.updateCSSClassName();
    const attrs = attributes || {};
    Object.keys(attrs).forEach((a) => {
      if (attrs[a] === null) {
        delete attrs[a];
      }
    });
    const targetAriaLabel = this.getTargetAttr(target.click, "aria-label");
    attr13(this.innerElement, merge45(targetAriaLabel ? {
      "aria-label": targetAriaLabel
    } : {}, attrs));
    this.eventProvider.removeAddedEvents();
    this.addProxyEventsToElement(this.innerElement, target.click);
    this.refreshPosition();
  }
  /**
   * Refresh the position of the proxy element to match the current target
   */
  refreshPosition() {
    const bBox = this.getTargetPosition();
    css15(this.innerElement, {
      width: (bBox.width || 1) + "px",
      height: (bBox.height || 1) + "px",
      left: (Math.round(bBox.x) || 0) + "px",
      top: (Math.round(bBox.y) || 0) + "px"
    });
  }
  /**
   * Remove button from DOM, and clear events.
   */
  remove() {
    this.eventProvider.removeAddedEvents();
    removeElement3(this.element);
  }
  // -------------------------- private ------------------------------------
  /**
   * Update the CSS class name to match target
   */
  updateCSSClassName() {
    const stringHasNoTooltip = (s) => s.indexOf("highcharts-no-tooltip") > -1;
    const legend = this.chart.legend;
    const groupDiv = legend.group && legend.group.div;
    const noTooltipOnGroup = stringHasNoTooltip(groupDiv && groupDiv.className || "");
    const targetClassName = this.getTargetAttr(this.target.click, "class") || "";
    const noTooltipOnTarget = stringHasNoTooltip(targetClassName);
    this.innerElement.className = noTooltipOnGroup || noTooltipOnTarget ? "highcharts-a11y-proxy-element highcharts-no-tooltip" : "highcharts-a11y-proxy-element";
  }
  /**
   * Mirror events for a proxy element to a target
   */
  addProxyEventsToElement(element, target) {
    [
      "click",
      "touchstart",
      "touchend",
      "touchcancel",
      "touchmove",
      "mouseover",
      "mouseenter",
      "mouseleave",
      "mouseout"
    ].forEach((evtType) => {
      const isTouchEvent = evtType.indexOf("touch") === 0;
      this.eventProvider.addEvent(element, evtType, (e) => {
        const clonedEvent = isTouchEvent ? cloneTouchEvent2(e) : cloneMouseEvent2(e);
        if (target) {
          fireEventOnWrappedOrUnwrappedElement4(target, clonedEvent);
        }
        e.stopPropagation();
        if (!isTouchEvent) {
          e.preventDefault();
        }
      }, { passive: false });
    });
  }
  /**
   * Set visually hidden style on a proxy element
   */
  hideElementVisually(el) {
    css15(el, {
      borderWidth: 0,
      backgroundColor: "transparent",
      cursor: "pointer",
      outline: "none",
      opacity: 1e-3,
      filter: "alpha(opacity=1)",
      zIndex: 999,
      overflow: "hidden",
      padding: 0,
      margin: 0,
      display: "block",
      position: "absolute",
      "-ms-filter": "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)"
    });
  }
  /**
   * Get the position relative to chart container for the target
   */
  getTargetPosition() {
    const clickTarget = this.target.click;
    const clickTargetElement = clickTarget.element ? clickTarget.element : clickTarget;
    const posElement = this.target.visual || clickTargetElement;
    const chartDiv = this.chart.renderTo, pointer = this.chart.pointer;
    if (chartDiv && posElement?.getBoundingClientRect && pointer) {
      const scrollTop = win13.scrollY || doc15.documentElement.scrollTop, rectEl = posElement.getBoundingClientRect(), chartPos = pointer.getChartPosition();
      return {
        x: (rectEl.left - chartPos.left) / chartPos.scaleX,
        // #21994, Add scroll position as "getBoundingClientRect"
        // returns the position from the viewport, not the document top.
        y: (rectEl.top + scrollTop - chartPos.top) / chartPos.scaleY,
        width: rectEl.right / chartPos.scaleX - rectEl.left / chartPos.scaleX,
        height: rectEl.bottom / chartPos.scaleY - rectEl.top / chartPos.scaleY
      };
    }
    return { x: 0, y: 0, width: 1, height: 1 };
  }
  /**
   * Get an attribute value of a target
   */
  getTargetAttr(target, key) {
    if (target.element) {
      return target.element.getAttribute(key);
    }
    return target.getAttribute(key);
  }
};
var ProxyElement_default = ProxyElement;

// node_modules/highcharts/es-modules/Accessibility/ProxyProvider.js
var { doc: doc16 } = Globals_default;
var { attr: attr14, css: css16 } = Utilities_default;
var { unhideChartElementFromAT: unhideChartElementFromAT6 } = ChartUtilities_default;
var { removeChildNodes: removeChildNodes2 } = HTMLUtilities_default;
var ProxyProvider = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart) {
    this.chart = chart;
    this.domElementProvider = new DOMElementProvider_default();
    this.groups = {};
    this.groupOrder = [];
    this.beforeChartProxyPosContainer = this.createProxyPosContainer("before");
    this.afterChartProxyPosContainer = this.createProxyPosContainer("after");
    this.update();
  }
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable */
  /**
   * Add a new proxy element to a group, proxying a target control.
   */
  addProxyElement(groupKey, target, proxyElementType = "button", attributes) {
    const group = this.groups[groupKey];
    if (!group) {
      throw new Error("ProxyProvider.addProxyElement: Invalid group key " + groupKey);
    }
    const wrapperElementType = group.type === "ul" || group.type === "ol" ? "li" : void 0, proxy = new ProxyElement_default(this.chart, target, proxyElementType, wrapperElementType, attributes);
    group.proxyContainerElement.appendChild(proxy.element);
    group.proxyElements.push(proxy);
    return proxy;
  }
  /**
   * Create a group that will contain proxy elements. The group order is
   * automatically updated according to the last group order keys.
   *
   * Returns the added group.
   */
  addGroup(groupKey, groupElementType = "div", attributes) {
    const existingGroup = this.groups[groupKey];
    if (existingGroup) {
      return existingGroup.groupElement;
    }
    const proxyContainer = this.domElementProvider.createElement(groupElementType);
    let groupElement;
    if (attributes && attributes.role && groupElementType !== "div") {
      groupElement = this.domElementProvider.createElement("div");
      groupElement.appendChild(proxyContainer);
    } else {
      groupElement = proxyContainer;
    }
    groupElement.className = "highcharts-a11y-proxy-group highcharts-a11y-proxy-group-" + groupKey.replace(/\W/g, "-");
    this.groups[groupKey] = {
      proxyContainerElement: proxyContainer,
      groupElement,
      type: groupElementType,
      proxyElements: []
    };
    attr14(groupElement, attributes || {});
    if (groupElementType === "ul") {
      proxyContainer.setAttribute("role", "list");
    }
    this.afterChartProxyPosContainer.appendChild(groupElement);
    this.updateGroupOrder(this.groupOrder);
    return groupElement;
  }
  /**
   * Update HTML attributes of a group.
   */
  updateGroupAttrs(groupKey, attributes) {
    const group = this.groups[groupKey];
    if (!group) {
      throw new Error("ProxyProvider.updateGroupAttrs: Invalid group key " + groupKey);
    }
    attr14(group.groupElement, attributes);
  }
  /**
   * Reorder the proxy groups.
   *
   * The group key "series" refers to the chart's data points / <svg> element.
   * This is so that the keyboardNavigation.order option can be used to
   * determine the proxy group order.
   */
  updateGroupOrder(groupKeys) {
    this.groupOrder = groupKeys.slice();
    if (this.isDOMOrderGroupOrder()) {
      return;
    }
    const seriesIx = groupKeys.indexOf("series");
    const beforeKeys = seriesIx > -1 ? groupKeys.slice(0, seriesIx) : groupKeys;
    const afterKeys = seriesIx > -1 ? groupKeys.slice(seriesIx + 1) : [];
    const activeElement = doc16.activeElement;
    ["before", "after"].forEach((pos) => {
      const posContainer = this[pos === "before" ? "beforeChartProxyPosContainer" : "afterChartProxyPosContainer"];
      const keys = pos === "before" ? beforeKeys : afterKeys;
      removeChildNodes2(posContainer);
      keys.forEach((groupKey) => {
        const group = this.groups[groupKey];
        if (group) {
          posContainer.appendChild(group.groupElement);
        }
      });
    });
    if ((this.beforeChartProxyPosContainer.contains(activeElement) || this.afterChartProxyPosContainer.contains(activeElement)) && activeElement && activeElement.focus) {
      activeElement.focus();
    }
  }
  /**
   * Remove all proxy elements in a group
   */
  clearGroup(groupKey) {
    const group = this.groups[groupKey];
    if (!group) {
      throw new Error("ProxyProvider.clearGroup: Invalid group key " + groupKey);
    }
    removeChildNodes2(group.proxyContainerElement);
  }
  /**
   * Remove a group from the DOM and from the proxy provider's group list.
   * All child elements are removed.
   * If the group does not exist, nothing happens.
   */
  removeGroup(groupKey) {
    const group = this.groups[groupKey];
    if (group) {
      this.domElementProvider.removeElement(group.groupElement);
      if (group.groupElement !== group.proxyContainerElement) {
        this.domElementProvider.removeElement(group.proxyContainerElement);
      }
      delete this.groups[groupKey];
    }
  }
  /**
   * Update the position and order of all proxy groups and elements
   */
  update() {
    this.updatePosContainerPositions();
    this.updateGroupOrder(this.groupOrder);
    this.updateProxyElementPositions();
  }
  /**
   * Update all proxy element positions
   */
  updateProxyElementPositions() {
    Object.keys(this.groups).forEach(this.updateGroupProxyElementPositions.bind(this));
  }
  /**
   * Update a group's proxy elements' positions.
   * If the group does not exist, nothing happens.
   */
  updateGroupProxyElementPositions(groupKey) {
    const group = this.groups[groupKey];
    if (group) {
      group.proxyElements.forEach((el) => el.refreshPosition());
    }
  }
  /**
   * Remove all added elements
   */
  destroy() {
    this.domElementProvider.destroyCreatedElements();
  }
  // -------------------------- private ------------------------------------
  /**
   * Create and return a pos container element (the overall containers for
   * the proxy groups).
   */
  createProxyPosContainer(classNamePostfix) {
    const el = this.domElementProvider.createElement("div");
    el.setAttribute("aria-hidden", "false");
    el.className = "highcharts-a11y-proxy-container" + (classNamePostfix ? "-" + classNamePostfix : "");
    css16(el, {
      top: "0",
      left: "0"
    });
    if (!this.chart.styledMode) {
      el.style.whiteSpace = "nowrap";
      el.style.position = "absolute";
    }
    return el;
  }
  /**
   * Get an array of group keys that corresponds to the current group order
   * in the DOM.
   */
  getCurrentGroupOrderInDOM() {
    const getGroupKeyFromElement = (el) => {
      const allGroups = Object.keys(this.groups);
      let i = allGroups.length;
      while (i--) {
        const groupKey = allGroups[i];
        const group = this.groups[groupKey];
        if (group && el === group.groupElement) {
          return groupKey;
        }
      }
    };
    const getChildrenGroupOrder = (el) => {
      const childrenOrder = [];
      const children = el.children;
      for (let i = 0; i < children.length; ++i) {
        const groupKey = getGroupKeyFromElement(children[i]);
        if (groupKey) {
          childrenOrder.push(groupKey);
        }
      }
      return childrenOrder;
    };
    const before = getChildrenGroupOrder(this.beforeChartProxyPosContainer);
    const after = getChildrenGroupOrder(this.afterChartProxyPosContainer);
    before.push("series");
    return before.concat(after);
  }
  /**
   * Check if the current DOM order matches the current group order, so that
   * a reordering/update is unnecessary.
   */
  isDOMOrderGroupOrder() {
    const domOrder = this.getCurrentGroupOrderInDOM();
    const groupOrderWithGroups = this.groupOrder.filter((x) => x === "series" || !!this.groups[x]);
    let i = domOrder.length;
    if (i !== groupOrderWithGroups.length) {
      return false;
    }
    while (i--) {
      if (domOrder[i] !== groupOrderWithGroups[i]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Update the DOM positions of the before/after proxy
   * positioning containers for the groups.
   */
  updatePosContainerPositions() {
    const chart = this.chart;
    if (chart.renderer.forExport) {
      return;
    }
    const rendererSVGEl = chart.renderer.box;
    chart.container.insertBefore(this.afterChartProxyPosContainer, rendererSVGEl.nextSibling);
    chart.container.insertBefore(this.beforeChartProxyPosContainer, rendererSVGEl);
    unhideChartElementFromAT6(this.chart, this.afterChartProxyPosContainer);
    unhideChartElementFromAT6(this.chart, this.beforeChartProxyPosContainer);
  }
};
var ProxyProvider_default = ProxyProvider;

// node_modules/highcharts/es-modules/Accessibility/Components/RangeSelectorComponent.js
var { unhideChartElementFromAT: unhideChartElementFromAT7, getAxisRangeDescription: getAxisRangeDescription4 } = ChartUtilities_default;
var { addEvent: addEvent42, attr: attr15 } = Utilities_default;
function shouldRunInputNavigation(chart) {
  return Boolean(chart.rangeSelector && chart.rangeSelector.inputGroup && chart.rangeSelector.inputGroup.element.style.visibility !== "hidden" && chart.options.rangeSelector.inputEnabled !== false && chart.rangeSelector.minInput && chart.rangeSelector.maxInput);
}
var RangeSelectorComponent = class extends AccessibilityComponent_default {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Init the component
   * @private
   */
  init() {
    const chart = this.chart;
    this.announcer = new Announcer_default(chart, "polite");
  }
  /**
   * Called on first render/updates to the chart, including options changes.
   */
  onChartUpdate() {
    const chart = this.chart, component = this, rangeSelector2 = chart.rangeSelector;
    if (!rangeSelector2) {
      return;
    }
    this.updateSelectorVisibility();
    this.setDropdownAttrs();
    if (rangeSelector2.buttons && rangeSelector2.buttons.length) {
      rangeSelector2.buttons.forEach((button) => {
        component.setRangeButtonAttrs(button);
      });
    }
    if (rangeSelector2.maxInput && rangeSelector2.minInput) {
      ["minInput", "maxInput"].forEach(function(key, i) {
        const input = rangeSelector2[key];
        if (input) {
          unhideChartElementFromAT7(chart, input);
          component.setRangeInputAttrs(input, "accessibility.rangeSelector." + (i ? "max" : "min") + "InputLabel");
        }
      });
    }
  }
  /**
   * Hide buttons from AT when showing dropdown, and vice versa.
   * @private
   */
  updateSelectorVisibility() {
    const chart = this.chart;
    const rangeSelector2 = chart.rangeSelector;
    const dropdown = rangeSelector2 && rangeSelector2.dropdown;
    const buttons = rangeSelector2 && rangeSelector2.buttons || [];
    const hideFromAT = (el) => el.setAttribute("aria-hidden", true);
    if (rangeSelector2 && rangeSelector2.hasVisibleDropdown && dropdown) {
      unhideChartElementFromAT7(chart, dropdown);
      buttons.forEach((btn) => hideFromAT(btn.element));
    } else {
      if (dropdown) {
        hideFromAT(dropdown);
      }
      buttons.forEach((btn) => unhideChartElementFromAT7(chart, btn.element));
    }
  }
  /**
   * Set accessibility related attributes on dropdown element.
   * @private
   */
  setDropdownAttrs() {
    const chart = this.chart;
    const dropdown = chart.rangeSelector && chart.rangeSelector.dropdown;
    if (dropdown) {
      const label = chart.langFormat("accessibility.rangeSelector.dropdownLabel", { rangeTitle: chart.options.lang.rangeSelectorZoom });
      dropdown.setAttribute("aria-label", label);
      dropdown.setAttribute("tabindex", -1);
    }
  }
  /**
   * Set attrs for a range button
   * @private
   */
  setRangeButtonAttrs(button) {
    attr15(button.element, {
      tabindex: -1,
      role: "button"
    });
  }
  /**
   * Set attrs for a date input
   * @private
   */
  setRangeInputAttrs(input, langKey) {
    const chart = this.chart;
    attr15(input, {
      tabindex: -1,
      "aria-label": chart.langFormat(langKey, { chart })
    });
  }
  /**
   * Handle arrow key nav
   * @private
   */
  onButtonNavKbdArrowKey(keyboardNavigationHandler, keyCode) {
    const response = keyboardNavigationHandler.response, keys = this.keyCodes, chart = this.chart, wrapAround = chart.options.accessibility.keyboardNavigation.wrapAround, direction = keyCode === keys.left || keyCode === keys.up ? -1 : 1, didHighlight = chart.highlightRangeSelectorButton(chart.highlightedRangeSelectorItemIx + direction);
    if (!didHighlight) {
      if (wrapAround) {
        keyboardNavigationHandler.init(direction);
        return response.success;
      }
      return response[direction > 0 ? "next" : "prev"];
    }
    return response.success;
  }
  /**
   * Handle keyboard click
   * @private
   */
  onButtonNavKbdClick(keyboardNavigationHandler) {
    const response = keyboardNavigationHandler.response, chart = this.chart, wasDisabled = chart.oldRangeSelectorItemState === 3;
    if (!wasDisabled) {
      this.fakeClickEvent(chart.rangeSelector.buttons[chart.highlightedRangeSelectorItemIx].element);
    }
    return response.success;
  }
  /**
   * Called whenever a range selector button has been clicked, either by
   * mouse, touch, or kbd/voice/other.
   * @private
   */
  onAfterBtnClick() {
    const chart = this.chart;
    const axisRangeDescription = getAxisRangeDescription4(chart.xAxis[0]);
    const announcement = chart.langFormat("accessibility.rangeSelector.clickButtonAnnouncement", { chart, axisRangeDescription });
    if (announcement) {
      this.announcer.announce(announcement);
    }
  }
  /**
   * Handle move between input elements with Tab key
   * @private
   */
  onInputKbdMove(direction) {
    const chart = this.chart;
    const rangeSel = chart.rangeSelector;
    const newIx = chart.highlightedInputRangeIx = (chart.highlightedInputRangeIx || 0) + direction;
    const newIxOutOfRange = newIx > 1 || newIx < 0;
    if (newIxOutOfRange) {
      if (chart.accessibility) {
        chart.accessibility.keyboardNavigation.exiting = true;
        chart.accessibility.keyboardNavigation.tabindexContainer.focus();
        return chart.accessibility.keyboardNavigation.move(direction);
      }
    } else if (rangeSel) {
      const svgEl = rangeSel[newIx ? "maxDateBox" : "minDateBox"];
      const inputEl = rangeSel[newIx ? "maxInput" : "minInput"];
      if (svgEl && inputEl) {
        chart.setFocusToElement(svgEl, inputEl);
      }
    }
    return true;
  }
  /**
   * Init date input navigation
   * @private
   */
  onInputNavInit(direction) {
    const component = this;
    const chart = this.chart;
    const buttonIxToHighlight = direction > 0 ? 0 : 1;
    const rangeSel = chart.rangeSelector;
    const svgEl = rangeSel && rangeSel[buttonIxToHighlight ? "maxDateBox" : "minDateBox"];
    const minInput = rangeSel && rangeSel.minInput;
    const maxInput = rangeSel && rangeSel.maxInput;
    const inputEl = buttonIxToHighlight ? maxInput : minInput;
    chart.highlightedInputRangeIx = buttonIxToHighlight;
    if (svgEl && minInput && maxInput) {
      chart.setFocusToElement(svgEl, inputEl);
      if (this.removeInputKeydownHandler) {
        this.removeInputKeydownHandler();
      }
      const keydownHandler = (e) => {
        const isTab = (e.which || e.keyCode) === this.keyCodes.tab;
        if (isTab && component.onInputKbdMove(e.shiftKey ? -1 : 1)) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      const minRemover = addEvent42(minInput, "keydown", keydownHandler);
      const maxRemover = addEvent42(maxInput, "keydown", keydownHandler);
      this.removeInputKeydownHandler = () => {
        minRemover();
        maxRemover();
      };
    }
  }
  /**
   * Terminate date input nav
   * @private
   */
  onInputNavTerminate() {
    const rangeSel = this.chart.rangeSelector || {};
    if (rangeSel.maxInput) {
      rangeSel.hideInput("max");
    }
    if (rangeSel.minInput) {
      rangeSel.hideInput("min");
    }
    if (this.removeInputKeydownHandler) {
      this.removeInputKeydownHandler();
      delete this.removeInputKeydownHandler;
    }
  }
  /**
   * Init range selector dropdown nav
   * @private
   */
  initDropdownNav() {
    const chart = this.chart;
    const rangeSelector2 = chart.rangeSelector;
    const dropdown = rangeSelector2 && rangeSelector2.dropdown;
    if (rangeSelector2 && dropdown) {
      chart.setFocusToElement(rangeSelector2.buttonGroup, dropdown);
      if (this.removeDropdownKeydownHandler) {
        this.removeDropdownKeydownHandler();
      }
      this.removeDropdownKeydownHandler = addEvent42(dropdown, "keydown", (e) => {
        const isTab = (e.which || e.keyCode) === this.keyCodes.tab, a11y = chart.accessibility;
        if (isTab) {
          e.preventDefault();
          e.stopPropagation();
          if (a11y) {
            a11y.keyboardNavigation.move(e.shiftKey ? -1 : 1);
          }
        }
      });
    }
  }
  /**
   * Get navigation for the range selector buttons.
   * @private
   * @return {Highcharts.KeyboardNavigationHandler} The module object.
   */
  getRangeSelectorButtonNavigation() {
    const chart = this.chart;
    const keys = this.keyCodes;
    const component = this;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [
        [
          [keys.left, keys.right, keys.up, keys.down],
          function(keyCode) {
            return component.onButtonNavKbdArrowKey(this, keyCode);
          }
        ],
        [
          [keys.enter, keys.space],
          function() {
            return component.onButtonNavKbdClick(this);
          }
        ]
      ],
      validate: function() {
        return !!(chart.rangeSelector && chart.rangeSelector.buttons && chart.rangeSelector.buttons.length);
      },
      init: function(direction) {
        const rangeSelector2 = chart.rangeSelector;
        if (rangeSelector2 && rangeSelector2.hasVisibleDropdown) {
          component.initDropdownNav();
        } else if (rangeSelector2) {
          const lastButtonIx = rangeSelector2.buttons.length - 1;
          chart.highlightRangeSelectorButton(direction > 0 ? 0 : lastButtonIx);
        }
      },
      terminate: function() {
        if (component.removeDropdownKeydownHandler) {
          component.removeDropdownKeydownHandler();
          delete component.removeDropdownKeydownHandler;
        }
      }
    });
  }
  /**
   * Get navigation for the range selector input boxes.
   * @private
   * @return {Highcharts.KeyboardNavigationHandler}
   *         The module object.
   */
  getRangeSelectorInputNavigation() {
    const chart = this.chart;
    const component = this;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [],
      validate: function() {
        return shouldRunInputNavigation(chart);
      },
      init: function(direction) {
        component.onInputNavInit(direction);
      },
      terminate: function() {
        component.onInputNavTerminate();
      }
    });
  }
  /**
   * Get keyboard navigation handlers for this component.
   * @return {Array<Highcharts.KeyboardNavigationHandler>}
   *         List of module objects.
   */
  getKeyboardNavigation() {
    return [
      this.getRangeSelectorButtonNavigation(),
      this.getRangeSelectorInputNavigation()
    ];
  }
  /**
   * Remove component traces
   */
  destroy() {
    if (this.removeDropdownKeydownHandler) {
      this.removeDropdownKeydownHandler();
    }
    if (this.removeInputKeydownHandler) {
      this.removeInputKeydownHandler();
    }
    if (this.announcer) {
      this.announcer.destroy();
    }
  }
};
(function(RangeSelectorComponent2) {
  function chartHighlightRangeSelectorButton(ix) {
    const buttons = this.rangeSelector && this.rangeSelector.buttons || [];
    const curHighlightedIx = this.highlightedRangeSelectorItemIx;
    const curSelectedIx = this.rangeSelector && this.rangeSelector.selected;
    if (typeof curHighlightedIx !== "undefined" && buttons[curHighlightedIx] && curHighlightedIx !== curSelectedIx) {
      buttons[curHighlightedIx].setState(this.oldRangeSelectorItemState || 0);
    }
    this.highlightedRangeSelectorItemIx = ix;
    if (buttons[ix]) {
      this.setFocusToElement(buttons[ix].box, buttons[ix].element);
      if (ix !== curSelectedIx) {
        this.oldRangeSelectorItemState = buttons[ix].state;
        buttons[ix].setState(1);
      }
      return true;
    }
    return false;
  }
  function compose27(ChartClass, RangeSelectorClass) {
    const chartProto = ChartClass.prototype;
    if (!chartProto.highlightRangeSelectorButton) {
      chartProto.highlightRangeSelectorButton = chartHighlightRangeSelectorButton;
      addEvent42(RangeSelectorClass, "afterBtnClick", rangeSelectorAfterBtnClick);
    }
  }
  RangeSelectorComponent2.compose = compose27;
  function rangeSelectorAfterBtnClick() {
    const a11y = this.chart.accessibility;
    if (a11y && a11y.components.rangeSelector) {
      return a11y.components.rangeSelector.onAfterBtnClick();
    }
  }
})(RangeSelectorComponent || (RangeSelectorComponent = {}));
var RangeSelectorComponent_default = RangeSelectorComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/ForcedMarkers.js
var { composed: composed15 } = Globals_default;
var { addEvent: addEvent43, merge: merge46, pushUnique: pushUnique18 } = Utilities_default;
var ForcedMarkersComposition;
(function(ForcedMarkersComposition2) {
  function compose27(SeriesClass) {
    if (pushUnique18(composed15, "A11y.FM")) {
      addEvent43(SeriesClass, "afterSetOptions", seriesOnAfterSetOptions);
      addEvent43(SeriesClass, "render", seriesOnRender);
      addEvent43(SeriesClass, "afterRender", seriesOnAfterRender);
      addEvent43(SeriesClass, "renderCanvas", seriesOnRenderCanvas);
    }
  }
  ForcedMarkersComposition2.compose = compose27;
  function forceZeroOpacityMarkerOptions(options2) {
    merge46(true, options2, {
      marker: {
        enabled: true,
        states: {
          normal: {
            opacity: 0
          }
        }
      }
    });
  }
  function getPointMarkerOpacity(pointOptions) {
    return pointOptions.marker.states && pointOptions.marker.states.normal && pointOptions.marker.states.normal.opacity;
  }
  function handleForcePointMarkers(series) {
    let i = series.points.length;
    while (i--) {
      const point = series.points[i];
      const pointOptions = point.options;
      const hadForcedMarker = point.hasForcedA11yMarker;
      delete point.hasForcedA11yMarker;
      if (pointOptions.marker) {
        const isStillForcedMarker = hadForcedMarker && getPointMarkerOpacity(pointOptions) === 0;
        if (pointOptions.marker.enabled && !isStillForcedMarker) {
          unforcePointMarkerOptions(pointOptions);
          point.hasForcedA11yMarker = false;
        } else if (pointOptions.marker.enabled === false) {
          forceZeroOpacityMarkerOptions(pointOptions);
          point.hasForcedA11yMarker = true;
        }
      }
    }
  }
  function hasIndividualPointMarkerOptions(series) {
    return !!(series._hasPointMarkers && series.points && series.points.length);
  }
  function isWithinDescriptionThreshold(series) {
    const a11yOptions = series.chart.options.accessibility;
    return series.points.length < a11yOptions.series.pointDescriptionEnabledThreshold || a11yOptions.series.pointDescriptionEnabledThreshold === false;
  }
  function seriesOnAfterRender() {
    const series = this;
    if (series.chart.styledMode) {
      if (series.markerGroup) {
        series.markerGroup[series.a11yMarkersForced ? "addClass" : "removeClass"]("highcharts-a11y-markers-hidden");
      }
      if (hasIndividualPointMarkerOptions(series)) {
        series.points.forEach((point) => {
          if (point.graphic) {
            point.graphic[point.hasForcedA11yMarker ? "addClass" : "removeClass"]("highcharts-a11y-marker-hidden");
            point.graphic[point.hasForcedA11yMarker === false ? "addClass" : "removeClass"]("highcharts-a11y-marker-visible");
          }
        });
      }
    }
  }
  function seriesOnAfterSetOptions(e) {
    this.resetA11yMarkerOptions = merge46(e.options.marker || {}, this.userOptions.marker || {});
  }
  function seriesOnRender() {
    const series = this, options2 = series.options;
    if (shouldForceMarkers(series)) {
      if (options2.marker && options2.marker.enabled === false) {
        series.a11yMarkersForced = true;
        forceZeroOpacityMarkerOptions(series.options);
      }
      if (hasIndividualPointMarkerOptions(series)) {
        handleForcePointMarkers(series);
      }
    } else if (series.a11yMarkersForced) {
      delete series.a11yMarkersForced;
      unforceSeriesMarkerOptions(series);
      delete series.resetA11yMarkerOptions;
    }
  }
  function shouldForceMarkers(series) {
    const chart = series.chart, chartA11yEnabled = chart.options.accessibility.enabled, seriesA11yEnabled = (series.options.accessibility && series.options.accessibility.enabled) !== false;
    return chartA11yEnabled && seriesA11yEnabled && isWithinDescriptionThreshold(series);
  }
  function unforcePointMarkerOptions(pointOptions) {
    merge46(true, pointOptions.marker, {
      states: {
        normal: {
          opacity: getPointMarkerOpacity(pointOptions) || 1
        }
      }
    });
  }
  function unforceSeriesMarkerOptions(series) {
    const resetMarkerOptions = series.resetA11yMarkerOptions;
    if (resetMarkerOptions) {
      const originalOpacity = resetMarkerOptions.states && resetMarkerOptions.states.normal && resetMarkerOptions.states.normal.opacity;
      if (series.userOptions && series.userOptions.marker) {
        series.userOptions.marker.enabled = true;
      }
      series.update({
        marker: {
          enabled: resetMarkerOptions.enabled,
          states: {
            normal: { opacity: originalOpacity }
          }
        }
      });
    }
  }
  function seriesOnRenderCanvas() {
    if (this.boosted && this.a11yMarkersForced) {
      merge46(true, this.options, {
        marker: {
          enabled: false
        }
      });
      delete this.a11yMarkersForced;
    }
  }
})(ForcedMarkersComposition || (ForcedMarkersComposition = {}));
var ForcedMarkers_default = ForcedMarkersComposition;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js
var { seriesTypes: seriesTypes4 } = SeriesRegistry_default;
var { doc: doc17 } = Globals_default;
var { defined: defined43, fireEvent: fireEvent29 } = Utilities_default;
var { getPointFromXY: getPointFromXY2, getSeriesFromName: getSeriesFromName2, scrollAxisToPoint: scrollAxisToPoint2 } = ChartUtilities_default;
function getPointIndex(point) {
  const index = point.index, points = point.series.points;
  let i = points.length;
  if (points[index] !== point) {
    while (i--) {
      if (points[i] === point) {
        return i;
      }
    }
  } else {
    return index;
  }
}
function isSkipSeries(series) {
  const a11yOptions = series.chart.options.accessibility, seriesNavOptions = a11yOptions.keyboardNavigation.seriesNavigation, seriesA11yOptions = series.options.accessibility || {}, seriesKbdNavOptions = seriesA11yOptions.keyboardNavigation;
  return seriesKbdNavOptions && seriesKbdNavOptions.enabled === false || seriesA11yOptions.enabled === false || series.options.enableMouseTracking === false || // #8440
  !series.visible || // Skip all points in a series where pointNavigationEnabledThreshold is
  // reached
  seriesNavOptions.pointNavigationEnabledThreshold && +seriesNavOptions.pointNavigationEnabledThreshold <= series.points.length;
}
function isSkipPoint(point) {
  const series = point.series, nullInteraction = series.options.nullInteraction, pointOptions = point.options, pointA11yOptions = pointOptions.accessibility, a11yOptions = series.chart.options.accessibility, pointA11yDisabled = pointA11yOptions?.enabled === false;
  return a11yOptions.keyboardNavigation.seriesNavigation.skipNullPoints ?? (!(!point.isNull || nullInteraction) && point.visible === false || point.isInside === false || pointA11yDisabled || isSkipSeries(series));
}
function getFirstValidPointInSeries(series) {
  const points = series.points || [], len = points.length;
  for (let i = 0; i < len; ++i) {
    if (!isSkipPoint(points[i])) {
      return points[i];
    }
  }
  return null;
}
function getFirstValidPointInChart(chart) {
  const series = chart.series || [], len = series.length;
  for (let i = 0; i < len; ++i) {
    if (!isSkipSeries(series[i])) {
      const point = getFirstValidPointInSeries(series[i]);
      if (point) {
        return point;
      }
    }
  }
  return null;
}
function highlightLastValidPointInChart(chart) {
  const numSeries = chart.series.length;
  let i = numSeries, res = false;
  while (i--) {
    chart.highlightedPoint = chart.series[i].points[chart.series[i].points.length - 1];
    res = chart.series[i].highlightNextValidPoint();
    if (res) {
      break;
    }
  }
  return res;
}
function updateChartFocusAfterDrilling(chart) {
  const point = getFirstValidPointInChart(chart);
  if (point) {
    point.highlight(false);
  }
}
function highlightFirstValidPointInChart(chart) {
  delete chart.highlightedPoint;
  const point = getFirstValidPointInChart(chart);
  return point ? point.highlight() : false;
}
var SeriesKeyboardNavigation = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart, keyCodes) {
    this.keyCodes = keyCodes;
    this.chart = chart;
  }
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Init the keyboard navigation
   */
  init() {
    const keyboardNavigation = this, chart = this.chart, e = this.eventProvider = new EventProvider_default();
    e.addEvent(Series_default, "destroy", function() {
      return keyboardNavigation.onSeriesDestroy(this);
    });
    e.addEvent(chart, "afterApplyDrilldown", function() {
      updateChartFocusAfterDrilling(this);
    });
    e.addEvent(chart, "drilldown", function(e2) {
      const point = e2.point, series = point.series;
      keyboardNavigation.lastDrilledDownPoint = {
        x: point.x,
        y: point.y,
        seriesName: series ? series.name : ""
      };
    });
    e.addEvent(chart, "drillupall", function() {
      setTimeout(function() {
        keyboardNavigation.onDrillupAll();
      }, 10);
    });
    e.addEvent(Point_default, "afterSetState", function() {
      const point = this;
      const pointEl = point.graphic && point.graphic.element;
      const focusedElement = doc17.activeElement;
      const focusedElClassName = focusedElement && focusedElement.getAttribute("class");
      const isProxyFocused = focusedElClassName && focusedElClassName.indexOf("highcharts-a11y-proxy-element") > -1;
      if (chart.highlightedPoint === point && focusedElement !== pointEl && !isProxyFocused && pointEl && pointEl.focus) {
        pointEl.focus();
      }
    });
  }
  /**
   * After drillup we want to find the point that was drilled down to and
   * highlight it.
   * @private
   */
  onDrillupAll() {
    const last = this.lastDrilledDownPoint, chart = this.chart, series = last && getSeriesFromName2(chart, last.seriesName);
    let point;
    if (last && series && defined43(last.x) && defined43(last.y)) {
      point = getPointFromXY2(series, last.x, last.y);
    }
    point = point || getFirstValidPointInChart(chart);
    if (chart.container) {
      chart.container.focus();
    }
    if (point && point.highlight) {
      point.highlight(false);
    }
  }
  /**
   * @private
   */
  getKeyboardNavigationHandler() {
    const keyboardNavigation = this, keys = this.keyCodes, chart = this.chart, inverted = chart.inverted;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [
        [
          inverted ? [keys.up, keys.down] : [keys.left, keys.right],
          function(keyCode) {
            return keyboardNavigation.onKbdSideways(this, keyCode);
          }
        ],
        [
          inverted ? [keys.left, keys.right] : [keys.up, keys.down],
          function(keyCode) {
            return keyboardNavigation.onKbdVertical(this, keyCode);
          }
        ],
        [
          [keys.enter, keys.space],
          function(keyCode, event) {
            const point = chart.highlightedPoint;
            if (point) {
              const { plotLeft, plotTop } = this.chart, { plotX = 0, plotY = 0 } = point;
              event = {
                ...event,
                chartX: plotLeft + plotX,
                chartY: plotTop + plotY,
                point,
                target: point.graphic?.element || event.target
              };
              fireEvent29(point.series, "click", event);
              point.firePointEvent("click", event);
            }
            return this.response.success;
          }
        ],
        [
          [keys.home],
          function() {
            highlightFirstValidPointInChart(chart);
            return this.response.success;
          }
        ],
        [
          [keys.end],
          function() {
            highlightLastValidPointInChart(chart);
            return this.response.success;
          }
        ],
        [
          [keys.pageDown, keys.pageUp],
          function(keyCode) {
            chart.highlightAdjacentSeries(keyCode === keys.pageDown);
            return this.response.success;
          }
        ]
      ],
      init: function() {
        return keyboardNavigation.onHandlerInit(this);
      },
      validate: function() {
        return !!getFirstValidPointInChart(chart);
      },
      terminate: function() {
        return keyboardNavigation.onHandlerTerminate();
      }
    });
  }
  /**
   * @private
   * @param {Highcharts.KeyboardNavigationHandler} handler
   * @param {number} keyCode
   * @return {number}
   * response
   */
  onKbdSideways(handler, keyCode) {
    const keys = this.keyCodes, isNext = keyCode === keys.right || keyCode === keys.down;
    return this.attemptHighlightAdjacentPoint(handler, isNext);
  }
  /**
   * When keyboard navigation inits.
   * @private
   * @param {Highcharts.KeyboardNavigationHandler} handler The handler object
   * @return {number}
   * response
   */
  onHandlerInit(handler) {
    const chart = this.chart, kbdNavOptions = chart.options.accessibility.keyboardNavigation;
    if (kbdNavOptions.seriesNavigation.rememberPointFocus && chart.highlightedPoint) {
      chart.highlightedPoint.highlight();
    } else {
      highlightFirstValidPointInChart(chart);
    }
    return handler.response.success;
  }
  /**
   * @private
   * @param {Highcharts.KeyboardNavigationHandler} handler
   * @param {number} keyCode
   * @return {number}
   * response
   */
  onKbdVertical(handler, keyCode) {
    const chart = this.chart, keys = this.keyCodes, isNext = keyCode === keys.down || keyCode === keys.right, navOptions = chart.options.accessibility.keyboardNavigation.seriesNavigation;
    if (navOptions.mode && navOptions.mode === "serialize") {
      return this.attemptHighlightAdjacentPoint(handler, isNext);
    }
    const highlightMethod = chart.highlightedPoint && chart.highlightedPoint.series.keyboardMoveVertical ? "highlightAdjacentPointVertical" : "highlightAdjacentSeries";
    chart[highlightMethod](isNext);
    return handler.response.success;
  }
  /**
   * @private
   */
  onHandlerTerminate() {
    const chart = this.chart, kbdNavOptions = chart.options.accessibility.keyboardNavigation;
    if (chart.tooltip) {
      chart.tooltip.hide(0);
    }
    const hoverSeries = chart.highlightedPoint && chart.highlightedPoint.series;
    if (hoverSeries && hoverSeries.onMouseOut) {
      hoverSeries.onMouseOut();
    }
    if (chart.highlightedPoint && chart.highlightedPoint.onMouseOut) {
      chart.highlightedPoint.onMouseOut();
    }
    if (!kbdNavOptions.seriesNavigation.rememberPointFocus) {
      delete chart.highlightedPoint;
    }
  }
  /**
   * Function that attempts to highlight next/prev point. Handles wrap around.
   * @private
   */
  attemptHighlightAdjacentPoint(handler, directionIsNext) {
    const chart = this.chart, wrapAround = chart.options.accessibility.keyboardNavigation.wrapAround, highlightSuccessful = chart.highlightAdjacentPoint(directionIsNext);
    if (!highlightSuccessful) {
      if (wrapAround && (directionIsNext ? highlightFirstValidPointInChart(chart) : highlightLastValidPointInChart(chart))) {
        return handler.response.success;
      }
      return handler.response[directionIsNext ? "next" : "prev"];
    }
    return handler.response.success;
  }
  /**
   * @private
   */
  onSeriesDestroy(series) {
    const chart = this.chart, currentHighlightedPointDestroyed = chart.highlightedPoint && chart.highlightedPoint.series === series;
    if (currentHighlightedPointDestroyed) {
      delete chart.highlightedPoint;
      if (chart.focusElement) {
        chart.focusElement.removeFocusBorder();
      }
    }
  }
  /**
   * @private
   */
  destroy() {
    this.eventProvider.removeAddedEvents();
  }
};
(function(SeriesKeyboardNavigation2) {
  function chartHighlightAdjacentPoint(next) {
    const chart = this, series = chart.series, curPoint = chart.highlightedPoint, curPointIndex = curPoint && getPointIndex(curPoint) || 0, curPoints = curPoint && curPoint.series.points || [], lastSeries = chart.series && chart.series[chart.series.length - 1], lastPoint = lastSeries && lastSeries.points && lastSeries.points[lastSeries.points.length - 1];
    let newSeries, newPoint;
    if (!series[0] || !series[0].points) {
      return false;
    }
    if (!curPoint) {
      newPoint = next ? series[0].points[0] : lastPoint;
    } else {
      newSeries = series[curPoint.series.index + (next ? 1 : -1)];
      newPoint = curPoints[curPointIndex + (next ? 1 : -1)];
      if (!newPoint && newSeries) {
        newPoint = newSeries.points[next ? 0 : newSeries.points.length - 1];
      }
      if (!newPoint) {
        return false;
      }
    }
    if (isSkipPoint(newPoint)) {
      newSeries = newPoint.series;
      if (isSkipSeries(newSeries)) {
        chart.highlightedPoint = next ? newSeries.points[newSeries.points.length - 1] : newSeries.points[0];
      } else {
        chart.highlightedPoint = newPoint;
      }
      return chart.highlightAdjacentPoint(next);
    }
    return newPoint.highlight();
  }
  function chartHighlightAdjacentPointVertical(down) {
    const curPoint = this.highlightedPoint;
    let minDistance = Infinity, bestPoint;
    if (!defined43(curPoint.plotX) || !defined43(curPoint.plotY)) {
      return false;
    }
    this.series.forEach((series) => {
      if (isSkipSeries(series)) {
        return;
      }
      series.points.forEach((point) => {
        if (!defined43(point.plotY) || !defined43(point.plotX) || point === curPoint) {
          return;
        }
        let yDistance = point.plotY - curPoint.plotY;
        const width = Math.abs(point.plotX - curPoint.plotX), distance = Math.abs(yDistance) * Math.abs(yDistance) + width * width * 4;
        if (series.yAxis && series.yAxis.reversed) {
          yDistance *= -1;
        }
        if (yDistance <= 0 && down || yDistance >= 0 && !down || distance < 5 || // Points in same spot => infinite loop
        isSkipPoint(point)) {
          return;
        }
        if (distance < minDistance) {
          minDistance = distance;
          bestPoint = point;
        }
      });
    });
    return bestPoint ? bestPoint.highlight() : false;
  }
  function chartHighlightAdjacentSeries(down) {
    const chart = this, curPoint = chart.highlightedPoint, lastSeries = chart.series && chart.series[chart.series.length - 1], lastPoint = lastSeries && lastSeries.points && lastSeries.points[lastSeries.points.length - 1];
    let newSeries, newPoint, adjacentNewPoint;
    if (!chart.highlightedPoint) {
      newSeries = down ? chart.series && chart.series[0] : lastSeries;
      newPoint = down ? newSeries && newSeries.points && newSeries.points[0] : lastPoint;
      return newPoint ? newPoint.highlight() : false;
    }
    newSeries = chart.series[curPoint.series.index + (down ? -1 : 1)];
    if (!newSeries) {
      return false;
    }
    newPoint = getClosestPoint(curPoint, newSeries, 4);
    if (!newPoint) {
      return false;
    }
    if (isSkipSeries(newSeries)) {
      newPoint.highlight();
      adjacentNewPoint = chart.highlightAdjacentSeries(down);
      if (!adjacentNewPoint) {
        curPoint.highlight();
        return false;
      }
      return adjacentNewPoint;
    }
    newPoint.highlight();
    return newPoint.series.highlightNextValidPoint();
  }
  function compose27(ChartClass, PointClass, SeriesClass) {
    const chartProto = ChartClass.prototype, pointProto2 = PointClass.prototype, seriesProto7 = SeriesClass.prototype;
    if (!chartProto.highlightAdjacentPoint) {
      chartProto.highlightAdjacentPoint = chartHighlightAdjacentPoint;
      chartProto.highlightAdjacentPointVertical = chartHighlightAdjacentPointVertical;
      chartProto.highlightAdjacentSeries = chartHighlightAdjacentSeries;
      pointProto2.highlight = pointHighlight;
      seriesProto7.keyboardMoveVertical = true;
      [
        "column",
        "gantt",
        "pie"
      ].forEach((type) => {
        if (seriesTypes4[type]) {
          seriesTypes4[type].prototype.keyboardMoveVertical = false;
        }
      });
      seriesProto7.highlightNextValidPoint = seriesHighlightNextValidPoint;
    }
  }
  SeriesKeyboardNavigation2.compose = compose27;
  function getClosestPoint(point, series, xWeight, yWeight) {
    let minDistance = Infinity, dPoint, minIx, distance, i = series.points.length;
    const hasUndefinedPosition = (point2) => !(defined43(point2.plotX) && defined43(point2.plotY));
    if (hasUndefinedPosition(point)) {
      return;
    }
    while (i--) {
      dPoint = series.points[i];
      if (hasUndefinedPosition(dPoint)) {
        continue;
      }
      distance = (point.plotX - dPoint.plotX) * (point.plotX - dPoint.plotX) * (xWeight || 1) + (point.plotY - dPoint.plotY) * (point.plotY - dPoint.plotY) * (yWeight || 1);
      if (distance < minDistance) {
        minDistance = distance;
        minIx = i;
      }
    }
    return defined43(minIx) ? series.points[minIx] : void 0;
  }
  function pointHighlight(highlightVisually = true) {
    const chart = this.series.chart, tooltipElement = chart.tooltip?.label?.element;
    if ((!this.isNull || this.series.options?.nullInteraction) && highlightVisually) {
      this.onMouseOver();
    } else {
      if (chart.tooltip) {
        chart.tooltip.hide(0);
      }
    }
    scrollAxisToPoint2(this);
    if (this.graphic) {
      chart.setFocusToElement(this.graphic);
      if (!highlightVisually && chart.focusElement) {
        chart.focusElement.removeFocusBorder();
      }
    }
    chart.highlightedPoint = this;
    const tooltipTop = tooltipElement?.getBoundingClientRect().top;
    if (tooltipElement && tooltipTop && tooltipTop < 0) {
      const scrollTop = window.scrollY, newScrollTop = scrollTop + tooltipTop;
      window.scrollTo({
        behavior: "smooth",
        top: newScrollTop
      });
    }
    return this;
  }
  function seriesHighlightNextValidPoint() {
    const curPoint = this.chart.highlightedPoint, start = (curPoint && curPoint.series) === this ? getPointIndex(curPoint) : 0, points = this.points, len = points.length;
    if (points && len) {
      for (let i = start; i < len; ++i) {
        if (!isSkipPoint(points[i])) {
          return points[i].highlight();
        }
      }
      for (let j = start; j >= 0; --j) {
        if (!isSkipPoint(points[j])) {
          return points[j].highlight();
        }
      }
    }
    return false;
  }
})(SeriesKeyboardNavigation || (SeriesKeyboardNavigation = {}));
var SeriesKeyboardNavigation_default = SeriesKeyboardNavigation;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/SeriesComponent.js
var { hideSeriesFromAT: hideSeriesFromAT2 } = ChartUtilities_default;
var { describeSeries: describeSeries2 } = SeriesDescriber_default;
var SeriesComponent = class extends AccessibilityComponent_default {
  /* *
   *
   *  Static Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * @private
   */
  static compose(ChartClass, PointClass, SeriesClass) {
    NewDataAnnouncer_default.compose(SeriesClass);
    ForcedMarkers_default.compose(SeriesClass);
    SeriesKeyboardNavigation_default.compose(ChartClass, PointClass, SeriesClass);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Init the component.
   */
  init() {
    this.newDataAnnouncer = new NewDataAnnouncer_default(this.chart);
    this.newDataAnnouncer.init();
    this.keyboardNavigation = new SeriesKeyboardNavigation_default(this.chart, this.keyCodes);
    this.keyboardNavigation.init();
    this.hideTooltipFromATWhenShown();
    this.hideSeriesLabelsFromATWhenShown();
  }
  /**
   * @private
   */
  hideTooltipFromATWhenShown() {
    const component = this;
    if (this.chart.tooltip) {
      this.addEvent(this.chart.tooltip.constructor, "refresh", function() {
        if (this.chart === component.chart && this.label && this.label.element) {
          this.label.element.setAttribute("aria-hidden", true);
        }
      });
    }
  }
  /**
   * @private
   */
  hideSeriesLabelsFromATWhenShown() {
    this.addEvent(this.chart, "afterDrawSeriesLabels", function() {
      this.series.forEach(function(series) {
        if (series.labelBySeries) {
          series.labelBySeries.attr("aria-hidden", true);
        }
      });
    });
  }
  /**
   * Called on chart render. It is necessary to do this for render in case
   * markers change on zoom/pixel density.
   */
  onChartRender() {
    const chart = this.chart;
    chart.series.forEach(function(series) {
      const shouldDescribeSeries = (series.options.accessibility && series.options.accessibility.enabled) !== false && series.visible && series.getPointsCollection().length !== 0;
      if (shouldDescribeSeries) {
        describeSeries2(series);
      } else {
        hideSeriesFromAT2(series);
      }
    });
  }
  /**
   * Get keyboard navigation handler for this component.
   * @private
   */
  getKeyboardNavigation() {
    return this.keyboardNavigation.getKeyboardNavigationHandler();
  }
  /**
   * Remove traces
   * @private
   */
  destroy() {
    this.newDataAnnouncer.destroy();
    this.keyboardNavigation.destroy();
  }
};
var SeriesComponent_default = SeriesComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/ZoomComponent.js
var { unhideChartElementFromAT: unhideChartElementFromAT8 } = ChartUtilities_default;
var { getFakeMouseEvent: getFakeMouseEvent6 } = HTMLUtilities_default;
var { attr: attr16, pick: pick55 } = Utilities_default;
function chartHasMapZoom(chart) {
  return !!(chart.mapView && chart.mapNavigation && chart.mapNavigation.navButtons.length);
}
var ZoomComponent = class extends AccessibilityComponent_default {
  constructor() {
    super(...arguments);
    this.focusedMapNavButtonIx = -1;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Initialize the component
   */
  init() {
    const component = this, chart = this.chart;
    this.proxyProvider.addGroup("zoom", "div");
    [
      "afterShowResetZoom",
      "afterApplyDrilldown",
      "drillupall"
    ].forEach((eventType) => {
      component.addEvent(chart, eventType, function() {
        component.updateProxyOverlays();
      });
    });
  }
  /**
   * Called when chart is updated
   */
  onChartUpdate() {
    const chart = this.chart, component = this;
    if (chart.mapNavigation) {
      chart.mapNavigation.navButtons.forEach((button, i) => {
        unhideChartElementFromAT8(chart, button.element);
        component.setMapNavButtonAttrs(button.element, "accessibility.zoom.mapZoom" + (i ? "Out" : "In"));
      });
    }
  }
  /**
   * @private
   * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} button
   * @param {string} labelFormatKey
   */
  setMapNavButtonAttrs(button, labelFormatKey) {
    const chart = this.chart, label = chart.langFormat(labelFormatKey, { chart });
    attr16(button, {
      tabindex: -1,
      role: "button",
      "aria-label": label
    });
  }
  /**
   * Update the proxy overlays on every new render to ensure positions are
   * correct.
   */
  onChartRender() {
    this.updateProxyOverlays();
  }
  /**
   * Update proxy overlays, recreating the buttons.
   */
  updateProxyOverlays() {
    const chart = this.chart;
    this.proxyProvider.clearGroup("zoom");
    if (chart.resetZoomButton) {
      this.createZoomProxyButton(chart.resetZoomButton, "resetZoomProxyButton", chart.langFormat("accessibility.zoom.resetZoomButton", { chart }));
    }
    if (chart.drillUpButton && chart.breadcrumbs && chart.breadcrumbs.list) {
      const lastBreadcrumb = chart.breadcrumbs.list[chart.breadcrumbs.list.length - 1];
      this.createZoomProxyButton(chart.drillUpButton, "drillUpProxyButton", chart.langFormat("accessibility.drillUpButton", {
        chart,
        buttonText: chart.breadcrumbs.getButtonText(lastBreadcrumb)
      }));
    }
  }
  /**
   * @private
   * @param {Highcharts.SVGElement} buttonEl
   * @param {string} buttonProp
   * @param {string} label
   */
  createZoomProxyButton(buttonEl, buttonProp, label) {
    this[buttonProp] = this.proxyProvider.addProxyElement("zoom", {
      click: buttonEl
    }, "button", {
      "aria-label": label,
      tabindex: -1
    });
  }
  /**
   * Get keyboard navigation handler for map zoom.
   * @private
   * @return {Highcharts.KeyboardNavigationHandler} The module object
   */
  getMapZoomNavigation() {
    const keys = this.keyCodes, chart = this.chart, component = this;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [
        [
          [keys.up, keys.down, keys.left, keys.right],
          function(keyCode) {
            return component.onMapKbdArrow(this, keyCode);
          }
        ],
        [
          [keys.tab],
          function(_keyCode, e) {
            return component.onMapKbdTab(this, e);
          }
        ],
        [
          [keys.space, keys.enter],
          function() {
            return component.onMapKbdClick(this);
          }
        ]
      ],
      validate: function() {
        return chartHasMapZoom(chart);
      },
      init: function(direction) {
        return component.onMapNavInit(direction);
      }
    });
  }
  /**
   * Arrow key panning for maps.
   * @private
   * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler The handler context.
   * @param {number} keyCode Key pressed.
   * @return {number} Response code
   */
  onMapKbdArrow(keyboardNavigationHandler, keyCode) {
    const chart = this.chart, keys = this.keyCodes, target = chart.container, isY = keyCode === keys.up || keyCode === keys.down, stepDirection = keyCode === keys.left || keyCode === keys.up ? 1 : -1, granularity = 10, diff = (isY ? chart.plotHeight : chart.plotWidth) / granularity * stepDirection, r = Math.random() * 10, startPos = {
      x: target.offsetLeft + chart.plotLeft + chart.plotWidth / 2 + r,
      y: target.offsetTop + chart.plotTop + chart.plotHeight / 2 + r
    }, endPos = isY ? { x: startPos.x, y: startPos.y + diff } : { x: startPos.x + diff, y: startPos.y };
    [
      getFakeMouseEvent6("mousedown", startPos),
      getFakeMouseEvent6("mousemove", endPos),
      getFakeMouseEvent6("mouseup", endPos)
    ].forEach((e) => target.dispatchEvent(e));
    return keyboardNavigationHandler.response.success;
  }
  /**
   * @private
   * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
   * @param {global.KeyboardEvent} event
   * @return {number} Response code
   */
  onMapKbdTab(keyboardNavigationHandler, event) {
    const chart = this.chart;
    const response = keyboardNavigationHandler.response;
    const isBackwards = event.shiftKey;
    const isMoveOutOfRange = isBackwards && !this.focusedMapNavButtonIx || !isBackwards && this.focusedMapNavButtonIx;
    chart.mapNavigation.navButtons[this.focusedMapNavButtonIx].setState(0);
    if (isMoveOutOfRange) {
      if (chart.mapView) {
        chart.mapView.zoomBy();
      }
      return response[isBackwards ? "prev" : "next"];
    }
    this.focusedMapNavButtonIx += isBackwards ? -1 : 1;
    const button = chart.mapNavigation.navButtons[this.focusedMapNavButtonIx];
    chart.setFocusToElement(button.box, button.element);
    button.setState(2);
    return response.success;
  }
  /**
   * Called on map button click.
   * @private
   * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler The handler context object
   * @return {number} Response code
   */
  onMapKbdClick(keyboardNavigationHandler) {
    const el = this.chart.mapNavigation.navButtons[this.focusedMapNavButtonIx].element;
    this.fakeClickEvent(el);
    return keyboardNavigationHandler.response.success;
  }
  /**
   * @private
   * @param {number} direction
   */
  onMapNavInit(direction) {
    const chart = this.chart, zoomIn = chart.mapNavigation.navButtons[0], zoomOut = chart.mapNavigation.navButtons[1], initialButton = direction > 0 ? zoomIn : zoomOut;
    chart.setFocusToElement(initialButton.box, initialButton.element);
    initialButton.setState(2);
    this.focusedMapNavButtonIx = direction > 0 ? 0 : 1;
  }
  /**
   * Get keyboard navigation handler for a simple chart button. Provide the
   * button reference for the chart, and a function to call on click.
   *
   * @private
   * @param {string} buttonProp The property on chart referencing the button.
   * @return {Highcharts.KeyboardNavigationHandler} The module object
   */
  simpleButtonNavigation(buttonProp, proxyProp, onClick) {
    const keys = this.keyCodes, component = this, chart = this.chart;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [
        [
          [keys.tab, keys.up, keys.down, keys.left, keys.right],
          function(keyCode, e) {
            const isBackwards = keyCode === keys.tab && e.shiftKey || keyCode === keys.left || keyCode === keys.up;
            return this.response[isBackwards ? "prev" : "next"];
          }
        ],
        [
          [keys.space, keys.enter],
          function() {
            const res = onClick(this, chart);
            return pick55(res, this.response.success);
          }
        ]
      ],
      validate: function() {
        const hasButton = chart[buttonProp] && chart[buttonProp].box && component[proxyProp].innerElement;
        return hasButton;
      },
      init: function() {
        chart.setFocusToElement(chart[buttonProp].box, component[proxyProp].innerElement);
      }
    });
  }
  /**
   * Get keyboard navigation handlers for this component.
   * @return {Array<Highcharts.KeyboardNavigationHandler>}
   *         List of module objects
   */
  getKeyboardNavigation() {
    return [
      this.simpleButtonNavigation("resetZoomButton", "resetZoomProxyButton", function(_handler, chart) {
        chart.zoomOut();
      }),
      this.simpleButtonNavigation("drillUpButton", "drillUpProxyButton", function(handler, chart) {
        chart.drillUp();
        return handler.response.prev;
      }),
      this.getMapZoomNavigation()
    ];
  }
};
var ZoomComponent_default = ZoomComponent;

// node_modules/highcharts/es-modules/Accessibility/HighContrastMode.js
var { doc: doc18, isMS: isMS2, win: win14 } = Globals_default;
function isHighContrastModeActive() {
  const isEdge = /(Edg)/.test(win14.navigator.userAgent);
  if (win14.matchMedia && isEdge) {
    return win14.matchMedia("(-ms-high-contrast: active)").matches;
  }
  if (isMS2 && win14.getComputedStyle) {
    const testDiv = doc18.createElement("div");
    const imageSrc = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    testDiv.style.backgroundImage = `url(${imageSrc})`;
    doc18.body.appendChild(testDiv);
    const bi = (testDiv.currentStyle || win14.getComputedStyle(testDiv)).backgroundImage;
    doc18.body.removeChild(testDiv);
    return bi === "none";
  }
  return win14.matchMedia && win14.matchMedia("(forced-colors: active)").matches;
}
function setHighContrastTheme(chart) {
  chart.highContrastModeActive = true;
  const theme2 = chart.options.accessibility.highContrastTheme;
  chart.update(theme2, false);
  const hasCustomColors = theme2.colors?.length > 1;
  chart.series.forEach(function(s) {
    const plotOpts = theme2.plotOptions[s.type] || {};
    const fillColor = hasCustomColors && s.colorIndex !== void 0 ? theme2.colors[s.colorIndex] : plotOpts.color || "window";
    const seriesOptions = {
      color: plotOpts.color || "windowText",
      colors: hasCustomColors ? theme2.colors : [plotOpts.color || "windowText"],
      borderColor: plotOpts.borderColor || "window",
      fillColor
    };
    s.update(seriesOptions, false);
    if (s.points) {
      s.points.forEach(function(p) {
        if (p.options && p.options.color) {
          p.update({
            color: plotOpts.color || "windowText",
            borderColor: plotOpts.borderColor || "window"
          }, false);
        }
      });
    }
  });
  chart.redraw();
}
var whcm = {
  isHighContrastModeActive,
  setHighContrastTheme
};
var HighContrastMode_default = whcm;

// node_modules/highcharts/es-modules/Accessibility/HighContrastTheme.js
var theme = {
  chart: {
    backgroundColor: "window"
  },
  title: {
    style: {
      color: "windowText"
    }
  },
  subtitle: {
    style: {
      color: "windowText"
    }
  },
  colorAxis: {
    minColor: "windowText",
    maxColor: "windowText",
    stops: [],
    dataClasses: []
  },
  colors: ["windowText"],
  xAxis: {
    gridLineColor: "windowText",
    labels: {
      style: {
        color: "windowText"
      }
    },
    lineColor: "windowText",
    minorGridLineColor: "windowText",
    tickColor: "windowText",
    title: {
      style: {
        color: "windowText"
      }
    }
  },
  yAxis: {
    gridLineColor: "windowText",
    labels: {
      style: {
        color: "windowText"
      }
    },
    lineColor: "windowText",
    minorGridLineColor: "windowText",
    tickColor: "windowText",
    title: {
      style: {
        color: "windowText"
      }
    }
  },
  tooltip: {
    backgroundColor: "window",
    borderColor: "windowText",
    style: {
      color: "windowText"
    }
  },
  plotOptions: {
    series: {
      lineColor: "windowText",
      fillColor: "window",
      borderColor: "windowText",
      edgeColor: "windowText",
      borderWidth: 1,
      dataLabels: {
        connectorColor: "windowText",
        color: "windowText",
        style: {
          color: "windowText",
          textOutline: "none"
        }
      },
      marker: {
        lineColor: "windowText",
        fillColor: "windowText"
      }
    },
    pie: {
      color: "window",
      colors: ["window"],
      borderColor: "windowText",
      borderWidth: 1
    },
    boxplot: {
      fillColor: "window"
    },
    candlestick: {
      lineColor: "windowText",
      fillColor: "window"
    },
    errorbar: {
      fillColor: "window"
    }
  },
  legend: {
    backgroundColor: "window",
    itemStyle: {
      color: "windowText"
    },
    itemHoverStyle: {
      color: "windowText"
    },
    itemHiddenStyle: {
      color: "#555"
    },
    title: {
      style: {
        color: "windowText"
      }
    }
  },
  credits: {
    style: {
      color: "windowText"
    }
  },
  drilldown: {
    activeAxisLabelStyle: {
      color: "windowText"
    },
    activeDataLabelStyle: {
      color: "windowText"
    }
  },
  navigation: {
    buttonOptions: {
      symbolStroke: "windowText",
      theme: {
        fill: "window"
      }
    }
  },
  rangeSelector: {
    buttonTheme: {
      fill: "window",
      stroke: "windowText",
      style: {
        color: "windowText"
      },
      states: {
        hover: {
          fill: "window",
          stroke: "windowText",
          style: {
            color: "windowText"
          }
        },
        select: {
          fill: "#444",
          stroke: "windowText",
          style: {
            color: "windowText"
          }
        }
      }
    },
    inputBoxBorderColor: "windowText",
    inputStyle: {
      backgroundColor: "window",
      color: "windowText"
    },
    labelStyle: {
      color: "windowText"
    }
  },
  navigator: {
    handles: {
      backgroundColor: "window",
      borderColor: "windowText"
    },
    outlineColor: "windowText",
    maskFill: "transparent",
    series: {
      color: "windowText",
      lineColor: "windowText"
    },
    xAxis: {
      gridLineColor: "windowText"
    }
  },
  scrollbar: {
    barBackgroundColor: "#444",
    barBorderColor: "windowText",
    buttonArrowColor: "windowText",
    buttonBackgroundColor: "window",
    buttonBorderColor: "windowText",
    rifleColor: "windowText",
    trackBackgroundColor: "window",
    trackBorderColor: "windowText"
  }
};
var HighContrastTheme_default = theme;

// node_modules/highcharts/es-modules/Accessibility/Options/A11yDefaults.js
var Options = {
  /**
   * Options for configuring accessibility for the chart. Requires the
   * [accessibility module](https://code.highcharts.com/modules/accessibility.js)
   * to be loaded. For a description of the module and information
   * on its features, see
   * [Highcharts Accessibility](https://www.highcharts.com/docs/accessibility/accessibility-module).
   *
   * @since        5.0.0
   * @requires     modules/accessibility
   * @optionparent accessibility
   */
  accessibility: {
    /**
     * Enable accessibility functionality for the chart. For more
     * information on how to include these features, and why this is
     * recommended, see [Highcharts Accessibility](https://www.highcharts.com/docs/accessibility/accessibility-module).
     *
     * Highcharts will by default emit a warning to the console if
     * the [accessibility module](https://code.highcharts.com/modules/accessibility.js)
     * is not loaded. Setting this option to `false` will override
     * and silence the warning.
     *
     * Once the module is loaded, setting this option to `false`
     * will disable the module for this chart.
     *
     * @since 5.0.0
     */
    enabled: true,
    /**
     * Accessibility options for the screen reader information sections
     * added before and after the chart.
     *
     * @since 8.0.0
     */
    screenReaderSection: {
      /**
       * Function to run upon clicking the "View as Data Table" link in
       * the screen reader region.
       *
       * By default Highcharts will insert and set focus to a data table
       * representation of the chart.
       *
       * @type      {Highcharts.ScreenReaderClickCallbackFunction}
       * @since 8.0.0
       * @apioption accessibility.screenReaderSection.onViewDataTableClick
       */
      /**
       * Function to run upon clicking the "Play as sound" button in
       * the screen reader region.
       *
       * By default Highcharts will call the `chart.sonify` function.
       *
       * @type      {Highcharts.ScreenReaderClickCallbackFunction}
       * @since 8.0.1
       * @apioption accessibility.screenReaderSection.onPlayAsSoundClick
       */
      /**
       * A formatter function to create the HTML contents of the hidden
       * screen reader information region before the chart. Receives one
       * argument, `chart`, referring to the chart object. Should return a
       * string with the HTML content of the region. By default this
       * returns an automatic description of the chart based on
       * [beforeChartFormat](#accessibility.screenReaderSection.beforeChartFormat).
       *
       * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Chart>}
       * @since 8.0.0
       * @apioption accessibility.screenReaderSection.beforeChartFormatter
       */
      /**
       * Format for the screen reader information region before the chart.
       * Supported HTML tags are `<h1-6>`, `<p>`, `<div>`, `<a>`, `<ul>`,
       * `<ol>`, `<li>`, and `<button>`. Attributes are not supported,
       * except for id on `<div>`, `<a>`, and `<button>`. Id is required
       * on `<a>` and `<button>` in the format `<tag id="abcd">`. Numbers,
       * lower- and uppercase letters, "-" and "#" are valid characters in
       * IDs.
       *
       * The headingTagName is an auto-detected heading (h1-h6) that
       * corresponds to the heading level below the previous heading in
       * the DOM.
       *
       * Set to empty string to remove the region altogether.
       *
       * @since 8.0.0
       */
      beforeChartFormat: "<{headingTagName}>{chartTitle}</{headingTagName}><div>{typeDescription}</div><div>{chartSubtitle}</div><div>{chartLongdesc}</div><div>{playAsSoundButton}</div><div>{viewTableButton}</div><div>{xAxisDescription}</div><div>{yAxisDescription}</div><div>{annotationsTitle}{annotationsList}</div>",
      /**
       * A formatter function to create the HTML contents of the hidden
       * screen reader information region after the chart. Analogous to
       * [beforeChartFormatter](#accessibility.screenReaderSection.beforeChartFormatter).
       *
       * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Chart>}
       * @since 8.0.0
       * @apioption accessibility.screenReaderSection.afterChartFormatter
       */
      /**
       * Format for the screen reader information region after the chart.
       * Analogous to [beforeChartFormat](#accessibility.screenReaderSection.beforeChartFormat).
       *
       * @since 8.0.0
       */
      afterChartFormat: "{endOfChartMarker}",
      /**
       * Date format to use to describe range of datetime axes.
       *
       * For an overview of the replacement codes, see
       * [dateFormat](/class-reference/Highcharts.Time#dateFormat).
       *
       * @see [point.dateFormat](#accessibility.point.dateFormat)
       *
       * @since 8.0.0
       */
      axisRangeDateFormat: "%Y-%m-%d %H:%M:%S"
    },
    /**
     * Accessibility options global to all data series. Individual series
     * can also have specific [accessibility options](#plotOptions.series.accessibility)
     * set.
     *
     * @since 8.0.0
     */
    series: {
      /**
       * Formatter function to use instead of the default for series
       * descriptions. Receives one argument, `series`, referring to the
       * series to describe. Should return a string with the description
       * of the series for a screen reader user. If `false` is returned,
       * the default formatter will be used for that series.
       *
       * @see [series.descriptionFormat](#accessibility.series.descriptionFormat)
       * @see [series.description](#plotOptions.series.description)
       *
       * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Series>}
       * @since 8.0.0
       * @apioption accessibility.series.descriptionFormatter
       */
      /**
       * Format to use for describing the data series group to assistive
       * technology - including screen readers.
       *
       * The series context and its subproperties are available under the
       * variable `{series}`, for example `{series.name}` for the series
       * name, and `{series.points.length}` for the number of data points.
       *
       * The chart context and its subproperties are available under the
       * variable `{chart}`, for example `{chart.series.length}` for the
       * number of series in the chart.
       *
       * `{seriesDescription}` refers to the automatic description of the
       * series type and number of points added by Highcharts by default.
       * `{authorDescription}` refers to the description added in
       * [series.description](#plotOptions.series.description) if one is
       * present. `{axisDescription}` refers to the description added if
       * the chart has multiple X or Y axes.
       *
       * Note that if [series.descriptionFormatter](#accessibility.series.descriptionFormatter)
       * is declared it will take precedence, and this option will be
       * overridden.
       *
       * @sample highcharts/accessibility/advanced-accessible
       *  Accessible low-medium-high chart
       *
       * @type      {string}
       * @since 10.1.0
       */
      descriptionFormat: "{seriesDescription}{authorDescription}{axisDescription}",
      /**
       * Whether or not to add series descriptions to charts with a single
       * series.
       *
       * @since 8.0.0
       */
      describeSingleSeries: false,
      /**
       * When a series contains more points than this, we no longer expose
       * information about individual points to screen readers.
       * Note that the keyboard navigation remains functional, but points
       * won't have accessible descriptions unless handled separately.
       *
       * Set to `false` to disable.
       *
       * @type  {boolean|number}
       * @since 8.0.0
       */
      pointDescriptionEnabledThreshold: 200
    },
    /**
     * Options for descriptions of individual data points.
     *
     * @since 8.0.0
     */
    point: {
      /**
       * Date format to use for points on datetime axes when describing
       * them to screen reader users.
       *
       * Defaults to the same format as in tooltip.
       *
       * For an overview of the replacement codes, see
       * [dateFormat](/class-reference/Highcharts.Time#dateFormat).
       *
       * @see [dateFormatter](#accessibility.point.dateFormatter)
       *
       * @type      {string}
       * @since 8.0.0
       * @apioption accessibility.point.dateFormat
       */
      /**
       * Formatter function to determine the date/time format used with
       * points on datetime axes when describing them to screen reader
       * users. Receives one argument, `point`, referring to the point
       * to describe. Should return a date format string compatible with
       * [dateFormat](/class-reference/Highcharts.Time#dateFormat).
       *
       * @see [dateFormat](#accessibility.point.dateFormat)
       *
       * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}
       * @since 8.0.0
       * @apioption accessibility.point.dateFormatter
       */
      /**
       * Prefix to add to the values in the point descriptions. Uses
       * [tooltip.valuePrefix](#tooltip.valuePrefix) if not defined.
       *
       * @type        {string}
       * @since 8.0.0
       * @apioption   accessibility.point.valuePrefix
       */
      /**
       * Suffix to add to the values in the point descriptions. Uses
       * [tooltip.valueSuffix](#tooltip.valueSuffix) if not defined.
       *
       * @type        {string}
       * @since 8.0.0
       * @apioption   accessibility.point.valueSuffix
       */
      /**
       * Decimals to use for the values in the point descriptions. Uses
       * [tooltip.valueDecimals](#tooltip.valueDecimals) if not defined.
       *
       * @type        {number}
       * @since 8.0.0
       * @apioption   accessibility.point.valueDecimals
       */
      /**
       * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
       * to use instead of the default for point descriptions.
       *
       * The context of the format string is the point instance.
       *
       * As opposed to [accessibility.point.valueDescriptionFormat](#accessibility.point.valueDescriptionFormat),
       * this option replaces the whole description.
       *
       * @type      {string}
       * @since 11.1.0
       * @sample highcharts/demo/advanced-accessible
       *      Description format
       * @apioption accessibility.point.descriptionFormat
       */
      /**
       * Formatter function to use instead of the default for point
       * descriptions.
       *
       * Receives one argument, `point`, referring to the point to
       * describe. Should return a string with the description of the
       * point for a screen reader user. If `false` is returned, the
       * default formatter will be used for that point.
       *
       * Note: Prefer using [accessibility.point.valueDescriptionFormat](#accessibility.point.valueDescriptionFormat)
       * instead if possible, as default functionality such as describing
       * annotations will be preserved.
       *
       * @see [accessibility.point.valueDescriptionFormat](#accessibility.point.valueDescriptionFormat)
       * @see [point.accessibility.description](#series.line.data.accessibility.description)
       *
       * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}
       * @since 8.0.0
       * @apioption accessibility.point.descriptionFormatter
       */
      /**
       * Format to use for describing the values of data points
       * to assistive technology - including screen readers.
       * The point context is available as `{point}`.
       *
       * Other available context variables include `{index}`, `{value}`, and `{xDescription}`.
       *
       * Additionally, the series name, annotation info, and
       * description added in `point.accessibility.description`
       * is added by default if relevant. To override this, use the
       * [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)
       * option.
       *
       * @see [point.accessibility.description](#series.line.data.accessibility.description)
       * @see [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)
       *
       * @type      {string}
       * @since 8.0.1
       */
      valueDescriptionFormat: "{xDescription}{separator}{value}.",
      /**
       * Whether or not to describe points with the value `null` to
       * assistive technology, such as screen readers.
       *
       * @sample {highmaps} maps/demo/all-areas-as-null
       *         Accessible map with null points
       *
       * @type      {boolean}
       * @since 10.1.0
       */
      describeNull: true
    },
    /**
     * Amount of landmarks/regions to create for screen reader users. More
     * landmarks can make navigation with screen readers easier, but can
     * be distracting if there are lots of charts on the page. Three modes
     * are available:
     *  - `all`: Adds regions for all series, legend, information
     *      region.
     *  - `one`: Adds a single landmark per chart.
     *  - `disabled`: No landmarks are added.
     *
     * @since 7.1.0
     * @validvalue ["all", "one", "disabled"]
     */
    landmarkVerbosity: "all",
    /**
     * Link the chart to an HTML element describing the contents of the
     * chart.
     *
     * It is always recommended to describe charts using visible text, to
     * improve SEO as well as accessibility for users with disabilities.
     * This option lets an HTML element with a description be linked to the
     * chart, so that screen reader users can connect the two.
     *
     * By setting this option to a string, Highcharts runs the string as an
     * HTML selector query on the entire document. If there is only a single
     * match, this element is linked to the chart. The content of the linked
     * element will be included in the chart description for screen reader
     * users.
     *
     * By default, the chart looks for an adjacent sibling element with the
     * `highcharts-description` class.
     *
     * The feature can be disabled by setting the option to an empty string,
     * or overridden by providing the
     * [accessibility.description](#accessibility.description) option.
     * Alternatively, the HTML element to link can be passed in directly as
     * an HTML node.
     *
     * If you need the description to be part of the exported image,
     * consider using the [caption](#caption) feature.
     *
     * If you need the description to be hidden visually, use the
     * [accessibility.description](#accessibility.description) option.
     *
     * @see [caption](#caption)
     * @see [description](#accessibility.description)
     * @see [typeDescription](#accessibility.typeDescription)
     *
     * @sample highcharts/accessibility/accessible-line
     *         Accessible line chart
     *
     * @type  {string|Highcharts.HTMLDOMElement}
     * @since 8.0.0
     */
    linkedDescription: '*[data-highcharts-chart="{index}"] + .highcharts-description',
    // eslint-disable-line
    /**
     * A hook for adding custom components to the accessibility module.
     * Should be an object mapping component names to instances of classes
     * inheriting from the Highcharts.AccessibilityComponent base class.
     * Remember to add the component to the
     * [keyboardNavigation.order](#accessibility.keyboardNavigation.order)
     * for the keyboard navigation to be usable.
     *
     * @sample highcharts/accessibility/custom-component
     *         Custom accessibility component
     *
     * @type      {*}
     * @since     7.1.0
     * @apioption accessibility.customComponents
     */
    /**
     * Theme to apply to the chart when Windows High Contrast Mode is
     * detected. By default, a high contrast theme matching the high
     * contrast system colors is used.
     *
     * @type      {*}
     * @since     7.1.3
     * @apioption accessibility.highContrastTheme
     */
    /**
     * Controls how [highContrastTheme](#accessibility.highContrastTheme)
     * is applied.
     *
     * The default option is `auto`, which applies the high contrast theme
     * the user's system has a high contrast theme active.
     *
     * @since 11.4.0
     */
    highContrastMode: "auto",
    /**
     * A text description of the chart.
     *
     * **Note: Prefer using [linkedDescription](#accessibility.linkedDescription)
     * or [caption](#caption.text) instead.**
     *
     * If the Accessibility module is loaded, this option is included by
     * default as a long description of the chart in the hidden screen
     * reader information region.
     *
     * Note: Since Highcharts now supports captions and linked descriptions,
     * it is preferred to define the description using those methods, as a
     * visible caption/description benefits all users. If the
     * `accessibility.description` option is defined, the linked description
     * is ignored, and the caption is hidden from screen reader users.
     *
     * @see [linkedDescription](#accessibility.linkedDescription)
     * @see [caption](#caption)
     * @see [typeDescription](#accessibility.typeDescription)
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption accessibility.description
     */
    /**
     * A text description of the chart type.
     *
     * If the Accessibility module is loaded, this will be included in the
     * description of the chart in the screen reader information region.
     *
     * Highcharts will by default attempt to guess the chart type, but for
     * more complex charts it is recommended to specify this property for
     * clarity.
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption accessibility.typeDescription
     */
    /**
     * Options for keyboard navigation.
     *
     * @declare Highcharts.KeyboardNavigationOptionsObject
     * @since   5.0.0
     */
    keyboardNavigation: {
      /**
       * Enable keyboard navigation for the chart.
       *
       * @since 5.0.0
       */
      enabled: true,
      /**
       * Options for the focus border drawn around elements while
       * navigating through them.
       *
       * @sample highcharts/accessibility/custom-focus
       *         Custom focus ring
       *
       * @declare Highcharts.KeyboardNavigationFocusBorderOptionsObject
       * @since   6.0.3
       */
      focusBorder: {
        /**
         * Enable/disable focus border for chart.
         *
         * @since 6.0.3
         */
        enabled: true,
        /**
         * Hide the browser's default focus indicator.
         *
         * @since 6.0.4
         */
        hideBrowserFocusOutline: true,
        /**
         * Style options for the focus border drawn around elements
         * while navigating through them. Note that some browsers in
         * addition draw their own borders for focused elements. These
         * automatic borders cannot be styled by Highcharts.
         *
         * In styled mode, the border is given the
         * `.highcharts-focus-border` class.
         *
         * @type    {Highcharts.CSSObject}
         * @since   6.0.3
         */
        style: {
          /** @internal */
          color: "#334eff",
          /** @internal */
          lineWidth: 2,
          /** @internal */
          borderRadius: 3
        },
        /**
         * Focus border margin around the elements.
         *
         * @since 6.0.3
         */
        margin: 2
      },
      /**
       * Order of tab navigation in the chart. Determines which elements
       * are tabbed to first. Available elements are: `series`, `zoom`,
       * `rangeSelector`, `navigator`, `chartMenu`, `legend` and `container`.
       * In addition, any custom components can be added here. Adding
       * `container` first in order will make the keyboard focus stop on
       * the chart container first, requiring the user to tab again to
       * enter the chart.
       *
       * @type  {Array<string>}
       * @since 7.1.0
       */
      order: [
        "series",
        "zoom",
        "rangeSelector",
        "navigator",
        "legend",
        "chartMenu"
      ],
      /**
       * Whether or not to wrap around when reaching the end of arrow-key
       * navigation for an element in the chart.
       * @since 7.1.0
       */
      wrapAround: true,
      /**
       * Options for the keyboard navigation of data points and series.
       *
       * @declare Highcharts.KeyboardNavigationSeriesNavigationOptionsObject
       * @since 8.0.0
       */
      seriesNavigation: {
        /**
         * Set the keyboard navigation mode for the chart. Can be
         * "normal" or "serialize". In normal mode, left/right arrow
         * keys move between points in a series, while up/down arrow
         * keys move between series. Up/down navigation acts
         * intelligently to figure out which series makes sense to move
         * to from any given point.
         *
         * In "serialize" mode, points are instead navigated as a single
         * list. Left/right behaves as in "normal" mode. Up/down arrow
         * keys will behave like left/right. This can be useful for
         * unifying navigation behavior with/without screen readers
         * enabled.
         *
         * @type       {string}
         * @default    normal
         * @since 8.0.0
         * @validvalue ["normal", "serialize"]
         * @apioption  accessibility.keyboardNavigation.seriesNavigation.mode
         */
        /**
         * Skip null points when navigating through points with the
         * keyboard. By default this is the opposite of
         * [series.nullInteraction](https://api.highcharts.com/highcharts/plotOptions.series.nullInteraction).
         *
         * @since 8.0.0
         */
        skipNullPoints: void 0,
        /**
         * When a series contains more points than this, we no longer
         * allow keyboard navigation for it.
         *
         * Set to `false` to disable.
         *
         * @type  {boolean|number}
         * @since 8.0.0
         */
        pointNavigationEnabledThreshold: false,
        /**
         * Remember which point was focused even after navigating away
         * from the series, so that when navigating back to the series
         * you start at the last focused point.
         *
         * @type  {boolean}
         * @since 10.1.0
         */
        rememberPointFocus: false
      }
    },
    /**
     * Options for announcing new data to screen reader users. Useful
     * for dynamic data applications and drilldown.
     *
     * Keep in mind that frequent announcements will not be useful to
     * users, as they won't have time to explore the new data. For these
     * applications, consider making snapshots of the data accessible, and
     * do the announcements in batches.
     *
     * @declare Highcharts.AccessibilityAnnounceNewDataOptionsObject
     * @since   7.1.0
     */
    announceNewData: {
      /**
       * Optional formatter callback for the announcement. Receives
       * up to three arguments. The first argument is always an array
       * of all series that received updates. If an announcement is
       * already queued, the series that received updates for that
       * announcement are also included in this array. The second
       * argument is provided if `chart.addSeries` was called, and
       * there is a new series. In that case, this argument is a
       * reference to the new series. The third argument, similarly,
       * is provided if `series.addPoint` was called, and there is a
       * new point. In that case, this argument is a reference to the
       * new point.
       *
       * The function should return a string with the text to announce
       * to the user. Return empty string to not announce anything.
       * Return `false` to use the default announcement format.
       *
       * @sample highcharts/accessibility/custom-dynamic
       *         High priority live alerts
       *
       * @type      {Highcharts.AccessibilityAnnouncementFormatter}
       * @apioption accessibility.announceNewData.announcementFormatter
       */
      /**
       * Enable announcing new data to screen reader users
       * @sample highcharts/accessibility/accessible-dynamic
       *         Dynamic data accessible
       */
      enabled: false,
      /**
       * Minimum interval between announcements in milliseconds. If
       * new data arrives before this amount of time has passed, it is
       * queued for announcement. If another new data event happens
       * while an announcement is queued, the queued announcement is
       * dropped, and the latest announcement is queued instead. Set
       * to 0 to allow all announcements, but be warned that frequent
       * announcements are disturbing to users.
       */
      minAnnounceInterval: 5e3,
      /**
       * Choose whether or not the announcements should interrupt the
       * screen reader. If not enabled, the user will be notified once
       * idle. It is recommended not to enable this setting unless
       * there is a specific reason to do so.
       */
      interruptUser: false
    }
  },
  /**
   * Accessibility options for a data point.
   *
   * @declare   Highcharts.PointAccessibilityOptionsObject
   * @since     7.1.0
   * @apioption series.line.data.accessibility
   */
  /**
   * Provide a description of the data point, announced to screen readers.
   *
   * @type      {string}
   * @since     7.1.0
   * @apioption series.line.data.accessibility.description
   */
  /**
   * Set to false to disable accessibility functionality for a specific point.
   * The point will not be included in keyboard navigation, and will not be
   * exposed to assistive technology.
   *
   * @type      {boolean}
   * @since 9.0.1
   * @apioption series.line.data.accessibility.enabled
   */
  /**
   * Accessibility options for a series.
   *
   * @declare    Highcharts.SeriesAccessibilityOptionsObject
   * @since      7.1.0
   * @requires   modules/accessibility
   * @apioption  plotOptions.series.accessibility
   */
  /**
   * Enable/disable accessibility functionality for a specific series.
   *
   * @type       {boolean}
   * @since      7.1.0
   * @apioption  plotOptions.series.accessibility.enabled
   */
  /**
   * Provide a description of the series, announced to screen readers.
   *
   * @type       {string}
   * @since      7.1.0
   * @apioption  plotOptions.series.accessibility.description
   */
  /**
   * Format to use for describing the data series group to assistive
   * technology - including screen readers.
   *
   * @see [series.descriptionFormat](#accessibility.series.descriptionFormat)
   * @type       {string}
   * @since 11.0.0
   * @apioption  plotOptions.series.accessibility.descriptionFormat
   */
  /**
   * Expose only the series element to screen readers, not its points.
   *
   * @type       {boolean}
   * @since      7.1.0
   * @apioption  plotOptions.series.accessibility.exposeAsGroupOnly
   */
  /**
   * Point accessibility options for a series.
   *
   * @extends    accessibility.point
   * @since 9.3.0
   * @requires   modules/accessibility
   * @apioption  plotOptions.series.accessibility.point
   */
  /**
   * Formatter function to use instead of the default for point
   * descriptions. Same as `accessibility.point.descriptionFormatter`, but
   * applies to a series instead of the whole chart.
   *
   * Note: Prefer using [accessibility.point.valueDescriptionFormat](#plotOptions.series.accessibility.point.valueDescriptionFormat)
   * instead if possible, as default functionality such as describing
   * annotations will be preserved.
   *
   * @see [accessibility.point.valueDescriptionFormat](#plotOptions.series.accessibility.point.valueDescriptionFormat)
   * @see [point.accessibility.description](#series.line.data.accessibility.description)
   * @see [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)
   *
   * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}
   * @since 9.3.0
   * @apioption plotOptions.series.accessibility.point.descriptionFormatter
   */
  /**
   * Keyboard navigation for a series
   *
   * @declare    Highcharts.SeriesAccessibilityKeyboardNavigationOptionsObject
   * @since      7.1.0
   * @apioption  plotOptions.series.accessibility.keyboardNavigation
   */
  /**
   * Enable/disable keyboard navigation support for a specific series.
   *
   * @type       {boolean}
   * @since      7.1.0
   * @apioption  plotOptions.series.accessibility.keyboardNavigation.enabled
   */
  /**
   * Accessibility options for an annotation label.
   *
   * @declare    Highcharts.AnnotationLabelAccessibilityOptionsObject
   * @since 8.0.1
   * @requires   modules/accessibility
   * @apioption  annotations.labelOptions.accessibility
   */
  /**
   * Description of an annotation label for screen readers and other assistive
   * technology.
   *
   * @type       {string}
   * @since 8.0.1
   * @apioption  annotations.labelOptions.accessibility.description
   */
  /**
   * Accessibility options for an axis. Requires the accessibility module.
   *
   * @declare    Highcharts.AxisAccessibilityOptionsObject
   * @since      7.1.0
   * @requires   modules/accessibility
   * @apioption  xAxis.accessibility
   */
  /**
   * Enable axis accessibility features, including axis information in the
   * screen reader information region. If this is disabled on the xAxis, the
   * x values are not exposed to screen readers for the individual data points
   * by default.
   *
   * @type       {boolean}
   * @since      7.1.0
   * @apioption  xAxis.accessibility.enabled
   */
  /**
   * Description for an axis to expose to screen reader users.
   *
   * @type       {string}
   * @since      7.1.0
   * @apioption  xAxis.accessibility.description
   */
  /**
   * Range description for an axis. Overrides the default range description.
   * Set to empty to disable range description for this axis.
   *
   * @type       {string}
   * @since      7.1.0
   * @apioption  xAxis.accessibility.rangeDescription
   */
  /**
   * @optionparent legend
   */
  legend: {
    /**
     * Accessibility options for the legend. Requires the Accessibility
     * module.
     *
     * @since     7.1.0
     * @requires  modules/accessibility
     */
    accessibility: {
      /**
       * Enable accessibility support for the legend.
       *
       * @since  7.1.0
       */
      enabled: true,
      /**
       * Options for keyboard navigation for the legend.
       *
       * @since     7.1.0
       * @requires  modules/accessibility
       */
      keyboardNavigation: {
        /**
         * Enable keyboard navigation for the legend.
         *
         * @see [accessibility.keyboardNavigation](#accessibility.keyboardNavigation.enabled)
         *
         * @since  7.1.0
         */
        enabled: true
      }
    }
  },
  /**
   * @optionparent exporting
   */
  exporting: {
    /**
     * Accessibility options for the exporting menu. Requires the
     * Accessibility module.
     *
     * @since    7.1.0
     * @requires modules/accessibility
     */
    accessibility: {
      /**
       * Enable accessibility support for the export menu.
       *
       * @since 7.1.0
       */
      enabled: true
    }
  },
  /**
   * @optionparent navigator
   */
  navigator: {
    /**
     * Accessibility options for the navigator. Requires the
     * Accessibility module.
     *
     * @since 11.2.0
     * @requires modules/accessibility
     */
    accessibility: {
      /**
       * Enable accessibility support for the navigator.
       *
       * @since 11.2.0
       */
      enabled: true
    }
  }
};
var A11yDefaults_default = Options;

// node_modules/highcharts/es-modules/Accessibility/Options/LangDefaults.js
var langOptions = {
  /**
   * Configure the accessibility strings in the chart. Requires the
   * [accessibility module](https://code.highcharts.com/modules/accessibility.js)
   * to be loaded. For a description of the module and information on its
   * features, see
   * [Highcharts Accessibility](https://www.highcharts.com/docs/chart-concepts/accessibility).
   *
   * The lang options use [Format Strings](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#format-strings)
   * with variables that are replaced at run time. These variables should be
   * used when available, to avoid duplicating text that is defined elsewhere.
   *
   * For more dynamic control over the accessibility functionality, see
   * [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter),
   * [accessibility.series.descriptionFormatter](#accessibility.series.descriptionFormatter),
   * and
   * [accessibility.screenReaderSection.beforeChartFormatter](#accessibility.screenReaderSection.beforeChartFormatter).
   *
   * @since        6.0.6
   * @optionparent lang.accessibility
   */
  accessibility: {
    /**
     * @deprecated 10.2.1
     * @type       {string}
     * @apioption  lang.accessibility.resetZoomButton
     */
    /**
     * Default title of the chart for assistive technology, for charts
     * without a chart title.
     */
    defaultChartTitle: "Chart",
    /**
     * Accessible label for the chart container HTML element.
     * `{title}` refers to the chart title.
     */
    chartContainerLabel: "{title}. Highcharts interactive chart.",
    /**
     * Accessible label for the chart SVG element.
     * `{chartTitle}` refers to the chart title.
     */
    svgContainerLabel: "Interactive chart",
    /**
     * Accessible label for the drill-up button.
     * `{buttonText}` refers to the visual text on the button.
     */
    drillUpButton: "{buttonText}",
    /**
     * Accessible label for the chart credits.
     * `{creditsStr}` refers to the visual text in the credits.
     */
    credits: "Chart credits: {creditsStr}",
    /**
     * Thousands separator to use when formatting numbers for screen
     * readers. Note that many screen readers will not handle space as a
     * thousands separator, and will consider "11 700" as two numbers.
     *
     * Set to `null` to use the separator defined in
     * [lang.thousandsSep](lang.thousandsSep).
     *
     * @since 7.1.0
     */
    thousandsSep: ",",
    /**
     * Title element text for the chart SVG element. Leave this
     * empty to disable adding the title element. Browsers will display
     * this content when hovering over elements in the chart. Assistive
     * technology may use this element to label the chart.
     *
     * @since 6.0.8
     */
    svgContainerTitle: "",
    /**
     * Set a label on the container wrapping the SVG.
     *
     * @see [chartContainerLabel](#lang.accessibility.chartContainerLabel)
     *
     * @since 8.0.0
     */
    graphicContainerLabel: "",
    /**
     * Language options for the screen reader information sections added
     * before and after the charts.
     *
     * @since 8.0.0
     */
    screenReaderSection: {
      beforeRegionLabel: "",
      afterRegionLabel: "",
      /**
       * Language options for annotation descriptions.
       *
       * @since 8.0.1
       */
      annotations: {
        heading: "Chart annotations summary",
        descriptionSinglePoint: "{annotationText}. Related to {annotationPoint}",
        descriptionMultiplePoints: "{annotationText}. Related to {annotationPoint}{#each additionalAnnotationPoints}, also related to {this}{/each}",
        descriptionNoPoints: "{annotationText}"
      },
      /**
       * Label for the end of the chart. Announced by screen readers.
       *
       * @since 8.0.0
       */
      endOfChartMarker: "End of interactive chart."
    },
    /**
     * Language options for sonification.
     *
     * @since 8.0.1
     */
    sonification: {
      playAsSoundButtonText: "Play as sound, {chartTitle}",
      playAsSoundClickAnnouncement: "Play"
    },
    /**
     * Language options for accessibility of the legend.
     *
     * @since 8.0.0
     */
    legend: {
      /**
       * Accessible label for the legend, for charts where there is no
       * legend title defined.
       */
      legendLabelNoTitle: "Toggle series visibility, {chartTitle}",
      /**
       * Accessible label for the legend, for charts where there is a
       * legend title defined. `{legendTitle}` refers to the visual text
       * in the legend title.
       */
      legendLabel: "Chart legend: {legendTitle}",
      /**
       * Accessible label for individual legend items. `{itemName}` refers
       * to the visual text in the legend for that item.
       */
      legendItem: "Show {itemName}"
    },
    /**
     * Chart and map zoom accessibility language options.
     *
     * @since 8.0.0
     */
    zoom: {
      mapZoomIn: "Zoom chart",
      mapZoomOut: "Zoom out chart",
      resetZoomButton: "Reset zoom"
    },
    /**
     * Range selector language options for accessibility.
     *
     * @since 8.0.0
     */
    rangeSelector: {
      dropdownLabel: "{rangeTitle}",
      minInputLabel: "Select start date.",
      maxInputLabel: "Select end date.",
      clickButtonAnnouncement: "Viewing {axisRangeDescription}"
    },
    /**
     * Navigator language options for accessibility.
     *
     * @since 11.2.0
     */
    navigator: {
      /**
       * Label for the navigator handles.
       *
       * Receives `handleIx` and `chart` as context.
       * `handleIx` refers to the index of the navigator handle.
       */
      handleLabel: "{#eq handleIx 0}Start, percent{else}End, percent{/eq}",
      /**
       * Label for the navigator region.
       *
       * Receives `chart` as context.
       */
      groupLabel: "Axis zoom",
      /**
       * Announcement for assistive technology when navigator values
       * are changed.
       *
       * Receives `axisRangeDescription` and `chart` as context.
       * `axisRangeDescription` corresponds to the range description
       * defined in [lang.accessibility.axis](#lang.accessibility.axis)
       */
      changeAnnouncement: "{axisRangeDescription}"
    },
    /**
     * Accessibility language options for the data table.
     *
     * @since 8.0.0
     */
    table: {
      viewAsDataTableButtonText: "View as data table, {chartTitle}",
      tableSummary: "Table representation of chart."
    },
    /**
     * Default announcement for new data in charts. If addPoint or
     * addSeries is used, and only one series/point is added, the
     * `newPointAnnounce` and `newSeriesAnnounce` strings are used.
     * The `...Single` versions will be used if there is only one chart
     * on the page, and the `...Multiple` versions will be used if there
     * are multiple charts on the page. For all other new data events,
     * the `newDataAnnounce` string will be used.
     *
     * @since 7.1.0
     */
    announceNewData: {
      newDataAnnounce: "Updated data for chart {chartTitle}",
      newSeriesAnnounceSingle: "New data series: {seriesDesc}",
      newPointAnnounceSingle: "New data point: {pointDesc}",
      newSeriesAnnounceMultiple: "New data series in chart {chartTitle}: {seriesDesc}",
      newPointAnnounceMultiple: "New data point in chart {chartTitle}: {pointDesc}"
    },
    /**
     * Descriptions of lesser known series types. The relevant
     * description is added to the screen reader information region
     * when these series types are used.
     *
     * @since 6.0.6
     */
    seriesTypeDescriptions: {
      boxplot: "Box plot charts are typically used to display groups of statistical data. Each data point in the chart can have up to 5 values: minimum, lower quartile, median, upper quartile, and maximum.",
      arearange: "Arearange charts are line charts displaying a range between a lower and higher value for each point.",
      areasplinerange: "These charts are line charts displaying a range between a lower and higher value for each point.",
      bubble: "Bubble charts are scatter charts where each data point also has a size value.",
      columnrange: "Columnrange charts are column charts displaying a range between a lower and higher value for each point.",
      errorbar: "Errorbar series are used to display the variability of the data.",
      funnel: "Funnel charts are used to display reduction of data in stages.",
      pyramid: "Pyramid charts consist of a single pyramid with item heights corresponding to each point value.",
      waterfall: "A waterfall chart is a column chart where each column contributes towards a total end value."
    },
    /**
     * Chart type description strings. This is added to the chart
     * information region.
     *
     * If there is only a single series type used in the chart, we use
     * the format string for the series type, or default if missing.
     * There is one format string for cases where there is only a single
     * series in the chart, and one for multiple series of the same
     * type.
     *
     * @since 6.0.6
     */
    chartTypes: {
      /* eslint-disable max-len */
      emptyChart: "Empty chart",
      mapTypeDescription: "Map of {mapTitle} with {numSeries} data series.",
      unknownMap: "Map of unspecified region with {numSeries} data series.",
      combinationChart: "Combination chart with {numSeries} data series.",
      defaultSingle: "Chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.",
      defaultMultiple: "Chart with {numSeries} data series.",
      splineSingle: "Line chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.",
      splineMultiple: "Line chart with {numSeries} lines.",
      lineSingle: "Line chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.",
      lineMultiple: "Line chart with {numSeries} lines.",
      columnSingle: "Bar chart with {numPoints} {#eq numPoints 1}bar{else}bars{/eq}.",
      columnMultiple: "Bar chart with {numSeries} data series.",
      barSingle: "Bar chart with {numPoints} {#eq numPoints 1}bar{else}bars{/eq}.",
      barMultiple: "Bar chart with {numSeries} data series.",
      pieSingle: "Pie chart with {numPoints} {#eq numPoints 1}slice{else}slices{/eq}.",
      pieMultiple: "Pie chart with {numSeries} pies.",
      scatterSingle: "Scatter chart with {numPoints} {#eq numPoints 1}point{else}points{/eq}.",
      scatterMultiple: "Scatter chart with {numSeries} data series.",
      boxplotSingle: "Boxplot with {numPoints} {#eq numPoints 1}box{else}boxes{/eq}.",
      boxplotMultiple: "Boxplot with {numSeries} data series.",
      bubbleSingle: "Bubble chart with {numPoints} {#eq numPoints 1}bubbles{else}bubble{/eq}.",
      bubbleMultiple: "Bubble chart with {numSeries} data series."
    },
    /* eslint-enable max-len */
    /**
     * Axis description format strings.
     *
     * @since 6.0.6
     */
    axis: {
      /* eslint-disable max-len */
      xAxisDescriptionSingular: "The chart has 1 X axis displaying {names[0]}. {ranges[0]}",
      xAxisDescriptionPlural: "The chart has {numAxes} X axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.",
      yAxisDescriptionSingular: "The chart has 1 Y axis displaying {names[0]}. {ranges[0]}",
      yAxisDescriptionPlural: "The chart has {numAxes} Y axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.",
      timeRangeDays: "Data range: {range} days.",
      timeRangeHours: "Data range: {range} hours.",
      timeRangeMinutes: "Data range: {range} minutes.",
      timeRangeSeconds: "Data range: {range} seconds.",
      rangeFromTo: "Data ranges from {rangeFrom} to {rangeTo}.",
      rangeCategories: "Data range: {numCategories} categories."
    },
    /* eslint-enable max-len */
    /**
     * Exporting menu format strings for accessibility module.
     *
     * @since 6.0.6
     */
    exporting: {
      chartMenuLabel: "Chart menu",
      menuButtonLabel: "View chart menu, {chartTitle}"
    },
    /**
     * Lang configuration for different series types. For more dynamic
     * control over the series element descriptions, see
     * [accessibility.seriesDescriptionFormatter](#accessibility.seriesDescriptionFormatter).
     *
     * @since 6.0.6
     */
    series: {
      /**
       * Lang configuration for the series main summary. Each series
       * type has two modes:
       *
       * 1. This series type is the only series type used in the
       *    chart
       *
       * 2. This is a combination chart with multiple series types
       *
       * If a definition does not exist for the specific series type
       * and mode, the 'default' lang definitions are used.
       *
       * Chart and its subproperties can be accessed with the `{chart}` variable.
       * The series and its subproperties can be accessed with the `{series}` variable.
       *
       * The series index (starting from 1) can be accessed with the `{seriesNumber}` variable.
       *
       * @since 6.0.6
       */
      summary: {
        /* eslint-disable max-len */
        "default": "{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
        defaultCombination: "{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
        line: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
        lineCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
        spline: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
        splineCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
        column: "{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
        columnCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
        bar: "{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
        barCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
        pie: "{series.name}, pie {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.",
        pieCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Pie with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.",
        scatter: "{series.name}, scatter plot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.",
        scatterCombination: "{series.name}, series {seriesNumber} of {chart.series.length}, scatter plot with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.",
        boxplot: "{series.name}, boxplot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.",
        boxplotCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Boxplot with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.",
        bubble: "{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
        bubbleCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
        map: "{series.name}, map {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.",
        mapCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Map with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.",
        mapline: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
        maplineCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
        mapbubble: "{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
        mapbubbleCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}."
      },
      /* eslint-enable max-len */
      /**
       * User supplied description text. This is added in the point
       * comment description by default if present.
       *
       * `{description}` refers to the value given in
       * [point.accessibility.description](#series.line.data.accessibility.description).
       *
       * @since 6.0.6
       */
      description: "{description}",
      /**
       * X-axis description for series if there are multiple xAxes in
       * the chart.
       *
       * @since 6.0.6
       */
      xAxisDescription: "X axis, {name}",
      /**
       * Y-axis description for series if there are multiple yAxes in
       * the chart.
       *
       * @since 6.0.6
       */
      yAxisDescription: "Y axis, {name}",
      /**
       * Description for the value of null points.
       *
       * @since 8.0.0
       */
      nullPointValue: "No value",
      /**
       * Description for annotations on a point, as it is made available
       * to assistive technology.
       *
       * @since 8.0.1
       */
      pointAnnotationsDescription: "{#each annotations}Annotation: {this}{/each}"
    }
  }
};
var LangDefaults_default = langOptions;

// node_modules/highcharts/es-modules/Accessibility/Options/DeprecatedOptions.js
var { error: error9, pick: pick56 } = Utilities_default;
function traverseSetOption(root, optionAsArray, val) {
  let opt = root, prop, i = 0;
  for (; i < optionAsArray.length - 1; ++i) {
    prop = optionAsArray[i];
    opt = opt[prop] = pick56(opt[prop], {});
  }
  opt[optionAsArray[optionAsArray.length - 1]] = val;
}
function deprecateFromOptionsMap(chart, rootOldAsArray, rootNewAsArray, mapToNewOptions) {
  function getChildProp(root, propAsArray) {
    return propAsArray.reduce(function(acc, cur) {
      return acc[cur];
    }, root);
  }
  const rootOld = getChildProp(chart.options, rootOldAsArray), rootNew = getChildProp(chart.options, rootNewAsArray);
  Object.keys(mapToNewOptions).forEach(function(oldOptionKey) {
    const val = rootOld[oldOptionKey];
    if (typeof val !== "undefined") {
      traverseSetOption(rootNew, mapToNewOptions[oldOptionKey], val);
      error9(32, false, chart, {
        [rootOldAsArray.join(".") + "." + oldOptionKey]: rootNewAsArray.join(".") + "." + mapToNewOptions[oldOptionKey].join(".")
      });
    }
  });
}
function copyDeprecatedChartOptions(chart) {
  const chartOptions = chart.options.chart, a11yOptions = chart.options.accessibility || {};
  ["description", "typeDescription"].forEach(function(prop) {
    if (chartOptions[prop]) {
      a11yOptions[prop] = chartOptions[prop];
      error9(32, false, chart, { [`chart.${prop}`]: `use accessibility.${prop}` });
    }
  });
}
function copyDeprecatedAxisOptions(chart) {
  chart.axes.forEach(function(axis) {
    const opts = axis.options;
    if (opts && opts.description) {
      opts.accessibility = opts.accessibility || {};
      opts.accessibility.description = opts.description;
      error9(32, false, chart, {
        "axis.description": "use axis.accessibility.description"
      });
    }
  });
}
function copyDeprecatedSeriesOptions(chart) {
  const oldToNewSeriesOptions = {
    description: ["accessibility", "description"],
    exposeElementToA11y: ["accessibility", "exposeAsGroupOnly"],
    pointDescriptionFormatter: [
      "accessibility",
      "point",
      "descriptionFormatter"
    ],
    skipKeyboardNavigation: [
      "accessibility",
      "keyboardNavigation",
      "enabled"
    ],
    "accessibility.pointDescriptionFormatter": [
      "accessibility",
      "point",
      "descriptionFormatter"
    ]
  };
  chart.series.forEach(function(series) {
    Object.keys(oldToNewSeriesOptions).forEach(function(oldOption) {
      let optionVal = series.options[oldOption];
      if (oldOption === "accessibility.pointDescriptionFormatter") {
        optionVal = series.options.accessibility && series.options.accessibility.pointDescriptionFormatter;
      }
      if (typeof optionVal !== "undefined") {
        traverseSetOption(
          series.options,
          oldToNewSeriesOptions[oldOption],
          // Note that skipKeyboardNavigation has inverted option
          // value, since we set enabled rather than disabled
          oldOption === "skipKeyboardNavigation" ? !optionVal : optionVal
        );
        error9(32, false, chart, {
          [`series.${oldOption}`]: "series." + oldToNewSeriesOptions[oldOption].join(".")
        });
      }
    });
  });
}
function copyDeprecatedTopLevelAccessibilityOptions(chart) {
  deprecateFromOptionsMap(chart, ["accessibility"], ["accessibility"], {
    pointDateFormat: ["point", "dateFormat"],
    pointDateFormatter: ["point", "dateFormatter"],
    pointDescriptionFormatter: ["point", "descriptionFormatter"],
    pointDescriptionThreshold: [
      "series",
      "pointDescriptionEnabledThreshold"
    ],
    pointNavigationThreshold: [
      "keyboardNavigation",
      "seriesNavigation",
      "pointNavigationEnabledThreshold"
    ],
    pointValueDecimals: ["point", "valueDecimals"],
    pointValuePrefix: ["point", "valuePrefix"],
    pointValueSuffix: ["point", "valueSuffix"],
    screenReaderSectionFormatter: [
      "screenReaderSection",
      "beforeChartFormatter"
    ],
    describeSingleSeries: ["series", "describeSingleSeries"],
    seriesDescriptionFormatter: ["series", "descriptionFormatter"],
    onTableAnchorClick: ["screenReaderSection", "onViewDataTableClick"],
    axisRangeDateFormat: ["screenReaderSection", "axisRangeDateFormat"]
  });
}
function copyDeprecatedKeyboardNavigationOptions(chart) {
  deprecateFromOptionsMap(chart, ["accessibility", "keyboardNavigation"], ["accessibility", "keyboardNavigation", "seriesNavigation"], {
    skipNullPoints: ["skipNullPoints"],
    mode: ["mode"]
  });
}
function copyDeprecatedLangOptions(chart) {
  deprecateFromOptionsMap(chart, ["lang", "accessibility"], ["lang", "accessibility"], {
    legendItem: ["legend", "legendItem"],
    legendLabel: ["legend", "legendLabel"],
    mapZoomIn: ["zoom", "mapZoomIn"],
    mapZoomOut: ["zoom", "mapZoomOut"],
    resetZoomButton: ["zoom", "resetZoomButton"],
    screenReaderRegionLabel: [
      "screenReaderSection",
      "beforeRegionLabel"
    ],
    rangeSelectorButton: ["rangeSelector", "buttonText"],
    rangeSelectorMaxInput: ["rangeSelector", "maxInputLabel"],
    rangeSelectorMinInput: ["rangeSelector", "minInputLabel"],
    svgContainerEnd: ["screenReaderSection", "endOfChartMarker"],
    viewAsDataTable: ["table", "viewAsDataTableButtonText"],
    tableSummary: ["table", "tableSummary"]
  });
}
function copyDeprecatedOptions(chart) {
  copyDeprecatedChartOptions(chart);
  copyDeprecatedAxisOptions(chart);
  if (chart.series) {
    copyDeprecatedSeriesOptions(chart);
  }
  copyDeprecatedTopLevelAccessibilityOptions(chart);
  copyDeprecatedKeyboardNavigationOptions(chart);
  copyDeprecatedLangOptions(chart);
}
var DeprecatedOptions_default = copyDeprecatedOptions;

// node_modules/highcharts/es-modules/Accessibility/Accessibility.js
var { defaultOptions: defaultOptions16 } = Defaults_default;
var { doc: doc19 } = Globals_default;
var { addEvent: addEvent44, extend: extend42, fireEvent: fireEvent30, merge: merge47 } = Utilities_default;
var { removeElement: removeElement4 } = HTMLUtilities_default;
var Accessibility = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart) {
    this.init(chart);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Initialize the accessibility class
   * @private
   * @param {Highcharts.Chart} chart
   *        Chart object
   */
  init(chart) {
    this.chart = chart;
    if (!doc19?.addEventListener) {
      this.zombie = true;
      this.components = {};
      chart.renderTo.setAttribute("aria-hidden", true);
      return;
    }
    DeprecatedOptions_default(chart);
    this.proxyProvider = new ProxyProvider_default(this.chart);
    this.initComponents();
    this.keyboardNavigation = new KeyboardNavigation_default(chart, this.components);
  }
  /**
   * @private
   */
  initComponents() {
    const chart = this.chart;
    const proxyProvider = this.proxyProvider;
    const a11yOptions = chart.options.accessibility;
    this.components = {
      container: new ContainerComponent_default(),
      infoRegions: new InfoRegionsComponent_default(),
      legend: new LegendComponent_default(),
      chartMenu: new MenuComponent_default(),
      rangeSelector: new RangeSelectorComponent_default(),
      series: new SeriesComponent_default(),
      zoom: new ZoomComponent_default(),
      navigator: new NavigatorComponent_default()
    };
    if (a11yOptions.customComponents) {
      extend42(this.components, a11yOptions.customComponents);
    }
    const components = this.components;
    this.getComponentOrder().forEach(function(componentName) {
      components[componentName].initBase(chart, proxyProvider);
      components[componentName].init();
    });
  }
  /**
   * Get order to update components in.
   * @private
   */
  getComponentOrder() {
    if (!this.components) {
      return [];
    }
    if (!this.components.series) {
      return Object.keys(this.components);
    }
    const componentsExceptSeries = Object.keys(this.components).filter((c) => c !== "series");
    return ["series"].concat(componentsExceptSeries);
  }
  /**
   * Update all components.
   */
  update() {
    const components = this.components, chart = this.chart, a11yOptions = chart.options.accessibility;
    fireEvent30(chart, "beforeA11yUpdate");
    chart.types = this.getChartTypes();
    const kbdNavOrder = a11yOptions.keyboardNavigation.order;
    this.proxyProvider.updateGroupOrder(kbdNavOrder);
    this.getComponentOrder().forEach(function(componentName) {
      components[componentName].onChartUpdate();
      fireEvent30(chart, "afterA11yComponentUpdate", {
        name: componentName,
        component: components[componentName]
      });
    });
    this.keyboardNavigation.update(kbdNavOrder);
    if (!chart.highContrastModeActive && a11yOptions.highContrastMode !== false && (HighContrastMode_default.isHighContrastModeActive() || a11yOptions.highContrastMode === true)) {
      HighContrastMode_default.setHighContrastTheme(chart);
    }
    fireEvent30(chart, "afterA11yUpdate", {
      accessibility: this
    });
  }
  /**
   * Destroy all elements.
   */
  destroy() {
    const chart = this.chart || {};
    const components = this.components;
    Object.keys(components).forEach(function(componentName) {
      components[componentName].destroy();
      components[componentName].destroyBase();
    });
    if (this.proxyProvider) {
      this.proxyProvider.destroy();
    }
    if (chart.announcerContainer) {
      removeElement4(chart.announcerContainer);
    }
    if (this.keyboardNavigation) {
      this.keyboardNavigation.destroy();
    }
    if (chart.renderTo) {
      chart.renderTo.setAttribute("aria-hidden", true);
    }
    if (chart.focusElement) {
      chart.focusElement.removeFocusBorder();
    }
  }
  /**
   * Return a list of the types of series we have in the chart.
   * @private
   */
  getChartTypes() {
    const types = {};
    this.chart.series.forEach(function(series) {
      types[series.type] = 1;
    });
    return Object.keys(types);
  }
};
(function(Accessibility2) {
  Accessibility2.i18nFormat = A11yI18n_default.i18nFormat;
  function chartOnDestroy() {
    if (this.accessibility) {
      this.accessibility.destroy();
    }
  }
  function chartOnRender() {
    if (this.a11yDirty && this.renderTo) {
      delete this.a11yDirty;
      this.updateA11yEnabled();
    }
    const a11y = this.accessibility;
    if (a11y && !a11y.zombie) {
      a11y.proxyProvider.updateProxyElementPositions();
      a11y.getComponentOrder().forEach(function(componentName) {
        a11y.components[componentName].onChartRender();
      });
    }
  }
  function chartOnUpdate(e) {
    const newOptions = e.options.accessibility;
    if (newOptions) {
      if (newOptions.customComponents) {
        this.options.accessibility.customComponents = newOptions.customComponents;
        delete newOptions.customComponents;
      }
      merge47(true, this.options.accessibility, newOptions);
      if (this.accessibility && this.accessibility.destroy) {
        this.accessibility.destroy();
        delete this.accessibility;
      }
    }
    this.a11yDirty = true;
  }
  function chartUpdateA11yEnabled() {
    let a11y = this.accessibility;
    const accessibilityOptions = this.options.accessibility, svg4 = this.renderer.boxWrapper.element, title = this.title;
    if (accessibilityOptions && accessibilityOptions.enabled) {
      if (a11y && !a11y.zombie) {
        a11y.update();
      } else {
        this.accessibility = a11y = new Accessibility2(this);
        if (a11y && !a11y.zombie) {
          a11y.update();
        }
        if (svg4.getAttribute("role") === "img") {
          svg4.removeAttribute("role");
        }
      }
    } else if (a11y) {
      if (a11y.destroy) {
        a11y.destroy();
      }
      delete this.accessibility;
    } else {
      this.renderTo.setAttribute("role", "img");
      this.renderTo.setAttribute("aria-hidden", false);
      this.renderTo.setAttribute("aria-label", (title && title.element.textContent || "").replace(/</g, "&lt;"));
      svg4.setAttribute("aria-hidden", true);
      const description = document.getElementsByClassName("highcharts-description")[0];
      if (description) {
        description.setAttribute("aria-hidden", false);
        description.classList.remove("highcharts-linked-description");
      }
    }
  }
  function compose27(ChartClass, LegendClass, PointClass, SeriesClass, SVGElementClass, RangeSelectorClass) {
    KeyboardNavigation_default.compose(ChartClass);
    NewDataAnnouncer_default.compose(SeriesClass);
    LegendComponent_default.compose(ChartClass, LegendClass);
    MenuComponent_default.compose(ChartClass);
    SeriesComponent_default.compose(ChartClass, PointClass, SeriesClass);
    A11yI18n_default.compose(ChartClass);
    FocusBorder_default.compose(ChartClass, SVGElementClass);
    if (RangeSelectorClass) {
      RangeSelectorComponent_default.compose(ChartClass, RangeSelectorClass);
    }
    const chartProto = ChartClass.prototype;
    if (!chartProto.updateA11yEnabled) {
      chartProto.updateA11yEnabled = chartUpdateA11yEnabled;
      addEvent44(ChartClass, "destroy", chartOnDestroy);
      addEvent44(ChartClass, "render", chartOnRender);
      addEvent44(ChartClass, "update", chartOnUpdate);
      ["addSeries", "init"].forEach((event) => {
        addEvent44(ChartClass, event, function() {
          this.a11yDirty = true;
        });
      });
      ["afterApplyDrilldown", "drillupall"].forEach((event) => {
        addEvent44(ChartClass, event, function chartOnAfterDrilldown() {
          const a11y = this.accessibility;
          if (a11y && !a11y.zombie) {
            a11y.update();
          }
        });
      });
      addEvent44(PointClass, "update", pointOnUpdate);
      ["update", "updatedData", "remove"].forEach((event) => {
        addEvent44(SeriesClass, event, function() {
          if (this.chart.accessibility) {
            this.chart.a11yDirty = true;
          }
        });
      });
    }
  }
  Accessibility2.compose = compose27;
  function pointOnUpdate() {
    if (this.series.chart.accessibility) {
      this.series.chart.a11yDirty = true;
    }
  }
})(Accessibility || (Accessibility = {}));
merge47(true, defaultOptions16, A11yDefaults_default, {
  accessibility: {
    highContrastTheme: HighContrastTheme_default
  },
  lang: LangDefaults_default
});
var Accessibility_default = Accessibility;

// node_modules/highcharts/es-modules/masters/modules/accessibility.src.js
var G6 = Globals_default;
G6.i18nFormat = Accessibility_default.i18nFormat;
G6.A11yChartUtilities = ChartUtilities_default;
G6.A11yHTMLUtilities = HTMLUtilities_default;
G6.AccessibilityComponent = AccessibilityComponent_default;
G6.KeyboardNavigationHandler = KeyboardNavigationHandler_default;
G6.SeriesAccessibilityDescriber = SeriesDescriber_default;
Accessibility_default.compose(G6.Chart, G6.Legend, G6.Point, G6.Series, G6.SVGElement, G6.RangeSelector);

// node_modules/highcharts/es-modules/Extensions/Annotations/AnnotationChart.js
var { addEvent: addEvent45, erase: erase11, find: find13, fireEvent: fireEvent31, pick: pick57, wrap: wrap3 } = Utilities_default;
function chartAddAnnotation(userOptions, redraw) {
  const annotation = this.initAnnotation(userOptions);
  this.options.annotations.push(annotation.options);
  if (pick57(redraw, true)) {
    annotation.redraw();
    annotation.graphic.attr({
      opacity: 1
    });
  }
  return annotation;
}
function chartCallback() {
  const chart = this;
  chart.plotBoxClip = this.renderer.clipRect(this.plotBox);
  chart.controlPointsGroup = chart.renderer.g("control-points").attr({ zIndex: 99 }).clip(chart.plotBoxClip).add();
  chart.options.annotations.forEach((annotationOptions, i) => {
    if (
      // Verify that it has not been previously added in a responsive rule
      !chart.annotations.some((annotation) => annotation.options === annotationOptions)
    ) {
      const annotation = chart.initAnnotation(annotationOptions);
      chart.options.annotations[i] = annotation.options;
    }
  });
  chart.drawAnnotations();
  addEvent45(chart, "redraw", chart.drawAnnotations);
  addEvent45(chart, "destroy", function() {
    chart.plotBoxClip.destroy();
    chart.controlPointsGroup.destroy();
  });
  addEvent45(chart, "exportData", function(event) {
    const annotations = chart.annotations, csvColumnHeaderFormatter = (this.options.exporting && this.options.exporting.csv || {}).columnHeaderFormatter, multiLevelHeaders = !event.dataRows[1].xValues, annotationHeader = chart.options.lang && chart.options.lang.exportData && chart.options.lang.exportData.annotationHeader, columnHeaderFormatter = function(index) {
      let s;
      if (csvColumnHeaderFormatter) {
        s = csvColumnHeaderFormatter(index);
        if (s !== false) {
          return s;
        }
      }
      s = annotationHeader + " " + index;
      if (multiLevelHeaders) {
        return {
          columnTitle: s,
          topLevelColumnTitle: s
        };
      }
      return s;
    }, startRowLength = event.dataRows[0].length, annotationSeparator = chart.options.exporting && chart.options.exporting.csv && chart.options.exporting.csv.annotations && chart.options.exporting.csv.annotations.itemDelimiter, joinAnnotations = chart.options.exporting && chart.options.exporting.csv && chart.options.exporting.csv.annotations && chart.options.exporting.csv.annotations.join;
    annotations.forEach((annotation) => {
      if (annotation.options.labelOptions && annotation.options.labelOptions.includeInDataExport) {
        annotation.labels.forEach((label) => {
          if (label.options.text) {
            const annotationText = label.options.text;
            label.points.forEach((points) => {
              const annotationX = points.x, xAxisIndex = points.series.xAxis ? points.series.xAxis.index : -1;
              let wasAdded = false;
              if (xAxisIndex === -1) {
                const n = event.dataRows[0].length, newRow = new Array(n);
                for (let i = 0; i < n; ++i) {
                  newRow[i] = "";
                }
                newRow.push(annotationText);
                newRow.xValues = [];
                newRow.xValues[xAxisIndex] = annotationX;
                event.dataRows.push(newRow);
                wasAdded = true;
              }
              if (!wasAdded) {
                event.dataRows.forEach((row) => {
                  if (!wasAdded && row.xValues && xAxisIndex !== void 0 && annotationX === row.xValues[xAxisIndex]) {
                    if (joinAnnotations && row.length > startRowLength) {
                      row[row.length - 1] += annotationSeparator + annotationText;
                    } else {
                      row.push(annotationText);
                    }
                    wasAdded = true;
                  }
                });
              }
              if (!wasAdded) {
                const n = event.dataRows[0].length, newRow = new Array(n);
                for (let i = 0; i < n; ++i) {
                  newRow[i] = "";
                }
                newRow[0] = annotationX;
                newRow.push(annotationText);
                newRow.xValues = [];
                if (xAxisIndex !== void 0) {
                  newRow.xValues[xAxisIndex] = annotationX;
                }
                event.dataRows.push(newRow);
              }
            });
          }
        });
      }
    });
    let maxRowLen = 0;
    event.dataRows.forEach((row) => {
      maxRowLen = Math.max(maxRowLen, row.length);
    });
    const newRows = maxRowLen - event.dataRows[0].length;
    for (let i = 0; i < newRows; i++) {
      const header = columnHeaderFormatter(i + 1);
      if (multiLevelHeaders) {
        event.dataRows[0].push(header.topLevelColumnTitle);
        event.dataRows[1].push(header.columnTitle);
      } else {
        event.dataRows[0].push(header);
      }
    }
  });
}
function chartDrawAnnotations() {
  this.plotBoxClip.attr(this.plotBox);
  this.annotations.forEach((annotation) => {
    annotation.redraw();
    annotation.graphic.animate({
      opacity: 1
    }, annotation.animationConfig);
  });
}
function chartRemoveAnnotation(idOrAnnotation) {
  const annotations = this.annotations, annotation = idOrAnnotation.coll === "annotations" ? idOrAnnotation : find13(annotations, function(annotation2) {
    return annotation2.options.id === idOrAnnotation;
  });
  if (annotation) {
    fireEvent31(annotation, "remove");
    erase11(this.options.annotations, annotation.options);
    erase11(annotations, annotation);
    annotation.destroy();
  }
}
function onChartAfterInit() {
  const chart = this;
  chart.annotations = [];
  if (!this.options.annotations) {
    this.options.annotations = [];
  }
}
function wrapPointerOnContainerMouseDown(proceed) {
  if (!this.chart.hasDraggedAnnotation) {
    proceed.apply(this, Array.prototype.slice.call(arguments, 1));
  }
}
var AnnotationChart;
(function(AnnotationChart2) {
  function compose27(AnnotationClass, ChartClass, PointerClass) {
    const chartProto = ChartClass.prototype;
    if (!chartProto.addAnnotation) {
      const pointerProto = PointerClass.prototype;
      addEvent45(ChartClass, "afterInit", onChartAfterInit);
      chartProto.addAnnotation = chartAddAnnotation;
      chartProto.callbacks.push(chartCallback);
      chartProto.collectionsWithInit.annotations = [chartAddAnnotation];
      chartProto.collectionsWithUpdate.push("annotations");
      chartProto.drawAnnotations = chartDrawAnnotations;
      chartProto.removeAnnotation = chartRemoveAnnotation;
      chartProto.initAnnotation = function chartInitAnnotation(userOptions) {
        const Constructor = AnnotationClass.types[userOptions.type] || AnnotationClass, annotation = new Constructor(this, userOptions);
        this.annotations.push(annotation);
        return annotation;
      };
      wrap3(pointerProto, "onContainerMouseDown", wrapPointerOnContainerMouseDown);
    }
  }
  AnnotationChart2.compose = compose27;
})(AnnotationChart || (AnnotationChart = {}));
var AnnotationChart_default = AnnotationChart;

// node_modules/highcharts/es-modules/Extensions/Annotations/AnnotationDefaults.js
var { defined: defined44 } = Utilities_default;
var AnnotationDefaults = {
  /**
   * Sets an ID for an annotation. Can be user later when
   * removing an annotation in [Chart#removeAnnotation(id)](
   * /class-reference/Highcharts.Chart#removeAnnotation) method.
   *
   * @type      {number|string}
   * @apioption annotations.id
   */
  /**
   * Whether the annotation is visible.
   *
   * @sample highcharts/annotations/visible/
   *         Set annotation visibility
   */
  visible: true,
  /**
   * Enable or disable the initial animation when a series is
   * displayed for the `annotation`. The animation can also be set
   * as a configuration object. Please note that this option only
   * applies to the initial animation.
   * For other animations, see [chart.animation](#chart.animation)
   * and the animation parameter under the API methods.
   * The following properties are supported:
   *
   * - `defer`: The animation delay time in milliseconds.
   *
   * @sample {highcharts} highcharts/annotations/defer/
   *          Animation defer settings
   * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
   * @since 8.2.0
   */
  animation: {},
  /**
   * Whether to hide the part of the annotation
   * that is outside the plot area.
   *
   * @sample highcharts/annotations/label-crop-overflow/
   *         Crop line annotation
   * @type  {boolean}
   * @since 9.3.0
   */
  crop: true,
  /**
   * The animation delay time in milliseconds.
   * Set to `0` renders annotation immediately.
   * As `undefined` inherits defer time from the [series.animation.defer](#plotOptions.series.animation.defer).
   *
   * @type      {number}
   * @since 8.2.0
   * @apioption annotations.animation.defer
   */
  /**
   * Allow an annotation to be draggable by a user. Possible
   * values are `'x'`, `'xy'`, `'y'` and `''` (disabled).
   *
   * @sample highcharts/annotations/draggable/
   *         Annotations draggable: 'xy'
   *
   * @type {Highcharts.AnnotationDraggableValue}
   */
  draggable: "xy",
  /**
   * Options for annotation's labels. Each label inherits options
   * from the labelOptions object. An option from the labelOptions
   * can be overwritten by config for a specific label.
   *
   * @requires modules/annotations
   */
  labelOptions: {
    /**
     * The alignment of the annotation's label. If right,
     * the right side of the label should be touching the point.
     *
     * @sample highcharts/annotations/label-position/
     *         Set labels position
     *
     * @type {Highcharts.AlignValue}
     */
    align: "center",
    /**
     * Whether to allow the annotation's labels to overlap.
     * To make the labels less sensitive for overlapping,
     * the can be set to 0.
     *
     * @sample highcharts/annotations/tooltip-like/
     *         Hide overlapping labels
     */
    allowOverlap: false,
    /**
     * The background color or gradient for the annotation's
     * label.
     *
     * @sample highcharts/annotations/label-presentation/
     *         Set labels graphic options
     *
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    backgroundColor: "rgba(0, 0, 0, 0.75)",
    /**
     * The border color for the annotation's label.
     *
     * @sample highcharts/annotations/label-presentation/
     *         Set labels graphic options
     *
     * @type {Highcharts.ColorString}
     */
    borderColor: "#000000",
    /**
     * The border radius in pixels for the annotation's label.
     *
     * @sample highcharts/annotations/label-presentation/
     *         Set labels graphic options
     */
    borderRadius: 3,
    /**
     * The border width in pixels for the annotation's label
     *
     * @sample highcharts/annotations/label-presentation/
     *         Set labels graphic options
     */
    borderWidth: 1,
    /**
     * A class name for styling by CSS.
     *
     * @sample highcharts/css/annotations
     *         Styled mode annotations
     *
     * @since 6.0.5
     */
    className: "highcharts-no-tooltip",
    /**
     * Whether to hide the annotation's label
     * that is outside the plot area.
     *
     * @sample highcharts/annotations/label-crop-overflow/
     *         Crop or justify labels
     */
    crop: false,
    /**
     * The label's pixel distance from the point.
     *
     * @sample highcharts/annotations/label-position/
     *         Set labels position
     *
     * @type      {number}
     * @apioption annotations.labelOptions.distance
     */
    /**
     * A
     * [format](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
     * string for the data label.
     *
     * @see [plotOptions.series.dataLabels.format](plotOptions.series.dataLabels.format.html)
     *
     * @sample highcharts/annotations/label-text/
     *         Set labels text
     *
     * @type      {string}
     * @apioption annotations.labelOptions.format
     */
    /**
     * Alias for the format option.
     *
     * @see [format](annotations.labelOptions.format.html)
     *
     * @sample highcharts/annotations/label-text/
     *         Set labels text
     *
     * @type      {string}
     * @apioption annotations.labelOptions.text
     */
    /**
     * Callback JavaScript function to format the annotation's
     * label. Note that if a `format` or `text` are defined,
     * the format or text take precedence and the formatter is
     * ignored. `This` refers to a point object.
     *
     * @sample highcharts/annotations/label-text/
     *         Set labels text
     *
     * @type    {Highcharts.FormatterCallbackFunction<Highcharts.Point>}
     * @default function () { return defined(this.y) ? this.y : 'Annotation label'; }
     */
    formatter: function() {
      return defined44(this.y) ? "" + this.y : "Annotation label";
    },
    /**
     * Whether the annotation is visible in the exported data
     * table.
     *
     * @sample highcharts/annotations/include-in-data-export/
     *         Do not include in the data export
     *
     * @since 8.2.0
     * @requires modules/export-data
     */
    includeInDataExport: true,
    /**
     * How to handle the annotation's label that flow outside
     * the plot area. The justify option aligns the label inside
     * the plot area.
     *
     * @sample highcharts/annotations/label-crop-overflow/
     *         Crop or justify labels
     *
     * @validvalue ["allow", "justify"]
     */
    overflow: "justify",
    /**
     * When either the borderWidth or the backgroundColor is
     * set, this is the padding within the box.
     *
     * @sample highcharts/annotations/label-presentation/
     *         Set labels graphic options
     */
    padding: 5,
    /**
     * The shadow of the box. The shadow can be an object
     * configuration containing `color`, `offsetX`, `offsetY`,
     * `opacity` and `width`.
     *
     * @sample highcharts/annotations/label-presentation/
     *         Set labels graphic options
     *
     * @type {boolean|Highcharts.ShadowOptionsObject}
     */
    shadow: false,
    /**
     * The name of a symbol to use for the border around the
     * label. Symbols are predefined functions on the Renderer
     * object.
     *
     * @sample highcharts/annotations/shapes/
     *         Available shapes for labels
     */
    shape: "callout",
    /**
     * Styles for the annotation's label.
     *
     * @see [plotOptions.series.dataLabels.style](plotOptions.series.dataLabels.style.html)
     *
     * @sample highcharts/annotations/label-presentation/
     *         Set labels graphic options
     *
     * @type {Highcharts.CSSObject}
     */
    style: {
      /** @ignore */
      fontSize: "0.7em",
      /** @ignore */
      fontWeight: "normal",
      /** @ignore */
      color: "contrast"
    },
    /**
     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the annotation's label.
     */
    useHTML: false,
    /**
     * The vertical alignment of the annotation's label.
     *
     * @sample highcharts/annotations/label-position/
     *         Set labels position
     *
     * @type {Highcharts.VerticalAlignValue}
     */
    verticalAlign: "bottom",
    /**
     * The x position offset of the label relative to the point.
     * Note that if a `distance` is defined, the distance takes
     * precedence over `x` and `y` options.
     *
     * @sample highcharts/annotations/label-position/
     *         Set labels position
     */
    x: 0,
    /**
     * The y position offset of the label relative to the point.
     * Note that if a `distance` is defined, the distance takes
     * precedence over `x` and `y` options.
     *
     * @sample highcharts/annotations/label-position/
     *         Set labels position
     */
    y: -16
  },
  /**
   * An array of labels for the annotation. For options that apply
   * to multiple labels, they can be added to the
   * [labelOptions](annotations.labelOptions.html).
   *
   * @type      {Array<*>}
   * @extends   annotations.labelOptions
   * @apioption annotations.labels
   */
  /**
   * This option defines the point to which the label will be
   * connected. It can be either the point which exists in the
   * series - it is referenced by the point's id - or a new point
   * with defined x, y properties and optionally axes.
   *
   * @sample highcharts/annotations/mock-point/
   *         Attach annotation to a mock point
   * @sample highcharts/annotations/mock-points/
   *         Attach annotation to a mock point with different ways
   *
   * @declare   Highcharts.AnnotationMockPointOptionsObject
   * @type      {
   *               string|
   *               Highcharts.AnnotationMockPointOptionsObject|
   *               Highcharts.AnnotationMockPointFunction
   *            }
   * @requires  modules/annotations
   * @apioption annotations.labels.point
   */
  /**
   * An array of shapes for the annotation. For options that apply
   * to multiple shapes, then can be added to the
   * [shapeOptions](annotations.shapeOptions.html).
   *
   * @type      {Array<*>}
   * @extends   annotations.shapeOptions
   * @apioption annotations.shapes
   */
  /**
   * This option defines the point to which the shape will be
   * connected. It can be either the point which exists in the
   * series - it is referenced by the point's id - or a new point
   * with defined x, y properties and optionally axes.
   *
   * @sample highcharts/annotations/mock-points/
   *         Attach annotation to a mock point with different ways
   *
   * @declare   Highcharts.AnnotationMockPointOptionsObject
   * @type      {
   *               string|
   *               Highcharts.AnnotationMockPointOptionsObject|
   *               Highcharts.AnnotationMockPointFunction
   *            }
   * @extends   annotations.labels.point
   * @requires  modules/annotations
   * @apioption annotations.shapes.point
   */
  /**
   * An array of points for the shape
   * or a callback function that returns that shape point.
   *
   * This option is available
   * for shapes which can use multiple points such as path. A
   * point can be either a point object or a point's id.
   *
   * @see [annotations.shapes.point](annotations.shapes.point.html)
   *
   * @type      {Array<Highcharts.AnnotationShapePointOptions>}
   * @extends   annotations.labels.point
   * @apioption annotations.shapes.points
   */
  /**
   * The URL for an image to use as the annotation shape. Note,
   * type has to be set to `'image'`.
   *
   * @see [annotations.shapes.type](annotations.shapes.type)
   * @sample highcharts/annotations/shape-src/
   *         Define a marker image url for annotations
   *
   * @type      {string}
   * @apioption annotations.shapes.src
   */
  /**
   * Id of the marker which will be drawn at the final vertex of
   * the path. Custom markers can be defined in defs property.
   *
   * @see [defs.markers](defs.markers.html)
   *
   * @sample highcharts/annotations/custom-markers/
   *         Define a custom marker for annotations
   *
   * @type      {string}
   * @apioption annotations.shapes.markerEnd
   */
  /**
   * Id of the marker which will be drawn at the first vertex of
   * the path. Custom markers can be defined in defs property.
   *
   * @see [defs.markers](defs.markers.html)
   *
   * @sample {highcharts} highcharts/annotations/custom-markers/
   *         Define a custom marker for annotations
   *
   * @type      {string}
   * @apioption annotations.shapes.markerStart
   */
  /**
   * Options for annotation's shapes. Each shape inherits options
   * from the shapeOptions object. An option from the shapeOptions
   * can be overwritten by config for a specific shape.
   *
   * @requires  modules/annotations
   */
  shapeOptions: {
    /**
     *
     * The radius of the shape in y direction.
     * Used for the ellipse.
     *
     * @sample highcharts/annotations/ellipse/
     *         Ellipse annotation
     *
     * @type      {number}
     * @apioption annotations.shapeOptions.ry
     **/
    /**
     *
     * The xAxis index to which the points should be attached.
     * Used for the ellipse.
     *
     * @type      {number}
     * @apioption annotations.shapeOptions.xAxis
     **/
    /**
     * The yAxis index to which the points should be attached.
     * Used for the ellipse.
     *
     * @type      {number}
     * @apioption annotations.shapeOptions.yAxis
     **/
    /**
     * The width of the shape.
     *
     * @sample highcharts/annotations/shape/
     *         Basic shape annotation
     *
     * @type      {number}
     * @apioption annotations.shapeOptions.width
     **/
    /**
     * The height of the shape.
     *
     * @sample highcharts/annotations/shape/
     *         Basic shape annotation
     *
     * @type      {number}
     * @apioption annotations.shapeOptions.height
     */
    /**
     * The type of the shape.
     * Available options are circle, rect and ellipse.
     *
     * @sample highcharts/annotations/shape/
     *         Basic shape annotation
     *
     * @sample highcharts/annotations/ellipse/
     *         Ellipse annotation
     *
     * @type      {string}
     * @default   rect
     * @apioption annotations.shapeOptions.type
     */
    /**
     * The URL for an image to use as the annotation shape.
     * Note, type has to be set to `'image'`.
     *
     * @see [annotations.shapeOptions.type](annotations.shapeOptions.type)
     * @sample highcharts/annotations/shape-src/
     *         Define a marker image url for annotations
     *
     * @type      {string}
     * @apioption annotations.shapeOptions.src
     */
    /**
     * Name of the dash style to use for the shape's stroke.
     *
     * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
     *         Possible values demonstrated
     *
     * @type      {Highcharts.DashStyleValue}
     * @apioption annotations.shapeOptions.dashStyle
     */
    /**
     * The color of the shape's stroke.
     *
     * @sample highcharts/annotations/shape/
     *         Basic shape annotation
     *
     * @type {Highcharts.ColorString}
     */
    stroke: "rgba(0, 0, 0, 0.75)",
    /**
     * The pixel stroke width of the shape.
     *
     * @sample highcharts/annotations/shape/
     *         Basic shape annotation
     */
    strokeWidth: 1,
    /**
     * The color of the shape's fill.
     *
     * @sample highcharts/annotations/shape/
     *         Basic shape annotation
     *
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    fill: "rgba(0, 0, 0, 0.75)",
    /**
     * The radius of the shape.
     *
     * @sample highcharts/annotations/shape/
     *         Basic shape annotation
     */
    r: 0,
    /**
     * Defines additional snapping area around an annotation
     * making this annotation to focus. Defined in pixels.
     */
    snap: 2
  },
  /**
   * Options for annotation's control points. Each control point
   * inherits options from controlPointOptions object.
   * Options from the controlPointOptions can be overwritten
   * by options in a specific control point.
   *
   * @declare  Highcharts.AnnotationControlPointOptionsObject
   * @requires modules/annotations
   */
  controlPointOptions: {
    /**
     * @type      {Highcharts.AnnotationControlPointPositionerFunction}
     * @apioption annotations.controlPointOptions.positioner
     */
    /**
     * @type {Highcharts.Dictionary<Function>}
     */
    events: {},
    /**
     * @type {Highcharts.SVGAttributes}
     */
    style: {
      cursor: "pointer",
      fill: "#ffffff",
      stroke: "#000000",
      "stroke-width": 2
    },
    height: 10,
    symbol: "circle",
    visible: false,
    width: 10
  },
  /**
   * Event callback when annotation is added to the chart.
   *
   * @type      {Highcharts.EventCallbackFunction<Highcharts.Annotation>}
   * @since     7.1.0
   * @apioption annotations.events.add
   */
  /**
   * Event callback when annotation is updated (e.g. drag and
   * dropped or resized by control points).
   *
   * @type      {Highcharts.EventCallbackFunction<Highcharts.Annotation>}
   * @since     7.1.0
   * @apioption annotations.events.afterUpdate
   */
  /**
   * Fires when the annotation is clicked.
   *
   * @type      {Highcharts.EventCallbackFunction<Highcharts.Annotation>}
   * @since     7.1.0
   * @apioption annotations.events.click
   */
  /**
   * Fires when the annotation is dragged.
   *
   * @type      {Highcharts.EventCallbackFunction<Highcharts.Annotation>}
   * @apioption annotations.events.drag
   */
  /**
   * Event callback when annotation is removed from the chart.
   *
   * @type      {Highcharts.EventCallbackFunction<Highcharts.Annotation>}
   * @since     7.1.0
   * @apioption annotations.events.remove
   */
  /**
   * Events available in annotations.
   *
   * @requires modules/annotations
   */
  events: {},
  /**
   * The Z index of the annotation.
   */
  zIndex: 6
};
var AnnotationDefaults_default = AnnotationDefaults;

// node_modules/highcharts/es-modules/Extensions/Annotations/EventEmitter.js
var { doc: doc20, isTouchDevice: isTouchDevice6 } = Globals_default;
var { addEvent: addEvent46, fireEvent: fireEvent32, objectEach: objectEach23, pick: pick58, removeEvent: removeEvent10 } = Utilities_default;
var EventEmitter = class {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Add emitter events.
   * @private
   */
  addEvents() {
    const emitter = this, addMouseDownEvent = function(element) {
      addEvent46(element, isTouchDevice6 ? "touchstart" : "mousedown", (e) => {
        emitter.onMouseDown(e);
      }, { passive: false });
    };
    addMouseDownEvent(this.graphic.element);
    (emitter.labels || []).forEach((label) => {
      if (label.options.useHTML && label.graphic.text && !label.graphic.text.foreignObject) {
        addMouseDownEvent(label.graphic.text.element);
      }
    });
    objectEach23(emitter.options.events, (event, type) => {
      const eventHandler = function(e) {
        if (type !== "click" || !emitter.cancelClick) {
          event.call(emitter, emitter.chart.pointer?.normalize(e), emitter.target);
        }
      };
      if ((emitter.nonDOMEvents || []).indexOf(type) === -1) {
        addEvent46(emitter.graphic.element, type, eventHandler, { passive: false });
        if (emitter.graphic.div) {
          addEvent46(emitter.graphic.div, type, eventHandler, { passive: false });
        }
      } else {
        addEvent46(emitter, type, eventHandler, { passive: false });
      }
    });
    if (emitter.options.draggable) {
      addEvent46(emitter, "drag", emitter.onDrag);
      if (!emitter.graphic.renderer.styledMode) {
        const cssPointer = {
          cursor: {
            x: "ew-resize",
            y: "ns-resize",
            xy: "move"
          }[emitter.options.draggable]
        };
        emitter.graphic.css(cssPointer);
        (emitter.labels || []).forEach((label) => {
          if (label.options.useHTML && label.graphic.text && !label.graphic.text.foreignObject) {
            label.graphic.text.css(cssPointer);
          }
        });
      }
    }
    if (!emitter.isUpdating) {
      fireEvent32(emitter, "add");
    }
  }
  /**
   * Destroy the event emitter.
   */
  destroy() {
    this.removeDocEvents();
    removeEvent10(this);
    this.hcEvents = null;
  }
  /**
   * Map mouse move event to the radians.
   * @private
   */
  mouseMoveToRadians(e, cx, cy) {
    let prevDy = e.prevChartY - cy, prevDx = e.prevChartX - cx, dy = e.chartY - cy, dx = e.chartX - cx, temp;
    if (this.chart.inverted) {
      temp = prevDx;
      prevDx = prevDy;
      prevDy = temp;
      temp = dx;
      dx = dy;
      dy = temp;
    }
    return Math.atan2(dy, dx) - Math.atan2(prevDy, prevDx);
  }
  /**
   * Map mouse move to the scale factors.
   * @private
   */
  mouseMoveToScale(e, cx, cy) {
    const prevDx = e.prevChartX - cx, prevDy = e.prevChartY - cy, dx = e.chartX - cx, dy = e.chartY - cy;
    let sx = (dx || 1) / (prevDx || 1), sy = (dy || 1) / (prevDy || 1);
    if (this.chart.inverted) {
      const temp = sy;
      sy = sx;
      sx = temp;
    }
    return {
      x: sx,
      y: sy
    };
  }
  /**
   * Map mouse move event to the distance between two following events.
   * @private
   */
  mouseMoveToTranslation(e) {
    let dx = e.chartX - e.prevChartX, dy = e.chartY - e.prevChartY, temp;
    if (this.chart.inverted) {
      temp = dy;
      dy = dx;
      dx = temp;
    }
    return {
      x: dx,
      y: dy
    };
  }
  /**
   * Drag and drop event. All basic annotations should share this
   * capability as well as the extended ones.
   * @private
   */
  onDrag(e) {
    if (this.chart.isInsidePlot(e.chartX - this.chart.plotLeft, e.chartY - this.chart.plotTop, {
      visiblePlotOnly: true
    })) {
      const translation = this.mouseMoveToTranslation(e);
      if (this.options.draggable === "x") {
        translation.y = 0;
      }
      if (this.options.draggable === "y") {
        translation.x = 0;
      }
      const emitter = this;
      if (emitter.points.length) {
        emitter.translate(translation.x, translation.y);
      } else {
        emitter.shapes.forEach((shape) => shape.translate(translation.x, translation.y));
        emitter.labels.forEach((label) => label.translate(translation.x, translation.y));
      }
      this.redraw(false);
    }
  }
  /**
   * Mouse down handler.
   * @private
   */
  onMouseDown(e) {
    if (e.preventDefault) {
      e.preventDefault();
    }
    if (e.button === 2) {
      return;
    }
    const emitter = this, pointer = emitter.chart.pointer, firesTouchEvents = e?.sourceCapabilities?.firesTouchEvents || false;
    e = pointer?.normalize(e) || e;
    let prevChartX = e.chartX, prevChartY = e.chartY;
    emitter.cancelClick = false;
    emitter.chart.hasDraggedAnnotation = true;
    emitter.removeDrag = addEvent46(doc20, isTouchDevice6 || firesTouchEvents ? "touchmove" : "mousemove", function(e2) {
      emitter.hasDragged = true;
      e2 = pointer?.normalize(e2) || e2;
      e2.prevChartX = prevChartX;
      e2.prevChartY = prevChartY;
      fireEvent32(emitter, "drag", e2);
      prevChartX = e2.chartX;
      prevChartY = e2.chartY;
    }, isTouchDevice6 || firesTouchEvents ? { passive: false } : void 0);
    emitter.removeMouseUp = addEvent46(doc20, isTouchDevice6 || firesTouchEvents ? "touchend" : "mouseup", function() {
      const annotation = pick58(emitter.target && emitter.target.annotation, emitter.target);
      if (annotation) {
        annotation.cancelClick = emitter.hasDragged;
      }
      emitter.cancelClick = emitter.hasDragged;
      emitter.chart.hasDraggedAnnotation = false;
      if (emitter.hasDragged) {
        fireEvent32(pick58(
          annotation,
          // #15952
          emitter
        ), "afterUpdate");
      }
      emitter.hasDragged = false;
      emitter.onMouseUp();
    }, isTouchDevice6 || firesTouchEvents ? { passive: false } : void 0);
  }
  /**
   * Mouse up handler.
   */
  onMouseUp() {
    this.removeDocEvents();
  }
  /**
   * Remove emitter document events.
   * @private
   */
  removeDocEvents() {
    if (this.removeDrag) {
      this.removeDrag = this.removeDrag();
    }
    if (this.removeMouseUp) {
      this.removeMouseUp = this.removeMouseUp();
    }
  }
};
var EventEmitter_default = EventEmitter;

// node_modules/highcharts/es-modules/Extensions/Annotations/ControlPoint.js
var { merge: merge48, pick: pick59 } = Utilities_default;
var ControlPoint = class extends EventEmitter_default {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart, target, options2, index) {
    super();
    this.nonDOMEvents = ["drag"];
    this.chart = chart;
    this.target = target;
    this.options = options2;
    this.index = pick59(options2.index, index);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Destroy the control point.
   * @private
   */
  destroy() {
    super.destroy();
    if (this.graphic) {
      this.graphic = this.graphic.destroy();
    }
    this.chart = null;
    this.target = null;
    this.options = null;
  }
  /**
   * Redraw the control point.
   * @private
   * @param {boolean} [animation]
   */
  redraw(animation) {
    this.graphic[animation ? "animate" : "attr"](this.options.positioner.call(this, this.target));
  }
  /**
   * Render the control point.
   * @private
   */
  render() {
    const chart = this.chart, options2 = this.options;
    this.graphic = chart.renderer.symbol(options2.symbol, 0, 0, options2.width, options2.height).add(chart.controlPointsGroup).css(options2.style);
    this.setVisibility(options2.visible);
    this.addEvents();
  }
  /**
   * Set the visibility of the control point.
   *
   * @function Highcharts.AnnotationControlPoint#setVisibility
   *
   * @param {boolean} visible
   * Visibility of the control point.
   *
   */
  setVisibility(visible) {
    this.graphic[visible ? "show" : "hide"]();
    this.options.visible = visible;
  }
  /**
   * Update the control point.
   *
   * @function Highcharts.AnnotationControlPoint#update
   *
   * @param {Partial<Highcharts.AnnotationControlPointOptionsObject>} userOptions
   * New options for the control point.
   */
  update(userOptions) {
    const chart = this.chart, target = this.target, index = this.index, options2 = merge48(true, this.options, userOptions);
    this.destroy();
    this.constructor(chart, target, options2, index);
    this.render(chart.controlPointsGroup);
    this.redraw();
  }
};
var ControlPoint_default = ControlPoint;

// node_modules/highcharts/es-modules/Extensions/Annotations/MockPoint.js
var { series: { prototype: seriesProto4 } } = SeriesRegistry_default;
var { defined: defined45, fireEvent: fireEvent33 } = Utilities_default;
var MockPoint = class _MockPoint {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * Create a mock point from a real Highcharts point.
   *
   * @private
   * @static
   *
   * @param {Highcharts.Point} point
   *
   * @return {Highcharts.AnnotationMockPoint}
   * A mock point instance.
   */
  static fromPoint(point) {
    return new _MockPoint(point.series.chart, null, {
      x: point.x,
      y: point.y,
      xAxis: point.series.xAxis,
      yAxis: point.series.yAxis
    });
  }
  /**
   * Get the pixel position from the point like object.
   *
   * @private
   * @static
   *
   * @param {Highcharts.AnnotationPointType} point
   *
   * @param {boolean} [paneCoordinates]
   *        Whether the pixel position should be relative
   *
   * @return {Highcharts.PositionObject} pixel position
   */
  static pointToPixels(point, paneCoordinates) {
    const series = point.series, chart = series.chart;
    let x = point.plotX || 0, y = point.plotY || 0, plotBox;
    if (chart.inverted) {
      if (point.mock) {
        x = point.plotY;
        y = point.plotX;
      } else {
        x = chart.plotWidth - (point.plotY || 0);
        y = chart.plotHeight - (point.plotX || 0);
      }
    }
    if (series && !paneCoordinates) {
      plotBox = series.getPlotBox();
      x += plotBox.translateX;
      y += plotBox.translateY;
    }
    return {
      x,
      y
    };
  }
  /**
   * Get fresh mock point options from the point like object.
   *
   * @private
   * @static
   *
   * @param {Highcharts.AnnotationPointType} point
   *
   * @return {Highcharts.AnnotationMockPointOptionsObject}
   * A mock point's options.
   */
  static pointToOptions(point) {
    return {
      x: point.x,
      y: point.y,
      xAxis: point.series.xAxis,
      yAxis: point.series.yAxis
    };
  }
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart, target, options2) {
    this.mock = true;
    this.point = this;
    this.series = {
      visible: true,
      chart,
      getPlotBox: seriesProto4.getPlotBox
    };
    this.target = target || null;
    this.options = options2;
    this.applyOptions(this.getOptions());
  }
  /**
   * Apply options for the point.
   * @private
   * @param {Highcharts.AnnotationMockPointOptionsObject} options
   */
  applyOptions(options2) {
    this.command = options2.command;
    this.setAxis(options2, "x");
    this.setAxis(options2, "y");
    this.refresh();
  }
  /**
   * Get the point's options.
   * @private
   * @return {Highcharts.AnnotationMockPointOptionsObject}
   * The mock point's options.
   */
  getOptions() {
    return this.hasDynamicOptions() ? this.options(this.target) : this.options;
  }
  /**
   * Check if the point has dynamic options.
   * @private
   * @return {boolean}
   * A positive flag if the point has dynamic options.
   */
  hasDynamicOptions() {
    return typeof this.options === "function";
  }
  /**
   * Check if the point is inside its pane.
   * @private
   * @return {boolean} A flag indicating whether the point is inside the pane.
   */
  isInsidePlot() {
    const plotX = this.plotX, plotY = this.plotY, xAxis2 = this.series.xAxis, yAxis2 = this.series.yAxis, e = {
      x: plotX,
      y: plotY,
      isInsidePlot: true,
      options: {}
    };
    if (xAxis2) {
      e.isInsidePlot = defined45(plotX) && plotX >= 0 && plotX <= xAxis2.len;
    }
    if (yAxis2) {
      e.isInsidePlot = e.isInsidePlot && defined45(plotY) && plotY >= 0 && plotY <= yAxis2.len;
    }
    fireEvent33(this.series.chart, "afterIsInsidePlot", e);
    return e.isInsidePlot;
  }
  /**
   * Refresh point values and coordinates based on its options.
   * @private
   */
  refresh() {
    const series = this.series, xAxis2 = series.xAxis, yAxis2 = series.yAxis, options2 = this.getOptions();
    if (xAxis2) {
      this.x = options2.x;
      this.plotX = xAxis2.toPixels(options2.x, true);
    } else {
      this.x = void 0;
      this.plotX = options2.x;
    }
    if (yAxis2) {
      this.y = options2.y;
      this.plotY = yAxis2.toPixels(options2.y, true);
    } else {
      this.y = null;
      this.plotY = options2.y;
    }
    this.isInside = this.isInsidePlot();
  }
  /**
   * Refresh point options based on its plot coordinates.
   * @private
   */
  refreshOptions() {
    const series = this.series, xAxis2 = series.xAxis, yAxis2 = series.yAxis;
    this.x = this.options.x = xAxis2 ? this.options.x = xAxis2.toValue(this.plotX, true) : this.plotX;
    this.y = this.options.y = yAxis2 ? yAxis2.toValue(this.plotY, true) : this.plotY;
  }
  /**
   * Rotate the point.
   * @private
   * @param {number} cx origin x rotation
   * @param {number} cy origin y rotation
   * @param {number} radians
   */
  rotate(cx, cy, radians) {
    if (!this.hasDynamicOptions()) {
      const cos2 = Math.cos(radians), sin2 = Math.sin(radians), x = this.plotX - cx, y = this.plotY - cy, tx = x * cos2 - y * sin2, ty = x * sin2 + y * cos2;
      this.plotX = tx + cx;
      this.plotY = ty + cy;
      this.refreshOptions();
    }
  }
  /**
   * Scale the point.
   *
   * @private
   *
   * @param {number} cx
   * Origin x transformation.
   *
   * @param {number} cy
   * Origin y transformation.
   *
   * @param {number} sx
   * Scale factor x.
   *
   * @param {number} sy
   * Scale factor y.
   */
  scale(cx, cy, sx, sy) {
    if (!this.hasDynamicOptions()) {
      const x = this.plotX * sx, y = this.plotY * sy, tx = (1 - sx) * cx, ty = (1 - sy) * cy;
      this.plotX = tx + x;
      this.plotY = ty + y;
      this.refreshOptions();
    }
  }
  /**
   * Set x or y axis.
   * @private
   * @param {Highcharts.AnnotationMockPointOptionsObject} options
   * @param {string} xOrY
   * 'x' or 'y' string literal
   */
  setAxis(options2, xOrY) {
    const axisName = xOrY + "Axis", axisOptions = options2[axisName], chart = this.series.chart;
    this.series[axisName] = typeof axisOptions === "object" ? axisOptions : defined45(axisOptions) ? chart[axisName][axisOptions] || // @todo v--- (axisName)[axisOptions] ?
    chart.get(axisOptions) : null;
  }
  /**
   * Transform the mock point to an anchor (relative position on the chart).
   * @private
   * @return {Array<number>}
   * A quadruple of numbers which denotes x, y, width and height of the box
   **/
  toAnchor() {
    const anchor = [this.plotX, this.plotY, 0, 0];
    if (this.series.chart.inverted) {
      anchor[0] = this.plotY;
      anchor[1] = this.plotX;
    }
    return anchor;
  }
  /**
   * Translate the point.
   *
   * @private
   *
   * @param {number|undefined} cx
   * Origin x transformation.
   *
   * @param {number|undefined} cy
   * Origin y transformation.
   *
   * @param {number} dx
   * Translation for x coordinate.
   *
   * @param {number} dy
   * Translation for y coordinate.
   **/
  translate(_cx, _cy, dx, dy) {
    if (!this.hasDynamicOptions()) {
      this.plotX += dx;
      this.plotY += dy;
      this.refreshOptions();
    }
  }
};
var MockPoint_default = MockPoint;

// node_modules/highcharts/es-modules/Extensions/Annotations/ControlTarget.js
var ControlTarget;
(function(ControlTarget2) {
  function addControlPoints() {
    const controlPoints = this.controlPoints, controlPointsOptions = this.options.controlPoints || [];
    controlPointsOptions.forEach((controlPointOptions, i) => {
      const options2 = Utilities_default.merge(this.options.controlPointOptions, controlPointOptions);
      if (!options2.index) {
        options2.index = i;
      }
      controlPointsOptions[i] = options2;
      controlPoints.push(new ControlPoint_default(this.chart, this, options2));
    });
  }
  function anchor(point2) {
    const plotBox = point2.series.getPlotBox(), chart = point2.series.chart, box = point2.mock ? point2.toAnchor() : chart.tooltip && chart.tooltip.getAnchor.call({
      chart: point2.series.chart
    }, point2) || [0, 0, 0, 0], anchor2 = {
      x: box[0] + (this.options.x || 0),
      y: box[1] + (this.options.y || 0),
      height: box[2] || 0,
      width: box[3] || 0
    };
    return {
      relativePosition: anchor2,
      absolutePosition: Utilities_default.merge(anchor2, {
        x: anchor2.x + (point2.mock ? plotBox.translateX : chart.plotLeft),
        y: anchor2.y + (point2.mock ? plotBox.translateY : chart.plotTop)
      })
    };
  }
  function compose27(ControlTargetClass) {
    const controlProto = ControlTargetClass.prototype;
    if (!controlProto.addControlPoints) {
      Utilities_default.merge(true, controlProto, {
        addControlPoints,
        anchor,
        destroyControlTarget,
        getPointsOptions,
        linkPoints,
        point,
        redrawControlPoints,
        renderControlPoints,
        transform,
        transformPoint,
        translate,
        translatePoint
      });
    }
  }
  ControlTarget2.compose = compose27;
  function destroyControlTarget() {
    this.controlPoints.forEach((controlPoint) => controlPoint.destroy());
    this.chart = null;
    this.controlPoints = null;
    this.points = null;
    this.options = null;
    if (this.annotation) {
      this.annotation = null;
    }
  }
  function getPointsOptions() {
    const options2 = this.options;
    return options2.points || options2.point && Utilities_default.splat(options2.point);
  }
  function linkPoints() {
    const pointsOptions = this.getPointsOptions(), points = this.points, len = pointsOptions && pointsOptions.length || 0;
    let i, point2;
    for (i = 0; i < len; i++) {
      point2 = this.point(pointsOptions[i], points[i]);
      if (!point2) {
        points.length = 0;
        return;
      }
      if (point2.mock) {
        point2.refresh();
      }
      points[i] = point2;
    }
    return points;
  }
  function point(pointOptions, point2) {
    if (pointOptions && pointOptions.series) {
      return pointOptions;
    }
    if (!point2 || point2.series === null) {
      if (Utilities_default.isObject(pointOptions)) {
        point2 = new MockPoint_default(this.chart, this, pointOptions);
      } else if (Utilities_default.isString(pointOptions)) {
        point2 = this.chart.get(pointOptions) || null;
      } else if (typeof pointOptions === "function") {
        const pointConfig = pointOptions.call(point2, this);
        point2 = pointConfig.series ? pointConfig : new MockPoint_default(this.chart, this, pointOptions);
      }
    }
    return point2;
  }
  function redrawControlPoints(animation) {
    this.controlPoints.forEach((controlPoint) => controlPoint.redraw(animation));
  }
  function renderControlPoints() {
    this.controlPoints.forEach((controlPoint) => controlPoint.render());
  }
  function transform(transformation, cx, cy, p1, p2) {
    if (this.chart.inverted) {
      const temp = cx;
      cx = cy;
      cy = temp;
    }
    this.points.forEach((_point, i) => this.transformPoint(transformation, cx, cy, p1, p2, i), this);
  }
  function transformPoint(transformation, cx, cy, p1, p2, i) {
    let point2 = this.points[i];
    if (!point2.mock) {
      point2 = this.points[i] = MockPoint_default.fromPoint(point2);
    }
    point2[transformation](cx, cy, p1, p2);
  }
  function translate(dx, dy) {
    this.transform("translate", null, null, dx, dy);
  }
  function translatePoint(dx, dy, i) {
    this.transformPoint("translate", null, null, dx, dy, i);
  }
})(ControlTarget || (ControlTarget = {}));
var ControlTarget_default = ControlTarget;

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/Controllable.js
var { merge: merge49 } = Utilities_default;
var Controllable = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(annotation, options2, index, itemType) {
    this.annotation = annotation;
    this.chart = annotation.chart;
    this.collection = itemType === "label" ? "labels" : "shapes";
    this.controlPoints = [];
    this.options = options2;
    this.points = [];
    this.index = index;
    this.itemType = itemType;
    this.init(annotation, options2, index);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Redirect attr usage on the controllable graphic element.
   * @private
   */
  attr(..._args) {
    this.graphic.attr.apply(this.graphic, arguments);
  }
  /**
   * Utility function for mapping item's options
   * to element's attribute
   * @private
   * @param {Highcharts.AnnotationsLabelsOptions|Highcharts.AnnotationsShapesOptions} options
   * @return {Highcharts.SVGAttributes}
   *         Mapped options.
   */
  attrsFromOptions(options2) {
    const map = this.constructor.attrsMap, attrs = {}, styledMode = this.chart.styledMode;
    let key, mappedKey;
    for (key in options2) {
      mappedKey = map[key];
      if (typeof map[key] !== "undefined" && (!styledMode || ["fill", "stroke", "stroke-width"].indexOf(mappedKey) === -1)) {
        attrs[mappedKey] = options2[key];
      }
    }
    return attrs;
  }
  /**
   * Destroy a controllable.
   * @private
   */
  destroy() {
    if (this.graphic) {
      this.graphic = this.graphic.destroy();
    }
    if (this.tracker) {
      this.tracker = this.tracker.destroy();
    }
    this.destroyControlTarget();
  }
  /**
   * Init the controllable
   * @private
   */
  init(annotation, options2, index) {
    this.annotation = annotation;
    this.chart = annotation.chart;
    this.options = options2;
    this.points = [];
    this.controlPoints = [];
    this.index = index;
    this.linkPoints();
    this.addControlPoints();
  }
  /**
   * Redraw a controllable.
   * @private
   */
  redraw(animation) {
    this.redrawControlPoints(animation);
  }
  /**
   * Render a controllable.
   * @private
   */
  render(_parentGroup) {
    if (this.options.className && this.graphic) {
      this.graphic.addClass(this.options.className);
    }
    this.renderControlPoints();
  }
  /**
   * Rotate a controllable.
   * @private
   * @param {number} cx
   *        Origin x rotation
   * @param {number} cy
   *        Origin y rotation
   * @param {number} radians
   **/
  rotate(cx, cy, radians) {
    this.transform("rotate", cx, cy, radians);
  }
  /**
   * Scale a controllable.
   * @private
   * @param {number} cx
   *        Origin x rotation
   * @param {number} cy
   *        Origin y rotation
   * @param {number} sx
   *        Scale factor x
   * @param {number} sy
   *        Scale factor y
   */
  scale(cx, cy, sx, sy) {
    this.transform("scale", cx, cy, sx, sy);
  }
  /**
   * Set control points' visibility.
   * @private
   */
  setControlPointsVisibility(visible) {
    this.controlPoints.forEach((controlPoint) => {
      controlPoint.setVisibility(visible);
    });
  }
  /**
   * Check if a controllable should be rendered/redrawn.
   * @private
   * @return {boolean}
   *         Whether a controllable should be drawn.
   */
  shouldBeDrawn() {
    return !!this.points.length;
  }
  /**
   * Translate shape within controllable item.
   * Replaces `controllable.translate` method.
   * @private
   * @param {number} dx
   *        Translation for x coordinate
   * @param {number} dy
   *        Translation for y coordinate
   * @param {boolean|undefined} translateSecondPoint
   *        If the shape has two points attached to it, this option allows you
   *        to translate also the second point.
   */
  translateShape(dx, dy, translateSecondPoint) {
    const chart = this.annotation.chart, shapeOptions = this.annotation.userOptions, annotationIndex = chart.annotations.indexOf(this.annotation), chartOptions = chart.options.annotations[annotationIndex];
    this.translatePoint(dx, dy, 0);
    if (translateSecondPoint) {
      this.translatePoint(dx, dy, 1);
    }
    chartOptions[this.collection][this.index].point = this.options.point;
    shapeOptions[this.collection][this.index].point = this.options.point;
  }
  /**
   * Update a controllable.
   * @private
   */
  update(newOptions) {
    const annotation = this.annotation, options2 = merge49(true, this.options, newOptions), parentGroup = this.graphic.parentGroup, Constructor = this.constructor;
    this.destroy();
    const newControllable = new Constructor(annotation, options2, this.index, this.itemType);
    merge49(true, this, newControllable);
    this.render(parentGroup);
    this.redraw();
  }
};
ControlTarget_default.compose(Controllable);
var Controllable_default = Controllable;

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/ControllableDefaults.js
var defaultMarkers = {
  /**
   * @type {Highcharts.ASTNode}
   */
  arrow: {
    tagName: "marker",
    attributes: {
      id: "arrow",
      refY: 5,
      refX: 9,
      markerWidth: 10,
      markerHeight: 10
    },
    /**
     * @type {Array<Highcharts.DefsOptions>}
     */
    children: [{
      tagName: "path",
      attributes: {
        d: "M 0 0 L 10 5 L 0 10 Z",
        // Triangle (used as an arrow)
        "stroke-width": 0
      }
    }]
  },
  /**
   * @type {Highcharts.ASTNode}
   */
  "reverse-arrow": {
    tagName: "marker",
    attributes: {
      id: "reverse-arrow",
      refY: 5,
      refX: 1,
      markerWidth: 10,
      markerHeight: 10
    },
    children: [{
      tagName: "path",
      attributes: {
        // Reverse triangle (used as an arrow)
        d: "M 0 5 L 10 0 L 10 10 Z",
        "stroke-width": 0
      }
    }]
  }
};
var ControllableDefaults = {
  defaultMarkers
};
var ControllableDefaults_default = ControllableDefaults;

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/ControllablePath.js
var { defaultMarkers: defaultMarkers2 } = ControllableDefaults_default;
var { addEvent: addEvent47, defined: defined46, extend: extend43, merge: merge50, uniqueKey: uniqueKey8 } = Utilities_default;
var markerEndSetter = createMarkerSetter("marker-end");
var markerStartSetter = createMarkerSetter("marker-start");
var TRACKER_FILL = "rgba(192,192,192," + (Globals_default.svg ? 1e-4 : 2e-3) + ")";
function createMarkerSetter(markerType) {
  return function(value) {
    this.attr(markerType, "url(#" + value + ")");
  };
}
function onChartAfterGetContainer() {
  this.options.defs = merge50(defaultMarkers2, this.options.defs || {});
}
function svgRendererAddMarker(id, markerOptions) {
  const options2 = { attributes: { id } };
  const attrs = {
    stroke: markerOptions.color || "none",
    fill: markerOptions.color || "rgba(0, 0, 0, 0.75)"
  };
  options2.children = markerOptions.children && markerOptions.children.map(function(child) {
    return merge50(attrs, child);
  });
  const ast = merge50(true, {
    attributes: {
      markerWidth: 20,
      markerHeight: 20,
      refX: 0,
      refY: 0,
      orient: "auto"
    }
  }, markerOptions, options2);
  const marker = this.definition(ast);
  marker.id = id;
  return marker;
}
var ControllablePath = class extends Controllable_default {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(ChartClass, SVGRendererClass) {
    const svgRendererProto = SVGRendererClass.prototype;
    if (!svgRendererProto.addMarker) {
      addEvent47(ChartClass, "afterGetContainer", onChartAfterGetContainer);
      svgRendererProto.addMarker = svgRendererAddMarker;
    }
  }
  /* *
   *
   *  Constructors
   *
   * */
  constructor(annotation, options2, index) {
    super(annotation, options2, index, "shape");
    this.type = "path";
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Map the controllable path to 'd' path attribute.
   *
   * @return {Highcharts.SVGPathArray|null}
   * A path's d attribute.
   */
  toD() {
    const dOption = this.options.d;
    if (dOption) {
      return typeof dOption === "function" ? dOption.call(this) : dOption;
    }
    const points = this.points, len = points.length, d = [];
    let showPath = len, point = points[0], position = showPath && this.anchor(point).absolutePosition, pointIndex = 0, command;
    if (position) {
      d.push(["M", position.x, position.y]);
      while (++pointIndex < len && showPath) {
        point = points[pointIndex];
        command = point.command || "L";
        position = this.anchor(point).absolutePosition;
        if (command === "M") {
          d.push([command, position.x, position.y]);
        } else if (command === "L") {
          d.push([command, position.x, position.y]);
        } else if (command === "Z") {
          d.push([command]);
        }
        showPath = point.series.visible;
      }
    }
    return showPath && this.graphic ? this.chart.renderer.crispLine(d, this.graphic.strokeWidth()) : null;
  }
  shouldBeDrawn() {
    return super.shouldBeDrawn() || !!this.options.d;
  }
  render(parent) {
    const options2 = this.options, attrs = this.attrsFromOptions(options2);
    this.graphic = this.annotation.chart.renderer.path([["M", 0, 0]]).attr(attrs).add(parent);
    this.tracker = this.annotation.chart.renderer.path([["M", 0, 0]]).addClass("highcharts-tracker-line").attr({
      zIndex: 2
    }).add(parent);
    if (!this.annotation.chart.styledMode) {
      this.tracker.attr({
        "stroke-linejoin": "round",
        // #1225
        stroke: TRACKER_FILL,
        fill: TRACKER_FILL,
        "stroke-width": this.graphic.strokeWidth() + options2.snap * 2
      });
    }
    super.render();
    extend43(this.graphic, { markerStartSetter, markerEndSetter });
    this.setMarkers(this);
  }
  redraw(animation) {
    if (this.graphic) {
      const d = this.toD(), action = animation ? "animate" : "attr";
      if (d) {
        this.graphic[action]({ d });
        this.tracker[action]({ d });
      } else {
        this.graphic.attr({ d: "M 0 " + -9e9 });
        this.tracker.attr({ d: "M 0 " + -9e9 });
      }
      this.graphic.placed = this.tracker.placed = !!d;
    }
    super.redraw(animation);
  }
  /**
   * Set markers.
   * @private
   * @param {Highcharts.AnnotationControllablePath} item
   */
  setMarkers(item) {
    const itemOptions = item.options, chart = item.chart, defs = chart.options.defs, fill = itemOptions.fill, color14 = defined46(fill) && fill !== "none" ? fill : itemOptions.stroke;
    const setMarker = function(markerType) {
      const markerId = itemOptions[markerType];
      let def, predefinedMarker, key, marker;
      if (markerId) {
        for (key in defs) {
          def = defs[key];
          if ((markerId === (def.attributes && def.attributes.id) || // Legacy, for
          // unit-tests/annotations/annotations-shapes
          markerId === def.id) && def.tagName === "marker") {
            predefinedMarker = def;
            break;
          }
        }
        if (predefinedMarker) {
          marker = item[markerType] = chart.renderer.addMarker((itemOptions.id || uniqueKey8()) + "-" + markerId, merge50(predefinedMarker, { color: color14 }));
          item.attr(markerType, marker.getAttribute("id"));
        }
      }
    };
    ["markerStart", "markerEnd"].forEach(setMarker);
  }
};
ControllablePath.attrsMap = {
  dashStyle: "dashstyle",
  strokeWidth: "stroke-width",
  stroke: "stroke",
  fill: "fill",
  zIndex: "zIndex"
};
var ControllablePath_default = ControllablePath;

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/ControllableRect.js
var { merge: merge51 } = Utilities_default;
var ControllableRect = class extends Controllable_default {
  /* *
   *
   *  Constructors
   *
   * */
  constructor(annotation, options2, index) {
    super(annotation, options2, index, "shape");
    this.type = "rect";
    this.translate = super.translateShape;
  }
  /* *
   *
   *  Functions
   *
   * */
  render(parent) {
    const attrs = this.attrsFromOptions(this.options);
    this.graphic = this.annotation.chart.renderer.rect(0, -9e9, 0, 0).attr(attrs).add(parent);
    super.render();
  }
  redraw(animation) {
    if (this.graphic) {
      const position = this.anchor(this.points[0]).absolutePosition;
      if (position) {
        this.graphic[animation ? "animate" : "attr"]({
          x: position.x,
          y: position.y,
          width: this.options.width,
          height: this.options.height
        });
      } else {
        this.attr({
          x: 0,
          y: -9e9
        });
      }
      this.graphic.placed = Boolean(position);
    }
    super.redraw(animation);
  }
};
ControllableRect.attrsMap = merge51(ControllablePath_default.attrsMap, {
  width: "width",
  height: "height"
});
var ControllableRect_default = ControllableRect;

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/ControllableCircle.js
var { merge: merge52 } = Utilities_default;
var ControllableCircle = class extends Controllable_default {
  /* *
   *
   *  Constructors
   *
   * */
  constructor(annotation, options2, index) {
    super(annotation, options2, index, "shape");
    this.type = "circle";
    this.translate = super.translateShape;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  redraw(animation) {
    if (this.graphic) {
      const position = this.anchor(this.points[0]).absolutePosition;
      if (position) {
        this.graphic[animation ? "animate" : "attr"]({
          x: position.x,
          y: position.y,
          r: this.options.r
        });
      } else {
        this.graphic.attr({
          x: 0,
          y: -9e9
        });
      }
      this.graphic.placed = !!position;
    }
    super.redraw.call(this, animation);
  }
  /**
   * @private
   */
  render(parent) {
    const attrs = this.attrsFromOptions(this.options);
    this.graphic = this.annotation.chart.renderer.circle(0, -9e9, 0).attr(attrs).add(parent);
    super.render();
  }
  /**
   * Set the radius.
   * @private
   * @param {number} r
   *        A radius to be set
   */
  setRadius(r) {
    this.options.r = r;
  }
};
ControllableCircle.attrsMap = merge52(ControllablePath_default.attrsMap, { r: "r" });
var ControllableCircle_default = ControllableCircle;

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/ControllableEllipse.js
var { merge: merge53, defined: defined47 } = Utilities_default;
var ControllableEllipse = class extends Controllable_default {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(annotation, options2, index) {
    super(annotation, options2, index, "shape");
    this.type = "ellipse";
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  init(annotation, options2, index) {
    if (defined47(options2.yAxis)) {
      options2.points.forEach((point) => {
        point.yAxis = options2.yAxis;
      });
    }
    if (defined47(options2.xAxis)) {
      options2.points.forEach((point) => {
        point.xAxis = options2.xAxis;
      });
    }
    super.init(annotation, options2, index);
  }
  /**
   * Render the element
   * @private
   * @param parent
   *        Parent SVG element.
   */
  render(parent) {
    this.graphic = this.annotation.chart.renderer.createElement("ellipse").attr(this.attrsFromOptions(this.options)).add(parent);
    super.render();
  }
  /**
   * Translate the points. Mostly used to handle dragging of the ellipse.
   * @private
   */
  translate(dx, dy) {
    super.translateShape(dx, dy, true);
  }
  /**
   * Get the distance from the line to the point.
   * @private
   * @param point1
   *        First point which is on the line
   * @param point2
   *        Second point
   * @param x0
   *        Point's x value from which you want to calculate the distance from
   * @param y0
   *        Point's y value from which you want to calculate the distance from
   */
  getDistanceFromLine(point1, point2, x0, y0) {
    return Math.abs((point2.y - point1.y) * x0 - (point2.x - point1.x) * y0 + point2.x * point1.y - point2.y * point1.x) / Math.sqrt((point2.y - point1.y) * (point2.y - point1.y) + (point2.x - point1.x) * (point2.x - point1.x));
  }
  /**
   * The function calculates the svg attributes of the ellipse, and returns
   * all parameters necessary to draw the ellipse.
   * @private
   * @param position
   *        Absolute position of the first point in points array
   * @param position2
   *        Absolute position of the second point in points array
   */
  getAttrs(position, position2) {
    const x1 = position.x, y1 = position.y, x2 = position2.x, y2 = position2.y, cx = (x1 + x2) / 2, cy = (y1 + y2) / 2, rx = Math.sqrt((x1 - x2) * (x1 - x2) / 4 + (y1 - y2) * (y1 - y2) / 4), tan = (y2 - y1) / (x2 - x1);
    let angle = Math.atan(tan) * 180 / Math.PI;
    if (cx < x1) {
      angle += 180;
    }
    const ry = this.getRY();
    return { cx, cy, rx, ry, angle };
  }
  /**
   * Get the value of minor radius of the ellipse.
   * @private
   */
  getRY() {
    const yAxis2 = this.getYAxis();
    return defined47(yAxis2) ? Math.abs(yAxis2.toPixels(this.options.ry) - yAxis2.toPixels(0)) : this.options.ry;
  }
  /**
   * Get the yAxis object to which the ellipse is pinned.
   * @private
   */
  getYAxis() {
    const yAxisIndex = this.options.yAxis;
    return this.chart.yAxis[yAxisIndex];
  }
  /**
   * Get the absolute coordinates of the MockPoint
   * @private
   * @param point
   *        MockPoint that is added through options
   */
  getAbsolutePosition(point) {
    return this.anchor(point).absolutePosition;
  }
  /**
   * Redraw the element
   * @private
   * @param animation
   *        Display an animation
   */
  redraw(animation) {
    if (this.graphic) {
      const position = this.getAbsolutePosition(this.points[0]), position2 = this.getAbsolutePosition(this.points[1]), attrs = this.getAttrs(position, position2);
      if (position) {
        this.graphic[animation ? "animate" : "attr"]({
          cx: attrs.cx,
          cy: attrs.cy,
          rx: attrs.rx,
          ry: attrs.ry,
          rotation: attrs.angle,
          rotationOriginX: attrs.cx,
          rotationOriginY: attrs.cy
        });
      } else {
        this.graphic.attr({
          x: 0,
          y: -9e9
        });
      }
      this.graphic.placed = Boolean(position);
    }
    super.redraw(animation);
  }
  /**
   * Set the radius Y.
   * @private
   * @param {number} ry
   *        A radius in y direction to be set
   */
  setYRadius(ry) {
    const shapes = this.annotation.userOptions.shapes;
    this.options.ry = ry;
    if (shapes && shapes[0]) {
      shapes[0].ry = ry;
      shapes[0].ry = ry;
    }
  }
};
ControllableEllipse.attrsMap = merge53(ControllablePath_default.attrsMap, {
  ry: "ry"
});
var ControllableEllipse_default = ControllableEllipse;

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/ControllableLabel.js
var { format: format15 } = Templating_default;
var { extend: extend44, getAlignFactor: getAlignFactor11, isNumber: isNumber42, pick: pick60 } = Utilities_default;
function symbolConnector(x, y, w, h, options2) {
  const anchorX = options2 && options2.anchorX, anchorY = options2 && options2.anchorY;
  let path, yOffset, lateral = w / 2;
  if (isNumber42(anchorX) && isNumber42(anchorY)) {
    path = [["M", anchorX, anchorY]];
    yOffset = y - anchorY;
    if (yOffset < 0) {
      yOffset = -h - yOffset;
    }
    if (yOffset < w) {
      lateral = anchorX < x + w / 2 ? yOffset : w - yOffset;
    }
    if (anchorY > y + h) {
      path.push(["L", x + lateral, y + h]);
    } else if (anchorY < y) {
      path.push(["L", x + lateral, y]);
    } else if (anchorX < x) {
      path.push(["L", x, y + h / 2]);
    } else if (anchorX > x + w) {
      path.push(["L", x + w, y + h / 2]);
    }
  }
  return path || [];
}
var ControllableLabel = class _ControllableLabel extends Controllable_default {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * Returns new aligned position based alignment options and box to align to.
   * It is almost a one-to-one copy from SVGElement.prototype.align
   * except it does not use and mutate an element
   *
   * @param {Highcharts.AnnotationAlignObject} alignOptions
   *
   * @param {Highcharts.BBoxObject} box
   *
   * @return {Highcharts.PositionObject}
   * Aligned position.
   */
  static alignedPosition(alignOptions, box) {
    return {
      x: Math.round((box.x || 0) + (alignOptions.x || 0) + (box.width - (alignOptions.width || 0)) * getAlignFactor11(alignOptions.align)),
      y: Math.round((box.y || 0) + (alignOptions.y || 0) + (box.height - (alignOptions.height || 0)) * getAlignFactor11(alignOptions.verticalAlign))
    };
  }
  static compose(SVGRendererClass) {
    const symbols3 = SVGRendererClass.prototype.symbols;
    symbols3.connector = symbolConnector;
  }
  /**
   * Returns new alignment options for a label if the label is outside the
   * plot area. It is almost a one-to-one copy from
   * Series.prototype.justifyDataLabel except it does not mutate the label and
   * it works with absolute instead of relative position.
   */
  static justifiedOptions(chart, label, alignOptions, alignAttr) {
    const align = alignOptions.align, verticalAlign = alignOptions.verticalAlign, padding = label.box ? 0 : label.padding || 0, bBox = label.getBBox(), options2 = {
      align,
      verticalAlign,
      x: alignOptions.x,
      y: alignOptions.y,
      width: label.width,
      height: label.height
    }, x = (alignAttr.x || 0) - chart.plotLeft, y = (alignAttr.y || 0) - chart.plotTop;
    let off;
    off = x + padding;
    if (off < 0) {
      if (align === "right") {
        options2.align = "left";
      } else {
        options2.x = (options2.x || 0) - off;
      }
    }
    off = x + bBox.width - padding;
    if (off > chart.plotWidth) {
      if (align === "left") {
        options2.align = "right";
      } else {
        options2.x = (options2.x || 0) + chart.plotWidth - off;
      }
    }
    off = y + padding;
    if (off < 0) {
      if (verticalAlign === "bottom") {
        options2.verticalAlign = "top";
      } else {
        options2.y = (options2.y || 0) - off;
      }
    }
    off = y + bBox.height - padding;
    if (off > chart.plotHeight) {
      if (verticalAlign === "top") {
        options2.verticalAlign = "bottom";
      } else {
        options2.y = (options2.y || 0) + chart.plotHeight - off;
      }
    }
    return options2;
  }
  /* *
   *
   *  Constructors
   *
   * */
  constructor(annotation, options2, index) {
    super(annotation, options2, index, "label");
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Translate the point of the label by deltaX and deltaY translations.
   * The point is the label's anchor.
   *
   * @param {number} dx translation for x coordinate
   * @param {number} dy translation for y coordinate
   */
  translatePoint(dx, dy) {
    super.translatePoint(dx, dy, 0);
  }
  /**
   * Translate x and y position relative to the label's anchor.
   *
   * @param {number} dx translation for x coordinate
   * @param {number} dy translation for y coordinate
   */
  translate(dx, dy) {
    const chart = this.annotation.chart, labelOptions = this.annotation.userOptions, annotationIndex = chart.annotations.indexOf(this.annotation), chartAnnotations = chart.options.annotations, chartOptions = chartAnnotations[annotationIndex];
    if (chart.inverted) {
      const temp = dx;
      dx = dy;
      dy = temp;
    }
    this.options.x += dx;
    this.options.y += dy;
    chartOptions[this.collection][this.index].x = this.options.x;
    chartOptions[this.collection][this.index].y = this.options.y;
    labelOptions[this.collection][this.index].x = this.options.x;
    labelOptions[this.collection][this.index].y = this.options.y;
  }
  render(parent) {
    const options2 = this.options, attrs = this.attrsFromOptions(options2), style = options2.style;
    this.graphic = this.annotation.chart.renderer.label(
      "",
      0,
      -9999,
      // #10055
      options2.shape,
      null,
      null,
      options2.useHTML,
      null,
      "annotation-label"
    ).attr(attrs).add(parent);
    if (!this.annotation.chart.styledMode) {
      if (style.color === "contrast") {
        style.color = this.annotation.chart.renderer.getContrast(_ControllableLabel.shapesWithoutBackground.indexOf(options2.shape) > -1 ? "#FFFFFF" : options2.backgroundColor);
      }
      this.graphic.css(options2.style).shadow(options2.shadow);
    }
    this.graphic.labelrank = options2.labelrank;
    super.render();
  }
  redraw(animation) {
    const options2 = this.options, text = this.text || options2.format || options2.text, label = this.graphic, point = this.points[0];
    if (!label) {
      this.redraw(animation);
      return;
    }
    label.attr({
      text: text ? format15(String(text), point, this.annotation.chart) : options2.formatter.call(point, this)
    });
    const anchor = this.anchor(point);
    const attrs = this.position(anchor);
    if (attrs) {
      label.alignAttr = attrs;
      attrs.anchorX = anchor.absolutePosition.x;
      attrs.anchorY = anchor.absolutePosition.y;
      label[animation ? "animate" : "attr"](attrs);
    } else {
      label.attr({
        x: 0,
        y: -9999
        // #10055
      });
    }
    label.placed = !!attrs;
    super.redraw(animation);
  }
  /**
   * All basic shapes don't support alignTo() method except label.
   * For a controllable label, we need to subtract translation from
   * options.
   */
  anchor(_point) {
    const anchor = super.anchor.apply(this, arguments), x = this.options.x || 0, y = this.options.y || 0;
    anchor.absolutePosition.x -= x;
    anchor.absolutePosition.y -= y;
    anchor.relativePosition.x -= x;
    anchor.relativePosition.y -= y;
    return anchor;
  }
  /**
   * Returns the label position relative to its anchor.
   */
  position(anchor) {
    const item = this.graphic, chart = this.annotation.chart, tooltip = chart.tooltip, point = this.points[0], itemOptions = this.options, anchorAbsolutePosition = anchor.absolutePosition, anchorRelativePosition = anchor.relativePosition;
    let itemPosition, alignTo, itemPosRelativeX, itemPosRelativeY, showItem = point.series.visible && MockPoint_default.prototype.isInsidePlot.call(point);
    if (item && showItem) {
      const { width = 0, height = 0 } = item;
      if (itemOptions.distance && tooltip) {
        itemPosition = tooltip.getPosition.call({
          chart,
          distance: pick60(itemOptions.distance, 16),
          getPlayingField: tooltip.getPlayingField,
          pointer: tooltip.pointer
        }, width, height, {
          plotX: anchorRelativePosition.x,
          plotY: anchorRelativePosition.y,
          negative: point.negative,
          ttBelow: point.ttBelow,
          h: anchorRelativePosition.height || anchorRelativePosition.width
        });
      } else if (itemOptions.positioner) {
        itemPosition = itemOptions.positioner.call(this);
      } else {
        alignTo = {
          x: anchorAbsolutePosition.x,
          y: anchorAbsolutePosition.y,
          width: 0,
          height: 0
        };
        itemPosition = _ControllableLabel.alignedPosition(extend44(itemOptions, {
          width,
          height
        }), alignTo);
        if (this.options.overflow === "justify") {
          itemPosition = _ControllableLabel.alignedPosition(_ControllableLabel.justifiedOptions(chart, item, itemOptions, itemPosition), alignTo);
        }
      }
      if (itemOptions.crop) {
        itemPosRelativeX = itemPosition.x - chart.plotLeft;
        itemPosRelativeY = itemPosition.y - chart.plotTop;
        showItem = chart.isInsidePlot(itemPosRelativeX, itemPosRelativeY) && chart.isInsidePlot(itemPosRelativeX + width, itemPosRelativeY + height);
      }
    }
    return showItem ? itemPosition : null;
  }
};
ControllableLabel.attrsMap = {
  backgroundColor: "fill",
  borderColor: "stroke",
  borderWidth: "stroke-width",
  zIndex: "zIndex",
  borderRadius: "r",
  padding: "padding"
};
ControllableLabel.shapesWithoutBackground = ["connector"];
var ControllableLabel_default = ControllableLabel;

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/ControllableImage.js
var ControllableImage = class extends Controllable_default {
  /* *
   *
   *  Constructors
   *
   * */
  constructor(annotation, options2, index) {
    super(annotation, options2, index, "shape");
    this.type = "image";
    this.translate = super.translateShape;
  }
  render(parent) {
    const attrs = this.attrsFromOptions(this.options), options2 = this.options;
    this.graphic = this.annotation.chart.renderer.image(options2.src, 0, -9e9, options2.width, options2.height).attr(attrs).add(parent);
    this.graphic.width = options2.width;
    this.graphic.height = options2.height;
    super.render();
  }
  redraw(animation) {
    if (this.graphic) {
      const anchor = this.anchor(this.points[0]), position = ControllableLabel_default.prototype.position.call(this, anchor);
      if (position) {
        this.graphic[animation ? "animate" : "attr"]({
          x: position.x,
          y: position.y
        });
      } else {
        this.graphic.attr({
          x: 0,
          y: -9e9
        });
      }
      this.graphic.placed = Boolean(position);
    }
    super.redraw(animation);
  }
};
ControllableImage.attrsMap = {
  width: "width",
  height: "height",
  zIndex: "zIndex"
};
var ControllableImage_default = ControllableImage;

// node_modules/highcharts/es-modules/Shared/BaseForm.js
var { addEvent: addEvent48, createElement: createElement10 } = Utilities_default;
var BaseForm = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(parentDiv, iconsURL) {
    this.iconsURL = iconsURL;
    this.container = this.createPopupContainer(parentDiv);
    this.closeButton = this.addCloseButton();
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Create popup div container.
   *
   * @param {HTMLElement} parentDiv
   * Parent div to attach popup.
   *
   * @param  {string} className
   * Class name of the popup.
   *
   * @return {HTMLElement}
   * Popup div.
   */
  createPopupContainer(parentDiv, className = "highcharts-popup highcharts-no-tooltip") {
    return createElement10("div", { className }, void 0, parentDiv);
  }
  /**
   * Create HTML element and attach click event to close popup.
   *
   * @param {string} className
   * Class name of the close button.
   *
   * @return {HTMLElement}
   * Close button.
   */
  addCloseButton(className = "highcharts-popup-close") {
    const popup = this, iconsURL = this.iconsURL;
    const closeButton = createElement10("button", { className }, void 0, this.container);
    closeButton.style["background-image"] = "url(" + (iconsURL.match(/png|svg|jpeg|jpg|gif/ig) ? iconsURL : iconsURL + "close.svg") + ")";
    ["click", "touchstart"].forEach((eventName) => {
      addEvent48(closeButton, eventName, popup.closeButtonEvents.bind(popup));
    });
    addEvent48(document, "keydown", function(event) {
      if (event.code === "Escape") {
        popup.closeButtonEvents();
      }
    });
    return closeButton;
  }
  /**
   * Close button events.
   * @return {void}
   */
  closeButtonEvents() {
    this.closePopup();
  }
  /**
   * Reset content of the current popup and show.
   *
   * @param {string} toolbarClass
   * Class name of the toolbar which styles should be reset.
   */
  showPopup(toolbarClass = "highcharts-annotation-toolbar") {
    const popupDiv = this.container, popupCloseButton = this.closeButton;
    this.type = void 0;
    popupDiv.innerHTML = AST_default.emptyHTML;
    if (popupDiv.className.indexOf(toolbarClass) >= 0) {
      popupDiv.classList.remove(toolbarClass);
      popupDiv.removeAttribute("style");
    }
    popupDiv.appendChild(popupCloseButton);
    popupDiv.style.display = "block";
    popupDiv.style.height = "";
  }
  /**
   * Hide popup.
   */
  closePopup() {
    this.container.style.display = "none";
  }
};
var BaseForm_default = BaseForm;

// node_modules/highcharts/es-modules/Extensions/Annotations/Popup/PopupAnnotations.js
var { doc: doc21, isFirefox: isFirefox4 } = Globals_default;
var { createElement: createElement11, isArray: isArray16, isObject: isObject14, objectEach: objectEach24, pick: pick61, stableSort: stableSort5 } = Utilities_default;
function addForm(chart, options2, callback, isInit) {
  if (!chart) {
    return;
  }
  const popupDiv = this.container, lang6 = this.lang;
  let lhsCol = createElement11("h2", {
    className: "highcharts-popup-main-title"
  }, void 0, popupDiv);
  lhsCol.appendChild(doc21.createTextNode(lang6[options2.langKey] || options2.langKey || ""));
  lhsCol = createElement11("div", {
    className: "highcharts-popup-lhs-col highcharts-popup-lhs-full"
  }, void 0, popupDiv);
  const bottomRow = createElement11("div", {
    className: "highcharts-popup-bottom-row"
  }, void 0, popupDiv);
  addFormFields.call(this, lhsCol, chart, "", options2, [], true);
  this.addButton(bottomRow, isInit ? lang6.addButton || "Add" : lang6.saveButton || "Save", isInit ? "add" : "save", popupDiv, callback);
}
function addToolbar(chart, options2, callback) {
  const lang6 = this.lang, popupDiv = this.container, showForm = this.showForm, toolbarClass = "highcharts-annotation-toolbar";
  if (popupDiv.className.indexOf(toolbarClass) === -1) {
    popupDiv.className += " " + toolbarClass + " highcharts-no-mousewheel";
  }
  if (chart) {
    popupDiv.style.top = chart.plotTop + 10 + "px";
  }
  const label = createElement11("p", {
    className: "highcharts-annotation-label"
  }, void 0, popupDiv);
  label.setAttribute("aria-label", "Annotation type");
  label.appendChild(doc21.createTextNode(pick61(
    // Advanced annotations:
    lang6[options2.langKey] || options2.langKey,
    // Basic shapes:
    options2.shapes && options2.shapes[0].type,
    ""
  )));
  let button = this.addButton(popupDiv, lang6.editButton || "Edit", "edit", popupDiv, () => {
    showForm.call(this, "annotation-edit", chart, options2, callback);
  });
  button.className += " highcharts-annotation-edit-button";
  button.style["background-image"] = "url(" + this.iconsURL + "edit.svg)";
  button = this.addButton(popupDiv, lang6.removeButton || "Remove", "remove", popupDiv, callback);
  button.className += " highcharts-annotation-remove-button";
  button.style["background-image"] = "url(" + this.iconsURL + "destroy.svg)";
}
function addFormFields(parentDiv, chart, parentNode, options2, storage, isRoot) {
  if (!chart) {
    return;
  }
  const addInput = this.addInput, lang6 = this.lang;
  let parentFullName, titleName;
  objectEach24(options2, (value, option) => {
    parentFullName = parentNode !== "" ? parentNode + "." + option : option;
    if (isObject14(value)) {
      if (
        // Value is object of options
        !isArray16(value) || // Array of objects with params. i.e labels in Fibonacci
        isArray16(value) && isObject14(value[0])
      ) {
        titleName = lang6[option] || option;
        if (!titleName.match(/\d/g)) {
          storage.push([
            true,
            titleName,
            parentDiv
          ]);
        }
        addFormFields.call(this, parentDiv, chart, parentFullName, value, storage, false);
      } else {
        storage.push([
          this,
          parentFullName,
          "annotation",
          parentDiv,
          value
        ]);
      }
    }
  });
  if (isRoot) {
    stableSort5(storage, (a) => a[1].match(/format/g) ? -1 : 1);
    if (isFirefox4) {
      storage.reverse();
    }
    storage.forEach((genInput) => {
      if (genInput[0] === true) {
        createElement11("span", {
          className: "highcharts-annotation-title"
        }, void 0, genInput[2]).appendChild(doc21.createTextNode(genInput[1]));
      } else {
        genInput[4] = {
          value: genInput[4][0],
          type: genInput[4][1]
        };
        addInput.apply(genInput[0], genInput.splice(1));
      }
    });
  }
}
var PopupAnnotations = {
  addForm,
  addToolbar
};
var PopupAnnotations_default = PopupAnnotations;

// node_modules/highcharts/es-modules/Extensions/Annotations/Popup/PopupIndicators.js
var { doc: doc22 } = Globals_default;
var { seriesTypes: seriesTypes5 } = SeriesRegistry_default;
var { addEvent: addEvent49, createElement: createElement12, defined: defined48, isArray: isArray17, isObject: isObject15, objectEach: objectEach25, stableSort: stableSort6 } = Utilities_default;
var DropdownProperties;
(function(DropdownProperties2) {
  DropdownProperties2[DropdownProperties2["params.algorithm"] = 0] = "params.algorithm";
  DropdownProperties2[DropdownProperties2["params.average"] = 1] = "params.average";
})(DropdownProperties || (DropdownProperties = {}));
var dropdownParameters = {
  "algorithm-pivotpoints": ["standard", "fibonacci", "camarilla"],
  "average-disparityindex": ["sma", "ema", "dema", "tema", "wma"]
};
function addColsContainer(container) {
  const lhsCol = createElement12("div", {
    className: "highcharts-popup-lhs-col"
  }, void 0, container);
  const rhsCol = createElement12("div", {
    className: "highcharts-popup-rhs-col"
  }, void 0, container);
  createElement12("div", {
    className: "highcharts-popup-rhs-col-wrapper"
  }, void 0, rhsCol);
  return {
    lhsCol,
    rhsCol
  };
}
function addForm2(chart, _options, callback) {
  const lang6 = this.lang;
  let buttonParentDiv;
  if (!chart) {
    return;
  }
  this.tabs.init.call(this, chart);
  const tabsContainers = this.container.querySelectorAll(".highcharts-tab-item-content");
  addColsContainer(tabsContainers[0]);
  addSearchBox.call(this, chart, tabsContainers[0]);
  addIndicatorList.call(this, chart, tabsContainers[0], "add");
  buttonParentDiv = tabsContainers[0].querySelectorAll(".highcharts-popup-rhs-col")[0];
  this.addButton(buttonParentDiv, lang6.addButton || "add", "add", buttonParentDiv, callback);
  addColsContainer(tabsContainers[1]);
  addIndicatorList.call(this, chart, tabsContainers[1], "edit");
  buttonParentDiv = tabsContainers[1].querySelectorAll(".highcharts-popup-rhs-col")[0];
  this.addButton(buttonParentDiv, lang6.saveButton || "save", "edit", buttonParentDiv, callback);
  this.addButton(buttonParentDiv, lang6.removeButton || "remove", "remove", buttonParentDiv, callback);
}
function addFormFields2(chart, series, seriesType, rhsColWrapper) {
  const fields = series.params || series.options.params;
  rhsColWrapper.innerHTML = AST_default.emptyHTML;
  createElement12("h3", {
    className: "highcharts-indicator-title"
  }, void 0, rhsColWrapper).appendChild(doc22.createTextNode(getNameType(series, seriesType).indicatorFullName));
  createElement12("input", {
    type: "hidden",
    name: "highcharts-type-" + seriesType,
    value: seriesType
  }, void 0, rhsColWrapper);
  listAllSeries.call(this, seriesType, "series", chart, rhsColWrapper, series, series.linkedParent && series.linkedParent.options.id);
  if (fields.volumeSeriesID) {
    listAllSeries.call(this, seriesType, "volume", chart, rhsColWrapper, series, series.linkedParent && fields.volumeSeriesID);
  }
  addParamInputs.call(this, chart, "params", fields, seriesType, rhsColWrapper);
}
function addIndicatorList(chart, parentDiv, listType, filter) {
  function selectIndicator(series2, indicatorType) {
    const button = rhsColWrapper.parentNode.children[1];
    addFormFields2.call(popup, chart, series2, indicatorType, rhsColWrapper);
    if (button) {
      button.style.display = "block";
    }
    if (isEdit && series2.options) {
      createElement12("input", {
        type: "hidden",
        name: "highcharts-id-" + indicatorType,
        value: series2.options.id
      }, void 0, rhsColWrapper).setAttribute("highcharts-data-series-id", series2.options.id);
    }
  }
  const popup = this, lang6 = popup.lang, lhsCol = parentDiv.querySelectorAll(".highcharts-popup-lhs-col")[0], rhsCol = parentDiv.querySelectorAll(".highcharts-popup-rhs-col")[0], isEdit = listType === "edit", series = isEdit ? chart.series : (
    // EDIT mode
    chart.options.plotOptions || {}
  );
  if (!chart && series) {
    return;
  }
  let item, filteredSeriesArray = [];
  if (!isEdit && !isArray17(series)) {
    filteredSeriesArray = filterSeries.call(this, series, filter);
  } else if (isArray17(series)) {
    filteredSeriesArray = filterSeriesArray.call(this, series);
  }
  stableSort6(filteredSeriesArray, (a, b) => {
    const seriesAName = a.indicatorFullName.toLowerCase(), seriesBName = b.indicatorFullName.toLowerCase();
    return seriesAName < seriesBName ? -1 : seriesAName > seriesBName ? 1 : 0;
  });
  if (lhsCol.children[1]) {
    lhsCol.children[1].remove();
  }
  const indicatorList = createElement12("ul", {
    className: "highcharts-indicator-list"
  }, void 0, lhsCol);
  const rhsColWrapper = rhsCol.querySelectorAll(".highcharts-popup-rhs-col-wrapper")[0];
  filteredSeriesArray.forEach((seriesSet) => {
    const { indicatorFullName, indicatorType, series: series2 } = seriesSet;
    item = createElement12("li", {
      className: "highcharts-indicator-list"
    }, void 0, indicatorList);
    const btn = createElement12("button", {
      className: "highcharts-indicator-list-item",
      textContent: indicatorFullName
    }, void 0, item);
    ["click", "touchstart"].forEach((eventName) => {
      addEvent49(btn, eventName, function() {
        selectIndicator(series2, indicatorType);
      });
    });
  });
  if (filteredSeriesArray.length > 0) {
    const { series: series2, indicatorType } = filteredSeriesArray[0];
    selectIndicator(series2, indicatorType);
  } else if (!isEdit) {
    AST_default.setElementHTML(rhsColWrapper.parentNode.children[0], lang6.noFilterMatch || "");
    rhsColWrapper.parentNode.children[1].style.display = "none";
  }
}
function addParamInputs(chart, parentNode, fields, type, parentDiv) {
  if (!chart) {
    return;
  }
  const addInput = this.addInput;
  objectEach25(fields, (value, fieldName) => {
    const parentFullName = parentNode + "." + fieldName;
    if (defined48(value) && // Skip if field is unnecessary, #15362
    parentFullName) {
      if (isObject15(value)) {
        addInput.call(this, parentFullName, type, parentDiv, {});
        addParamInputs.call(this, chart, parentFullName, value, type, parentDiv);
      }
      if (parentFullName in DropdownProperties) {
        const selectBox = addSelection.call(this, type, parentFullName, parentDiv);
        addSelectionOptions.call(this, chart, parentNode, selectBox, type, fieldName, value);
      } else if (
        // Skip volume field which is created by addFormFields.
        parentFullName !== "params.volumeSeriesID" && !isArray17(value)
      ) {
        addInput.call(
          this,
          parentFullName,
          type,
          parentDiv,
          {
            value,
            type: "number"
          }
          // All inputs are text type
        );
      }
    }
  });
}
function addSearchBox(chart, parentDiv) {
  const popup = this, lhsCol = parentDiv.querySelectorAll(".highcharts-popup-lhs-col")[0], options2 = "searchIndicators", inputAttributes = {
    value: "",
    type: "text",
    htmlFor: "search-indicators",
    labelClassName: "highcharts-input-search-indicators-label"
  }, clearFilterText = this.lang.clearFilter, inputWrapper = createElement12("div", {
    className: "highcharts-input-wrapper"
  }, void 0, lhsCol);
  const handleInputChange = function(inputText) {
    addIndicatorList.call(popup, chart, popup.container, "add", inputText);
  };
  const input = this.addInput(options2, "input", inputWrapper, inputAttributes), button = createElement12("a", {
    textContent: clearFilterText
  }, void 0, inputWrapper);
  input.classList.add("highcharts-input-search-indicators");
  button.classList.add("clear-filter-button");
  addEvent49(input, "input", function() {
    handleInputChange(this.value);
    if (this.value.length) {
      button.style.display = "inline-block";
    } else {
      button.style.display = "none";
    }
  });
  ["click", "touchstart"].forEach((eventName) => {
    addEvent49(button, eventName, function() {
      input.value = "";
      handleInputChange("");
      button.style.display = "none";
    });
  });
}
function addSelection(indicatorType, optionName, parentDiv) {
  const optionParamList = optionName.split("."), labelText = optionParamList[optionParamList.length - 1], selectName = "highcharts-" + optionName + "-type-" + indicatorType, lang6 = this.lang;
  createElement12("label", {
    htmlFor: selectName
  }, null, parentDiv).appendChild(doc22.createTextNode(lang6[labelText] || optionName));
  const selectBox = createElement12("select", {
    name: selectName,
    className: "highcharts-popup-field",
    id: "highcharts-select-" + optionName
  }, null, parentDiv);
  selectBox.setAttribute("id", "highcharts-select-" + optionName);
  return selectBox;
}
function addSelectionOptions(chart, optionName, selectBox, indicatorType, parameterName, selectedOption, currentSeries) {
  if (optionName === "series" || optionName === "volume") {
    chart.series.forEach((series) => {
      const seriesOptions = series.options, seriesName = seriesOptions.name || seriesOptions.params ? series.name : seriesOptions.id || "";
      if (seriesOptions.id !== "highcharts-navigator-series" && seriesOptions.id !== (currentSeries && currentSeries.options && currentSeries.options.id)) {
        if (!defined48(selectedOption) && optionName === "volume" && series.type === "column") {
          selectedOption = seriesOptions.id;
        }
        createElement12("option", {
          value: seriesOptions.id
        }, void 0, selectBox).appendChild(doc22.createTextNode(seriesName));
      }
    });
  } else if (indicatorType && parameterName) {
    const dropdownKey = parameterName + "-" + indicatorType, parameterOption = dropdownParameters[dropdownKey];
    parameterOption.forEach((element) => {
      createElement12("option", {
        value: element
      }, void 0, selectBox).appendChild(doc22.createTextNode(element));
    });
  }
  if (defined48(selectedOption)) {
    selectBox.value = selectedOption;
  }
}
function filterSeries(series, filter) {
  const popup = this, lang6 = popup.chart && popup.chart.options.lang, indicatorAliases = lang6 && lang6.navigation && lang6.navigation.popup && lang6.navigation.popup.indicatorAliases, filteredSeriesArray = [];
  let filteredSeries;
  objectEach25(series, (series2, value) => {
    const seriesOptions = series2 && series2.options;
    if (series2.params || seriesOptions && seriesOptions.params) {
      const { indicatorFullName, indicatorType } = getNameType(series2, value);
      if (filter) {
        const validFilter = filter.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const regex = new RegExp(validFilter, "i"), alias = indicatorAliases && indicatorAliases[indicatorType] && indicatorAliases[indicatorType].join(" ") || "";
        if (indicatorFullName.match(regex) || alias.match(regex)) {
          filteredSeries = {
            indicatorFullName,
            indicatorType,
            series: series2
          };
          filteredSeriesArray.push(filteredSeries);
        }
      } else {
        filteredSeries = {
          indicatorFullName,
          indicatorType,
          series: series2
        };
        filteredSeriesArray.push(filteredSeries);
      }
    }
  });
  return filteredSeriesArray;
}
function filterSeriesArray(series) {
  const filteredSeriesArray = [];
  series.forEach((series2) => {
    if (series2.is("sma")) {
      filteredSeriesArray.push({
        indicatorFullName: series2.name,
        indicatorType: series2.type,
        series: series2
      });
    }
  });
  return filteredSeriesArray;
}
function getAmount() {
  let counter = 0;
  this.series.forEach((serie) => {
    if (serie.params || serie.options.params) {
      counter++;
    }
  });
  return counter;
}
function getNameType(series, indicatorType) {
  const options2 = series.options;
  let seriesName = seriesTypes5[indicatorType] && seriesTypes5[indicatorType].prototype.nameBase || indicatorType.toUpperCase(), seriesType = indicatorType;
  if (options2 && options2.type) {
    seriesType = series.options.type;
    seriesName = series.name;
  }
  return {
    indicatorFullName: seriesName,
    indicatorType: seriesType
  };
}
function listAllSeries(indicatorType, optionName, chart, parentDiv, currentSeries, selectedOption) {
  const popup = this;
  if (!chart) {
    return;
  }
  const selectBox = addSelection.call(popup, indicatorType, optionName, parentDiv);
  addSelectionOptions.call(popup, chart, optionName, selectBox, void 0, void 0, void 0, currentSeries);
  if (defined48(selectedOption)) {
    selectBox.value = selectedOption;
  }
}
var PopupIndicators = {
  addForm: addForm2,
  getAmount
};
var PopupIndicators_default = PopupIndicators;

// node_modules/highcharts/es-modules/Extensions/Annotations/Popup/PopupTabs.js
var { doc: doc23 } = Globals_default;
var { addEvent: addEvent50, createElement: createElement13 } = Utilities_default;
function addContentItem() {
  const popupDiv = this.container;
  return createElement13("div", {
    // #12100
    className: "highcharts-tab-item-content highcharts-no-mousewheel"
  }, void 0, popupDiv);
}
function addMenuItem(tabName, disableTab) {
  const popupDiv = this.container, lang6 = this.lang;
  let className = "highcharts-tab-item";
  if (disableTab === 0) {
    className += " highcharts-tab-disabled";
  }
  const menuItem = createElement13("button", {
    className
  }, void 0, popupDiv);
  menuItem.appendChild(doc23.createTextNode(lang6[tabName + "Button"] || tabName));
  menuItem.setAttribute("highcharts-data-tab-type", tabName);
  return menuItem;
}
function deselectAll() {
  const popupDiv = this.container, tabs = popupDiv.querySelectorAll(".highcharts-tab-item"), tabsContent = popupDiv.querySelectorAll(".highcharts-tab-item-content");
  for (let i = 0; i < tabs.length; i++) {
    tabs[i].classList.remove("highcharts-tab-item-active");
    tabsContent[i].classList.remove("highcharts-tab-item-show");
  }
}
function init(chart) {
  if (!chart) {
    return;
  }
  const indicatorsCount = this.indicators.getAmount.call(chart);
  const firstTab = addMenuItem.call(this, "add");
  addMenuItem.call(this, "edit", indicatorsCount);
  addContentItem.call(this);
  addContentItem.call(this);
  switchTabs.call(this, indicatorsCount);
  selectTab.call(this, firstTab, 0);
}
function selectTab(tab, index) {
  const allTabs = this.container.querySelectorAll(".highcharts-tab-item-content");
  tab.className += " highcharts-tab-item-active";
  allTabs[index].className += " highcharts-tab-item-show";
}
function switchTabs(disableTab) {
  const popup = this, popupDiv = this.container, tabs = popupDiv.querySelectorAll(".highcharts-tab-item");
  tabs.forEach((tab, i) => {
    if (disableTab === 0 && tab.getAttribute("highcharts-data-tab-type") === "edit") {
      return;
    }
    ["click", "touchstart"].forEach((eventName) => {
      addEvent50(tab, eventName, function() {
        deselectAll.call(popup);
        selectTab.call(popup, this, i);
      });
    });
  });
}
var PopupTabs = {
  init
};
var PopupTabs_default = PopupTabs;

// node_modules/highcharts/es-modules/Extensions/Annotations/Popup/Popup.js
var { doc: doc24 } = Globals_default;
var { getOptions: getOptions3 } = Defaults_default;
var { addEvent: addEvent51, createElement: createElement14, extend: extend45, fireEvent: fireEvent34, pick: pick62 } = Utilities_default;
function getFields(parentDiv, type) {
  const inputList = Array.prototype.slice.call(parentDiv.querySelectorAll("input")), selectList = Array.prototype.slice.call(parentDiv.querySelectorAll("select")), optionSeries = "#highcharts-select-series > option:checked", optionVolume = "#highcharts-select-volume > option:checked", linkedTo = parentDiv.querySelectorAll(optionSeries)[0], volumeTo = parentDiv.querySelectorAll(optionVolume)[0];
  const fieldsOutput = {
    actionType: type,
    linkedTo: linkedTo && linkedTo.getAttribute("value") || "",
    fields: {}
  };
  inputList.forEach((input) => {
    const param = input.getAttribute("highcharts-data-name"), seriesId = input.getAttribute("highcharts-data-series-id");
    if (seriesId) {
      fieldsOutput.seriesId = input.value;
    } else if (param) {
      fieldsOutput.fields[param] = input.value;
    } else {
      fieldsOutput.type = input.value;
    }
  });
  selectList.forEach((select) => {
    const id = select.id;
    if (id !== "highcharts-select-series" && id !== "highcharts-select-volume") {
      const parameter = id.split("highcharts-select-")[1];
      fieldsOutput.fields[parameter] = select.value;
    }
  });
  if (volumeTo) {
    fieldsOutput.fields["params.volumeSeriesID"] = volumeTo.getAttribute("value") || "";
  }
  return fieldsOutput;
}
var Popup = class extends BaseForm_default {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(parentDiv, iconsURL, chart) {
    super(parentDiv, iconsURL);
    this.chart = chart;
    this.lang = (getOptions3().lang.navigation || {}).popup || {};
    addEvent51(this.container, "mousedown", () => {
      const activeAnnotation = chart && chart.navigationBindings && chart.navigationBindings.activeAnnotation;
      if (activeAnnotation) {
        activeAnnotation.cancelClick = true;
        const unbind = addEvent51(doc24, "click", () => {
          setTimeout(() => {
            activeAnnotation.cancelClick = false;
          }, 0);
          unbind();
        });
      }
    });
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Create input with label.
   *
   * @private
   *
   * @param {string} option
   *        Chain of fields i.e params.styles.fontSize separated by the dot.
   *
   * @param {string} indicatorType
   *        Type of the indicator i.e. sma, ema...
   *
   * @param {HTMLDOMElement} parentDiv
   *        HTML parent element.
   *
   * @param {Highcharts.InputAttributes} inputAttributes
   *        Attributes of the input.
   *
   * @return {HTMLInputElement}
   *         Return created input element.
   */
  addInput(option, indicatorType, parentDiv, inputAttributes) {
    const optionParamList = option.split("."), optionName = optionParamList[optionParamList.length - 1], lang6 = this.lang, inputName = "highcharts-" + indicatorType + "-" + pick62(inputAttributes.htmlFor, optionName);
    if (!optionName.match(/^\d+$/)) {
      createElement14("label", {
        htmlFor: inputName,
        className: inputAttributes.labelClassName
      }, void 0, parentDiv).appendChild(doc24.createTextNode(lang6[optionName] || optionName));
    }
    const input = createElement14("input", {
      name: inputName,
      value: inputAttributes.value,
      type: inputAttributes.type,
      className: "highcharts-popup-field"
    }, void 0, parentDiv);
    input.setAttribute("highcharts-data-name", option);
    return input;
  }
  closeButtonEvents() {
    if (this.chart) {
      const navigationBindings = this.chart.navigationBindings;
      fireEvent34(navigationBindings, "closePopup");
      if (navigationBindings && navigationBindings.selectedButtonElement) {
        fireEvent34(navigationBindings, "deselectButton", { button: navigationBindings.selectedButtonElement });
      }
    } else {
      super.closeButtonEvents();
    }
  }
  /**
   * Create button.
   * @private
   * @param {Highcharts.HTMLDOMElement} parentDiv
   * Container where elements should be added
   * @param {string} label
   * Text placed as button label
   * @param {string} type
   * add | edit | remove
   * @param {Function} callback
   * On click callback
   * @param {Highcharts.HTMLDOMElement} fieldsDiv
   * Container where inputs are generated
   * @return {Highcharts.HTMLDOMElement}
   * HTML button
   */
  addButton(parentDiv, label, type, fieldsDiv, callback) {
    const button = createElement14("button", void 0, void 0, parentDiv);
    button.appendChild(doc24.createTextNode(label));
    if (callback) {
      ["click", "touchstart"].forEach((eventName) => {
        addEvent51(button, eventName, () => {
          this.closePopup();
          return callback(getFields(fieldsDiv, type));
        });
      });
    }
    return button;
  }
  /**
   * Create content and show popup.
   * @private
   * @param {string} - type of popup i.e indicators
   * @param {Highcharts.Chart} - chart
   * @param {Highcharts.AnnotationsOptions} - options
   * @param {Function} - on click callback
   */
  showForm(type, chart, options2, callback) {
    if (!chart) {
      return;
    }
    this.showPopup();
    if (type === "indicators") {
      this.indicators.addForm.call(this, chart, options2, callback);
    }
    if (type === "annotation-toolbar") {
      this.annotations.addToolbar.call(this, chart, options2, callback);
    }
    if (type === "annotation-edit") {
      this.annotations.addForm.call(this, chart, options2, callback);
    }
    if (type === "flag") {
      this.annotations.addForm.call(this, chart, options2, callback, true);
    }
    this.type = type;
    this.container.style.height = this.container.offsetHeight + "px";
  }
};
extend45(Popup.prototype, {
  annotations: PopupAnnotations_default,
  indicators: PopupIndicators_default,
  tabs: PopupTabs_default
});
var Popup_default = Popup;

// node_modules/highcharts/es-modules/Extensions/Annotations/Popup/PopupComposition.js
var { composed: composed16 } = Globals_default;
var { addEvent: addEvent52, pushUnique: pushUnique19, wrap: wrap4 } = Utilities_default;
function compose10(NagivationBindingsClass, PointerClass) {
  if (pushUnique19(composed16, "Popup")) {
    addEvent52(NagivationBindingsClass, "closePopup", onNavigationBindingsClosePopup);
    addEvent52(NagivationBindingsClass, "showPopup", onNavigationBindingsShowPopup);
    wrap4(PointerClass.prototype, "onContainerMouseDown", wrapPointerOnContainerMouserDown);
  }
}
function onNavigationBindingsClosePopup() {
  if (this.popup) {
    this.popup.closePopup();
  }
}
function onNavigationBindingsShowPopup(config2) {
  if (!this.popup) {
    this.popup = new Popup_default(this.chart.container, this.chart.options.navigation.iconsURL || this.chart.options.stockTools && this.chart.options.stockTools.gui.iconsURL || "https://code.highcharts.com/12.2.0/gfx/stock-icons/", this.chart);
  }
  this.popup.showForm(config2.formType, this.chart, config2.options, config2.onSubmit);
}
function wrapPointerOnContainerMouserDown(proceed, e) {
  if (!this.inClass(e.target, "highcharts-popup")) {
    proceed.apply(this, Array.prototype.slice.call(arguments, 1));
  }
}
var PopupComposition = {
  compose: compose10
};
var PopupComposition_default = PopupComposition;

// node_modules/highcharts/es-modules/Extensions/Annotations/Annotation.js
var { getDeferredAnimation: getDeferredAnimation4 } = AnimationUtilities_default;
var { destroyObjectProperties: destroyObjectProperties12, erase: erase12, fireEvent: fireEvent35, merge: merge54, pick: pick63, splat: splat13 } = Utilities_default;
function adjustVisibility(item) {
  const label = item.graphic, hasVisiblePoints = item.points.some((point) => point.series.visible !== false && point.visible !== false);
  if (label) {
    if (!hasVisiblePoints) {
      label.hide();
    } else if (label.visibility === "hidden") {
      label.show();
    }
  }
}
function getLabelsAndShapesOptions(baseOptions, newOptions) {
  const mergedOptions = {};
  ["labels", "shapes"].forEach((name) => {
    const someBaseOptions = baseOptions[name], newOptionsValue = newOptions[name];
    if (someBaseOptions) {
      if (newOptionsValue) {
        mergedOptions[name] = splat13(newOptionsValue).map((basicOptions, i) => merge54(someBaseOptions[i], basicOptions));
      } else {
        mergedOptions[name] = baseOptions[name];
      }
    }
  });
  return mergedOptions;
}
var Annotation = class _Annotation extends EventEmitter_default {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * @private
   */
  static compose(ChartClass, NavigationBindingsClass, PointerClass, SVGRendererClass) {
    AnnotationChart_default.compose(_Annotation, ChartClass, PointerClass);
    ControllableLabel_default.compose(SVGRendererClass);
    ControllablePath_default.compose(ChartClass, SVGRendererClass);
    NavigationBindingsClass.compose(_Annotation, ChartClass);
    PopupComposition_default.compose(NavigationBindingsClass, PointerClass);
  }
  /* *
   *
   *  Constructors
   *
   * */
  constructor(chart, userOptions) {
    super();
    this.coll = "annotations";
    this.chart = chart;
    this.points = [];
    this.controlPoints = [];
    this.coll = "annotations";
    this.index = -1;
    this.labels = [];
    this.shapes = [];
    this.options = merge54(this.defaultOptions, userOptions);
    this.userOptions = userOptions;
    const labelsAndShapes = getLabelsAndShapesOptions(this.options, userOptions);
    this.options.labels = labelsAndShapes.labels;
    this.options.shapes = labelsAndShapes.shapes;
    this.init(chart, this.options);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  addClipPaths() {
    this.setClipAxes();
    if (this.clipXAxis && this.clipYAxis && this.options.crop) {
      this.clipRect = this.chart.renderer.clipRect(this.getClipBox());
    }
  }
  /**
   * @private
   */
  addLabels() {
    const labelsOptions = this.options.labels || [];
    labelsOptions.forEach((labelOptions, i) => {
      const label = this.initLabel(labelOptions, i);
      merge54(true, labelsOptions[i], label.options);
    });
  }
  /**
   * @private
   */
  addShapes() {
    const shapes = this.options.shapes || [];
    shapes.forEach((shapeOptions, i) => {
      const shape = this.initShape(shapeOptions, i);
      merge54(true, shapes[i], shape.options);
    });
  }
  /**
   * Destroy the annotation. This function does not touch the chart
   * that the annotation belongs to (all annotations are kept in
   * the chart.annotations array) - it is recommended to use
   * {@link Highcharts.Chart#removeAnnotation} instead.
   * @private
   */
  destroy() {
    const chart = this.chart, destroyItem = function(item) {
      item.destroy();
    };
    this.labels.forEach(destroyItem);
    this.shapes.forEach(destroyItem);
    this.clipXAxis = null;
    this.clipYAxis = null;
    erase12(chart.labelCollectors, this.labelCollector);
    super.destroy();
    this.destroyControlTarget();
    destroyObjectProperties12(this, chart);
  }
  /**
   * Destroy a single item.
   * @private
   */
  destroyItem(item) {
    erase12(this[item.itemType + "s"], item);
    item.destroy();
  }
  /**
   * @private
   */
  getClipBox() {
    if (this.clipXAxis && this.clipYAxis) {
      return {
        x: this.clipXAxis.left,
        y: this.clipYAxis.top,
        width: this.clipXAxis.width,
        height: this.clipYAxis.height
      };
    }
  }
  /**
   * Initialize the annotation properties.
   * @private
   */
  initProperties(chart, userOptions) {
    this.setOptions(userOptions);
    const labelsAndShapes = getLabelsAndShapesOptions(this.options, userOptions);
    this.options.labels = labelsAndShapes.labels;
    this.options.shapes = labelsAndShapes.shapes;
    this.chart = chart;
    this.points = [];
    this.controlPoints = [];
    this.coll = "annotations";
    this.userOptions = userOptions;
    this.labels = [];
    this.shapes = [];
  }
  /**
   * Initialize the annotation.
   * @private
   */
  init(_annotationOrChart, _userOptions, index = this.index) {
    const chart = this.chart, animOptions = this.options.animation;
    this.index = index;
    this.linkPoints();
    this.addControlPoints();
    this.addShapes();
    this.addLabels();
    this.setLabelCollector();
    this.animationConfig = getDeferredAnimation4(chart, animOptions);
  }
  /**
   * Initialisation of a single label
   * @private
   */
  initLabel(labelOptions, index) {
    const options2 = merge54(this.options.labelOptions, {
      controlPointOptions: this.options.controlPointOptions
    }, labelOptions), label = new ControllableLabel_default(this, options2, index);
    label.itemType = "label";
    this.labels.push(label);
    return label;
  }
  /**
   * Initialisation of a single shape
   * @private
   * @param {Object} shapeOptions
   * a config object for a single shape
   * @param {number} index
   * annotation may have many shapes, this is the shape's index saved in
   * shapes.index.
   */
  initShape(shapeOptions, index) {
    const options2 = merge54(this.options.shapeOptions, {
      controlPointOptions: this.options.controlPointOptions
    }, shapeOptions), shape = new _Annotation.shapesMap[options2.type](this, options2, index);
    shape.itemType = "shape";
    this.shapes.push(shape);
    return shape;
  }
  /**
   * @private
   */
  redraw(animation) {
    this.linkPoints();
    if (!this.graphic) {
      this.render();
    }
    if (this.clipRect) {
      this.clipRect.animate(this.getClipBox());
    }
    this.redrawItems(this.shapes, animation);
    this.redrawItems(this.labels, animation);
    this.redrawControlPoints(animation);
  }
  /**
   * Redraw a single item.
   * @private
   */
  redrawItem(item, animation) {
    item.linkPoints();
    if (!item.shouldBeDrawn()) {
      this.destroyItem(item);
    } else {
      if (!item.graphic) {
        this.renderItem(item);
      }
      item.redraw(pick63(animation, true) && item.graphic.placed);
      if (item.points.length) {
        adjustVisibility(item);
      }
    }
  }
  /**
   * @private
   */
  redrawItems(items, animation) {
    let i = items.length;
    while (i--) {
      this.redrawItem(items[i], animation);
    }
  }
  /**
   * See {@link Highcharts.Chart#removeAnnotation}.
   * @private
   */
  remove() {
    return this.chart.removeAnnotation(this);
  }
  /**
   * @private
   */
  render() {
    const renderer = this.chart.renderer;
    this.graphic = renderer.g("annotation").attr({
      opacity: 0,
      zIndex: this.options.zIndex,
      visibility: this.options.visible ? "inherit" : "hidden"
    }).add();
    this.shapesGroup = renderer.g("annotation-shapes").add(this.graphic);
    if (this.options.crop) {
      this.shapesGroup.clip(this.chart.plotBoxClip);
    }
    this.labelsGroup = renderer.g("annotation-labels").attr({
      // `hideOverlappingLabels` requires translation
      translateX: 0,
      translateY: 0
    }).add(this.graphic);
    this.addClipPaths();
    if (this.clipRect) {
      this.graphic.clip(this.clipRect);
    }
    this.renderItems(this.shapes);
    this.renderItems(this.labels);
    this.addEvents();
    this.renderControlPoints();
  }
  /**
   * @private
   */
  renderItem(item) {
    item.render(item.itemType === "label" ? this.labelsGroup : this.shapesGroup);
  }
  /**
   * @private
   */
  renderItems(items) {
    let i = items.length;
    while (i--) {
      this.renderItem(items[i]);
    }
  }
  /**
   * @private
   */
  setClipAxes() {
    const xAxes = this.chart.xAxis, yAxes = this.chart.yAxis, linkedAxes = (this.options.labels || []).concat(this.options.shapes || []).reduce((axes, labelOrShape) => {
      const point = labelOrShape && (labelOrShape.point || labelOrShape.points && labelOrShape.points[0]);
      return [
        xAxes[point && point.xAxis] || axes[0],
        yAxes[point && point.yAxis] || axes[1]
      ];
    }, []);
    this.clipXAxis = linkedAxes[0];
    this.clipYAxis = linkedAxes[1];
  }
  /**
   * @private
   */
  setControlPointsVisibility(visible) {
    const setItemControlPointsVisibility = function(item) {
      item.setControlPointsVisibility(visible);
    };
    this.controlPoints.forEach((controlPoint) => {
      controlPoint.setVisibility(visible);
    });
    this.shapes.forEach(setItemControlPointsVisibility);
    this.labels.forEach(setItemControlPointsVisibility);
  }
  /**
   * @private
   */
  setLabelCollector() {
    const annotation = this;
    annotation.labelCollector = function() {
      return annotation.labels.reduce(function(labels, label) {
        if (!label.options.allowOverlap) {
          labels.push(label.graphic);
        }
        return labels;
      }, []);
    };
    annotation.chart.labelCollectors.push(annotation.labelCollector);
  }
  /**
   * Set an annotation options.
   * @private
   * @param {Highcharts.AnnotationsOptions} userOptions
   *        User options for an annotation
   */
  setOptions(userOptions) {
    this.options = merge54(this.defaultOptions, userOptions);
  }
  /**
   * Set the annotation's visibility.
   * @private
   * @param {boolean} [visible]
   * Whether to show or hide an annotation. If the param is omitted, the
   * annotation's visibility is toggled.
   */
  setVisibility(visible) {
    const options2 = this.options, navigation3 = this.chart.navigationBindings, visibility = pick63(visible, !options2.visible);
    this.graphic.attr("visibility", visibility ? "inherit" : "hidden");
    if (!visibility) {
      const setItemControlPointsVisibility = function(item) {
        item.setControlPointsVisibility(visibility);
      };
      this.shapes.forEach(setItemControlPointsVisibility);
      this.labels.forEach(setItemControlPointsVisibility);
      if (navigation3.activeAnnotation === this && navigation3.popup && navigation3.popup.type === "annotation-toolbar") {
        fireEvent35(navigation3, "closePopup");
      }
    }
    options2.visible = visibility;
  }
  /**
   * Updates an annotation.
   *
   * @function Highcharts.Annotation#update
   *
   * @param {Partial<Highcharts.AnnotationsOptions>} userOptions
   *        New user options for the annotation.
   *
   */
  update(userOptions, redraw) {
    const chart = this.chart, labelsAndShapes = getLabelsAndShapesOptions(this.userOptions, userOptions), userOptionsIndex = chart.annotations.indexOf(this), options2 = merge54(true, this.userOptions, userOptions);
    options2.labels = labelsAndShapes.labels;
    options2.shapes = labelsAndShapes.shapes;
    this.destroy();
    this.initProperties(chart, options2);
    this.init(chart, options2);
    chart.options.annotations[userOptionsIndex] = this.options;
    this.isUpdating = true;
    if (pick63(redraw, true)) {
      chart.drawAnnotations();
    }
    fireEvent35(this, "afterUpdate");
    this.isUpdating = false;
  }
};
Annotation.ControlPoint = ControlPoint_default;
Annotation.MockPoint = MockPoint_default;
Annotation.shapesMap = {
  "rect": ControllableRect_default,
  "circle": ControllableCircle_default,
  "ellipse": ControllableEllipse_default,
  "path": ControllablePath_default,
  "image": ControllableImage_default
};
Annotation.types = {};
Annotation.prototype.defaultOptions = AnnotationDefaults_default;
Annotation.prototype.nonDOMEvents = ["add", "afterUpdate", "drag", "remove"];
ControlTarget_default.compose(Annotation);
var Annotation_default = Annotation;

// node_modules/highcharts/es-modules/Core/Chart/ChartNavigationComposition.js
var ChartNavigationComposition;
(function(ChartNavigationComposition2) {
  function compose27(chart) {
    if (!chart.navigation) {
      chart.navigation = new Additions(chart);
    }
    return chart;
  }
  ChartNavigationComposition2.compose = compose27;
  class Additions {
    /* *
     *
     *  Constructor
     *
     * */
    constructor(chart) {
      this.updates = [];
      this.chart = chart;
    }
    /* *
     *
     *  Functions
     *
     * */
    /**
     * Registers an `update()` method in the `chart.navigation` object.
     *
     * @private
     * @param {UpdateFunction} updateFn
     * The `update()` method that will be called in `chart.update()`.
     */
    addUpdate(updateFn) {
      this.chart.navigation.updates.push(updateFn);
    }
    /**
     * @private
     */
    update(options2, redraw) {
      this.updates.forEach((updateFn) => {
        updateFn.call(this.chart, options2, redraw);
      });
    }
  }
  ChartNavigationComposition2.Additions = Additions;
})(ChartNavigationComposition || (ChartNavigationComposition = {}));
var ChartNavigationComposition_default = ChartNavigationComposition;

// node_modules/highcharts/es-modules/Extensions/Annotations/NavigationBindingsDefaults.js
var { getAssignedAxis: getAssignedAxis3 } = NavigationBindingsUtilities_default;
var { isNumber: isNumber43, merge: merge55 } = Utilities_default;
var lang2 = {
  /**
   * Configure the Popup strings in the chart. Requires the
   * `annotations.js` or `annotations-advanced.src.js` module to be
   * loaded.
   * @since   7.0.0
   * @product highcharts highstock
   */
  navigation: {
    /**
     * Translations for all field names used in popup.
     *
     * @product highcharts highstock
     */
    popup: {
      simpleShapes: "Simple shapes",
      lines: "Lines",
      circle: "Circle",
      ellipse: "Ellipse",
      rectangle: "Rectangle",
      label: "Label",
      shapeOptions: "Shape options",
      typeOptions: "Details",
      fill: "Fill",
      format: "Text",
      strokeWidth: "Line width",
      stroke: "Line color",
      title: "Title",
      name: "Name",
      labelOptions: "Label options",
      labels: "Labels",
      backgroundColor: "Background color",
      backgroundColors: "Background colors",
      borderColor: "Border color",
      borderRadius: "Border radius",
      borderWidth: "Border width",
      style: "Style",
      padding: "Padding",
      fontSize: "Font size",
      color: "Color",
      height: "Height",
      shapes: "Shape options"
    }
  }
};
var navigation = {
  /**
   * A CSS class name where all bindings will be attached to. Multiple
   * charts on the same page should have separate class names to prevent
   * duplicating events.
   *
   * Default value of versions < 7.0.4 `highcharts-bindings-wrapper`
   *
   * @since     7.0.0
   * @type      {string}
   */
  bindingsClassName: "highcharts-bindings-container",
  /**
   * Bindings definitions for custom HTML buttons. Each binding implements
   * simple event-driven interface:
   *
   * - `className`: classname used to bind event to
   *
   * - `init`: initial event, fired on button click
   *
   * - `start`: fired on first click on a chart
   *
   * - `steps`: array of sequential events fired one after another on each
   *   of users clicks
   *
   * - `end`: last event to be called after last step event
   *
   * @type         {Highcharts.Dictionary<Highcharts.NavigationBindingsOptionsObject>|*}
   *
   * @sample {highstock} stock/stocktools/stocktools-thresholds
   *               Custom bindings
   * @sample {highcharts} highcharts/annotations/bindings/
   *               Simple binding
   * @sample {highcharts} highcharts/annotations/bindings-custom-annotation/
   *               Custom annotation binding
   *
   * @since        7.0.0
   * @requires     modules/annotations
   * @product      highcharts highstock
   */
  bindings: {
    /**
     * A circle annotation bindings. Includes `start` and one event in
     * `steps` array.
     *
     * @type    {Highcharts.NavigationBindingsOptionsObject}
     * @default {"className": "highcharts-circle-annotation", "start": function() {}, "steps": [function() {}], "annotationsOptions": {}}
     */
    circleAnnotation: {
      /** @ignore-option */
      className: "highcharts-circle-annotation",
      /** @ignore-option */
      start: function(e) {
        const coords = this.chart.pointer?.getCoordinates(e), coordsX = coords && getAssignedAxis3(coords.xAxis), coordsY = coords && getAssignedAxis3(coords.yAxis), navigation3 = this.chart.options.navigation;
        if (!coordsX || !coordsY) {
          return;
        }
        return this.chart.addAnnotation(merge55({
          langKey: "circle",
          type: "basicAnnotation",
          shapes: [{
            type: "circle",
            point: {
              x: coordsX.value,
              y: coordsY.value,
              xAxis: coordsX.axis.index,
              yAxis: coordsY.axis.index
            },
            r: 5
          }]
        }, navigation3.annotationsOptions, navigation3.bindings.circleAnnotation.annotationsOptions));
      },
      /** @ignore-option */
      steps: [
        function(e, annotation) {
          const shapes = annotation.options.shapes, mockPointOpts = shapes && shapes[0] && shapes[0].point || {};
          let distance;
          if (isNumber43(mockPointOpts.xAxis) && isNumber43(mockPointOpts.yAxis)) {
            const inverted = this.chart.inverted, x = this.chart.xAxis[mockPointOpts.xAxis].toPixels(mockPointOpts.x), y = this.chart.yAxis[mockPointOpts.yAxis].toPixels(mockPointOpts.y);
            distance = Math.max(Math.sqrt(Math.pow(inverted ? y - e.chartX : x - e.chartX, 2) + Math.pow(inverted ? x - e.chartY : y - e.chartY, 2)), 5);
          }
          annotation.update({
            shapes: [{
              r: distance
            }]
          });
        }
      ]
    },
    /**
     * A ellipse annotation bindings. Includes `start` and two events in
     * `steps` array. First updates the second point, responsible for a
     * rx width, and second updates the ry width.
     *
     * @type    {Highcharts.NavigationBindingsOptionsObject}
     * @default {"className": "highcharts-ellipse-annotation", "start": function() {}, "steps": [function() {}], "annotationsOptions": {}}
     */
    ellipseAnnotation: {
      className: "highcharts-ellipse-annotation",
      start: function(e) {
        const coords = this.chart.pointer?.getCoordinates(e), coordsX = coords && getAssignedAxis3(coords.xAxis), coordsY = coords && getAssignedAxis3(coords.yAxis), navigation3 = this.chart.options.navigation;
        if (!coordsX || !coordsY) {
          return;
        }
        return this.chart.addAnnotation(merge55({
          langKey: "ellipse",
          type: "basicAnnotation",
          shapes: [
            {
              type: "ellipse",
              xAxis: coordsX.axis.index,
              yAxis: coordsY.axis.index,
              points: [{
                x: coordsX.value,
                y: coordsY.value
              }, {
                x: coordsX.value,
                y: coordsY.value
              }],
              ry: 1
            }
          ]
        }, navigation3.annotationsOptions, navigation3.bindings.ellipseAnnotation.annotationsOptions));
      },
      steps: [
        function(e, annotation) {
          const target = annotation.shapes[0], position = target.getAbsolutePosition(target.points[1]);
          target.translatePoint(e.chartX - position.x, e.chartY - position.y, 1);
          target.redraw(false);
        },
        function(e, annotation) {
          const target = annotation.shapes[0], position = target.getAbsolutePosition(target.points[0]), position2 = target.getAbsolutePosition(target.points[1]), newR = target.getDistanceFromLine(position, position2, e.chartX, e.chartY), yAxis2 = target.getYAxis(), newRY = Math.abs(yAxis2.toValue(0) - yAxis2.toValue(newR));
          target.setYRadius(newRY);
          target.redraw(false);
        }
      ]
    },
    /**
     * A rectangle annotation bindings. Includes `start` and one event
     * in `steps` array.
     *
     * @type    {Highcharts.NavigationBindingsOptionsObject}
     * @default {"className": "highcharts-rectangle-annotation", "start": function() {}, "steps": [function() {}], "annotationsOptions": {}}
     */
    rectangleAnnotation: {
      /** @ignore-option */
      className: "highcharts-rectangle-annotation",
      /** @ignore-option */
      start: function(e) {
        const coords = this.chart.pointer?.getCoordinates(e), coordsX = coords && getAssignedAxis3(coords.xAxis), coordsY = coords && getAssignedAxis3(coords.yAxis);
        if (!coordsX || !coordsY) {
          return;
        }
        const x = coordsX.value, y = coordsY.value, xAxis2 = coordsX.axis.index, yAxis2 = coordsY.axis.index, navigation3 = this.chart.options.navigation;
        return this.chart.addAnnotation(merge55({
          langKey: "rectangle",
          type: "basicAnnotation",
          shapes: [{
            type: "path",
            points: [
              { xAxis: xAxis2, yAxis: yAxis2, x, y },
              { xAxis: xAxis2, yAxis: yAxis2, x, y },
              { xAxis: xAxis2, yAxis: yAxis2, x, y },
              { xAxis: xAxis2, yAxis: yAxis2, x, y },
              { command: "Z" }
            ]
          }]
        }, navigation3.annotationsOptions, navigation3.bindings.rectangleAnnotation.annotationsOptions));
      },
      /** @ignore-option */
      steps: [
        function(e, annotation) {
          const shapes = annotation.options.shapes, points = shapes && shapes[0] && shapes[0].points || [], coords = this.chart.pointer?.getCoordinates(e), coordsX = coords && getAssignedAxis3(coords.xAxis), coordsY = coords && getAssignedAxis3(coords.yAxis);
          if (coordsX && coordsY) {
            const x = coordsX.value, y = coordsY.value;
            points[1].x = x;
            points[2].x = x;
            points[2].y = y;
            points[3].y = y;
            annotation.update({
              shapes: [{
                points
              }]
            });
          }
        }
      ]
    },
    /**
     * A label annotation bindings. Includes `start` event only.
     *
     * @type    {Highcharts.NavigationBindingsOptionsObject}
     * @default {"className": "highcharts-label-annotation", "start": function() {}, "steps": [function() {}], "annotationsOptions": {}}
     */
    labelAnnotation: {
      /** @ignore-option */
      className: "highcharts-label-annotation",
      /** @ignore-option */
      start: function(e) {
        const coords = this.chart.pointer?.getCoordinates(e), coordsX = coords && getAssignedAxis3(coords.xAxis), coordsY = coords && getAssignedAxis3(coords.yAxis), navigation3 = this.chart.options.navigation;
        if (!coordsX || !coordsY) {
          return;
        }
        return this.chart.addAnnotation(merge55({
          langKey: "label",
          type: "basicAnnotation",
          labelOptions: {
            format: "{y:.2f}",
            overflow: "none",
            crop: true
          },
          labels: [{
            point: {
              xAxis: coordsX.axis.index,
              yAxis: coordsY.axis.index,
              x: coordsX.value,
              y: coordsY.value
            }
          }]
        }, navigation3.annotationsOptions, navigation3.bindings.labelAnnotation.annotationsOptions));
      }
    }
  },
  /**
   * Path where Highcharts will look for icons. Change this to use icons
   * from a different server.
   *
   * @type      {string}
   * @default   https://code.highcharts.com/12.2.0/gfx/stock-icons/
   * @since     7.1.3
   * @apioption navigation.iconsURL
   */
  /**
   * A `showPopup` event. Fired when selecting for example an annotation.
   *
   * @type      {Function}
   * @apioption navigation.events.showPopup
   */
  /**
   * A `closePopup` event. Fired when Popup should be hidden, for example
   * when clicking on an annotation again.
   *
   * @type      {Function}
   * @apioption navigation.events.closePopup
   */
  /**
   * Event fired on a button click.
   *
   * @type      {Function}
   * @sample    highcharts/annotations/gui/
   *            Change icon in a dropddown on event
   * @sample    highcharts/annotations/gui-buttons/
   *            Change button class on event
   * @apioption navigation.events.selectButton
   */
  /**
   * Event fired when button state should change, for example after
   * adding an annotation.
   *
   * @type      {Function}
   * @sample    highcharts/annotations/gui/
   *            Change icon in a dropddown on event
   * @sample    highcharts/annotations/gui-buttons/
   *            Change button class on event
   * @apioption navigation.events.deselectButton
   */
  /**
   * Events to communicate between Stock Tools and custom GUI.
   *
   * @since        7.0.0
   * @product      highcharts highstock
   * @optionparent navigation.events
   */
  events: {},
  /**
   * Additional options to be merged into all annotations.
   *
   * @sample stock/stocktools/navigation-annotation-options
   *         Set red color of all line annotations
   *
   * @type      {Highcharts.AnnotationsOptions}
   * @extends   annotations
   * @exclude   crookedLine, elliottWave, fibonacci, infinityLine,
   *            measure, pitchfork, tunnel, verticalLine, basicAnnotation
   * @requires     modules/annotations
   * @apioption navigation.annotationsOptions
   */
  annotationsOptions: {
    animation: {
      defer: 0
    }
  }
};
var NavigationBindingDefaults = {
  lang: lang2,
  navigation
};
var NavigationBindingsDefaults_default = NavigationBindingDefaults;

// node_modules/highcharts/es-modules/Extensions/Annotations/NavigationBindings.js
var { setOptions: setOptions3 } = Defaults_default;
var { format: format16 } = Templating_default;
var { composed: composed17, doc: doc25, win: win15 } = Globals_default;
var { getAssignedAxis: getAssignedAxis4, getFieldType: getFieldType2 } = NavigationBindingsUtilities_default;
var { addEvent: addEvent53, attr: attr17, defined: defined49, fireEvent: fireEvent36, isArray: isArray18, isFunction: isFunction6, isNumber: isNumber44, isObject: isObject16, merge: merge56, objectEach: objectEach26, pick: pick64, pushUnique: pushUnique20 } = Utilities_default;
function closestPolyfill(el, s) {
  const ElementProto = win15.Element.prototype, elementMatches = ElementProto.matches || ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector;
  let ret = null;
  if (ElementProto.closest) {
    ret = ElementProto.closest.call(el, s);
  } else {
    do {
      if (elementMatches.call(el, s)) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);
  }
  return ret;
}
function onAnnotationRemove() {
  if (this.chart.navigationBindings) {
    this.chart.navigationBindings.deselectAnnotation();
  }
}
function onChartDestroy2() {
  if (this.navigationBindings) {
    this.navigationBindings.destroy();
  }
}
function onChartLoad() {
  const options2 = this.options;
  if (options2 && options2.navigation && options2.navigation.bindings) {
    this.navigationBindings = new NavigationBindings(this, options2.navigation);
    this.navigationBindings.initEvents();
    this.navigationBindings.initUpdate();
  }
}
function onChartRender3() {
  const navigationBindings = this.navigationBindings, disabledClassName = "highcharts-disabled-btn";
  if (this && navigationBindings) {
    let buttonsEnabled = false;
    this.series.forEach((series) => {
      if (!series.options.isInternal && series.visible) {
        buttonsEnabled = true;
      }
    });
    if (this.navigationBindings && this.navigationBindings.container && this.navigationBindings.container[0]) {
      const container = this.navigationBindings.container[0];
      objectEach26(navigationBindings.boundClassNames, (value, key) => {
        const buttonNode = container.querySelectorAll("." + key);
        if (buttonNode) {
          for (let i = 0; i < buttonNode.length; i++) {
            const button = buttonNode[i], cls = button.className;
            if (value.noDataState === "normal") {
              if (cls.indexOf(disabledClassName) !== -1) {
                button.classList.remove(disabledClassName);
              }
            } else if (!buttonsEnabled) {
              if (cls.indexOf(disabledClassName) === -1) {
                button.className += " " + disabledClassName;
              }
            } else {
              if (cls.indexOf(disabledClassName) !== -1) {
                button.classList.remove(disabledClassName);
              }
            }
          }
        }
      });
    }
  }
}
function onNavigationBindingsClosePopup2() {
  this.deselectAnnotation();
}
function onNavigationBindingsDeselectButton() {
  this.selectedButtonElement = null;
}
function selectableAnnotation(annotationType) {
  const originalClick = annotationType.prototype.defaultOptions.events && annotationType.prototype.defaultOptions.events.click;
  function selectAndShowPopup(eventArguments) {
    const annotation = this, navigation3 = annotation.chart.navigationBindings, prevAnnotation = navigation3.activeAnnotation;
    if (originalClick) {
      originalClick.call(annotation, eventArguments);
    }
    if (prevAnnotation !== annotation) {
      navigation3.deselectAnnotation();
      navigation3.activeAnnotation = annotation;
      annotation.setControlPointsVisibility(true);
      fireEvent36(navigation3, "showPopup", {
        annotation,
        formType: "annotation-toolbar",
        options: navigation3.annotationToFields(annotation),
        onSubmit: function(data) {
          if (data.actionType === "remove") {
            navigation3.activeAnnotation = false;
            navigation3.chart.removeAnnotation(annotation);
          } else {
            const config2 = {};
            navigation3.fieldsToOptions(data.fields, config2);
            navigation3.deselectAnnotation();
            const typeOptions = config2.typeOptions;
            if (annotation.options.type === "measure") {
              typeOptions.crosshairY.enabled = typeOptions.crosshairY.strokeWidth !== 0;
              typeOptions.crosshairX.enabled = typeOptions.crosshairX.strokeWidth !== 0;
            }
            annotation.update(config2);
          }
        }
      });
    } else {
      fireEvent36(navigation3, "closePopup");
    }
    eventArguments.activeAnnotation = true;
  }
  let touchStartX, touchStartY;
  function saveCoords(e) {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  }
  function checkForTouchmove(e) {
    const hasMoved = touchStartX ? Math.sqrt(Math.pow(touchStartX - e.changedTouches[0].clientX, 2) + Math.pow(touchStartY - e.changedTouches[0].clientY, 2)) >= 4 : false;
    if (!hasMoved) {
      selectAndShowPopup.call(this, e);
    }
  }
  merge56(true, annotationType.prototype.defaultOptions.events, {
    click: selectAndShowPopup,
    touchstart: saveCoords,
    touchend: checkForTouchmove
  });
}
var NavigationBindings = class _NavigationBindings {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(AnnotationClass, ChartClass) {
    if (pushUnique20(composed17, "NavigationBindings")) {
      addEvent53(AnnotationClass, "remove", onAnnotationRemove);
      selectableAnnotation(AnnotationClass);
      objectEach26(AnnotationClass.types, (annotationType) => {
        selectableAnnotation(annotationType);
      });
      addEvent53(ChartClass, "destroy", onChartDestroy2);
      addEvent53(ChartClass, "load", onChartLoad);
      addEvent53(ChartClass, "render", onChartRender3);
      addEvent53(_NavigationBindings, "closePopup", onNavigationBindingsClosePopup2);
      addEvent53(_NavigationBindings, "deselectButton", onNavigationBindingsDeselectButton);
      setOptions3(NavigationBindingsDefaults_default);
    }
  }
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart, options2) {
    this.boundClassNames = void 0;
    this.chart = chart;
    this.options = options2;
    this.eventsToUnbind = [];
    this.container = this.chart.container.getElementsByClassName(this.options.bindingsClassName || "");
    if (!this.container.length) {
      this.container = doc25.getElementsByClassName(this.options.bindingsClassName || "");
    }
  }
  /* *
   *
   *  Functions
   *
   * */
  getCoords(e) {
    const coords = this.chart.pointer?.getCoordinates(e);
    return [
      coords && getAssignedAxis4(coords.xAxis),
      coords && getAssignedAxis4(coords.yAxis)
    ];
  }
  /**
   * Init all events connected to NavigationBindings.
   *
   * @private
   * @function Highcharts.NavigationBindings#initEvents
   */
  initEvents() {
    const navigation3 = this, chart = navigation3.chart, bindingsContainer = navigation3.container, options2 = navigation3.options;
    navigation3.boundClassNames = {};
    objectEach26(options2.bindings || {}, (value) => {
      navigation3.boundClassNames[value.className] = value;
    });
    [].forEach.call(bindingsContainer, (subContainer) => {
      navigation3.eventsToUnbind.push(addEvent53(subContainer, "click", (event) => {
        const bindings = navigation3.getButtonEvents(subContainer, event);
        if (bindings && !bindings.button.classList.contains("highcharts-disabled-btn")) {
          navigation3.bindingsButtonClick(bindings.button, bindings.events, event);
        }
      }));
    });
    objectEach26(options2.events || {}, (callback, eventName) => {
      if (isFunction6(callback)) {
        navigation3.eventsToUnbind.push(addEvent53(navigation3, eventName, callback, { passive: false }));
      }
    });
    navigation3.eventsToUnbind.push(addEvent53(chart.container, "click", function(e) {
      if (!chart.cancelClick && chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop, {
        visiblePlotOnly: true
      })) {
        navigation3.bindingsChartClick(this, e);
      }
    }));
    navigation3.eventsToUnbind.push(addEvent53(chart.container, Globals_default.isTouchDevice ? "touchmove" : "mousemove", function(e) {
      navigation3.bindingsContainerMouseMove(this, e);
    }, Globals_default.isTouchDevice ? { passive: false } : void 0));
  }
  /**
   * Common chart.update() delegation, shared between bindings and exporting.
   *
   * @private
   * @function Highcharts.NavigationBindings#initUpdate
   */
  initUpdate() {
    const navigation3 = this;
    ChartNavigationComposition_default.compose(this.chart).navigation.addUpdate((options2) => {
      navigation3.update(options2);
    });
  }
  /**
   * Hook for click on a button, method selects/unselects buttons,
   * then calls `bindings.init` callback.
   *
   * @private
   * @function Highcharts.NavigationBindings#bindingsButtonClick
   *
   * @param {Highcharts.HTMLDOMElement} [button]
   *        Clicked button
   *
   * @param {Object} events
   *        Events passed down from bindings (`init`, `start`, `step`, `end`)
   *
   * @param {Highcharts.PointerEventObject} clickEvent
   *        Browser's click event
   */
  bindingsButtonClick(button, events, clickEvent) {
    const navigation3 = this, chart = navigation3.chart, svgContainer = chart.renderer.boxWrapper;
    let shouldEventBeFired = true;
    if (navigation3.selectedButtonElement) {
      if (navigation3.selectedButtonElement.classList === button.classList) {
        shouldEventBeFired = false;
      }
      fireEvent36(navigation3, "deselectButton", { button: navigation3.selectedButtonElement });
      if (navigation3.nextEvent) {
        if (navigation3.currentUserDetails && navigation3.currentUserDetails.coll === "annotations") {
          chart.removeAnnotation(navigation3.currentUserDetails);
        }
        navigation3.mouseMoveEvent = navigation3.nextEvent = false;
      }
    }
    if (shouldEventBeFired) {
      navigation3.selectedButton = events;
      navigation3.selectedButtonElement = button;
      fireEvent36(navigation3, "selectButton", { button });
      if (events.init) {
        events.init.call(navigation3, button, clickEvent);
      }
      if (events.start || events.steps) {
        chart.renderer.boxWrapper.addClass("highcharts-draw-mode");
      }
    } else {
      chart.stockTools && button.classList.remove("highcharts-active");
      svgContainer.removeClass("highcharts-draw-mode");
      navigation3.nextEvent = false;
      navigation3.mouseMoveEvent = false;
      navigation3.selectedButton = null;
    }
  }
  /**
   * Hook for click on a chart, first click on a chart calls `start` event,
   * then on all subsequent clicks iterate over `steps` array.
   * When finished, calls `end` event.
   *
   * @private
   * @function Highcharts.NavigationBindings#bindingsChartClick
   *
   * @param {Highcharts.Chart} chart
   *        Chart that click was performed on.
   *
   * @param {Highcharts.PointerEventObject} clickEvent
   *        Browser's click event.
   */
  bindingsChartClick(chart, clickEvent) {
    chart = this.chart;
    const navigation3 = this, activeAnnotation = navigation3.activeAnnotation, selectedButton = navigation3.selectedButton, svgContainer = chart.renderer.boxWrapper;
    if (activeAnnotation) {
      if (!activeAnnotation.cancelClick && // #15729
      !clickEvent.activeAnnotation && // Element could be removed in the child action, e.g. button
      clickEvent.target.parentNode && // TO DO: Polyfill for IE11?
      !closestPolyfill(clickEvent.target, ".highcharts-popup")) {
        fireEvent36(navigation3, "closePopup");
      } else if (activeAnnotation.cancelClick) {
        setTimeout(() => {
          activeAnnotation.cancelClick = false;
        }, 0);
      }
    }
    if (!selectedButton || !selectedButton.start) {
      return;
    }
    if (!navigation3.nextEvent) {
      navigation3.currentUserDetails = selectedButton.start.call(navigation3, clickEvent);
      if (navigation3.currentUserDetails && selectedButton.steps) {
        navigation3.stepIndex = 0;
        navigation3.steps = true;
        navigation3.mouseMoveEvent = navigation3.nextEvent = selectedButton.steps[navigation3.stepIndex];
      } else {
        fireEvent36(navigation3, "deselectButton", { button: navigation3.selectedButtonElement });
        svgContainer.removeClass("highcharts-draw-mode");
        navigation3.steps = false;
        navigation3.selectedButton = null;
        if (selectedButton.end) {
          selectedButton.end.call(navigation3, clickEvent, navigation3.currentUserDetails);
        }
      }
    } else {
      navigation3.nextEvent(clickEvent, navigation3.currentUserDetails);
      if (navigation3.steps) {
        navigation3.stepIndex++;
        if (selectedButton.steps[navigation3.stepIndex]) {
          navigation3.mouseMoveEvent = navigation3.nextEvent = selectedButton.steps[navigation3.stepIndex];
        } else {
          fireEvent36(navigation3, "deselectButton", { button: navigation3.selectedButtonElement });
          svgContainer.removeClass("highcharts-draw-mode");
          if (selectedButton.end) {
            selectedButton.end.call(navigation3, clickEvent, navigation3.currentUserDetails);
          }
          navigation3.nextEvent = false;
          navigation3.mouseMoveEvent = false;
          navigation3.selectedButton = null;
        }
      }
    }
  }
  /**
   * Hook for mouse move on a chart's container. It calls current step.
   *
   * @private
   * @function Highcharts.NavigationBindings#bindingsContainerMouseMove
   *
   * @param {Highcharts.HTMLDOMElement} container
   *        Chart's container.
   *
   * @param {global.Event} moveEvent
   *        Browser's move event.
   */
  bindingsContainerMouseMove(_container, moveEvent) {
    if (this.mouseMoveEvent) {
      this.mouseMoveEvent(moveEvent, this.currentUserDetails);
    }
  }
  /**
   * Translate fields (e.g. `params.period` or `marker.styles.color`) to
   * Highcharts options object (e.g. `{ params: { period } }`).
   *
   * @private
   * @function Highcharts.NavigationBindings#fieldsToOptions<T>
   *
   * @param {Highcharts.Dictionary<string>} fields
   *        Fields from popup form.
   *
   * @param {T} config
   *        Default config to be modified.
   *
   * @return {T}
   *         Modified config
   */
  fieldsToOptions(fields, config2) {
    objectEach26(fields, (value, field) => {
      const parsedValue = parseFloat(value), path = field.split("."), pathLength = path.length - 1;
      if (isNumber44(parsedValue) && !value.match(/px|em/g) && !field.match(/format/g)) {
        value = parsedValue;
      }
      if (value !== "undefined") {
        let parent = config2;
        path.forEach((name, index) => {
          if (name !== "__proto__" && name !== "constructor") {
            const nextName = pick64(path[index + 1], "");
            if (pathLength === index) {
              parent[name] = value;
            } else if (!parent[name]) {
              parent[name] = nextName.match(/\d/g) ? [] : {};
              parent = parent[name];
            } else {
              parent = parent[name];
            }
          }
        });
      }
    });
    return config2;
  }
  /**
   * Shorthand method to deselect an annotation.
   *
   * @function Highcharts.NavigationBindings#deselectAnnotation
   */
  deselectAnnotation() {
    if (this.activeAnnotation) {
      this.activeAnnotation.setControlPointsVisibility(false);
      this.activeAnnotation = false;
    }
  }
  /**
   * Generates API config for popup in the same format as options for
   * Annotation object.
   *
   * @function Highcharts.NavigationBindings#annotationToFields
   *
   * @param {Highcharts.Annotation} annotation
   *        Annotations object
   *
   * @return {Highcharts.Dictionary<string>}
   *         Annotation options to be displayed in popup box
   */
  annotationToFields(annotation) {
    const options2 = annotation.options, editables = _NavigationBindings.annotationsEditable, nestedEditables = editables.nestedOptions, type = pick64(options2.type, options2.shapes && options2.shapes[0] && options2.shapes[0].type, options2.labels && options2.labels[0] && options2.labels[0].type, "label"), nonEditables = _NavigationBindings.annotationsNonEditable[options2.langKey] || [], visualOptions = {
      langKey: options2.langKey,
      type
    };
    function traverse(option, key, parentEditables, parent, parentKey) {
      let nextParent;
      if (parentEditables && defined49(option) && nonEditables.indexOf(key) === -1 && ((parentEditables.indexOf && parentEditables.indexOf(key)) >= 0 || parentEditables[key] || // Nested array
      parentEditables === true)) {
        if (isArray18(option)) {
          parent[key] = [];
          option.forEach((arrayOption, i) => {
            if (!isObject16(arrayOption)) {
              traverse(arrayOption, 0, nestedEditables[key], parent[key], key);
            } else {
              parent[key][i] = {};
              objectEach26(arrayOption, (nestedOption, nestedKey) => {
                traverse(nestedOption, nestedKey, nestedEditables[key], parent[key][i], key);
              });
            }
          });
        } else if (isObject16(option)) {
          nextParent = {};
          if (isArray18(parent)) {
            parent.push(nextParent);
            nextParent[key] = {};
            nextParent = nextParent[key];
          } else {
            parent[key] = nextParent;
          }
          objectEach26(option, (nestedOption, nestedKey) => {
            traverse(nestedOption, nestedKey, key === 0 ? parentEditables : nestedEditables[key], nextParent, key);
          });
        } else {
          if (key === "format") {
            parent[key] = [
              format16(option, annotation.labels[0].points[0]).toString(),
              "text"
            ];
          } else if (isArray18(parent)) {
            parent.push([option, getFieldType2(parentKey, option)]);
          } else {
            parent[key] = [option, getFieldType2(key, option)];
          }
        }
      }
    }
    objectEach26(options2, (option, key) => {
      if (key === "typeOptions") {
        visualOptions[key] = {};
        objectEach26(options2[key], (typeOption, typeKey) => {
          traverse(typeOption, typeKey, nestedEditables, visualOptions[key], typeKey);
        });
      } else {
        traverse(option, key, editables[type], visualOptions, key);
      }
    });
    return visualOptions;
  }
  /**
   * Get all class names for all parents in the element. Iterates until finds
   * main container.
   *
   * @private
   * @function Highcharts.NavigationBindings#getClickedClassNames
   *
   * @param {Highcharts.HTMLDOMElement} container
   * Container that event is bound to.
   *
   * @param {global.Event} event
   * Browser's event.
   *
   * @return {Array<Array<string, Highcharts.HTMLDOMElement>>}
   * Array of class names with corresponding elements
   */
  getClickedClassNames(container, event) {
    let element = event.target, classNames = [], elemClassName;
    while (element && element.tagName) {
      elemClassName = attr17(element, "class");
      if (elemClassName) {
        classNames = classNames.concat(elemClassName.split(" ").map((name) => [name, element]));
      }
      element = element.parentNode;
      if (element === container) {
        return classNames;
      }
    }
    return classNames;
  }
  /**
   * Get events bound to a button. It's a custom event delegation to find all
   * events connected to the element.
   *
   * @private
   * @function Highcharts.NavigationBindings#getButtonEvents
   *
   * @param {Highcharts.HTMLDOMElement} container
   *        Container that event is bound to.
   *
   * @param {global.Event} event
   *        Browser's event.
   *
   * @return {Object}
   *         Object with events (init, start, steps, and end)
   */
  getButtonEvents(container, event) {
    const navigation3 = this, classNames = this.getClickedClassNames(container, event);
    let bindings;
    classNames.forEach((className) => {
      if (navigation3.boundClassNames[className[0]] && !bindings) {
        bindings = {
          events: navigation3.boundClassNames[className[0]],
          button: className[1]
        };
      }
    });
    return bindings;
  }
  /**
   * Bindings are just events, so the whole update process is simply
   * removing old events and adding new ones.
   *
   * @private
   * @function Highcharts.NavigationBindings#update
   */
  update(options2) {
    this.options = merge56(true, this.options, options2);
    this.removeEvents();
    this.initEvents();
  }
  /**
   * Remove all events created in the navigation.
   *
   * @private
   * @function Highcharts.NavigationBindings#removeEvents
   */
  removeEvents() {
    this.eventsToUnbind.forEach((unbinder) => unbinder());
  }
  /**
   * @private
   * @function Highcharts.NavigationBindings#destroy
   */
  destroy() {
    this.removeEvents();
  }
};
NavigationBindings.annotationsEditable = {
  // `typeOptions` are always available
  // Nested and shared options:
  nestedOptions: {
    labelOptions: ["style", "format", "backgroundColor"],
    labels: ["style"],
    label: ["style"],
    style: ["fontSize", "color"],
    background: ["fill", "strokeWidth", "stroke"],
    innerBackground: ["fill", "strokeWidth", "stroke"],
    outerBackground: ["fill", "strokeWidth", "stroke"],
    shapeOptions: ["fill", "strokeWidth", "stroke"],
    shapes: ["fill", "strokeWidth", "stroke"],
    line: ["strokeWidth", "stroke"],
    backgroundColors: [true],
    connector: ["fill", "strokeWidth", "stroke"],
    crosshairX: ["strokeWidth", "stroke"],
    crosshairY: ["strokeWidth", "stroke"]
  },
  // Simple shapes:
  circle: ["shapes"],
  ellipse: ["shapes"],
  verticalLine: [],
  label: ["labelOptions"],
  // Measure
  measure: ["background", "crosshairY", "crosshairX"],
  // Others:
  fibonacci: [],
  tunnel: ["background", "line", "height"],
  pitchfork: ["innerBackground", "outerBackground"],
  rect: ["shapes"],
  // Crooked lines, elliots, arrows etc:
  crookedLine: [],
  basicAnnotation: ["shapes", "labelOptions"]
};
NavigationBindings.annotationsNonEditable = {
  rectangle: ["crosshairX", "crosshairY", "labelOptions"],
  ellipse: ["labelOptions"],
  circle: ["labelOptions"]
};
var NavigationBindings_default = NavigationBindings;

// node_modules/highcharts/es-modules/masters/modules/annotations.src.js
var G7 = Globals_default;
G7.Annotation = G7.Annotation || Annotation_default;
G7.NavigationBindings = G7.NavigationBindings || NavigationBindings_default;
G7.Annotation.compose(G7.Chart, G7.NavigationBindings, G7.Pointer, G7.SVGRenderer);

// node_modules/highcharts/es-modules/Extensions/Pane/PaneComposition.js
var { addEvent: addEvent54, correctFloat: correctFloat12, defined: defined50, pick: pick65 } = Utilities_default;
function chartGetHoverPane(eventArgs) {
  const chart = this;
  let hoverPane;
  if (eventArgs) {
    chart.pane.forEach((pane2) => {
      const x = eventArgs.chartX - chart.plotLeft, y = eventArgs.chartY - chart.plotTop;
      if (isInsidePane(x, y, pane2.center)) {
        hoverPane = pane2;
      }
    });
  }
  return hoverPane;
}
function compose11(ChartClass, PointerClass) {
  const chartProto = ChartClass.prototype;
  if (!chartProto.getHoverPane) {
    chartProto.collectionsWithUpdate.push("pane");
    chartProto.getHoverPane = chartGetHoverPane;
    addEvent54(ChartClass, "afterIsInsidePlot", onChartAfterIsInsiderPlot);
    addEvent54(PointerClass, "afterGetHoverData", onPointerAfterGetHoverData);
    addEvent54(PointerClass, "beforeGetHoverData", onPointerBeforeGetHoverData);
  }
}
function isInsidePane(x, y, center, startAngle, endAngle) {
  let insideSlice = true;
  const cx = center[0], cy = center[1];
  const distance = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2));
  if (defined50(startAngle) && defined50(endAngle)) {
    const angle = Math.atan2(correctFloat12(y - cy, 8), correctFloat12(x - cx, 8));
    if (endAngle !== startAngle) {
      if (startAngle > endAngle) {
        insideSlice = angle >= startAngle && angle <= Math.PI || angle <= endAngle && angle >= -Math.PI;
      } else {
        insideSlice = angle >= startAngle && angle <= correctFloat12(endAngle, 8);
      }
    }
  }
  return distance <= Math.ceil(center[2] / 2) && insideSlice;
}
function onChartAfterIsInsiderPlot(e) {
  const chart = this;
  if (chart.polar) {
    if (e.options.inverted) {
      [e.x, e.y] = [e.y, e.x];
    }
    e.isInsidePlot = chart.pane.some((pane2) => isInsidePane(e.x, e.y, pane2.center, pane2.axis && pane2.axis.normalizedStartAngleRad, pane2.axis && pane2.axis.normalizedEndAngleRad));
  }
}
function onPointerAfterGetHoverData(eventArgs) {
  const chart = this.chart;
  if (eventArgs.hoverPoint && eventArgs.hoverPoint.plotX && eventArgs.hoverPoint.plotY && chart.hoverPane && !isInsidePane(eventArgs.hoverPoint.plotX, eventArgs.hoverPoint.plotY, chart.hoverPane.center)) {
    eventArgs.hoverPoint = void 0;
  }
}
function onPointerBeforeGetHoverData(eventArgs) {
  const chart = this.chart;
  if (chart.polar) {
    chart.hoverPane = chart.getHoverPane(eventArgs);
    eventArgs.filter = function(s) {
      return s.visible && !(!eventArgs.shared && s.directTouch) && // #3821
      pick65(s.options.enableMouseTracking, true) && (!chart.hoverPane || s.xAxis.pane === chart.hoverPane);
    };
  } else {
    chart.hoverPane = void 0;
  }
}
var PaneComposition = {
  compose: compose11
};
var PaneComposition_default = PaneComposition;

// node_modules/highcharts/es-modules/Extensions/Pane/PaneDefaults.js
var background = {
  /**
   * The class name for this background.
   *
   * @sample {highcharts} highcharts/css/pane/
   *         Panes styled by CSS
   * @sample {highstock} highcharts/css/pane/
   *         Panes styled by CSS
   * @sample {highmaps} highcharts/css/pane/
   *         Panes styled by CSS
   *
   * @type      {string}
   * @default   highcharts-pane
   * @since     5.0.0
   * @apioption pane.background.className
   */
  /**
   * The shape of the pane background. When `solid`, the background
   * is circular. When `arc`, the background extends only from the min
   * to the max of the value axis.
   *
   * @type    {Highcharts.PaneBackgroundShapeValue}
   * @since   2.3.0
   * @product highcharts
   */
  shape: "circle",
  /**
   * The border radius of the pane background when the shape is `arc`. Can be
   * a number (pixels) or a percentage string.
   *
   * @since 11.4.2
   * @sample  highcharts/series-solidgauge/pane-borderradius
   *          Circular gauge and pane with equal border radius
   * @product highcharts
   * @type    {number|string}
   */
  borderRadius: 0,
  /**
   * The pixel border width of the pane background.
   *
   * @since 2.3.0
   * @product highcharts
   */
  borderWidth: 1,
  /**
   * The pane background border color.
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since   2.3.0
   * @product highcharts
   */
  borderColor: "#cccccc",
  /**
   * The background color or gradient for the pane.
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, #ffffff], [1, #e6e6e6]] }
   * @since   2.3.0
   * @product highcharts
   */
  backgroundColor: {
    /** @ignore-option */
    linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
    /** @ignore-option */
    stops: [
      [
        0,
        "#ffffff"
        /* Palette.backgroundColor */
      ],
      [
        1,
        "#e6e6e6"
        /* Palette.neutralColor10 */
      ]
    ]
  },
  /** @ignore-option */
  from: -Number.MAX_VALUE,
  // Corrected to axis min
  /**
   * The inner radius of the pane background. Can be either numeric
   * (pixels) or a percentage string.
   *
   * @type    {number|string}
   * @since   2.3.0
   * @product highcharts
   */
  innerRadius: 0,
  /** @ignore-option */
  to: Number.MAX_VALUE,
  // Corrected to axis max
  /**
   * The outer radius of the circular pane background. Can be either
   * numeric (pixels) or a percentage string.
   *
   * @type     {number|string}
   * @since    2.3.0
   * @product  highcharts
   */
  outerRadius: "105%"
};
var pane = {
  /**
   * The end angle of the polar X axis or gauge value axis, given in
   * degrees where 0 is north. Defaults to [startAngle](#pane.startAngle)
   * + 360.
   *
   * @sample {highcharts} highcharts/demo/gauge-vu-meter/
   *         VU-meter with custom start and end angle
   *
   * @type      {number}
   * @since     2.3.0
   * @product   highcharts
   * @apioption pane.endAngle
   */
  /**
   * The center of a polar chart or angular gauge, given as an array
   * of [x, y] positions. Positions can be given as integers that
   * transform to pixels, or as percentages of the plot area size.
   *
   * @sample {highcharts} highcharts/demo/gauge-vu-meter/
   *         Two gauges with different center
   *
   * @type    {Array<string|number>}
   * @default ["50%", "50%"]
   * @since   2.3.0
   * @product highcharts
   */
  center: ["50%", "50%"],
  /**
   * The size of the pane, either as a number defining pixels, or a
   * percentage defining a percentage of the available plot area (the
   * smallest of the plot height or plot width).
   *
   * @sample {highcharts} highcharts/demo/gauge-vu-meter/
   *         Smaller size
   *
   * @type    {number|string}
   * @product highcharts
   */
  size: "85%",
  /**
   * The inner size of the pane, either as a number defining pixels, or a
   * percentage defining a percentage of the pane's size.
   *
   * @sample {highcharts} highcharts/series-polar/column-inverted-inner
   *         The inner size set to 20%
   *
   * @type    {number|string}
   * @product highcharts
   */
  innerSize: "0%",
  /**
   * The start angle of the polar X axis or gauge axis, given in degrees
   * where 0 is north. Defaults to 0.
   *
   * @sample {highcharts} highcharts/demo/gauge-vu-meter/
   *         VU-meter with custom start and end angle
   *
   * @since   2.3.0
   * @product highcharts
   */
  startAngle: 0
};
var PaneDefaults = {
  pane,
  background
};
var PaneDefaults_default = PaneDefaults;

// node_modules/highcharts/es-modules/Extensions/Pane/Pane.js
var { extend: extend46, merge: merge57, splat: splat14 } = Utilities_default;
var Pane = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(options2, chart) {
    this.coll = "pane";
    this.init(options2, chart);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Initialize the Pane object
   *
   * @private
   * @function Highcharts.Pane#init
   *
   * @param {Highcharts.PaneOptions} options
   *
   * @param {Highcharts.Chart} chart
   */
  init(options2, chart) {
    this.chart = chart;
    this.background = [];
    chart.pane.push(this);
    this.setOptions(options2);
  }
  /**
   * @private
   * @function Highcharts.Pane#setOptions
   *
   * @param {Highcharts.PaneOptions} options
   */
  setOptions(options2) {
    this.options = options2 = merge57(PaneDefaults_default.pane, this.chart.angular ? { background: {} } : void 0, options2);
  }
  /**
   * Render the pane with its backgrounds.
   *
   * @private
   * @function Highcharts.Pane#render
   */
  render() {
    const options2 = this.options, renderer = this.chart.renderer;
    if (!this.group) {
      this.group = renderer.g("pane-group").attr({ zIndex: options2.zIndex || 0 }).add();
    }
    this.updateCenter();
    let backgroundOption = this.options.background;
    if (backgroundOption) {
      backgroundOption = splat14(backgroundOption);
      const len = Math.max(backgroundOption.length, this.background.length || 0);
      for (let i = 0; i < len; i++) {
        if (backgroundOption[i] && this.axis) {
          this.renderBackground(merge57(PaneDefaults_default.background, backgroundOption[i]), i);
        } else if (this.background[i]) {
          this.background[i] = this.background[i].destroy();
          this.background.splice(i, 1);
        }
      }
    }
  }
  /**
   * Render an individual pane background.
   *
   * @private
   * @function Highcharts.Pane#renderBackground
   *
   * @param {Highcharts.PaneBackgroundOptions} backgroundOptions
   *        Background options
   *
   * @param {number} i
   *        The index of the background in this.backgrounds
   */
  renderBackground(backgroundOptions, i) {
    const attribs = {
      "class": "highcharts-pane " + (backgroundOptions.className || "")
    };
    let method = "animate";
    if (!this.chart.styledMode) {
      extend46(attribs, {
        "fill": backgroundOptions.backgroundColor,
        "stroke": backgroundOptions.borderColor,
        "stroke-width": backgroundOptions.borderWidth
      });
    }
    if (!this.background[i]) {
      this.background[i] = this.chart.renderer.path().add(this.group);
      method = "attr";
    }
    this.background[i][method]({
      "d": this.axis.getPlotBandPath(backgroundOptions.from, backgroundOptions.to, backgroundOptions)
    }).attr(attribs);
  }
  /**
   * Gets the center for the pane and its axis.
   *
   * @private
   * @function Highcharts.Pane#updateCenter
   * @param {Highcharts.Axis} [axis]
   */
  updateCenter(axis) {
    this.center = (axis || this.axis || {}).center = CenteredUtilities_default.getCenter.call(this);
  }
  /**
   * Destroy the pane item
   *
   * @ignore
   * @private
   * @function Highcharts.Pane#destroy
   * /
  destroy: function () {
      erase(this.chart.pane, this);
      this.background.forEach(function (background) {
          background.destroy();
      });
      this.background.length = 0;
      this.group = this.group.destroy();
  },
  */
  /**
   * Update the pane item with new options
   *
   * @private
   * @function Highcharts.Pane#update
   * @param {Highcharts.PaneOptions} options
   *        New pane options
   * @param {boolean} [redraw]
   */
  update(options2, redraw) {
    merge57(true, this.options, options2);
    this.setOptions(this.options);
    this.render();
    this.chart.axes.forEach(function(axis) {
      if (axis.pane === this) {
        axis.pane = null;
        axis.update({}, redraw);
      }
    }, this);
  }
};
Pane.compose = PaneComposition_default.compose;
var Pane_default = Pane;

// node_modules/highcharts/es-modules/Series/AreaRange/AreaRangePoint.js
var { area: { prototype: { pointClass: AreaPoint, pointClass: { prototype: areaProto2 } } } } = SeriesRegistry_default.seriesTypes;
var { defined: defined51, isNumber: isNumber45 } = Utilities_default;
var AreaRangePoint = class extends AreaPoint {
  /**
   * Range series only. The high or maximum value for each data point.
   * @name Highcharts.Point#high
   * @type {number|undefined}
   */
  /**
   * Range series only. The low or minimum value for each data point.
   * @name Highcharts.Point#low
   * @type {number|undefined}
   */
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  setState() {
    const prevState = this.state, series = this.series, isPolar = series.chart.polar;
    if (!defined51(this.plotHigh)) {
      this.plotHigh = series.yAxis.toPixels(this.high, true);
    }
    if (!defined51(this.plotLow)) {
      this.plotLow = this.plotY = series.yAxis.toPixels(this.low, true);
    }
    series.lowerStateMarkerGraphic = series.stateMarkerGraphic;
    series.stateMarkerGraphic = series.upperStateMarkerGraphic;
    this.graphic = this.graphics && this.graphics[1];
    this.plotY = this.plotHigh;
    if (isPolar && isNumber45(this.plotHighX)) {
      this.plotX = this.plotHighX;
    }
    areaProto2.setState.apply(this, arguments);
    this.state = prevState;
    this.plotY = this.plotLow;
    this.graphic = this.graphics && this.graphics[0];
    if (isPolar && isNumber45(this.plotLowX)) {
      this.plotX = this.plotLowX;
    }
    series.upperStateMarkerGraphic = series.stateMarkerGraphic;
    series.stateMarkerGraphic = series.lowerStateMarkerGraphic;
    series.lowerStateMarkerGraphic = void 0;
    const originalSettings = series.modifyMarkerSettings();
    areaProto2.setState.apply(this, arguments);
    series.restoreMarkerSettings(originalSettings);
  }
  haloPath() {
    const isPolar = this.series.chart.polar;
    let path = [];
    this.plotY = this.plotLow;
    if (isPolar && isNumber45(this.plotLowX)) {
      this.plotX = this.plotLowX;
    }
    if (this.isInside) {
      path = areaProto2.haloPath.apply(this, arguments);
    }
    this.plotY = this.plotHigh;
    if (isPolar && isNumber45(this.plotHighX)) {
      this.plotX = this.plotHighX;
    }
    if (this.isTopInside) {
      path = path.concat(areaProto2.haloPath.apply(this, arguments));
    }
    return path;
  }
  isValid() {
    return isNumber45(this.low) && isNumber45(this.high);
  }
};
var AreaRangePoint_default = AreaRangePoint;

// node_modules/highcharts/es-modules/Series/AreaRange/AreaRangeSeries.js
var { noop: noop7 } = Globals_default;
var { area: AreaSeries3, area: { prototype: areaProto3 }, column: { prototype: columnProto2 } } = SeriesRegistry_default.seriesTypes;
var { addEvent: addEvent55, defined: defined52, extend: extend47, isArray: isArray19, isNumber: isNumber46, pick: pick66, merge: merge58 } = Utilities_default;
var areaRangeSeriesOptions = {
  /**
   * @see [fillColor](#plotOptions.arearange.fillColor)
   * @see [fillOpacity](#plotOptions.arearange.fillOpacity)
   *
   * @apioption plotOptions.arearange.color
   */
  /**
   * @default   low
   * @apioption plotOptions.arearange.colorKey
   */
  /**
   * @see [color](#plotOptions.arearange.color)
   * @see [fillOpacity](#plotOptions.arearange.fillOpacity)
   *
   * @apioption plotOptions.arearange.fillColor
   */
  /**
   * @see [color](#plotOptions.arearange.color)
   * @see [fillColor](#plotOptions.arearange.fillColor)
   *
   * @default   {highcharts} 0.75
   * @default   {highstock} 0.75
   * @apioption plotOptions.arearange.fillOpacity
   */
  /**
   * Whether to apply a drop shadow to the graph line. Since 2.3 the
   * shadow can be an object configuration containing `color`, `offsetX`,
   * `offsetY`, `opacity` and `width`.
   *
   * @type      {boolean|Highcharts.ShadowOptionsObject}
   * @product   highcharts
   * @apioption plotOptions.arearange.shadow
   */
  /**
   * Pixel width of the arearange graph line.
   *
   * @since 2.3.0
   *
   * @private
   */
  lineWidth: 1,
  /**
   * @type {number|null}
   */
  threshold: null,
  tooltip: {
    pointFormat: '<span style="color:{series.color}"></span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
  },
  /**
   * Whether the whole area or just the line should respond to mouseover
   * tooltips and other mouse or touch events.
   *
   * @since 2.3.0
   *
   * @private
   */
  trackByArea: true,
  /**
   * Extended data labels for range series types. Range series data
   * labels use no `x` and `y` options. Instead, they have `xLow`,
   * `xHigh`, `yLow` and `yHigh` options to allow the higher and lower
   * data label sets individually.
   *
   * @declare Highcharts.SeriesAreaRangeDataLabelsOptionsObject
   * @exclude x, y
   * @since   2.3.0
   * @product highcharts highstock
   *
   * @private
   */
  dataLabels: {
    align: void 0,
    verticalAlign: void 0,
    /**
     * X offset of the lower data labels relative to the point value.
     *
     * @sample highcharts/plotoptions/arearange-datalabels/
     *         Data labels on range series
     * @sample highcharts/plotoptions/arearange-datalabels/
     *         Data labels on range series
     */
    xLow: 0,
    /**
     * X offset of the higher data labels relative to the point value.
     *
     * @sample highcharts/plotoptions/arearange-datalabels/
     *         Data labels on range series
     */
    xHigh: 0,
    /**
     * Y offset of the lower data labels relative to the point value.
     *
     * @sample highcharts/plotoptions/arearange-datalabels/
     *         Data labels on range series
     */
    yLow: 0,
    /**
     * Y offset of the higher data labels relative to the point value.
     *
     * @sample highcharts/plotoptions/arearange-datalabels/
     *         Data labels on range series
     */
    yHigh: 0
  }
};
var AreaRangeSeries = class extends AreaSeries3 {
  /* *
   *
   *  Functions
   *
   * */
  toYData(point) {
    return [point.low, point.high];
  }
  /**
   * Translate a point's plotHigh from the internal angle and radius measures
   * to true plotHigh coordinates. This is an addition of the toXY method
   * found in Polar.js, because it runs too early for arearanges to be
   * considered (#3419).
   * @private
   */
  highToXY(point) {
    const chart = this.chart, xy = this.xAxis.postTranslate(point.rectPlotX || 0, this.yAxis.len - (point.plotHigh || 0));
    point.plotHighX = xy.x - chart.plotLeft;
    point.plotHigh = xy.y - chart.plotTop;
    point.plotLowX = point.plotX;
  }
  /**
   * Extend the line series' getSegmentPath method by applying the segment
   * path to both lower and higher values of the range.
   * @private
   */
  getGraphPath(points) {
    const highPoints = [], highAreaPoints = [], getGraphPath = areaProto3.getGraphPath, options2 = this.options, polar = this.chart.polar, connectEnds = polar && options2.connectEnds !== false, connectNulls = options2.connectNulls;
    let i, point, pointShim, step = options2.step;
    points = points || this.points;
    i = points.length;
    while (i--) {
      point = points[i];
      const highAreaPoint = polar ? {
        plotX: point.rectPlotX,
        plotY: point.yBottom,
        doCurve: false
        // #5186, gaps in areasplinerange fill
      } : {
        plotX: point.plotX,
        plotY: point.plotY,
        doCurve: false
        // #5186, gaps in areasplinerange fill
      };
      if (!point.isNull && !connectEnds && !connectNulls && (!points[i + 1] || points[i + 1].isNull)) {
        highAreaPoints.push(highAreaPoint);
      }
      pointShim = {
        polarPlotY: point.polarPlotY,
        rectPlotX: point.rectPlotX,
        yBottom: point.yBottom,
        // `plotHighX` is for polar charts
        plotX: pick66(point.plotHighX, point.plotX),
        plotY: point.plotHigh,
        isNull: point.isNull
      };
      highAreaPoints.push(pointShim);
      highPoints.push(pointShim);
      if (!point.isNull && !connectEnds && !connectNulls && (!points[i - 1] || points[i - 1].isNull)) {
        highAreaPoints.push(highAreaPoint);
      }
    }
    const lowerPath = getGraphPath.call(this, points);
    if (step) {
      if (step === true) {
        step = "left";
      }
      options2.step = {
        left: "right",
        center: "center",
        right: "left"
      }[step];
    }
    const higherPath = getGraphPath.call(this, highPoints);
    const higherAreaPath = getGraphPath.call(this, highAreaPoints);
    options2.step = step;
    const linePath = [].concat(lowerPath, higherPath);
    if (!this.chart.polar && higherAreaPath[0] && higherAreaPath[0][0] === "M") {
      higherAreaPath[0] = [
        "L",
        higherAreaPath[0][1],
        higherAreaPath[0][2]
      ];
    }
    this.graphPath = linePath;
    this.areaPath = lowerPath.concat(higherAreaPath);
    linePath.isArea = true;
    linePath.xMap = lowerPath.xMap;
    this.areaPath.xMap = lowerPath.xMap;
    return linePath;
  }
  /**
   * Extend the basic drawDataLabels method by running it for both lower and
   * higher values.
   * @private
   */
  drawDataLabels() {
    const data = this.points, length = data.length, originalDataLabels = [], dataLabelOptions = this.options.dataLabels, inverted = this.chart.inverted;
    let i, point, up, upperDataLabelOptions, lowerDataLabelOptions;
    if (dataLabelOptions) {
      if (isArray19(dataLabelOptions)) {
        upperDataLabelOptions = dataLabelOptions[0] || {
          enabled: false
        };
        lowerDataLabelOptions = dataLabelOptions[1] || {
          enabled: false
        };
      } else {
        upperDataLabelOptions = extend47({}, dataLabelOptions);
        upperDataLabelOptions.x = dataLabelOptions.xHigh;
        upperDataLabelOptions.y = dataLabelOptions.yHigh;
        lowerDataLabelOptions = extend47({}, dataLabelOptions);
        lowerDataLabelOptions.x = dataLabelOptions.xLow;
        lowerDataLabelOptions.y = dataLabelOptions.yLow;
      }
      if (upperDataLabelOptions.enabled || this.hasDataLabels?.()) {
        i = length;
        while (i--) {
          point = data[i];
          if (point) {
            const { plotHigh = 0, plotLow = 0 } = point;
            up = upperDataLabelOptions.inside ? plotHigh < plotLow : plotHigh > plotLow;
            point.y = point.high;
            point._plotY = point.plotY;
            point.plotY = plotHigh;
            originalDataLabels[i] = point.dataLabel;
            point.dataLabel = point.dataLabelUpper;
            point.below = up;
            if (inverted) {
              if (!upperDataLabelOptions.align) {
                upperDataLabelOptions.align = up ? "right" : "left";
              }
            } else {
              if (!upperDataLabelOptions.verticalAlign) {
                upperDataLabelOptions.verticalAlign = up ? "top" : "bottom";
              }
            }
          }
        }
        this.options.dataLabels = upperDataLabelOptions;
        if (areaProto3.drawDataLabels) {
          areaProto3.drawDataLabels.apply(this, arguments);
        }
        i = length;
        while (i--) {
          point = data[i];
          if (point) {
            point.dataLabelUpper = point.dataLabel;
            point.dataLabel = originalDataLabels[i];
            delete point.dataLabels;
            point.y = point.low;
            point.plotY = point._plotY;
          }
        }
      }
      if (lowerDataLabelOptions.enabled || this.hasDataLabels?.()) {
        i = length;
        while (i--) {
          point = data[i];
          if (point) {
            const { plotHigh = 0, plotLow = 0 } = point;
            up = lowerDataLabelOptions.inside ? plotHigh < plotLow : plotHigh > plotLow;
            point.below = !up;
            if (inverted) {
              if (!lowerDataLabelOptions.align) {
                lowerDataLabelOptions.align = up ? "left" : "right";
              }
            } else {
              if (!lowerDataLabelOptions.verticalAlign) {
                lowerDataLabelOptions.verticalAlign = up ? "bottom" : "top";
              }
            }
          }
        }
        this.options.dataLabels = lowerDataLabelOptions;
        if (areaProto3.drawDataLabels) {
          areaProto3.drawDataLabels.apply(this, arguments);
        }
      }
      if (upperDataLabelOptions.enabled) {
        i = length;
        while (i--) {
          point = data[i];
          if (point) {
            point.dataLabels = [
              point.dataLabelUpper,
              point.dataLabel
            ].filter(function(label) {
              return !!label;
            });
          }
        }
      }
      this.options.dataLabels = dataLabelOptions;
    }
  }
  alignDataLabel() {
    columnProto2.alignDataLabel.apply(this, arguments);
  }
  modifyMarkerSettings() {
    const series = this, originalMarkerSettings = {
      marker: series.options.marker,
      symbol: series.symbol
    };
    if (series.options.lowMarker) {
      const { options: { marker, lowMarker } } = series;
      series.options.marker = merge58(marker, lowMarker);
      if (lowMarker.symbol) {
        series.symbol = lowMarker.symbol;
      }
    }
    return originalMarkerSettings;
  }
  restoreMarkerSettings(originalSettings) {
    const series = this;
    series.options.marker = originalSettings.marker;
    series.symbol = originalSettings.symbol;
  }
  drawPoints() {
    const series = this, pointLength = series.points.length;
    let i, point;
    const originalSettings = series.modifyMarkerSettings();
    areaProto3.drawPoints.apply(series, arguments);
    series.restoreMarkerSettings(originalSettings);
    i = 0;
    while (i < pointLength) {
      point = series.points[i];
      point.graphics = point.graphics || [];
      point.origProps = {
        plotY: point.plotY,
        plotX: point.plotX,
        isInside: point.isInside,
        negative: point.negative,
        zone: point.zone,
        y: point.y
      };
      if (point.graphic || point.graphics[0]) {
        point.graphics[0] = point.graphic;
      }
      point.graphic = point.graphics[1];
      point.plotY = point.plotHigh;
      if (defined52(point.plotHighX)) {
        point.plotX = point.plotHighX;
      }
      point.y = pick66(point.high, point.origProps.y);
      point.negative = point.y < (series.options.threshold || 0);
      if (series.zones.length) {
        point.zone = point.getZone();
      }
      if (!series.chart.polar) {
        point.isInside = point.isTopInside = typeof point.plotY !== "undefined" && point.plotY >= 0 && point.plotY <= series.yAxis.len && // #3519
        point.plotX >= 0 && point.plotX <= series.xAxis.len;
      }
      i++;
    }
    areaProto3.drawPoints.apply(series, arguments);
    i = 0;
    while (i < pointLength) {
      point = series.points[i];
      point.graphics = point.graphics || [];
      if (point.graphic || point.graphics[1]) {
        point.graphics[1] = point.graphic;
      }
      point.graphic = point.graphics[0];
      if (point.origProps) {
        extend47(point, point.origProps);
        delete point.origProps;
      }
      i++;
    }
  }
  hasMarkerChanged(options2, oldOptions) {
    const lowMarker = options2.lowMarker, oldMarker = oldOptions.lowMarker || {};
    return lowMarker && (lowMarker.enabled === false || oldMarker.symbol !== lowMarker.symbol || // #10870, #15946
    oldMarker.height !== lowMarker.height || // #16274
    oldMarker.width !== lowMarker.width) || super.hasMarkerChanged(options2, oldOptions);
  }
};
AreaRangeSeries.defaultOptions = merge58(AreaSeries3.defaultOptions, areaRangeSeriesOptions);
addEvent55(AreaRangeSeries, "afterTranslate", function() {
  if (this.pointArrayMap.join(",") === "low,high") {
    this.points.forEach((point) => {
      const high2 = point.high, plotY = point.plotY;
      if (point.isNull) {
        point.plotY = void 0;
      } else {
        point.plotLow = plotY;
        point.plotHigh = isNumber46(high2) ? this.yAxis.translate(this.dataModify ? this.dataModify.modifyValue(high2) : high2, false, true, void 0, true) : void 0;
        if (this.dataModify) {
          point.yBottom = point.plotHigh;
        }
      }
    });
  }
}, { order: 0 });
addEvent55(AreaRangeSeries, "afterTranslate", function() {
  this.points.forEach((point) => {
    if (this.chart.polar) {
      this.highToXY(point);
      point.plotLow = point.plotY;
      point.tooltipPos = [
        ((point.plotHighX || 0) + (point.plotLowX || 0)) / 2,
        ((point.plotHigh || 0) + (point.plotLow || 0)) / 2
      ];
    } else {
      const tooltipPos = point.pos(false, point.plotLow), posHigh = point.pos(false, point.plotHigh);
      if (tooltipPos && posHigh) {
        tooltipPos[0] = (tooltipPos[0] + posHigh[0]) / 2;
        tooltipPos[1] = (tooltipPos[1] + posHigh[1]) / 2;
      }
      point.tooltipPos = tooltipPos;
    }
  });
}, { order: 3 });
extend47(AreaRangeSeries.prototype, {
  deferTranslatePolar: true,
  pointArrayMap: ["low", "high"],
  pointClass: AreaRangePoint_default,
  pointValKey: "low",
  setStackedPoints: noop7
});
SeriesRegistry_default.registerSeriesType("arearange", AreaRangeSeries);
var AreaRangeSeries_default = AreaRangeSeries;

// node_modules/highcharts/es-modules/Series/AreaSplineRange/AreaSplineRangeSeries.js
var { spline: { prototype: splineProto } } = SeriesRegistry_default.seriesTypes;
var { merge: merge59, extend: extend48 } = Utilities_default;
var AreaSplineRangeSeries = class extends AreaRangeSeries_default {
};
AreaSplineRangeSeries.defaultOptions = merge59(AreaRangeSeries_default.defaultOptions);
extend48(AreaSplineRangeSeries.prototype, {
  getPointSpline: splineProto.getPointSpline
});
SeriesRegistry_default.registerSeriesType("areasplinerange", AreaSplineRangeSeries);

// node_modules/highcharts/es-modules/Series/BoxPlot/BoxPlotSeriesDefaults.js
var BoxPlotSeriesDefaults = {
  /**
   * @type {number|null}
   */
  threshold: null,
  tooltip: {
    pointFormat: '<span style="color:{point.color}"></span> <b>{series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'
  },
  /**
   * The length of the whiskers, the horizontal lines marking low and
   * high values. It can be a numerical pixel value, or a percentage
   * value of the box width. Set `0` to disable whiskers.
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   *
   * @type    {number|string}
   * @since   3.0
   * @product highcharts
   */
  whiskerLength: "50%",
  /**
   * The fill color of the box.
   *
   * In styled mode, the fill color can be set with the
   * `.highcharts-boxplot-box` class.
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default #ffffff
   * @since   3.0
   * @product highcharts
   */
  fillColor: "#ffffff",
  /**
   * The width of the line surrounding the box. If any of
   * [stemWidth](#plotOptions.boxplot.stemWidth),
   * [medianWidth](#plotOptions.boxplot.medianWidth)
   * or [whiskerWidth](#plotOptions.boxplot.whiskerWidth) are `null`,
   * the lineWidth also applies to these lines.
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
   *         Error bar styling
   *
   * @since   3.0
   * @product highcharts
   */
  lineWidth: 1,
  /**
   * The color of the median line. If `undefined`, the general series
   * color applies.
   *
   * In styled mode, the median stroke width can be set with the
   * `.highcharts-boxplot-median` class.
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   * @sample {highcharts} highcharts/css/boxplot/
   *         Box plot in styled mode
   * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
   *         Error bar styling
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject}
   * @since     3.0
   * @product   highcharts
   * @apioption plotOptions.boxplot.medianColor
   */
  /**
   * The pixel width of the median line. If `null`, the
   * [lineWidth](#plotOptions.boxplot.lineWidth) is used.
   *
   * In styled mode, the median stroke width can be set with the
   * `.highcharts-boxplot-median` class.
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   * @sample {highcharts} highcharts/css/boxplot/
   *         Box plot in styled mode
   *
   * @type    {number|null}
   * @since   3.0
   * @product highcharts
   */
  medianWidth: 2,
  /*
  // States are not working and are removed from docs.
  // Refer to: #2340
  states: {
      hover: {
          brightness: -0.3
      }
  },
  */
  /**
   * The color of the stem, the vertical line extending from the box to
   * the whiskers. If `undefined`, the series color is used.
   *
   * In styled mode, the stem stroke can be set with the
   * `.highcharts-boxplot-stem` class.
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   * @sample {highcharts} highcharts/css/boxplot/
   *         Box plot in styled mode
   * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
   *         Error bar styling
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     3.0
   * @product   highcharts
   * @apioption plotOptions.boxplot.stemColor
   */
  /**
   * The dash style of the box.
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   * @sample {highcharts} highcharts/css/boxplot/
   *         Box plot in styled mode
   *
   * @type      {Highcharts.DashStyleValue}
   * @default   Solid
   * @since 8.1.0
   * @product   highcharts
   * @apioption plotOptions.boxplot.boxDashStyle
   */
  /**
   * The dash style of the median.
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   * @sample {highcharts} highcharts/css/boxplot/
   *         Box plot in styled mode
   *
   * @type      {Highcharts.DashStyleValue}
   * @default   Solid
   * @since 8.1.0
   * @product   highcharts
   * @apioption plotOptions.boxplot.medianDashStyle
   */
  /**
   * The dash style of the stem, the vertical line extending from the
   * box to the whiskers.
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   * @sample {highcharts} highcharts/css/boxplot/
   *         Box plot in styled mode
   * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
   *         Error bar styling
   *
   * @type      {Highcharts.DashStyleValue}
   * @default   Solid
   * @since     3.0
   * @product   highcharts
   * @apioption plotOptions.boxplot.stemDashStyle
   */
  /**
   * The dash style of the whiskers.
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   * @sample {highcharts} highcharts/css/boxplot/
   *         Box plot in styled mode
   *
   * @type      {Highcharts.DashStyleValue}
   * @default   Solid
   * @since 8.1.0
   * @product   highcharts
   * @apioption plotOptions.boxplot.whiskerDashStyle
   */
  /**
   * The width of the stem, the vertical line extending from the box to
   * the whiskers. If `undefined`, the width is inherited from the
   * [lineWidth](#plotOptions.boxplot.lineWidth) option.
   *
   * In styled mode, the stem stroke width can be set with the
   * `.highcharts-boxplot-stem` class.
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   * @sample {highcharts} highcharts/css/boxplot/
   *         Box plot in styled mode
   * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
   *         Error bar styling
   *
   * @type      {number}
   * @since     3.0
   * @product   highcharts
   * @apioption plotOptions.boxplot.stemWidth
   */
  /**
   * @default   high
   * @apioption plotOptions.boxplot.colorKey
   */
  /**
   * The color of the whiskers, the horizontal lines marking low and high
   * values. When `undefined`, the general series color is used.
   *
   * In styled mode, the whisker stroke can be set with the
   * `.highcharts-boxplot-whisker` class .
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   * @sample {highcharts} highcharts/css/boxplot/
   *         Box plot in styled mode
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     3.0
   * @product   highcharts
   * @apioption plotOptions.boxplot.whiskerColor
   */
  /**
   * The line width of the whiskers, the horizontal lines marking low and
   * high values. When `undefined`, the general
   * [lineWidth](#plotOptions.boxplot.lineWidth) applies.
   *
   * In styled mode, the whisker stroke width can be set with the
   * `.highcharts-boxplot-whisker` class.
   *
   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
   *         Box plot styling
   * @sample {highcharts} highcharts/css/boxplot/
   *         Box plot in styled mode
   *
   * @since   3.0
   * @product highcharts
   */
  whiskerWidth: 2
};
var BoxPlotSeriesDefaults_default = BoxPlotSeriesDefaults;

// node_modules/highcharts/es-modules/Series/BoxPlot/BoxPlotSeries.js
var { noop: noop8 } = Globals_default;
var { crisp: crisp12, extend: extend49, merge: merge60, pick: pick67, relativeLength: relativeLength10 } = Utilities_default;
var BoxPlotSeries = class extends ColumnSeries_default {
  /* *
   *
   *  Functions
   *
   * */
  // Get presentational attributes
  pointAttribs() {
    return {};
  }
  // Get an SVGPath object for both whiskers
  getWhiskerPair(halfWidth, stemX, upperWhiskerLength, lowerWhiskerLength, point) {
    const strokeWidth = point.whiskers.strokeWidth(), getWhisker = (xLen, yPos) => {
      const halfLen = relativeLength10(xLen, 2 * halfWidth) / 2, crispedYPos = crisp12(yPos, strokeWidth);
      return [
        [
          "M",
          crisp12(stemX - halfLen),
          crispedYPos
        ],
        [
          "L",
          crisp12(stemX + halfLen),
          crispedYPos
        ]
      ];
    };
    return [
      ...getWhisker(upperWhiskerLength, point.highPlot),
      ...getWhisker(lowerWhiskerLength, point.lowPlot)
    ];
  }
  // Translate data points from raw values x and y to plotX and plotY
  translate() {
    const series = this, yAxis2 = series.yAxis, pointArrayMap = series.pointArrayMap;
    super.translate.apply(series);
    series.points.forEach(function(point) {
      pointArrayMap.forEach(function(key) {
        if (point[key] !== null) {
          point[key + "Plot"] = yAxis2.translate(point[key], 0, 1, 0, 1);
        }
      });
      point.plotHigh = point.highPlot;
    });
  }
  /**
   * Draw the data points
   * @private
   */
  drawPoints() {
    const series = this, points = series.points, options2 = series.options, chart = series.chart, renderer = chart.renderer, doQuartiles = series.doQuartiles !== false, whiskerLength = series.options.whiskerLength;
    let q1Plot, q3Plot, highPlot, lowPlot, medianPlot, medianPath, boxPath, graphic, width, x, right;
    for (const point of points) {
      graphic = point.graphic;
      const verb = graphic ? "animate" : "attr", shapeArgs = point.shapeArgs, boxAttr = {}, stemAttr = {}, whiskersAttr = {}, medianAttr = {}, color14 = point.color || series.color, pointWhiskerLength = point.options.whiskerLength || whiskerLength;
      if (typeof point.plotY !== "undefined") {
        width = shapeArgs.width;
        x = shapeArgs.x;
        right = x + width;
        q1Plot = doQuartiles ? point.q1Plot : point.lowPlot;
        q3Plot = doQuartiles ? point.q3Plot : point.lowPlot;
        highPlot = point.highPlot;
        lowPlot = point.lowPlot;
        if (!graphic) {
          point.graphic = graphic = renderer.g("point").add(series.group);
          point.stem = renderer.path().addClass("highcharts-boxplot-stem").add(graphic);
          if (whiskerLength) {
            point.whiskers = renderer.path().addClass("highcharts-boxplot-whisker").add(graphic);
          }
          if (doQuartiles) {
            point.box = renderer.path(boxPath).addClass("highcharts-boxplot-box").add(graphic);
          }
          point.medianShape = renderer.path(medianPath).addClass("highcharts-boxplot-median").add(graphic);
        }
        if (!chart.styledMode) {
          stemAttr.stroke = point.stemColor || options2.stemColor || color14;
          stemAttr["stroke-width"] = pick67(point.stemWidth, options2.stemWidth, options2.lineWidth);
          stemAttr.dashstyle = point.stemDashStyle || options2.stemDashStyle || options2.dashStyle;
          point.stem.attr(stemAttr);
          if (pointWhiskerLength) {
            whiskersAttr.stroke = point.whiskerColor || options2.whiskerColor || color14;
            whiskersAttr["stroke-width"] = pick67(point.whiskerWidth, options2.whiskerWidth, options2.lineWidth);
            whiskersAttr.dashstyle = point.whiskerDashStyle || options2.whiskerDashStyle || options2.dashStyle;
            point.whiskers.attr(whiskersAttr);
          }
          if (doQuartiles) {
            boxAttr.fill = point.fillColor || options2.fillColor || color14;
            boxAttr.stroke = options2.lineColor || color14;
            boxAttr["stroke-width"] = options2.lineWidth || 0;
            boxAttr.dashstyle = point.boxDashStyle || options2.boxDashStyle || options2.dashStyle;
            point.box.attr(boxAttr);
          }
          medianAttr.stroke = point.medianColor || options2.medianColor || color14;
          medianAttr["stroke-width"] = pick67(point.medianWidth, options2.medianWidth, options2.lineWidth);
          medianAttr.dashstyle = point.medianDashStyle || options2.medianDashStyle || options2.dashStyle;
          point.medianShape.attr(medianAttr);
        }
        let d;
        const stemX = crisp12((point.plotX || 0) + (series.pointXOffset || 0) + (series.barW || 0) / 2, point.stem.strokeWidth());
        d = [
          // Stem up
          ["M", stemX, q3Plot],
          ["L", stemX, highPlot],
          // Stem down
          ["M", stemX, q1Plot],
          ["L", stemX, lowPlot]
        ];
        point.stem[verb]({ d });
        if (doQuartiles) {
          const boxStrokeWidth = point.box.strokeWidth();
          q1Plot = crisp12(q1Plot, boxStrokeWidth);
          q3Plot = crisp12(q3Plot, boxStrokeWidth);
          x = crisp12(x, boxStrokeWidth);
          right = crisp12(right, boxStrokeWidth);
          d = [
            ["M", x, q3Plot],
            ["L", x, q1Plot],
            ["L", right, q1Plot],
            ["L", right, q3Plot],
            ["L", x, q3Plot],
            ["Z"]
          ];
          point.box[verb]({ d });
        }
        if (pointWhiskerLength) {
          const halfWidth = width / 2, whiskers = this.getWhiskerPair(halfWidth, stemX, point.upperWhiskerLength ?? options2.upperWhiskerLength ?? pointWhiskerLength, point.lowerWhiskerLength ?? options2.lowerWhiskerLength ?? pointWhiskerLength, point);
          point.whiskers[verb]({ d: whiskers });
        }
        medianPlot = crisp12(point.medianPlot, point.medianShape.strokeWidth());
        d = [
          ["M", x, medianPlot],
          ["L", right, medianPlot]
        ];
        point.medianShape[verb]({ d });
      }
    }
  }
  // Return a plain array for speedy calculation
  toYData(point) {
    return [point.low, point.q1, point.median, point.q3, point.high];
  }
};
BoxPlotSeries.defaultOptions = merge60(ColumnSeries_default.defaultOptions, BoxPlotSeriesDefaults_default);
extend49(BoxPlotSeries.prototype, {
  // Array point configs are mapped to this
  pointArrayMap: ["low", "q1", "median", "q3", "high"],
  // Defines the top of the tracker
  pointValKey: "high",
  // Disable data labels for box plot
  drawDataLabels: noop8,
  setStackedPoints: noop8
  // #3890
});
SeriesRegistry_default.registerSeriesType("boxplot", BoxPlotSeries);
var BoxPlotSeries_default = BoxPlotSeries;

// node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendDefaults.js
var BubbleLegendDefaults = {
  /**
   * The color of the ranges borders, can be also defined for an
   * individual range.
   *
   * @sample highcharts/bubble-legend/similartoseries/
   *         Similar look to the bubble series
   * @sample highcharts/bubble-legend/bordercolor/
   *         Individual bubble border color
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  borderColor: void 0,
  /**
   * The width of the ranges borders in pixels, can be also
   * defined for an individual range.
   */
  borderWidth: 2,
  /**
   * An additional class name to apply to the bubble legend'
   * circle graphical elements. This option does not replace
   * default class names of the graphical element.
   *
   * @sample {highcharts} highcharts/css/bubble-legend/
   *         Styling by CSS
   *
   * @type {string}
   */
  className: void 0,
  /**
   * The main color of the bubble legend. Applies to ranges, if
   * individual color is not defined.
   *
   * @sample highcharts/bubble-legend/similartoseries/
   *         Similar look to the bubble series
   * @sample highcharts/bubble-legend/color/
   *         Individual bubble color
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  color: void 0,
  /**
   * An additional class name to apply to the bubble legend's
   * connector graphical elements. This option does not replace
   * default class names of the graphical element.
   *
   * @sample {highcharts} highcharts/css/bubble-legend/
   *         Styling by CSS
   *
   * @type {string}
   */
  connectorClassName: void 0,
  /**
   * The color of the connector, can be also defined
   * for an individual range.
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  connectorColor: void 0,
  /**
   * The length of the connectors in pixels. If labels are
   * centered, the distance is reduced to 0.
   *
   * @sample highcharts/bubble-legend/connectorandlabels/
   *         Increased connector length
   */
  connectorDistance: 60,
  /**
   * The width of the connectors in pixels.
   *
   * @sample highcharts/bubble-legend/connectorandlabels/
   *         Increased connector width
   */
  connectorWidth: 1,
  /**
   * Enable or disable the bubble legend.
   */
  enabled: false,
  /**
   * Options for the bubble legend labels.
   */
  labels: {
    /**
     * An additional class name to apply to the bubble legend
     * label graphical elements. This option does not replace
     * default class names of the graphical element.
     *
     * @sample {highcharts} highcharts/css/bubble-legend/
     *         Styling by CSS
     *
     * @type {string}
     */
    className: void 0,
    /**
     * Whether to allow data labels to overlap.
     */
    allowOverlap: false,
    /**
     * A format string for the bubble legend labels. Available
     * variables are the same as for `formatter`.
     *
     * @sample highcharts/bubble-legend/format/
     *         Add a unit
     *
     * @type {string}
     */
    format: "",
    /**
     * Available `this` properties are:
     *
     * - `this.value`: The bubble value.
     *
     * - `this.radius`: The radius of the bubble range.
     *
     * - `this.center`: The center y position of the range.
     *
     * @type {Highcharts.FormatterCallbackFunction<Highcharts.BubbleLegendFormatterContextObject>}
     */
    formatter: void 0,
    /**
     * The alignment of the labels compared to the bubble
     * legend. Can be one of `left`, `center` or `right`.
     *
     * @sample highcharts/bubble-legend/connectorandlabels/
     *         Labels on left
     *
     * @type {Highcharts.AlignValue}
     */
    align: "right",
    /**
     * CSS styles for the labels.
     *
     * @type {Highcharts.CSSObject}
     */
    style: {
      /** @ignore-option */
      fontSize: "0.9em",
      /** @ignore-option */
      color: "#000000"
      /* Palette.neutralColor100 */
    },
    /**
     * The x position offset of the label relative to the
     * connector.
     */
    x: 0,
    /**
     * The y position offset of the label relative to the
     * connector.
     */
    y: 0
  },
  /**
   * Maximum bubble legend range size. If values for ranges are
   * not specified, the `minSize` and the `maxSize` are calculated
   * from bubble series.
   */
  maxSize: 60,
  // Number
  /**
   * Minimum bubble legend range size. If values for ranges are
   * not specified, the `minSize` and the `maxSize` are calculated
   * from bubble series.
   */
  minSize: 10,
  // Number
  /**
   * The position of the bubble legend in the legend.
   * @sample highcharts/bubble-legend/connectorandlabels/
   *         Bubble legend as last item in legend
   */
  legendIndex: 0,
  // Number
  /**
   * Options for specific range. One range consists of bubble,
   * label and connector.
   *
   * @sample highcharts/bubble-legend/ranges/
   *         Manually defined ranges
   * @sample highcharts/bubble-legend/autoranges/
   *         Auto calculated ranges
   *
   * @type {Array<*>}
   */
  ranges: {
    /**
     * Range size value, similar to bubble Z data.
     * @type {number}
     */
    value: void 0,
    /**
     * The color of the border for individual range.
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    borderColor: void 0,
    /**
     * The color of the bubble for individual range.
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    color: void 0,
    /**
     * The color of the connector for individual range.
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    connectorColor: void 0
  },
  /**
   * Whether the bubble legend range value should be represented
   * by the area or the width of the bubble. The default, area,
   * corresponds best to the human perception of the size of each
   * bubble.
   *
   * @sample highcharts/bubble-legend/ranges/
   *         Size by width
   *
   * @type {Highcharts.BubbleSizeByValue}
   */
  sizeBy: "area",
  /**
   * When this is true, the absolute value of z determines the
   * size of the bubble. This means that with the default
   * zThreshold of 0, a bubble of value -1 will have the same size
   * as a bubble of value 1, while a bubble of value 0 will have a
   * smaller size according to minSize.
   */
  sizeByAbsoluteValue: false,
  /**
   * Define the visual z index of the bubble legend.
   */
  zIndex: 1,
  /**
   * Ranges with lower value than zThreshold are skipped.
   */
  zThreshold: 0
};
var BubbleLegendDefaults_default = BubbleLegendDefaults;

// node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendItem.js
var { noop: noop9 } = Globals_default;
var { arrayMax: arrayMax8, arrayMin: arrayMin7, isNumber: isNumber47, merge: merge61, pick: pick68, stableSort: stableSort7 } = Utilities_default;
var BubbleLegendItem = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(options2, legend) {
    this.setState = noop9;
    this.init(options2, legend);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Create basic bubbleLegend properties similar to item in legend.
   * @private
   */
  init(options2, legend) {
    this.options = options2;
    this.visible = true;
    this.chart = legend.chart;
    this.legend = legend;
  }
  /**
   * Depending on the position option, add bubbleLegend to legend items.
   *
   * @private
   *
   * @param {Array<(Highcharts.Point|Highcharts.Series)>} items
   *        All legend items
   */
  addToLegend(items) {
    items.splice(this.options.legendIndex, 0, this);
  }
  /**
   * Calculate ranges, sizes and call the next steps of bubbleLegend
   * creation.
   *
   * @private
   *
   * @param {Highcharts.Legend} legend
   *        Legend instance
   */
  drawLegendSymbol(legend) {
    const itemDistance = pick68(legend.options.itemDistance, 20), legendItem = this.legendItem || {}, options2 = this.options, ranges = options2.ranges, connectorDistance = options2.connectorDistance;
    let connectorSpace;
    if (!ranges || !ranges.length || !isNumber47(ranges[0].value)) {
      legend.options.bubbleLegend.autoRanges = true;
      return;
    }
    stableSort7(ranges, function(a, b) {
      return b.value - a.value;
    });
    this.ranges = ranges;
    this.setOptions();
    this.render();
    const maxLabel = this.getMaxLabelSize(), radius = this.ranges[0].radius, size = radius * 2;
    connectorSpace = connectorDistance - radius + maxLabel.width;
    connectorSpace = connectorSpace > 0 ? connectorSpace : 0;
    this.maxLabel = maxLabel;
    this.movementX = options2.labels.align === "left" ? connectorSpace : 0;
    legendItem.labelWidth = size + connectorSpace + itemDistance;
    legendItem.labelHeight = size + maxLabel.height / 2;
  }
  /**
   * Set style options for each bubbleLegend range.
   * @private
   */
  setOptions() {
    const ranges = this.ranges, options2 = this.options, series = this.chart.series[options2.seriesIndex], baseline = this.legend.baseline, bubbleAttribs = {
      zIndex: options2.zIndex,
      "stroke-width": options2.borderWidth
    }, connectorAttribs = {
      zIndex: options2.zIndex,
      "stroke-width": options2.connectorWidth
    }, labelAttribs = {
      align: this.legend.options.rtl || options2.labels.align === "left" ? "right" : "left",
      zIndex: options2.zIndex
    }, fillOpacity = series.options.marker.fillOpacity, styledMode = this.chart.styledMode;
    ranges.forEach(function(range2, i) {
      if (!styledMode) {
        bubbleAttribs.stroke = pick68(range2.borderColor, options2.borderColor, series.color);
        bubbleAttribs.fill = range2.color || options2.color;
        if (!bubbleAttribs.fill) {
          bubbleAttribs.fill = series.color;
          bubbleAttribs["fill-opacity"] = fillOpacity ?? 1;
        }
        connectorAttribs.stroke = pick68(range2.connectorColor, options2.connectorColor, series.color);
      }
      ranges[i].radius = this.getRangeRadius(range2.value);
      ranges[i] = merge61(ranges[i], {
        center: ranges[0].radius - ranges[i].radius + baseline
      });
      if (!styledMode) {
        merge61(true, ranges[i], {
          bubbleAttribs: merge61(bubbleAttribs),
          connectorAttribs: merge61(connectorAttribs),
          labelAttribs
        });
      }
    }, this);
  }
  /**
   * Calculate radius for each bubble range,
   * used code from BubbleSeries.js 'getRadius' method.
   *
   * @private
   *
   * @param {number} value
   *        Range value
   *
   * @return {number|null}
   *         Radius for one range
   */
  getRangeRadius(value) {
    const options2 = this.options, seriesIndex = this.options.seriesIndex, bubbleSeries = this.chart.series[seriesIndex], zMax = options2.ranges[0].value, zMin = options2.ranges[options2.ranges.length - 1].value, minSize = options2.minSize, maxSize = options2.maxSize;
    return bubbleSeries.getRadius.call(this, zMin, zMax, minSize, maxSize, value);
  }
  /**
   * Render the legendItem group.
   * @private
   */
  render() {
    const legendItem = this.legendItem || {}, renderer = this.chart.renderer, zThreshold = this.options.zThreshold;
    if (!this.symbols) {
      this.symbols = {
        connectors: [],
        bubbleItems: [],
        labels: []
      };
    }
    legendItem.symbol = renderer.g("bubble-legend");
    legendItem.label = renderer.g("bubble-legend-item").css(this.legend.itemStyle || {});
    legendItem.symbol.translateX = 0;
    legendItem.symbol.translateY = 0;
    legendItem.symbol.add(legendItem.label);
    legendItem.label.add(legendItem.group);
    for (const range2 of this.ranges) {
      if (range2.value >= zThreshold) {
        this.renderRange(range2);
      }
    }
    this.hideOverlappingLabels();
  }
  /**
   * Render one range, consisting of bubble symbol, connector and label.
   *
   * @private
   *
   * @param {Highcharts.LegendBubbleLegendRangesOptions} range
   *        Range options
   */
  renderRange(range2) {
    const mainRange = this.ranges[0], legend = this.legend, options2 = this.options, labelsOptions = options2.labels, chart = this.chart, bubbleSeries = chart.series[options2.seriesIndex], renderer = chart.renderer, symbols3 = this.symbols, labels = symbols3.labels, elementCenter = range2.center, absoluteRadius = Math.abs(range2.radius), connectorDistance = options2.connectorDistance || 0, labelsAlign = labelsOptions.align, rtl = legend.options.rtl, borderWidth = options2.borderWidth, connectorWidth = options2.connectorWidth, posX = mainRange.radius || 0, posY = elementCenter - absoluteRadius - borderWidth / 2 + connectorWidth / 2, crispMovement = (posY % 1 ? 1 : 0.5) - (connectorWidth % 2 ? 0 : 0.5), styledMode = renderer.styledMode;
    let connectorLength = rtl || labelsAlign === "left" ? -connectorDistance : connectorDistance;
    if (labelsAlign === "center") {
      connectorLength = 0;
      options2.connectorDistance = 0;
      range2.labelAttribs.align = "center";
    }
    symbols3.bubbleItems.push(renderer.circle(posX, elementCenter + crispMovement, absoluteRadius).attr(styledMode ? {} : range2.bubbleAttribs).addClass((styledMode ? "highcharts-color-" + bubbleSeries.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (options2.className || "")).add(this.legendItem.symbol));
    symbols3.connectors.push(renderer.path(renderer.crispLine([
      ["M", posX, posY],
      ["L", posX + connectorLength, posY]
    ], options2.connectorWidth)).attr(styledMode ? {} : range2.connectorAttribs).addClass((styledMode ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (options2.connectorClassName || "")).add(this.legendItem.symbol));
    const label = renderer.text(this.formatLabel(range2)).attr(styledMode ? {} : range2.labelAttribs).css(styledMode ? {} : labelsOptions.style).addClass("highcharts-bubble-legend-labels " + (options2.labels.className || "")).add(this.legendItem.symbol);
    const position = {
      x: posX + connectorLength + options2.labels.x,
      y: posY + options2.labels.y + label.getBBox().height * 0.4
    };
    label.attr(position);
    labels.push(label);
    label.placed = true;
    label.alignAttr = position;
  }
  /**
   * Get the label which takes up the most space.
   * @private
   */
  getMaxLabelSize() {
    const labels = this.symbols.labels;
    let maxLabel, labelSize;
    labels.forEach(function(label) {
      labelSize = label.getBBox(true);
      if (maxLabel) {
        maxLabel = labelSize.width > maxLabel.width ? labelSize : maxLabel;
      } else {
        maxLabel = labelSize;
      }
    });
    return maxLabel || {};
  }
  /**
   * Get formatted label for range.
   *
   * @private
   *
   * @param {Highcharts.LegendBubbleLegendRangesOptions} range
   *        Range options
   *
   * @return {string}
   *         Range label text
   */
  formatLabel(range2) {
    const options2 = this.options, formatter = options2.labels.formatter, format18 = options2.labels.format;
    const { numberFormatter } = this.chart;
    return format18 ? Templating_default.format(format18, range2, this.chart) : formatter ? formatter.call(range2) : numberFormatter(range2.value, 1);
  }
  /**
   * By using default chart 'hideOverlappingLabels' method, hide or show
   * labels and connectors.
   * @private
   */
  hideOverlappingLabels() {
    const chart = this.chart, allowOverlap = this.options.labels.allowOverlap, symbols3 = this.symbols;
    if (!allowOverlap && symbols3) {
      chart.hideOverlappingLabels(symbols3.labels);
      symbols3.labels.forEach(function(label, index) {
        if (!label.newOpacity) {
          symbols3.connectors[index].hide();
        } else if (label.newOpacity !== label.oldOpacity) {
          symbols3.connectors[index].show();
        }
      });
    }
  }
  /**
   * Calculate ranges from created series.
   *
   * @private
   *
   * @return {Array<Highcharts.LegendBubbleLegendRangesOptions>}
   *         Array of range objects
   */
  getRanges() {
    const bubbleLegend = this.legend.bubbleLegend, series = bubbleLegend.chart.series, rangesOptions = bubbleLegend.options.ranges;
    let ranges, zData, minZ = Number.MAX_VALUE, maxZ = -Number.MAX_VALUE;
    series.forEach(function(s) {
      if (s.isBubble && !s.ignoreSeries) {
        zData = s.getColumn("z").filter(isNumber47);
        if (zData.length) {
          minZ = pick68(s.options.zMin, Math.min(minZ, Math.max(arrayMin7(zData), s.options.displayNegative === false ? s.options.zThreshold : -Number.MAX_VALUE)));
          maxZ = pick68(s.options.zMax, Math.max(maxZ, arrayMax8(zData)));
        }
      }
    });
    if (minZ === maxZ) {
      ranges = [{ value: maxZ }];
    } else {
      ranges = [
        { value: minZ },
        { value: (minZ + maxZ) / 2 },
        { value: maxZ, autoRanges: true }
      ];
    }
    if (rangesOptions.length && rangesOptions[0].radius) {
      ranges.reverse();
    }
    ranges.forEach(function(range2, i) {
      if (rangesOptions && rangesOptions[i]) {
        ranges[i] = merge61(rangesOptions[i], range2);
      }
    });
    return ranges;
  }
  /**
   * Calculate bubble legend sizes from rendered series.
   *
   * @private
   *
   * @return {Array<number,number>}
   *         Calculated min and max bubble sizes
   */
  predictBubbleSizes() {
    const chart = this.chart, legendOptions = chart.legend.options, floating = legendOptions.floating, horizontal = legendOptions.layout === "horizontal", lastLineHeight = horizontal ? chart.legend.lastLineHeight : 0, plotSizeX = chart.plotSizeX, plotSizeY = chart.plotSizeY, bubbleSeries = chart.series[this.options.seriesIndex], pxSizes = bubbleSeries.getPxExtremes(), minSize = Math.ceil(pxSizes.minPxSize), maxPxSize = Math.ceil(pxSizes.maxPxSize), plotSize = Math.min(plotSizeY, plotSizeX);
    let calculatedSize, maxSize = bubbleSeries.options.maxSize;
    if (floating || !/%$/.test(maxSize)) {
      calculatedSize = maxPxSize;
    } else {
      maxSize = parseFloat(maxSize);
      calculatedSize = (plotSize + lastLineHeight) * maxSize / 100 / (maxSize / 100 + 1);
      if (horizontal && plotSizeY - calculatedSize >= plotSizeX || !horizontal && plotSizeX - calculatedSize >= plotSizeY) {
        calculatedSize = maxPxSize;
      }
    }
    return [minSize, Math.ceil(calculatedSize)];
  }
  /**
   * Correct ranges with calculated sizes.
   * @private
   */
  updateRanges(min4, max4) {
    const bubbleLegendOptions = this.legend.options.bubbleLegend;
    bubbleLegendOptions.minSize = min4;
    bubbleLegendOptions.maxSize = max4;
    bubbleLegendOptions.ranges = this.getRanges();
  }
  /**
   * Because of the possibility of creating another legend line, predicted
   * bubble legend sizes may differ by a few pixels, so it is necessary to
   * correct them.
   * @private
   */
  correctSizes() {
    const legend = this.legend, chart = this.chart, bubbleSeries = chart.series[this.options.seriesIndex], pxSizes = bubbleSeries.getPxExtremes(), bubbleSeriesSize = pxSizes.maxPxSize, bubbleLegendSize = this.options.maxSize;
    if (Math.abs(Math.ceil(bubbleSeriesSize) - bubbleLegendSize) > 1) {
      this.updateRanges(this.options.minSize, pxSizes.maxPxSize);
      legend.render();
    }
  }
};
var BubbleLegendItem_default = BubbleLegendItem;

// node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendComposition.js
var { setOptions: setOptions4 } = Defaults_default;
var { composed: composed18 } = Globals_default;
var { addEvent: addEvent56, objectEach: objectEach27, pushUnique: pushUnique21, wrap: wrap5 } = Utilities_default;
function chartDrawChartBox(proceed, options2, callback) {
  const chart = this, legend = chart.legend, bubbleSeries = getVisibleBubbleSeriesIndex(chart) >= 0;
  let bubbleLegendOptions, bubbleSizes, legendItem;
  if (legend && legend.options.enabled && legend.bubbleLegend && legend.options.bubbleLegend.autoRanges && bubbleSeries) {
    bubbleLegendOptions = legend.bubbleLegend.options;
    bubbleSizes = legend.bubbleLegend.predictBubbleSizes();
    legend.bubbleLegend.updateRanges(bubbleSizes[0], bubbleSizes[1]);
    if (!bubbleLegendOptions.placed) {
      legend.group.placed = false;
      legend.allItems.forEach((item) => {
        legendItem = item.legendItem || {};
        if (legendItem.group) {
          legendItem.group.translateY = void 0;
        }
      });
    }
    legend.render();
    if (!bubbleLegendOptions.placed) {
      chart.getMargins();
      chart.axes.forEach((axis) => {
        axis.setScale();
        axis.updateNames();
        objectEach27(axis.ticks, function(tick) {
          tick.isNew = true;
          tick.isNewLabel = true;
        });
      });
      chart.getMargins();
    }
    bubbleLegendOptions.placed = true;
    proceed.call(chart, options2, callback);
    legend.bubbleLegend.correctSizes();
    retranslateItems(legend, getLinesHeights(legend));
  } else {
    proceed.call(chart, options2, callback);
    if (legend && legend.options.enabled && legend.bubbleLegend) {
      legend.render();
      retranslateItems(legend, getLinesHeights(legend));
    }
  }
}
function compose12(ChartClass, LegendClass) {
  if (pushUnique21(composed18, "Series.BubbleLegend")) {
    setOptions4({
      // Set default bubble legend options
      legend: {
        bubbleLegend: BubbleLegendDefaults_default
      }
    });
    wrap5(ChartClass.prototype, "drawChartBox", chartDrawChartBox);
    addEvent56(LegendClass, "afterGetAllItems", onLegendAfterGetAllItems);
    addEvent56(LegendClass, "itemClick", onLegendItemClick);
  }
}
function getVisibleBubbleSeriesIndex(chart) {
  const series = chart.series;
  let i = 0;
  while (i < series.length) {
    if (series[i] && series[i].isBubble && series[i].visible && series[i].dataTable.rowCount) {
      return i;
    }
    i++;
  }
  return -1;
}
function getLinesHeights(legend) {
  const items = legend.allItems, lines = [], length = items.length;
  let lastLine, legendItem, legendItem2, i = 0, j = 0;
  for (i = 0; i < length; i++) {
    legendItem = items[i].legendItem || {};
    legendItem2 = (items[i + 1] || {}).legendItem || {};
    if (legendItem.labelHeight) {
      items[i].itemHeight = legendItem.labelHeight;
    }
    if (
      // Line break
      items[i] === items[length - 1] || legendItem.y !== legendItem2.y
    ) {
      lines.push({ height: 0 });
      lastLine = lines[lines.length - 1];
      for (j; j <= i; j++) {
        if (items[j].itemHeight > lastLine.height) {
          lastLine.height = items[j].itemHeight;
        }
      }
      lastLine.step = i;
    }
  }
  return lines;
}
function onLegendAfterGetAllItems(e) {
  const legend = this, bubbleLegend = legend.bubbleLegend, legendOptions = legend.options, options2 = legendOptions.bubbleLegend, bubbleSeriesIndex = getVisibleBubbleSeriesIndex(legend.chart);
  if (bubbleLegend && bubbleLegend.ranges && bubbleLegend.ranges.length) {
    if (options2.ranges.length) {
      options2.autoRanges = !!options2.ranges[0].autoRanges;
    }
    legend.destroyItem(bubbleLegend);
  }
  if (bubbleSeriesIndex >= 0 && legendOptions.enabled && options2.enabled) {
    options2.seriesIndex = bubbleSeriesIndex;
    legend.bubbleLegend = new BubbleLegendItem_default(options2, legend);
    legend.bubbleLegend.addToLegend(e.allItems);
  }
}
function onLegendItemClick(e) {
  if (e.defaultPrevented) {
    return false;
  }
  const legend = this, series = e.legendItem, chart = legend.chart, visible = series.visible;
  let status;
  if (legend && legend.bubbleLegend) {
    series.visible = !visible;
    series.ignoreSeries = visible;
    status = getVisibleBubbleSeriesIndex(chart) >= 0;
    if (legend.bubbleLegend.visible !== status) {
      legend.update({
        bubbleLegend: { enabled: status }
      });
      legend.bubbleLegend.visible = status;
    }
    series.visible = visible;
  }
}
function retranslateItems(legend, lines) {
  const items = legend.allItems, rtl = legend.options.rtl;
  let orgTranslateX, orgTranslateY, movementX, legendItem, actualLine = 0;
  items.forEach((item, index) => {
    legendItem = item.legendItem || {};
    if (!legendItem.group) {
      return;
    }
    orgTranslateX = legendItem.group.translateX || 0;
    orgTranslateY = legendItem.y || 0;
    movementX = item.movementX;
    if (movementX || rtl && item.ranges) {
      movementX = rtl ? orgTranslateX - item.options.maxSize / 2 : orgTranslateX + movementX;
      legendItem.group.attr({ translateX: movementX });
    }
    if (index > lines[actualLine].step) {
      actualLine++;
    }
    legendItem.group.attr({
      translateY: Math.round(orgTranslateY + lines[actualLine].height / 2)
    });
    legendItem.y = orgTranslateY + lines[actualLine].height / 2;
  });
}
var BubbleLegendComposition = {
  compose: compose12
};
var BubbleLegendComposition_default = BubbleLegendComposition;

// node_modules/highcharts/es-modules/Series/Bubble/BubblePoint.js
var { seriesTypes: { scatter: { prototype: { pointClass: ScatterPoint } } } } = SeriesRegistry_default;
var { extend: extend50 } = Utilities_default;
var BubblePoint = class extends ScatterPoint {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * @private
   */
  haloPath(size) {
    const computedSize = (size && this.marker ? this.marker.radius || 0 : 0) + size;
    if (this.series.chart.inverted) {
      const pos = this.pos() || [0, 0], { xAxis: xAxis2, yAxis: yAxis2, chart } = this.series;
      return chart.renderer.symbols.circle(xAxis2.len - pos[1] - computedSize, yAxis2.len - pos[0] - computedSize, computedSize * 2, computedSize * 2);
    }
    return Point_default.prototype.haloPath.call(
      this,
      // #6067
      computedSize
    );
  }
};
extend50(BubblePoint.prototype, {
  ttBelow: false
});
var BubblePoint_default = BubblePoint;

// node_modules/highcharts/es-modules/Series/Bubble/BubbleSeries.js
var { composed: composed19, noop: noop10 } = Globals_default;
var { series: Series6, seriesTypes: { column: { prototype: columnProto3 }, scatter: ScatterSeries2 } } = SeriesRegistry_default;
var { addEvent: addEvent57, arrayMax: arrayMax9, arrayMin: arrayMin8, clamp: clamp13, extend: extend51, isNumber: isNumber48, merge: merge62, pick: pick69, pushUnique: pushUnique22 } = Utilities_default;
function onAxisFoundExtremes() {
  const axisLength = this.len, { coll, isXAxis, min: min4 } = this, range2 = (this.max || 0) - (min4 || 0);
  let pxMin = 0, pxMax = axisLength, transA = axisLength / range2, hasActiveSeries;
  if (coll !== "xAxis" && coll !== "yAxis") {
    return;
  }
  this.series.forEach((series) => {
    if (series.bubblePadding && series.reserveSpace()) {
      this.allowZoomOutside = true;
      hasActiveSeries = true;
      const data = series.getColumn(isXAxis ? "x" : "y");
      if (isXAxis) {
        (series.onPoint || series).getRadii(0, 0, series);
        if (series.onPoint) {
          series.radii = series.onPoint.radii;
        }
      }
      if (range2 > 0) {
        let i = data.length;
        while (i--) {
          if (isNumber48(data[i]) && this.dataMin <= data[i] && data[i] <= this.max) {
            const radius = series.radii && series.radii[i] || 0;
            pxMin = Math.min((data[i] - min4) * transA - radius, pxMin);
            pxMax = Math.max((data[i] - min4) * transA + radius, pxMax);
          }
        }
      }
    }
  });
  if (hasActiveSeries && range2 > 0 && !this.logarithmic) {
    pxMax -= axisLength;
    transA *= (axisLength + Math.max(0, pxMin) - // #8901
    Math.min(pxMax, axisLength)) / axisLength;
    [
      ["min", "userMin", pxMin],
      ["max", "userMax", pxMax]
    ].forEach((keys) => {
      if (typeof pick69(this.options[keys[0]], this[keys[1]]) === "undefined") {
        this[keys[0]] += keys[2] / transA;
      }
    });
  }
}
function onAxisAfterRender() {
  const { ticks, tickPositions, dataMin = 0, dataMax = 0, categories } = this, type = this.options.type;
  if ((categories?.length || type === "category") && this.series.find((s) => s.bubblePadding)) {
    let tickCount = tickPositions.length;
    while (tickCount--) {
      const tick = ticks[tickPositions[tickCount]], pos = tick.pos || 0;
      if (pos > dataMax || pos < dataMin) {
        tick.label?.hide();
      }
    }
  }
}
var BubbleSeries = class extends ScatterSeries2 {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(AxisClass, ChartClass, LegendClass) {
    BubbleLegendComposition_default.compose(ChartClass, LegendClass);
    if (pushUnique22(composed19, "Series.Bubble")) {
      addEvent57(AxisClass, "foundExtremes", onAxisFoundExtremes);
      addEvent57(AxisClass, "afterRender", onAxisAfterRender);
    }
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Perform animation on the bubbles
   * @private
   */
  animate(init3) {
    if (!init3 && this.points.length < this.options.animationLimit) {
      this.points.forEach(function(point) {
        const { graphic, plotX = 0, plotY = 0 } = point;
        if (graphic && graphic.width) {
          if (!this.hasRendered) {
            graphic.attr({
              x: plotX,
              y: plotY,
              width: 1,
              height: 1
            });
          }
          graphic.animate(this.markerAttribs(point), this.options.animation);
        }
      }, this);
    }
  }
  /**
   * Get the radius for each point based on the minSize, maxSize and each
   * point's Z value. This must be done prior to Series.translate because
   * the axis needs to add padding in accordance with the point sizes.
   * @private
   */
  getRadii() {
    const zData = this.getColumn("z"), yData = this.getColumn("y"), radii = [];
    let len, i, value, zExtremes = this.chart.bubbleZExtremes;
    const { minPxSize, maxPxSize } = this.getPxExtremes();
    if (!zExtremes) {
      let zMin = Number.MAX_VALUE;
      let zMax = -Number.MAX_VALUE;
      let valid;
      this.chart.series.forEach((otherSeries) => {
        if (otherSeries.bubblePadding && otherSeries.reserveSpace()) {
          const zExtremes2 = (otherSeries.onPoint || otherSeries).getZExtremes();
          if (zExtremes2) {
            zMin = Math.min(pick69(zMin, zExtremes2.zMin), zExtremes2.zMin);
            zMax = Math.max(pick69(zMax, zExtremes2.zMax), zExtremes2.zMax);
            valid = true;
          }
        }
      });
      if (valid) {
        zExtremes = { zMin, zMax };
        this.chart.bubbleZExtremes = zExtremes;
      } else {
        zExtremes = { zMin: 0, zMax: 0 };
      }
    }
    for (i = 0, len = zData.length; i < len; i++) {
      value = zData[i];
      radii.push(this.getRadius(zExtremes.zMin, zExtremes.zMax, minPxSize, maxPxSize, value, yData && yData[i]));
    }
    this.radii = radii;
  }
  /**
   * Get the individual radius for one point.
   * @private
   */
  getRadius(zMin, zMax, minSize, maxSize, value, yValue) {
    const options2 = this.options, sizeByArea = options2.sizeBy !== "width", zThreshold = options2.zThreshold;
    let zRange = zMax - zMin, pos = 0.5;
    if (yValue === null || value === null) {
      return null;
    }
    if (isNumber48(value)) {
      if (options2.sizeByAbsoluteValue) {
        value = Math.abs(value - zThreshold);
        zMax = zRange = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));
        zMin = 0;
      }
      if (value < zMin) {
        return minSize / 2 - 1;
      }
      if (zRange > 0) {
        pos = (value - zMin) / zRange;
      }
    }
    if (sizeByArea && pos >= 0) {
      pos = Math.sqrt(pos);
    }
    return Math.ceil(minSize + pos * (maxSize - minSize)) / 2;
  }
  /**
   * Define hasData function for non-cartesian series.
   * Returns true if the series has points at all.
   * @private
   */
  hasData() {
    return !!this.dataTable.rowCount;
  }
  /**
   * @private
   */
  markerAttribs(point, state) {
    const attr18 = super.markerAttribs(point, state), { height = 0, width = 0 } = attr18;
    return this.chart.inverted ? extend51(attr18, {
      x: (point.plotX || 0) - width / 2,
      y: (point.plotY || 0) - height / 2
    }) : attr18;
  }
  /**
   * @private
   */
  pointAttribs(point, state) {
    const markerOptions = this.options.marker, fillOpacity = markerOptions?.fillOpacity, attr18 = Series6.prototype.pointAttribs.call(this, point, state);
    attr18["fill-opacity"] = fillOpacity ?? 1;
    return attr18;
  }
  /**
   * Extend the base translate method to handle bubble size
   * @private
   */
  translate() {
    super.translate.call(this);
    this.getRadii();
    this.translateBubble();
  }
  translateBubble() {
    const { data, options: options2, radii } = this, { minPxSize } = this.getPxExtremes();
    let i = data.length;
    while (i--) {
      const point = data[i], radius = radii ? radii[i] : 0;
      if (this.zoneAxis === "z") {
        point.negative = (point.z || 0) < (options2.zThreshold || 0);
      }
      if (isNumber48(radius) && radius >= minPxSize / 2) {
        point.marker = extend51(point.marker, {
          radius,
          width: 2 * radius,
          height: 2 * radius
        });
        point.dlBox = {
          x: point.plotX - radius,
          y: point.plotY - radius,
          width: 2 * radius,
          height: 2 * radius
        };
      } else {
        point.shapeArgs = point.plotY = point.dlBox = void 0;
        point.isInside = false;
      }
    }
  }
  getPxExtremes() {
    const smallestSize = Math.min(this.chart.plotWidth, this.chart.plotHeight);
    const getPxSize = (length) => {
      let isPercent;
      if (typeof length === "string") {
        isPercent = /%$/.test(length);
        length = parseInt(length, 10);
      }
      return isPercent ? smallestSize * length / 100 : length;
    };
    const minPxSize = getPxSize(pick69(this.options.minSize, 8));
    const maxPxSize = Math.max(getPxSize(pick69(this.options.maxSize, "20%")), minPxSize);
    return { minPxSize, maxPxSize };
  }
  getZExtremes() {
    const options2 = this.options, zData = this.getColumn("z").filter(isNumber48);
    if (zData.length) {
      const zMin = pick69(options2.zMin, clamp13(arrayMin8(zData), options2.displayNegative === false ? options2.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));
      const zMax = pick69(options2.zMax, arrayMax9(zData));
      if (isNumber48(zMin) && isNumber48(zMax)) {
        return { zMin, zMax };
      }
    }
  }
  /**
   * @private
   * @function Highcharts.Series#searchKDTree
   */
  searchKDTree(point, compareX, e, suppliedPointEvaluator = noop10, suppliedBSideCheckEvaluator = noop10) {
    suppliedPointEvaluator = (p1, p2, comparisonProp) => {
      const p1Dist = p1[comparisonProp] || 0;
      const p2Dist = p2[comparisonProp] || 0;
      let ret, flip = false;
      if (p1Dist === p2Dist) {
        ret = p1.index > p2.index ? p1 : p2;
      } else if (p1Dist < 0 && p2Dist < 0) {
        ret = p1Dist - (p1.marker?.radius || 0) >= p2Dist - (p2.marker?.radius || 0) ? p1 : p2;
        flip = true;
      } else {
        ret = p1Dist < p2Dist ? p1 : p2;
      }
      return [ret, flip];
    };
    suppliedBSideCheckEvaluator = (a, b, flip) => !flip && a > b || a < b;
    return super.searchKDTree(point, compareX, e, suppliedPointEvaluator, suppliedBSideCheckEvaluator);
  }
};
BubbleSeries.defaultOptions = merge62(ScatterSeries2.defaultOptions, {
  dataLabels: {
    formatter: function() {
      const { numberFormatter } = this.series.chart;
      const { z } = this.point;
      return isNumber48(z) ? numberFormatter(z, -1) : "";
    },
    inside: true,
    verticalAlign: "middle"
  },
  /**
   * If there are more points in the series than the `animationLimit`, the
   * animation won't run. Animation affects overall performance and
   * doesn't work well with heavy data series.
   *
   * @since 6.1.0
   */
  animationLimit: 250,
  /**
   * Whether to display negative sized bubbles. The threshold is given
   * by the [zThreshold](#plotOptions.bubble.zThreshold) option, and negative
   * bubbles can be visualized by setting
   * [negativeColor](#plotOptions.bubble.negativeColor).
   *
   * @sample {highcharts} highcharts/plotoptions/bubble-negative/
   *         Negative bubbles
   *
   * @type      {boolean}
   * @default   true
   * @since     3.0
   * @apioption plotOptions.bubble.displayNegative
   */
  /**
   * @extends   plotOptions.series.marker
   * @excluding enabled, enabledThreshold, height, radius, width
   */
  marker: {
    lineColor: null,
    // Inherit from series.color
    lineWidth: 1,
    /**
     * The fill opacity of the bubble markers.
     */
    fillOpacity: 0.5,
    /**
     * In bubble charts, the radius is overridden and determined based
     * on the point's data value.
     *
     * @ignore-option
     */
    radius: null,
    states: {
      hover: {
        radiusPlus: 0
      }
    },
    /**
     * A predefined shape or symbol for the marker. Possible values are
     * "circle", "square", "diamond", "triangle" and "triangle-down".
     *
     * Additionally, the URL to a graphic can be given on the form
     * `url(graphic.png)`. Note that for the image to be applied to
     * exported charts, its URL needs to be accessible by the export
     * server.
     *
     * Custom callbacks for symbol path generation can also be added to
     * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
     * used by its method name, as shown in the demo.
     *
     * @sample {highcharts} highcharts/plotoptions/bubble-symbol/
     *         Bubble chart with various symbols
     * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
     *         General chart with predefined, graphic and custom markers
     *
     * @type  {Highcharts.SymbolKeyValue|string}
     * @since 5.0.11
     */
    symbol: "circle"
  },
  /**
   * Minimum bubble size. Bubbles will automatically size between the
   * `minSize` and `maxSize` to reflect the `z` value of each bubble.
   * Can be either pixels (when no unit is given), or a percentage of
   * the smallest one of the plot width and height.
   *
   * @sample {highcharts} highcharts/plotoptions/bubble-size/
   *         Bubble size
   *
   * @type    {number|string}
   * @since   3.0
   * @product highcharts highstock
   */
  minSize: 8,
  /**
   * Maximum bubble size. Bubbles will automatically size between the
   * `minSize` and `maxSize` to reflect the `z` value of each bubble.
   * Can be either pixels (when no unit is given), or a percentage of
   * the smallest one of the plot width and height.
   *
   * @sample {highcharts} highcharts/plotoptions/bubble-size/
   *         Bubble size
   *
   * @type    {number|string}
   * @since   3.0
   * @product highcharts highstock
   */
  maxSize: "20%",
  /**
   * When a point's Z value is below the
   * [zThreshold](#plotOptions.bubble.zThreshold)
   * setting, this color is used.
   *
   * @sample {highcharts} highcharts/plotoptions/bubble-negative/
   *         Negative bubbles
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     3.0
   * @product   highcharts
   * @apioption plotOptions.bubble.negativeColor
   */
  /**
   * Whether the bubble's value should be represented by the area or the
   * width of the bubble. The default, `area`, corresponds best to the
   * human perception of the size of each bubble.
   *
   * @sample {highcharts} highcharts/plotoptions/bubble-sizeby/
   *         Comparison of area and size
   *
   * @type       {Highcharts.BubbleSizeByValue}
   * @default    area
   * @since      3.0.7
   * @apioption  plotOptions.bubble.sizeBy
   */
  /**
   * When this is true, the absolute value of z determines the size of
   * the bubble. This means that with the default `zThreshold` of 0, a
   * bubble of value -1 will have the same size as a bubble of value 1,
   * while a bubble of value 0 will have a smaller size according to
   * `minSize`.
   *
   * @sample    {highcharts} highcharts/plotoptions/bubble-sizebyabsolutevalue/
   *            Size by absolute value, various thresholds
   *
   * @type      {boolean}
   * @default   false
   * @since     4.1.9
   * @product   highcharts
   * @apioption plotOptions.bubble.sizeByAbsoluteValue
   */
  /**
   * When this is true, the series will not cause the Y axis to cross
   * the zero plane (or [threshold](#plotOptions.series.threshold) option)
   * unless the data actually crosses the plane.
   *
   * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
   * 3 will make the Y axis show negative values according to the
   * `minPadding` option. If `softThreshold` is `true`, the Y axis starts
   * at 0.
   *
   * @since   4.1.9
   * @product highcharts
   */
  softThreshold: false,
  states: {
    hover: {
      halo: {
        size: 5
      }
    }
  },
  tooltip: {
    pointFormat: "({point.x}, {point.y}), Size: {point.z}"
  },
  turboThreshold: 0,
  /**
   * The minimum for the Z value range. Defaults to the highest Z value
   * in the data.
   *
   * @see [zMin](#plotOptions.bubble.zMin)
   *
   * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/
   *         Z has a possible range of 0-100
   *
   * @type      {number}
   * @since     4.0.3
   * @product   highcharts
   * @apioption plotOptions.bubble.zMax
   */
  /**
   * @default   z
   * @apioption plotOptions.bubble.colorKey
   */
  /**
   * The minimum for the Z value range. Defaults to the lowest Z value
   * in the data.
   *
   * @see [zMax](#plotOptions.bubble.zMax)
   *
   * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/
   *         Z has a possible range of 0-100
   *
   * @type      {number}
   * @since     4.0.3
   * @product   highcharts
   * @apioption plotOptions.bubble.zMin
   */
  /**
   * When [displayNegative](#plotOptions.bubble.displayNegative) is `false`,
   * bubbles with lower Z values are skipped. When `displayNegative`
   * is `true` and a [negativeColor](#plotOptions.bubble.negativeColor)
   * is given, points with lower Z is colored.
   *
   * @sample {highcharts} highcharts/plotoptions/bubble-negative/
   *         Negative bubbles
   *
   * @since   3.0
   * @product highcharts
   */
  zThreshold: 0,
  zoneAxis: "z"
});
extend51(BubbleSeries.prototype, {
  alignDataLabel: columnProto3.alignDataLabel,
  applyZones: noop10,
  bubblePadding: true,
  isBubble: true,
  keysAffectYAxis: ["y"],
  pointArrayMap: ["y", "z"],
  pointClass: BubblePoint_default,
  parallelArrays: ["x", "y", "z"],
  trackerGroups: ["group", "dataLabelsGroup"],
  specialGroup: "group",
  // To allow clipping (#6296)
  zoneAxis: "z"
});
addEvent57(BubbleSeries, "updatedData", (e) => {
  delete e.target.chart.bubbleZExtremes;
});
addEvent57(BubbleSeries, "remove", (e) => {
  delete e.target.chart.bubbleZExtremes;
});
SeriesRegistry_default.registerSeriesType("bubble", BubbleSeries);
var BubbleSeries_default = BubbleSeries;

// node_modules/highcharts/es-modules/Series/ColumnRange/ColumnRangePoint.js
var { seriesTypes: { column: { prototype: { pointClass: { prototype: columnProto4 } } }, arearange: { prototype: { pointClass: AreaRangePoint2 } } } } = SeriesRegistry_default;
var { extend: extend52, isNumber: isNumber49 } = Utilities_default;
var ColumnRangePoint = class extends AreaRangePoint2 {
  /* *
   *
   *  Functions
   *
   * */
  isValid() {
    return isNumber49(this.low);
  }
};
extend52(ColumnRangePoint.prototype, {
  setState: columnProto4.setState
});
var ColumnRangePoint_default = ColumnRangePoint;

// node_modules/highcharts/es-modules/Series/ColumnRange/ColumnRangeSeries.js
var { noop: noop11 } = Globals_default;
var { seriesTypes: { arearange: AreaRangeSeries2, column: ColumnSeries6, column: { prototype: columnProto5 } } } = SeriesRegistry_default;
var { addEvent: addEvent58, clamp: clamp14, extend: extend53, isNumber: isNumber50, merge: merge63, pick: pick70 } = Utilities_default;
var columnRangeOptions = {
  borderRadius: {
    where: "all"
  },
  /**
   * Extended data labels for range series types. Range series data labels
   * have no `x` and `y` options. Instead, they have `xLow`, `xHigh`,
   * `yLow` and `yHigh` options to allow the higher and lower data label
   * sets individually.
   *
   * @declare   Highcharts.SeriesAreaRangeDataLabelsOptionsObject
   * @extends   plotOptions.arearange.dataLabels
   * @since     2.3.0
   * @product   highcharts highstock
   * @apioption plotOptions.columnrange.dataLabels
   */
  pointRange: null,
  legendSymbol: "rectangle",
  /** @ignore-option */
  marker: null,
  states: {
    hover: {
      /** @ignore-option */
      halo: false
    }
  }
};
var ColumnRangeSeries = class extends AreaRangeSeries2 {
  /* *
   *
   *  Functions
   *
   * */
  setOptions() {
    merge63(true, arguments[0], { stacking: void 0 });
    return AreaRangeSeries2.prototype.setOptions.apply(this, arguments);
  }
  // Overrides from modules that may be loaded after this module
  // @todo move to compositions
  translate() {
    return columnProto5.translate.apply(this);
  }
  // Public crispCol(): BBoxObject {
  //     return columnProto.crispCol.apply(this, arguments as any);
  // }
  // public drawPoints(): void {
  //     return columnProto.drawPoints.apply(this, arguments as any);
  // }
  // public drawTracker(): void {
  //     return columnProto.drawTracker.apply(this, arguments as any);
  // }
  // public getColumnMetrics(): ColumnMetricsObject {
  //     return columnProto.getColumnMetrics.apply(this, arguments as any);
  // }
  pointAttribs() {
    return columnProto5.pointAttribs.apply(this, arguments);
  }
  // Public adjustForMissingColumns(): number {
  //     return columnProto.adjustForMissingColumns.apply(this, arguments);
  // }
  // public animate(): void {
  //     return columnProto.animate.apply(this, arguments as any);
  // }
  translate3dPoints() {
    return columnProto5.translate3dPoints.apply(this, arguments);
  }
  translate3dShapes() {
    return columnProto5.translate3dShapes.apply(this, arguments);
  }
  afterColumnTranslate() {
    const yAxis2 = this.yAxis, xAxis2 = this.xAxis, startAngleRad = xAxis2.startAngleRad, chart = this.chart, isRadial = this.xAxis.isRadial, safeDistance = Math.max(chart.chartWidth, chart.chartHeight) + 999;
    let height, heightDifference, start, y;
    function safeBounds(pixelPos) {
      return clamp14(pixelPos, -safeDistance, safeDistance);
    }
    this.points.forEach((point) => {
      const shapeArgs = point.shapeArgs || {}, minPointLength = this.options.minPointLength, plotY = point.plotY, plotHigh = yAxis2.translate(point.high, 0, 1, 0, 1);
      if (isNumber50(plotHigh) && isNumber50(plotY)) {
        point.plotHigh = safeBounds(plotHigh);
        point.plotLow = safeBounds(plotY);
        y = point.plotHigh;
        height = pick70(point.rectPlotY, point.plotY) - point.plotHigh;
        if (Math.abs(height) < minPointLength) {
          heightDifference = minPointLength - height;
          height += heightDifference;
          y -= heightDifference / 2;
        } else if (height < 0) {
          height *= -1;
          y -= height;
        }
        if (isRadial && this.polar) {
          start = point.barX + startAngleRad;
          point.shapeType = "arc";
          point.shapeArgs = this.polar.arc(y + height, y, start, start + point.pointWidth);
        } else {
          shapeArgs.height = height;
          shapeArgs.y = y;
          const { x = 0, width = 0 } = shapeArgs;
          point.shapeArgs = merge63(point.shapeArgs, this.crispCol(x, y, width, height));
          point.tooltipPos = chart.inverted ? [
            yAxis2.len + yAxis2.pos - chart.plotLeft - y - height / 2,
            xAxis2.len + xAxis2.pos - chart.plotTop - x - width / 2,
            height
          ] : [
            xAxis2.left - chart.plotLeft + x + width / 2,
            yAxis2.pos - chart.plotTop + y + height / 2,
            height
          ];
        }
      }
    });
  }
};
ColumnRangeSeries.defaultOptions = merge63(ColumnSeries6.defaultOptions, AreaRangeSeries2.defaultOptions, columnRangeOptions);
addEvent58(ColumnRangeSeries, "afterColumnTranslate", function() {
  ColumnRangeSeries.prototype.afterColumnTranslate.apply(this);
}, { order: 5 });
extend53(ColumnRangeSeries.prototype, {
  directTouch: true,
  pointClass: ColumnRangePoint_default,
  trackerGroups: ["group", "dataLabelsGroup"],
  adjustForMissingColumns: columnProto5.adjustForMissingColumns,
  animate: columnProto5.animate,
  crispCol: columnProto5.crispCol,
  drawGraph: noop11,
  drawPoints: columnProto5.drawPoints,
  getSymbol: noop11,
  drawTracker: columnProto5.drawTracker,
  getColumnMetrics: columnProto5.getColumnMetrics
});
SeriesRegistry_default.registerSeriesType("columnrange", ColumnRangeSeries);

// node_modules/highcharts/es-modules/Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js
var ColumnPyramidSeriesDefaults = {};
var ColumnPyramidSeriesDefaults_default = ColumnPyramidSeriesDefaults;

// node_modules/highcharts/es-modules/Series/ColumnPyramid/ColumnPyramidSeries.js
var { column: ColumnSeries7 } = SeriesRegistry_default.seriesTypes;
var { clamp: clamp15, merge: merge64, pick: pick71 } = Utilities_default;
var ColumnPyramidSeries = class extends ColumnSeries7 {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Overrides the column translate method
   * @private
   */
  translate() {
    const series = this, chart = series.chart, options2 = series.options, dense = series.dense = series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick71(
      options2.borderWidth,
      dense ? 0 : 1
      // #3635
    ), yAxis2 = series.yAxis, threshold = options2.threshold, minPointLength = pick71(options2.minPointLength, 5), metrics = series.getColumnMetrics(), pointWidth = metrics.width, pointXOffset = series.pointXOffset = metrics.offset;
    let translatedThreshold = series.translatedThreshold = yAxis2.getThreshold(threshold), seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth);
    if (chart.inverted) {
      translatedThreshold -= 0.5;
    }
    if (options2.pointPadding) {
      seriesBarW = Math.ceil(seriesBarW);
    }
    super.translate();
    for (const point of series.points) {
      const yBottom = pick71(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotY = clamp15(point.plotY, -safeDistance, yAxis2.len + safeDistance), barW = seriesBarW / 2, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY;
      let barX = point.plotX + pointXOffset, stackTotal, stackHeight, topXwidth, bottomXwidth, invBarPos, x1, x2, x3, x4, y1, y2;
      if (options2.centerInCategory) {
        barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);
      }
      point.barX = barX;
      point.pointWidth = pointWidth;
      point.tooltipPos = chart.inverted ? [
        yAxis2.len + yAxis2.pos - chart.plotLeft - plotY,
        series.xAxis.len - barX - barW,
        barH
      ] : [
        barX + barW,
        plotY + yAxis2.pos - chart.plotTop,
        barH
      ];
      stackTotal = threshold + (point.total || point.y);
      if (options2.stacking === "percent") {
        stackTotal = threshold + (point.y < 0) ? -100 : 100;
      }
      const topPointY = yAxis2.toPixels(stackTotal, true);
      stackHeight = chart.plotHeight - topPointY - (chart.plotHeight - translatedThreshold);
      topXwidth = stackHeight ? barW * (barY - topPointY) / stackHeight : 0;
      bottomXwidth = stackHeight ? barW * (barY + barH - topPointY) / stackHeight : 0;
      x1 = barX - topXwidth + barW;
      x2 = barX + topXwidth + barW;
      x3 = barX + bottomXwidth + barW;
      x4 = barX - bottomXwidth + barW;
      y1 = barY - minPointLength;
      y2 = barY + barH;
      if (point.y < 0) {
        y1 = barY;
        y2 = barY + barH + minPointLength;
      }
      if (chart.inverted) {
        invBarPos = yAxis2.width - barY;
        stackHeight = topPointY - (yAxis2.width - translatedThreshold);
        topXwidth = barW * (topPointY - invBarPos) / stackHeight;
        bottomXwidth = barW * (topPointY - (invBarPos - barH)) / stackHeight;
        x1 = barX + barW + topXwidth;
        x2 = x1 - 2 * topXwidth;
        x3 = barX - bottomXwidth + barW;
        x4 = barX + bottomXwidth + barW;
        y1 = barY;
        y2 = barY + barH - minPointLength;
        if (point.y < 0) {
          y2 = barY + barH + minPointLength;
        }
      }
      point.shapeType = "path";
      point.shapeArgs = {
        x: x1,
        y: y1,
        width: x2 - x1,
        height: barH,
        // Path of pyramid
        d: [
          ["M", x1, y1],
          ["L", x2, y1],
          ["L", x3, y2],
          ["L", x4, y2],
          ["Z"]
        ]
      };
    }
  }
};
ColumnPyramidSeries.defaultOptions = merge64(ColumnSeries7.defaultOptions, ColumnPyramidSeriesDefaults_default);
SeriesRegistry_default.registerSeriesType("columnpyramid", ColumnPyramidSeries);

// node_modules/highcharts/es-modules/Series/ErrorBar/ErrorBarSeriesDefaults.js
var ErrorBarSeriesDefaults = {
  /**
   * The main color of the bars. This can be overridden by
   * [stemColor](#plotOptions.errorbar.stemColor) and
   * [whiskerColor](#plotOptions.errorbar.whiskerColor) individually.
   *
   * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
   *         Error bar styling
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default #000000
   * @since   3.0
   * @product highcharts
   */
  color: "#000000",
  grouping: false,
  /**
   * The parent series of the error bar. The default value links it to
   * the previous series. Otherwise, use the id of the parent series.
   *
   * @since   3.0
   * @product highcharts
   */
  linkedTo: ":previous",
  tooltip: {
    pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
  },
  /**
   * The line width of the whiskers, the horizontal lines marking
   * low and high values. When `null`, the general
   * [lineWidth](#plotOptions.errorbar.lineWidth) applies.
   *
   * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
   *         Error bar styling
   *
   * @type    {number}
   * @since   3.0
   * @product highcharts
   */
  whiskerWidth: null
};
var ErrorBarSeriesDefaults_default = ErrorBarSeriesDefaults;

// node_modules/highcharts/es-modules/Series/ErrorBar/ErrorBarSeries.js
var { arearange: AreaRangeSeries3 } = SeriesRegistry_default.seriesTypes;
var { addEvent: addEvent59, merge: merge65, extend: extend54 } = Utilities_default;
var ErrorBarSeries = class extends BoxPlotSeries_default {
  /* *
   *
   *  Functions
   *
   * */
  getColumnMetrics() {
    const series = this;
    return series.linkedParent && series.linkedParent.columnMetrics || ColumnSeries_default.prototype.getColumnMetrics.call(series);
  }
  drawDataLabels() {
    const series = this, valKey = series.pointValKey;
    if (AreaRangeSeries3) {
      AreaRangeSeries3.prototype.drawDataLabels.call(series);
      for (const point of series.points) {
        point.y = point[valKey];
      }
    }
  }
  toYData(point) {
    return [point.low, point.high];
  }
};
ErrorBarSeries.defaultOptions = merge65(BoxPlotSeries_default.defaultOptions, ErrorBarSeriesDefaults_default);
addEvent59(ErrorBarSeries, "afterTranslate", function() {
  for (const point of this.points) {
    point.plotLow = point.plotY;
  }
}, { order: 0 });
extend54(ErrorBarSeries.prototype, {
  pointArrayMap: ["low", "high"],
  // Array point configs are mapped to this
  pointValKey: "high",
  // Defines the top of the tracker
  doQuartiles: false
});
SeriesRegistry_default.registerSeriesType("errorbar", ErrorBarSeries);

// node_modules/highcharts/es-modules/Series/Gauge/GaugePoint.js
var { series: { prototype: { pointClass: Point2 } } } = SeriesRegistry_default;
var GaugePoint = class extends Point2 {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Don't do any hover colors or anything
   * @private
   */
  setState(state) {
    this.state = state;
  }
};
var GaugePoint_default = GaugePoint;

// node_modules/highcharts/es-modules/Series/Gauge/GaugeSeries.js
var { noop: noop12 } = Globals_default;
var { series: Series7, seriesTypes: { column: ColumnSeries8 } } = SeriesRegistry_default;
var { clamp: clamp16, isNumber: isNumber51, extend: extend55, merge: merge66, pick: pick72, pInt: pInt8, defined: defined53 } = Utilities_default;
var GaugeSeries = class extends Series7 {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Calculate paths etc
   * @private
   */
  translate() {
    const series = this, yAxis2 = series.yAxis, options2 = series.options, center = yAxis2.center;
    series.generatePoints();
    series.points.forEach((point) => {
      const dialOptions = merge66(options2.dial, point.dial), radius = pInt8(dialOptions.radius) * center[2] / 200, baseLength = pInt8(dialOptions.baseLength) * radius / 100, rearLength = pInt8(dialOptions.rearLength) * radius / 100, baseWidth = dialOptions.baseWidth, topWidth = dialOptions.topWidth;
      let overshoot = options2.overshoot, rotation = yAxis2.startAngleRad + yAxis2.translate(point.y, void 0, void 0, void 0, true);
      if (isNumber51(overshoot) || options2.wrap === false) {
        overshoot = isNumber51(overshoot) ? overshoot / 180 * Math.PI : 0;
        rotation = clamp16(rotation, yAxis2.startAngleRad - overshoot, yAxis2.endAngleRad + overshoot);
      }
      rotation = rotation * 180 / Math.PI;
      point.shapeType = "path";
      const d = dialOptions.path || [
        ["M", -rearLength, -baseWidth / 2],
        ["L", baseLength, -baseWidth / 2],
        ["L", radius, -topWidth / 2],
        ["L", radius, topWidth / 2],
        ["L", baseLength, baseWidth / 2],
        ["L", -rearLength, baseWidth / 2],
        ["Z"]
      ];
      point.shapeArgs = {
        d,
        translateX: center[0],
        translateY: center[1],
        rotation
      };
      point.plotX = center[0];
      point.plotY = center[1];
      if (defined53(point.y) && yAxis2.max - yAxis2.min) {
        point.percentage = (point.y - yAxis2.min) / (yAxis2.max - yAxis2.min) * 100;
      }
    });
  }
  /**
   * Draw the points where each point is one needle
   * @private
   */
  drawPoints() {
    const series = this, chart = series.chart, center = series.yAxis.center, pivot = series.pivot, options2 = series.options, pivotOptions = options2.pivot, renderer = chart.renderer;
    series.points.forEach((point) => {
      const graphic = point.graphic, shapeArgs = point.shapeArgs, d = shapeArgs.d, dialOptions = merge66(options2.dial, point.dial);
      if (graphic) {
        graphic.animate(shapeArgs);
        shapeArgs.d = d;
      } else {
        point.graphic = renderer[point.shapeType](shapeArgs).addClass("highcharts-dial").add(series.group);
      }
      if (!chart.styledMode) {
        point.graphic[graphic ? "animate" : "attr"]({
          stroke: dialOptions.borderColor,
          "stroke-width": dialOptions.borderWidth,
          fill: dialOptions.backgroundColor
        });
      }
    });
    if (pivot) {
      pivot.animate({
        translateX: center[0],
        translateY: center[1]
      });
    } else if (pivotOptions) {
      series.pivot = renderer.circle(0, 0, pivotOptions.radius).attr({
        zIndex: 2
      }).addClass("highcharts-pivot").translate(center[0], center[1]).add(series.group);
      if (!chart.styledMode) {
        series.pivot.attr({
          fill: pivotOptions.backgroundColor,
          stroke: pivotOptions.borderColor,
          "stroke-width": pivotOptions.borderWidth
        });
      }
    }
  }
  /**
   * Animate the arrow up from startAngle
   * @private
   */
  animate(init3) {
    const series = this;
    if (!init3) {
      series.points.forEach((point) => {
        const graphic = point.graphic;
        if (graphic) {
          graphic.attr({
            rotation: series.yAxis.startAngleRad * 180 / Math.PI
          });
          graphic.animate({
            rotation: point.shapeArgs.rotation
          }, series.options.animation);
        }
      });
    }
  }
  /**
   * @private
   */
  render() {
    this.group = this.plotGroup("group", "series", this.visible ? "inherit" : "hidden", this.options.zIndex, this.chart.seriesGroup);
    Series7.prototype.render.call(this);
    this.group.clip(this.chart.clipRect);
  }
  /**
   * Extend the basic setData method by running processData and generatePoints
   * immediately, in order to access the points from the legend.
   * @private
   */
  setData(data, redraw) {
    Series7.prototype.setData.call(this, data, false);
    this.processData();
    this.generatePoints();
    if (pick72(redraw, true)) {
      this.chart.redraw();
    }
  }
  /**
   * Define hasData function for non-cartesian series.
   * Returns true if the series has points at all.
   * @private
   */
  hasData() {
    return !!this.points.length;
  }
};
GaugeSeries.defaultOptions = merge66(Series7.defaultOptions, {
  /**
   * When this option is `true`, the dial will wrap around the axes.
   * For instance, in a full-range gauge going from 0 to 360, a value
   * of 400 will point to 40\. When `wrap` is `false`, the dial stops
   * at 360.
   *
   * @see [overshoot](#plotOptions.gauge.overshoot)
   *
   * @type      {boolean}
   * @default   true
   * @since     3.0
   * @product   highcharts
   * @apioption plotOptions.gauge.wrap
   */
  /**
   * Data labels for the gauge. For gauges, the data labels are
   * enabled by default and shown in a bordered box below the point.
   *
   * @since   2.3.0
   * @product highcharts
   */
  dataLabels: {
    borderColor: "#cccccc",
    borderRadius: 3,
    borderWidth: 1,
    crop: false,
    defer: false,
    enabled: true,
    verticalAlign: "top",
    y: 15,
    zIndex: 2
  },
  /**
   * Options for the dial or arrow pointer of the gauge.
   *
   * In styled mode, the dial is styled with the
   * `.highcharts-gauge-series .highcharts-dial` rule.
   *
   * @sample {highcharts} highcharts/css/gauge/
   *         Styled mode
   *
   * @type    {*}
   * @since   2.3.0
   * @product highcharts
   */
  dial: {
    /**
     * The background or fill color of the gauge's dial.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-dial/
     *         Dial options demonstrated
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @default   #000000
     * @since     2.3.0
     * @product   highcharts
     * @apioption plotOptions.gauge.dial.backgroundColor
     */
    backgroundColor: "#000000",
    /**
     * The length of the dial's base part, relative to the total
     * radius or length of the dial.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-dial/
     *         Dial options demonstrated
     *
     * @type      {string}
     * @default   70%
     * @since     2.3.0
     * @product   highcharts
     * @apioption plotOptions.gauge.dial.baseLength
     */
    baseLength: "70%",
    /**
     * The pixel width of the base of the gauge dial. The base is
     * the part closest to the pivot, defined by baseLength.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-dial/
     *         Dial options demonstrated
     *
     * @type      {number}
     * @default   3
     * @since     2.3.0
     * @product   highcharts
     * @apioption plotOptions.gauge.dial.baseWidth
     */
    baseWidth: 3,
    /**
     * The border color or stroke of the gauge's dial. By default,
     * the borderWidth is 0, so this must be set in addition to a
     * custom border color.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-dial/
     *         Dial options demonstrated
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @default   #cccccc
     * @since     2.3.0
     * @product   highcharts
     * @apioption plotOptions.gauge.dial.borderColor
     */
    borderColor: "#cccccc",
    /**
     * The width of the gauge dial border in pixels.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-dial/
     *         Dial options demonstrated
     *
     * @type      {number}
     * @default   0
     * @since     2.3.0
     * @product   highcharts
     * @apioption plotOptions.gauge.dial.borderWidth
     */
    borderWidth: 0,
    /**
     * An array with an SVG path for the custom dial.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-path/
     *         Dial options demonstrated
     *
     * @type      {Highcharts.SVGPathArray}
     * @since 10.2.0
     * @product   highcharts
     * @apioption plotOptions.gauge.dial.path
     */
    /**
     * The radius or length of the dial, in percentages relative to
     * the radius of the gauge itself.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-dial/
     *         Dial options demonstrated
     *
     * @type      {string}
     * @default   80%
     * @since     2.3.0
     * @product   highcharts
     * @apioption plotOptions.gauge.dial.radius
     */
    radius: "80%",
    /**
     * The length of the dial's rear end, the part that extends out
     * on the other side of the pivot. Relative to the dial's
     * length.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-dial/
     *         Dial options demonstrated
     *
     * @type      {string}
     * @default   10%
     * @since     2.3.0
     * @product   highcharts
     * @apioption plotOptions.gauge.dial.rearLength
     */
    rearLength: "10%",
    /**
     * The width of the top of the dial, closest to the perimeter.
     * The pivot narrows in from the base to the top.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-dial/
     *         Dial options demonstrated
     *
     * @type      {number}
     * @default   1
     * @since     2.3.0
     * @product   highcharts
     * @apioption plotOptions.gauge.dial.topWidth
     */
    topWidth: 1
  },
  /**
   * Allow the dial to overshoot the end of the perimeter axis by
   * this many degrees. Say if the gauge axis goes from 0 to 60, a
   * value of 100, or 1000, will show 5 degrees beyond the end of the
   * axis when this option is set to 5.
   *
   * @see [wrap](#plotOptions.gauge.wrap)
   *
   * @sample {highcharts} highcharts/plotoptions/gauge-overshoot/
   *         Allow 5 degrees overshoot
   *
   * @type      {number}
   * @since     3.0.10
   * @product   highcharts
   * @apioption plotOptions.gauge.overshoot
   */
  /**
   * Options for the pivot or the center point of the gauge.
   *
   * In styled mode, the pivot is styled with the
   * `.highcharts-gauge-series .highcharts-pivot` rule.
   *
   * @sample {highcharts} highcharts/css/gauge/
   *         Styled mode
   *
   * @type    {*}
   * @since   2.3.0
   * @product highcharts
   */
  pivot: {
    /**
     * The pixel radius of the pivot.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
     *         Pivot options demonstrated
     *
     * @type      {number}
     * @default   5
     * @since     2.3.0
     * @product   highcharts
     * @apioption plotOptions.gauge.pivot.radius
     */
    radius: 5,
    /**
     * The border or stroke width of the pivot.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
     *         Pivot options demonstrated
     *
     * @type      {number}
     * @default   0
     * @since     2.3.0
     * @product   highcharts
     * @apioption plotOptions.gauge.pivot.borderWidth
     */
    borderWidth: 0,
    /**
     * The border or stroke color of the pivot. In able to change
     * this, the borderWidth must also be set to something other
     * than the default 0.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
     *         Pivot options demonstrated
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @default   #cccccc
     * @since     2.3.0
     * @product   highcharts
     * @apioption plotOptions.gauge.pivot.borderColor
     */
    borderColor: "#cccccc",
    /**
     * The background color or fill of the pivot.
     *
     * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
     *         Pivot options demonstrated
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @default   #000000
     * @since     2.3.0
     * @product   highcharts
     * @apioption plotOptions.gauge.pivot.backgroundColor
     */
    backgroundColor: "#000000"
    /* Palette.neutralColor100 */
  },
  tooltip: {
    headerFormat: ""
  },
  /**
   * Whether to display this particular series or series type in the
   * legend. Defaults to false for gauge series.
   *
   * @since   2.3.0
   * @product highcharts
   */
  showInLegend: false
  // Prototype members
});
extend55(GaugeSeries.prototype, {
  // `chart.angular` will be set to true when a gauge series is present, and
  // this will be used on the axes
  angular: true,
  directTouch: true,
  // #5063
  drawGraph: noop12,
  drawTracker: ColumnSeries8.prototype.drawTracker,
  fixedBox: true,
  forceDL: true,
  noSharedTooltip: true,
  pointClass: GaugePoint_default,
  trackerGroups: ["group", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("gauge", GaugeSeries);

// node_modules/highcharts/es-modules/Series/DragNodesComposition.js
var { composed: composed20 } = Globals_default;
var { addEvent: addEvent60, pushUnique: pushUnique23 } = Utilities_default;
function compose13(ChartClass) {
  if (pushUnique23(composed20, "DragNodes")) {
    addEvent60(ChartClass, "load", onChartLoad2);
  }
}
function onChartLoad2() {
  const chart = this;
  let mousedownUnbinder, mousemoveUnbinder, mouseupUnbinder, point;
  if (chart.container) {
    mousedownUnbinder = addEvent60(chart.container, "mousedown", (event) => {
      if (mousemoveUnbinder) {
        mousemoveUnbinder();
      }
      if (mouseupUnbinder) {
        mouseupUnbinder();
      }
      point = chart.hoverPoint;
      if (point && point.series && point.series.hasDraggableNodes && point.series.options.draggable) {
        point.series.onMouseDown(point, event);
        mousemoveUnbinder = addEvent60(chart.container, "mousemove", (e) => point && point.series && point.series.onMouseMove(point, e));
        mouseupUnbinder = addEvent60(chart.container.ownerDocument, "mouseup", (e) => {
          mousemoveUnbinder();
          mouseupUnbinder();
          return point && point.series && point.series.onMouseUp(point, e);
        });
      }
    });
  }
  addEvent60(chart, "destroy", function() {
    mousedownUnbinder();
  });
}
function onMouseDown(point, event) {
  const normalizedEvent = this.chart.pointer?.normalize(event) || event;
  point.fixedPosition = {
    chartX: normalizedEvent.chartX,
    chartY: normalizedEvent.chartY,
    plotX: point.plotX,
    plotY: point.plotY
  };
  point.inDragMode = true;
}
function onMouseMove(point, event) {
  if (point.fixedPosition && point.inDragMode) {
    const series = this, chart = series.chart, normalizedEvent = chart.pointer?.normalize(event) || event, diffX = point.fixedPosition.chartX - normalizedEvent.chartX, diffY = point.fixedPosition.chartY - normalizedEvent.chartY, graphLayoutsLookup = chart.graphLayoutsLookup;
    let newPlotX, newPlotY;
    if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {
      newPlotX = point.fixedPosition.plotX - diffX;
      newPlotY = point.fixedPosition.plotY - diffY;
      if (chart.isInsidePlot(newPlotX, newPlotY)) {
        point.plotX = newPlotX;
        point.plotY = newPlotY;
        point.hasDragged = true;
        this.redrawHalo(point);
        graphLayoutsLookup.forEach((layout) => {
          layout.restartSimulation();
        });
      }
    }
  }
}
function onMouseUp(point) {
  if (point.fixedPosition) {
    if (point.hasDragged) {
      if (this.layout.enableSimulation) {
        this.layout.start();
      } else {
        this.chart.redraw();
      }
    }
    point.inDragMode = point.hasDragged = false;
    if (!this.options.fixedDraggable) {
      delete point.fixedPosition;
    }
  }
}
function redrawHalo(point) {
  if (point && this.halo) {
    this.halo.attr({
      d: point.haloPath(this.options.states.hover.halo.size)
    });
  }
}
var DragNodesComposition = {
  compose: compose13,
  onMouseDown,
  onMouseMove,
  onMouseUp,
  redrawHalo
};
var DragNodesComposition_default = DragNodesComposition;

// node_modules/highcharts/es-modules/Series/GraphLayoutComposition.js
var { setAnimation: setAnimation6 } = AnimationUtilities_default;
var { composed: composed21 } = Globals_default;
var { addEvent: addEvent61, pushUnique: pushUnique24 } = Utilities_default;
var integrations = {};
var layouts = {};
function compose14(ChartClass) {
  if (pushUnique24(composed21, "GraphLayout")) {
    addEvent61(ChartClass, "afterPrint", onChartAfterPrint);
    addEvent61(ChartClass, "beforePrint", onChartBeforePrint);
    addEvent61(ChartClass, "predraw", onChartPredraw);
    addEvent61(ChartClass, "render", onChartRender4);
  }
}
function onChartAfterPrint() {
  if (this.graphLayoutsLookup) {
    this.graphLayoutsLookup.forEach((layout) => {
      layout.updateSimulation();
    });
    this.redraw();
  }
}
function onChartBeforePrint() {
  if (this.graphLayoutsLookup) {
    this.graphLayoutsLookup.forEach((layout) => {
      layout.updateSimulation(false);
    });
    this.redraw();
  }
}
function onChartPredraw() {
  if (this.graphLayoutsLookup) {
    this.graphLayoutsLookup.forEach((layout) => {
      layout.stop();
    });
  }
}
function onChartRender4() {
  let systemsStable, afterRender = false;
  const layoutStep = (layout) => {
    if (layout.maxIterations-- && isFinite(layout.temperature) && !layout.isStable() && !layout.enableSimulation) {
      if (layout.beforeStep) {
        layout.beforeStep();
      }
      layout.step();
      systemsStable = false;
      afterRender = true;
    }
  };
  if (this.graphLayoutsLookup) {
    setAnimation6(false, this);
    this.graphLayoutsLookup.forEach((layout) => layout.start());
    while (!systemsStable) {
      systemsStable = true;
      this.graphLayoutsLookup.forEach(layoutStep);
    }
    if (afterRender) {
      this.series.forEach((series) => {
        if (series && series.layout) {
          series.render();
        }
      });
    }
  }
}
var GraphLayoutComposition = {
  compose: compose14,
  integrations,
  layouts
};
var GraphLayoutComposition_default = GraphLayoutComposition;

// node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubblePoint.js
var { seriesTypes: { bubble: { prototype: { pointClass: BubblePoint2 } } } } = SeriesRegistry_default;
var PackedBubblePoint = class extends BubblePoint2 {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Destroy point.
   * Then remove point from the layout.
   * @private
   */
  destroy() {
    if (this.series?.layout) {
      this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);
    }
    return Point_default.prototype.destroy.apply(this, arguments);
  }
  firePointEvent() {
    const series = this.series, seriesOptions = series.options;
    if (this.isParentNode && seriesOptions.parentNode) {
      const temp = seriesOptions.allowPointSelect;
      seriesOptions.allowPointSelect = seriesOptions.parentNode.allowPointSelect;
      Point_default.prototype.firePointEvent.apply(this, arguments);
      seriesOptions.allowPointSelect = temp;
    } else {
      Point_default.prototype.firePointEvent.apply(this, arguments);
    }
  }
  select() {
    const point = this, series = this.series, chart = series.chart;
    if (point.isParentNode) {
      chart.getSelectedPoints = chart.getSelectedParentNodes;
      Point_default.prototype.select.apply(this, arguments);
      chart.getSelectedPoints = Chart_default.prototype.getSelectedPoints;
    } else {
      Point_default.prototype.select.apply(this, arguments);
    }
  }
};
var PackedBubblePoint_default = PackedBubblePoint;

// node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubbleSeriesDefaults.js
var { isNumber: isNumber52 } = Utilities_default;
var PackedBubbleSeriesDefaults = {
  /**
   * Minimum bubble size. Bubbles will automatically size between the
   * `minSize` and `maxSize` to reflect the value of each bubble.
   * Can be either pixels (when no unit is given), or a percentage of
   * the smallest one of the plot width and height, divided by the square
   * root of total number of points.
   *
   * @sample highcharts/plotoptions/bubble-size/
   *         Bubble size
   *
   * @type {number|string}
   *
   * @private
   */
  minSize: "10%",
  /**
   * Maximum bubble size. Bubbles will automatically size between the
   * `minSize` and `maxSize` to reflect the value of each bubble.
   * Can be either pixels (when no unit is given), or a percentage of
   * the smallest one of the plot width and height, divided by the square
   * root of total number of points.
   *
   * @sample highcharts/plotoptions/bubble-size/
   *         Bubble size
   *
   * @type {number|string}
   *
   * @private
   */
  maxSize: "50%",
  sizeBy: "area",
  zoneAxis: "y",
  crisp: false,
  tooltip: {
    pointFormat: "Value: {point.value}"
  },
  /**
   * Flag to determine if nodes are draggable or not. Available for
   * graph with useSimulation set to true only.
   *
   * @since 7.1.0
   *
   * @private
   */
  draggable: true,
  /**
   * An option is giving a possibility to choose between using simulation
   * for calculating bubble positions. These reflects in both animation
   * and final position of bubbles. Simulation is also adding options to
   * the series graph based on used layout. In case of big data sets, with
   * any performance issues, it is possible to disable animation and pack
   * bubble in a simple circular way.
   *
   * @sample highcharts/series-packedbubble/spiral/
   *         useSimulation set to false
   *
   * @since 7.1.0
   *
   * @private
   */
  useSimulation: true,
  /**
   * Series options for parent nodes.
   *
   * @since 8.1.1
   *
   * @private
   */
  parentNode: {
    /**
     * Allow this series' parent nodes to be selected
     * by clicking on the graph.
     *
     * @since 8.1.1
     */
    allowPointSelect: false
  },
  /**
   *
   * @declare Highcharts.SeriesPackedBubbleDataLabelsOptionsObject
   *
   * @private
   */
  dataLabels: {
    /**
     * The
     * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
     * specifying what to show for _node_ in the networkgraph. In v7.0
     * defaults to `{key}`, since v7.1 defaults to `undefined` and
     * `formatter` is used instead.
     *
     * @type      {string}
     * @since     7.0.0
     * @apioption plotOptions.packedbubble.dataLabels.format
     */
    // eslint-disable-next-line valid-jsdoc
    /**
     * Callback JavaScript function to format the data label for a node.
     * Note that if a `format` is defined, the format takes precedence
     * and the formatter is ignored.
     *
     * @since 7.0.0
     */
    formatter: function() {
      const { numberFormatter } = this.series.chart;
      const { value } = this.point;
      return isNumber52(value) ? numberFormatter(value, -1) : "";
    },
    /**
     * @type      {string}
     * @since     7.1.0
     * @apioption plotOptions.packedbubble.dataLabels.parentNodeFormat
     */
    // eslint-disable-next-line valid-jsdoc
    /**
     * @since 7.1.0
     */
    parentNodeFormatter: function() {
      return this.name || "";
    },
    /**
     * @sample {highcharts} highcharts/demo/packed-bubble-project-status/
     *         Dashboard with dataLabels on parentNodes
     *
     * @declare Highcharts.SeriesPackedBubbleDataLabelsTextPathOptionsObject
     * @since   7.1.0
     */
    parentNodeTextPath: {
      /**
       * Presentation attributes for the text path.
       *
       * @type      {Highcharts.SVGAttributes}
       * @since     7.1.0
       * @apioption plotOptions.packedbubble.dataLabels.attributes
       */
      /**
       * Enable or disable `textPath` option for link's or marker's
       * data labels.
       *
       * @since 7.1.0
       */
      enabled: true
    },
    /**
     * Options for a _node_ label text which should follow marker's
     * shape.
     *
     * **Note:** Only SVG-based renderer supports this option.
     *
     * @extends   plotOptions.series.dataLabels.textPath
     * @apioption plotOptions.packedbubble.dataLabels.textPath
     */
    padding: 0,
    style: {
      transition: "opacity 2000ms"
    }
  },
  /**
   * Options for layout algorithm when simulation is enabled. Inside there
   * are options to change the speed, padding, initial bubbles positions
   * and more.
   *
   * @extends   plotOptions.networkgraph.layoutAlgorithm
   * @excluding approximation, attractiveForce, repulsiveForce, theta
   * @since     7.1.0
   *
   * @private
   */
  layoutAlgorithm: {
    /**
     * Initial layout algorithm for positioning nodes. Can be one of
     * the built-in options ("circle", "random") or a function where
     * positions should be set on each node (`this.nodes`) as
     * `node.plotX` and `node.plotY`.
     *
     * @sample highcharts/series-networkgraph/initial-positions/
     *         Initial positions with callback
     *
     * @type {"circle"|"random"|Function}
     */
    initialPositions: "circle",
    /**
     * @sample highcharts/series-packedbubble/initial-radius/
     *         Initial radius set to 200
     *
     * @extends   plotOptions.networkgraph.layoutAlgorithm.initialPositionRadius
     * @excluding states
     */
    initialPositionRadius: 20,
    /**
     * The distance between two bubbles, when the algorithm starts to
     * treat two bubbles as overlapping. The `bubblePadding` is also the
     * expected distance between all the bubbles on simulation end.
     */
    bubblePadding: 5,
    /**
     * Whether bubbles should interact with their parentNode to keep
     * them inside.
     */
    parentNodeLimit: false,
    /**
     * Whether series should interact with each other or not. When
     * `parentNodeLimit` is set to true, thi option should be set to
     * false to avoid sticking points in wrong series parentNode.
     */
    seriesInteraction: true,
    /**
     * In case of split series, this option allows user to drag and
     * drop points between series, for changing point related series.
     *
     * @sample highcharts/demo/packed-bubble-project-status/
     *         Example of drag'n drop bubbles for bubble kanban
     */
    dragBetweenSeries: false,
    /**
     * Layout algorithm options for parent nodes.
     *
     * @extends   plotOptions.networkgraph.layoutAlgorithm
     * @excluding approximation, attractiveForce, enableSimulation,
     *            repulsiveForce, theta
     */
    parentNodeOptions: {
      maxIterations: 400,
      gravitationalConstant: 0.03,
      maxSpeed: 50,
      initialPositionRadius: 100,
      seriesInteraction: true,
      /**
       * Styling options for parentNodes markers. Similar to
       * line.marker options.
       *
       * @sample highcharts/series-packedbubble/parentnode-style/
       *         Bubble size
       *
       * @extends   plotOptions.series.marker
       * @excluding states
       */
      marker: {
        fillColor: null,
        fillOpacity: 1,
        lineWidth: null,
        lineColor: null,
        symbol: "circle"
      }
    },
    enableSimulation: true,
    /**
     * Type of the algorithm used when positioning bubbles.
     * @ignore-option
     */
    type: "packedbubble",
    /**
     * Integration type. Integration determines how forces are applied
     * on particles. The `packedbubble` integration is based on
     * the networkgraph `verlet` integration, where the new position
     * is based on a previous position without velocity:
     * `newPosition += previousPosition - newPosition`.
     *
     * @sample highcharts/series-networkgraph/forces/
     *
     * @ignore-option
     */
    integration: "packedbubble",
    maxIterations: 1e3,
    /**
     * Whether to split series into individual groups or to mix all
     * series together.
     *
     * @since   7.1.0
     * @default false
     */
    splitSeries: false,
    /**
     * Max speed that node can get in one iteration. In terms of
     * simulation, it's a maximum translation (in pixels) that a node
     * can move (in both, x and y, dimensions). While `friction` is
     * applied on all nodes, max speed is applied only for nodes that
     * move very fast, for example small or disconnected ones.
     *
     * @see [layoutAlgorithm.integration](#series.networkgraph.layoutAlgorithm.integration)
     *
     * @see [layoutAlgorithm.friction](#series.networkgraph.layoutAlgorithm.friction)
     */
    maxSpeed: 5,
    gravitationalConstant: 0.01,
    friction: -0.981
  },
  stickyTracking: false
};
var PackedBubbleSeriesDefaults_default = PackedBubbleSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Networkgraph/VerletIntegration.js
function attractive(link, force, distanceXY) {
  const massFactor = link.getMass(), translatedX = -distanceXY.x * force * this.diffTemperature, translatedY = -distanceXY.y * force * this.diffTemperature;
  if (!link.fromNode.fixedPosition) {
    link.fromNode.plotX -= translatedX * massFactor.fromNode / link.fromNode.degree;
    link.fromNode.plotY -= translatedY * massFactor.fromNode / link.fromNode.degree;
  }
  if (!link.toNode.fixedPosition) {
    link.toNode.plotX += translatedX * massFactor.toNode / link.toNode.degree;
    link.toNode.plotY += translatedY * massFactor.toNode / link.toNode.degree;
  }
}
function attractiveForceFunction(d, k) {
  return (k - d) / d;
}
function barycenter() {
  const gravitationalConstant = this.options.gravitationalConstant || 0, xFactor = (this.barycenter.xFactor - (this.box.left + this.box.width) / 2) * gravitationalConstant, yFactor = (this.barycenter.yFactor - (this.box.top + this.box.height) / 2) * gravitationalConstant;
  this.nodes.forEach(function(node) {
    if (!node.fixedPosition) {
      node.plotX -= xFactor / node.mass / node.degree;
      node.plotY -= yFactor / node.mass / node.degree;
    }
  });
}
function getK(layout) {
  return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.5);
}
function integrate(layout, node) {
  const friction = -layout.options.friction, maxSpeed = layout.options.maxSpeed, prevX = node.prevX, prevY = node.prevY, frictionX = (node.plotX + node.dispX - prevX) * friction, frictionY = (node.plotY + node.dispY - prevY) * friction, abs2 = Math.abs, signX = abs2(frictionX) / (frictionX || 1), signY = abs2(frictionY) / (frictionY || 1), diffX = signX * Math.min(maxSpeed, Math.abs(frictionX)), diffY = signY * Math.min(maxSpeed, Math.abs(frictionY));
  node.prevX = node.plotX + node.dispX;
  node.prevY = node.plotY + node.dispY;
  node.plotX += diffX;
  node.plotY += diffY;
  node.temperature = layout.vectorLength({
    x: diffX,
    y: diffY
  });
}
function repulsive(node, force, distanceXY) {
  const factor = force * this.diffTemperature / node.mass / node.degree;
  if (!node.fixedPosition) {
    node.plotX += distanceXY.x * factor;
    node.plotY += distanceXY.y * factor;
  }
}
function repulsiveForceFunction(d, k) {
  return (k - d) / d * (k > d ? 1 : 0);
}
var VerletIntegration = {
  attractive,
  attractiveForceFunction,
  barycenter,
  getK,
  integrate,
  repulsive,
  repulsiveForceFunction
};
var VerletIntegration_default = VerletIntegration;

// node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubbleIntegration.js
var { noop: noop13 } = Globals_default;
function barycenter2() {
  const layout = this, gravitationalConstant = layout.options.gravitationalConstant || 0, box = layout.box, nodes = layout.nodes, nodeCountSqrt = Math.sqrt(nodes.length);
  let centerX, centerY;
  for (const node of nodes) {
    if (!node.fixedPosition) {
      const massTimesNodeCountSqrt = node.mass * nodeCountSqrt, plotX = node.plotX || 0, plotY = node.plotY || 0, series = node.series, parentNode = series.parentNode;
      if (this.resolveSplitSeries(node) && parentNode && !node.isParentNode) {
        centerX = parentNode.plotX || 0;
        centerY = parentNode.plotY || 0;
      } else {
        centerX = box.width / 2;
        centerY = box.height / 2;
      }
      node.plotX = plotX - (plotX - centerX) * gravitationalConstant / massTimesNodeCountSqrt;
      node.plotY = plotY - (plotY - centerY) * gravitationalConstant / massTimesNodeCountSqrt;
      if (series.chart.hoverPoint === node && // If redrawHalo exists we know its a draggable series and any
      // halo present should be redrawn to update its visual position
      series.redrawHalo && series.halo) {
        series.redrawHalo(node);
      }
    }
  }
}
function repulsive2(node, force, distanceXY, repNode) {
  const factor = force * this.diffTemperature / node.mass / node.degree, x = distanceXY.x * factor, y = distanceXY.y * factor;
  if (!node.fixedPosition) {
    node.plotX += x;
    node.plotY += y;
  }
  if (!repNode.fixedPosition) {
    repNode.plotX -= x;
    repNode.plotY -= y;
  }
}
function repulsiveForceFunction2(d, k, node, repNode) {
  return Math.min(d, (node.marker.radius + repNode.marker.radius) / 2);
}
var PackedBubbleIntegration = {
  barycenter: barycenter2,
  getK: noop13,
  integrate: VerletIntegration_default.integrate,
  repulsive: repulsive2,
  repulsiveForceFunction: repulsiveForceFunction2
};
var PackedBubbleIntegration_default = PackedBubbleIntegration;

// node_modules/highcharts/es-modules/Series/Networkgraph/EulerIntegration.js
function attractive2(link, force, distanceXY, distanceR) {
  const massFactor = link.getMass(), translatedX = distanceXY.x / distanceR * force, translatedY = distanceXY.y / distanceR * force;
  if (!link.fromNode.fixedPosition) {
    link.fromNode.dispX -= translatedX * massFactor.fromNode / link.fromNode.degree;
    link.fromNode.dispY -= translatedY * massFactor.fromNode / link.fromNode.degree;
  }
  if (!link.toNode.fixedPosition) {
    link.toNode.dispX += translatedX * massFactor.toNode / link.toNode.degree;
    link.toNode.dispY += translatedY * massFactor.toNode / link.toNode.degree;
  }
}
function attractiveForceFunction2(d, k) {
  return d * d / k;
}
function barycenter3() {
  const gravitationalConstant = this.options.gravitationalConstant, xFactor = this.barycenter.xFactor, yFactor = this.barycenter.yFactor;
  this.nodes.forEach(function(node) {
    if (!node.fixedPosition) {
      const degree = node.getDegree(), phi = degree * (1 + degree / 2);
      node.dispX += (xFactor - node.plotX) * gravitationalConstant * phi / node.degree;
      node.dispY += (yFactor - node.plotY) * gravitationalConstant * phi / node.degree;
    }
  });
}
function getK2(layout) {
  return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.3);
}
function integrate2(layout, node) {
  node.dispX += node.dispX * layout.options.friction;
  node.dispY += node.dispY * layout.options.friction;
  const distanceR = node.temperature = layout.vectorLength({
    x: node.dispX,
    y: node.dispY
  });
  if (distanceR !== 0) {
    node.plotX += node.dispX / distanceR * Math.min(Math.abs(node.dispX), layout.temperature);
    node.plotY += node.dispY / distanceR * Math.min(Math.abs(node.dispY), layout.temperature);
  }
}
function repulsive3(node, force, distanceXY, distanceR) {
  node.dispX += distanceXY.x / distanceR * force / node.degree;
  node.dispY += distanceXY.y / distanceR * force / node.degree;
}
function repulsiveForceFunction3(d, k) {
  return k * k / d;
}
var EulerIntegration = {
  attractive: attractive2,
  attractiveForceFunction: attractiveForceFunction2,
  barycenter: barycenter3,
  getK: getK2,
  integrate: integrate2,
  repulsive: repulsive3,
  repulsiveForceFunction: repulsiveForceFunction3
};
var EulerIntegration_default = EulerIntegration;

// node_modules/highcharts/es-modules/Series/Networkgraph/QuadTreeNode.js
var QuadTreeNode = class _QuadTreeNode {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(box) {
    this.body = false;
    this.isEmpty = false;
    this.isInternal = false;
    this.nodes = [];
    this.box = box;
    this.boxSize = Math.min(box.width, box.height);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * When inserting another node into the box, that already hove one node,
   * divide the available space into another four quadrants.
   *
   * Indexes of quadrants are:
   * ```
   * -------------               -------------
   * |           |               |     |     |
   * |           |               |  0  |  1  |
   * |           |   divide()    |     |     |
   * |     1     | ----------->  -------------
   * |           |               |     |     |
   * |           |               |  3  |  2  |
   * |           |               |     |     |
   * -------------               -------------
   * ```
   */
  divideBox() {
    const halfWidth = this.box.width / 2, halfHeight = this.box.height / 2;
    this.nodes[0] = new _QuadTreeNode({
      left: this.box.left,
      top: this.box.top,
      width: halfWidth,
      height: halfHeight
    });
    this.nodes[1] = new _QuadTreeNode({
      left: this.box.left + halfWidth,
      top: this.box.top,
      width: halfWidth,
      height: halfHeight
    });
    this.nodes[2] = new _QuadTreeNode({
      left: this.box.left + halfWidth,
      top: this.box.top + halfHeight,
      width: halfWidth,
      height: halfHeight
    });
    this.nodes[3] = new _QuadTreeNode({
      left: this.box.left,
      top: this.box.top + halfHeight,
      width: halfWidth,
      height: halfHeight
    });
  }
  /**
   * Determine which of the quadrants should be used when placing node in
   * the QuadTree. Returned index is always in range `< 0 , 3 >`.
   * @private
   */
  getBoxPosition(point) {
    const left = point.plotX < this.box.left + this.box.width / 2, top = point.plotY < this.box.top + this.box.height / 2;
    let index;
    if (left) {
      if (top) {
        index = 0;
      } else {
        index = 3;
      }
    } else {
      if (top) {
        index = 1;
      } else {
        index = 2;
      }
    }
    return index;
  }
  /**
   * Insert recursively point(node) into the QuadTree. If the given
   * quadrant is already occupied, divide it into smaller quadrants.
   *
   * @param {Highcharts.Point} point
   *        Point/node to be inserted
   * @param {number} depth
   *        Max depth of the QuadTree
   */
  insert(point, depth) {
    let newQuadTreeNode;
    if (this.isInternal) {
      this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);
    } else {
      this.isEmpty = false;
      if (!this.body) {
        this.isInternal = false;
        this.body = point;
      } else {
        if (depth) {
          this.isInternal = true;
          this.divideBox();
          if (this.body !== true) {
            this.nodes[this.getBoxPosition(this.body)].insert(this.body, depth - 1);
            this.body = true;
          }
          this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);
        } else {
          newQuadTreeNode = new _QuadTreeNode({
            top: point.plotX || NaN,
            left: point.plotY || NaN,
            // Width/height below 1px
            width: 0.1,
            height: 0.1
          });
          newQuadTreeNode.body = point;
          newQuadTreeNode.isInternal = false;
          this.nodes.push(newQuadTreeNode);
        }
      }
    }
  }
  /**
   * Each quad node requires it's mass and center position. That mass and
   * position is used to imitate real node in the layout by approximation.
   */
  updateMassAndCenter() {
    let mass = 0, plotX = 0, plotY = 0;
    if (this.isInternal) {
      for (const pointMass of this.nodes) {
        if (!pointMass.isEmpty) {
          mass += pointMass.mass;
          plotX += pointMass.plotX * pointMass.mass;
          plotY += pointMass.plotY * pointMass.mass;
        }
      }
      plotX /= mass;
      plotY /= mass;
    } else if (this.body) {
      mass = this.body.mass;
      plotX = this.body.plotX;
      plotY = this.body.plotY;
    }
    this.mass = mass;
    this.plotX = plotX;
    this.plotY = plotY;
  }
};
var QuadTreeNode_default = QuadTreeNode;

// node_modules/highcharts/es-modules/Series/Networkgraph/QuadTree.js
var QuadTree = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(x, y, width, height) {
    this.box = {
      left: x,
      top: y,
      width,
      height
    };
    this.maxDepth = 25;
    this.root = new QuadTreeNode_default(this.box);
    this.root.isInternal = true;
    this.root.isRoot = true;
    this.root.divideBox();
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Calculate mass of the each QuadNode in the tree.
   */
  calculateMassAndCenter() {
    this.visitNodeRecursive(null, null, function(node) {
      node.updateMassAndCenter();
    });
  }
  /**
   * Insert nodes into the QuadTree
   *
   * @param {Array<Highcharts.Point>} points
   *        Points as nodes
   */
  insertNodes(points) {
    for (const point of points) {
      this.root.insert(point, this.maxDepth);
    }
  }
  /**
   * Depth first treversal (DFS). Using `before` and `after` callbacks,
   * we can get two results: preorder and postorder traversals, reminder:
   *
   * ```
   *     (a)
   *     / \
   *   (b) (c)
   *   / \
   * (d) (e)
   * ```
   *
   * DFS (preorder): `a -> b -> d -> e -> c`
   *
   * DFS (postorder): `d -> e -> b -> c -> a`
   *
   * @param {Highcharts.QuadTreeNode|null} node
   *        QuadTree node
   * @param {Function} [beforeCallback]
   *        Function to be called before visiting children nodes.
   * @param {Function} [afterCallback]
   *        Function to be called after visiting children nodes.
   */
  visitNodeRecursive(node, beforeCallback, afterCallback) {
    let goFurther;
    if (!node) {
      node = this.root;
    }
    if (node === this.root && beforeCallback) {
      goFurther = beforeCallback(node);
    }
    if (goFurther === false) {
      return;
    }
    for (const qtNode of node.nodes) {
      if (qtNode.isInternal) {
        if (beforeCallback) {
          goFurther = beforeCallback(qtNode);
        }
        if (goFurther === false) {
          continue;
        }
        this.visitNodeRecursive(qtNode, beforeCallback, afterCallback);
      } else if (qtNode.body) {
        if (beforeCallback) {
          beforeCallback(qtNode.body);
        }
      }
      if (afterCallback) {
        afterCallback(qtNode);
      }
    }
    if (node === this.root && afterCallback) {
      afterCallback(node);
    }
  }
};
var QuadTree_default = QuadTree;

// node_modules/highcharts/es-modules/Series/Networkgraph/ReingoldFruchtermanLayout.js
var { win: win16 } = Globals_default;
var { clamp: clamp17, defined: defined54, isFunction: isFunction7, fireEvent: fireEvent37, pick: pick73 } = Utilities_default;
var ReingoldFruchtermanLayout = class _ReingoldFruchtermanLayout {
  constructor() {
    this.box = {};
    this.currentStep = 0;
    this.initialRendering = true;
    this.links = [];
    this.nodes = [];
    this.series = [];
    this.simulation = false;
  }
  static compose(ChartClass) {
    GraphLayoutComposition_default.compose(ChartClass);
    GraphLayoutComposition_default.integrations.euler = EulerIntegration_default;
    GraphLayoutComposition_default.integrations.verlet = VerletIntegration_default;
    GraphLayoutComposition_default.layouts["reingold-fruchterman"] = _ReingoldFruchtermanLayout;
  }
  init(options2) {
    this.options = options2;
    this.nodes = [];
    this.links = [];
    this.series = [];
    this.box = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    this.setInitialRendering(true);
    this.integration = GraphLayoutComposition_default.integrations[options2.integration];
    this.enableSimulation = options2.enableSimulation;
    this.attractiveForce = pick73(options2.attractiveForce, this.integration.attractiveForceFunction);
    this.repulsiveForce = pick73(options2.repulsiveForce, this.integration.repulsiveForceFunction);
    this.approximation = options2.approximation;
  }
  updateSimulation(enable) {
    this.enableSimulation = pick73(enable, this.options.enableSimulation);
  }
  start() {
    const layout = this, series = this.series, options2 = this.options;
    layout.currentStep = 0;
    layout.forces = series[0] && series[0].forces || [];
    layout.chart = series[0] && series[0].chart;
    if (layout.initialRendering) {
      layout.initPositions();
      series.forEach(function(s) {
        s.finishedAnimating = true;
        s.render();
      });
    }
    layout.setK();
    layout.resetSimulation(options2);
    if (layout.enableSimulation) {
      layout.step();
    }
  }
  step() {
    const anyLayout = this, allSeries = this.series;
    this.currentStep++;
    if (this.approximation === "barnes-hut") {
      this.createQuadTree();
      this.quadTree.calculateMassAndCenter();
    }
    for (const forceName of this.forces || []) {
      anyLayout[forceName + "Forces"](this.temperature);
    }
    this.applyLimits();
    this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep);
    this.prevSystemTemperature = this.systemTemperature;
    this.systemTemperature = this.getSystemTemperature();
    if (this.enableSimulation) {
      for (const series of allSeries) {
        if (series.chart) {
          series.render();
        }
      }
      if (this.maxIterations-- && isFinite(this.temperature) && !this.isStable()) {
        if (this.simulation) {
          win16.cancelAnimationFrame(this.simulation);
        }
        this.simulation = win16.requestAnimationFrame(() => this.step());
      } else {
        this.simulation = false;
        this.series.forEach((s) => {
          fireEvent37(s, "afterSimulation");
        });
      }
    }
  }
  stop() {
    if (this.simulation) {
      win16.cancelAnimationFrame(this.simulation);
    }
  }
  setArea(x, y, w, h) {
    this.box = {
      left: x,
      top: y,
      width: w,
      height: h
    };
  }
  setK() {
    this.k = this.options.linkLength || this.integration.getK(this);
  }
  addElementsToCollection(elements, collection) {
    for (const element of elements) {
      if (collection.indexOf(element) === -1) {
        collection.push(element);
      }
    }
  }
  removeElementFromCollection(element, collection) {
    const index = collection.indexOf(element);
    if (index !== -1) {
      collection.splice(index, 1);
    }
  }
  clear() {
    this.nodes.length = 0;
    this.links.length = 0;
    this.series.length = 0;
    this.resetSimulation();
  }
  resetSimulation() {
    this.forcedStop = false;
    this.systemTemperature = 0;
    this.setMaxIterations();
    this.setTemperature();
    this.setDiffTemperature();
  }
  restartSimulation() {
    if (!this.simulation) {
      this.setInitialRendering(false);
      if (!this.enableSimulation) {
        this.setMaxIterations(1);
      } else {
        this.start();
      }
      if (this.chart) {
        this.chart.redraw();
      }
      this.setInitialRendering(true);
    } else {
      this.resetSimulation();
    }
  }
  setMaxIterations(maxIterations) {
    this.maxIterations = pick73(maxIterations, this.options.maxIterations);
  }
  setTemperature() {
    this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);
  }
  setDiffTemperature() {
    this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);
  }
  setInitialRendering(enable) {
    this.initialRendering = enable;
  }
  createQuadTree() {
    this.quadTree = new QuadTree_default(this.box.left, this.box.top, this.box.width, this.box.height);
    this.quadTree.insertNodes(this.nodes);
  }
  initPositions() {
    const initialPositions = this.options.initialPositions;
    if (isFunction7(initialPositions)) {
      initialPositions.call(this);
      for (const node of this.nodes) {
        if (!defined54(node.prevX)) {
          node.prevX = node.plotX;
        }
        if (!defined54(node.prevY)) {
          node.prevY = node.plotY;
        }
        node.dispX = 0;
        node.dispY = 0;
      }
    } else if (initialPositions === "circle") {
      this.setCircularPositions();
    } else {
      this.setRandomPositions();
    }
  }
  setCircularPositions() {
    const box = this.box, nodes = this.nodes, nodesLength = nodes.length + 1, angle = 2 * Math.PI / nodesLength, rootNodes = nodes.filter(function(node2) {
      return node2.linksTo.length === 0;
    }), visitedNodes = {}, radius = this.options.initialPositionRadius, addToNodes = (node2) => {
      for (const link of node2.linksFrom || []) {
        if (!visitedNodes[link.toNode.id]) {
          visitedNodes[link.toNode.id] = true;
          sortedNodes.push(link.toNode);
          addToNodes(link.toNode);
        }
      }
    };
    let sortedNodes = [];
    for (const rootNode of rootNodes) {
      sortedNodes.push(rootNode);
      addToNodes(rootNode);
    }
    if (!sortedNodes.length) {
      sortedNodes = nodes;
    } else {
      for (const node2 of nodes) {
        if (sortedNodes.indexOf(node2) === -1) {
          sortedNodes.push(node2);
        }
      }
    }
    let node;
    for (let i = 0, iEnd = sortedNodes.length; i < iEnd; ++i) {
      node = sortedNodes[i];
      node.plotX = node.prevX = pick73(node.plotX, box.width / 2 + radius * Math.cos(i * angle));
      node.plotY = node.prevY = pick73(node.plotY, box.height / 2 + radius * Math.sin(i * angle));
      node.dispX = 0;
      node.dispY = 0;
    }
  }
  setRandomPositions() {
    const box = this.box, nodes = this.nodes, nodesLength = nodes.length + 1, unrandom = (n) => {
      let rand = n * n / Math.PI;
      rand = rand - Math.floor(rand);
      return rand;
    };
    let node;
    for (let i = 0, iEnd = nodes.length; i < iEnd; ++i) {
      node = nodes[i];
      node.plotX = node.prevX = pick73(node.plotX, box.width * unrandom(i));
      node.plotY = node.prevY = pick73(node.plotY, box.height * unrandom(nodesLength + i));
      node.dispX = 0;
      node.dispY = 0;
    }
  }
  force(name, ...args) {
    this.integration[name].apply(this, args);
  }
  barycenterForces() {
    this.getBarycenter();
    this.force("barycenter");
  }
  getBarycenter() {
    let systemMass = 0, cx = 0, cy = 0;
    for (const node of this.nodes) {
      cx += node.plotX * node.mass;
      cy += node.plotY * node.mass;
      systemMass += node.mass;
    }
    this.barycenter = {
      x: cx,
      y: cy,
      xFactor: cx / systemMass,
      yFactor: cy / systemMass
    };
    return this.barycenter;
  }
  barnesHutApproximation(node, quadNode) {
    const distanceXY = this.getDistXY(node, quadNode), distanceR = this.vectorLength(distanceXY);
    let goDeeper, force;
    if (node !== quadNode && distanceR !== 0) {
      if (quadNode.isInternal) {
        if (quadNode.boxSize / distanceR < this.options.theta && distanceR !== 0) {
          force = this.repulsiveForce(distanceR, this.k);
          this.force("repulsive", node, force * quadNode.mass, distanceXY, distanceR);
          goDeeper = false;
        } else {
          goDeeper = true;
        }
      } else {
        force = this.repulsiveForce(distanceR, this.k);
        this.force("repulsive", node, force * quadNode.mass, distanceXY, distanceR);
      }
    }
    return goDeeper;
  }
  repulsiveForces() {
    if (this.approximation === "barnes-hut") {
      for (const node of this.nodes) {
        this.quadTree.visitNodeRecursive(null, (quadNode) => this.barnesHutApproximation(node, quadNode));
      }
    } else {
      let force, distanceR, distanceXY;
      for (const node of this.nodes) {
        for (const repNode of this.nodes) {
          if (
            // Node cannot repulse itself:
            node !== repNode && // Only close nodes affect each other:
            // layout.getDistR(node, repNode) < 2 * k &&
            // Not dragged:
            !node.fixedPosition
          ) {
            distanceXY = this.getDistXY(node, repNode);
            distanceR = this.vectorLength(distanceXY);
            if (distanceR !== 0) {
              force = this.repulsiveForce(distanceR, this.k);
              this.force("repulsive", node, force * repNode.mass, distanceXY, distanceR);
            }
          }
        }
      }
    }
  }
  attractiveForces() {
    let distanceXY, distanceR, force;
    for (const link of this.links) {
      if (link.fromNode && link.toNode) {
        distanceXY = this.getDistXY(link.fromNode, link.toNode);
        distanceR = this.vectorLength(distanceXY);
        if (distanceR !== 0) {
          force = this.attractiveForce(distanceR, this.k);
          this.force("attractive", link, force, distanceXY, distanceR);
        }
      }
    }
  }
  applyLimits() {
    const nodes = this.nodes;
    for (const node of nodes) {
      if (node.fixedPosition) {
        continue;
      }
      this.integration.integrate(this, node);
      this.applyLimitBox(node, this.box);
      node.dispX = 0;
      node.dispY = 0;
    }
  }
  /**
   * External box that nodes should fall. When hitting an edge, node
   * should stop or bounce.
   * @private
   */
  applyLimitBox(node, box) {
    const radius = node.radius;
    node.plotX = clamp17(node.plotX, box.left + radius, box.width - radius);
    node.plotY = clamp17(node.plotY, box.top + radius, box.height - radius);
  }
  /**
   * From "A comparison of simulated annealing cooling strategies" by
   * Nourani and Andresen work.
   * @private
   */
  coolDown(temperature, temperatureStep, currentStep) {
    return temperature - temperatureStep * currentStep;
  }
  isStable() {
    return Math.abs(this.systemTemperature - this.prevSystemTemperature) < 1e-5 || this.temperature <= 0;
  }
  getSystemTemperature() {
    let value = 0;
    for (const node of this.nodes) {
      value += node.temperature;
    }
    return value;
  }
  vectorLength(vector) {
    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
  }
  getDistR(nodeA, nodeB) {
    const distance = this.getDistXY(nodeA, nodeB);
    return this.vectorLength(distance);
  }
  getDistXY(nodeA, nodeB) {
    const xDist = nodeA.plotX - nodeB.plotX, yDist = nodeA.plotY - nodeB.plotY;
    return {
      x: xDist,
      y: yDist,
      absX: Math.abs(xDist),
      absY: Math.abs(yDist)
    };
  }
};
var ReingoldFruchtermanLayout_default = ReingoldFruchtermanLayout;

// node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubbleLayout.js
var { addEvent: addEvent62, defined: defined55, pick: pick74 } = Utilities_default;
function chartGetSelectedParentNodes() {
  const allSeries = this.series, selectedParentsNodes = [];
  allSeries.forEach((series) => {
    if (series.parentNode && series.parentNode.selected) {
      selectedParentsNodes.push(series.parentNode);
    }
  });
  return selectedParentsNodes;
}
function onChartBeforeRedraw() {
  if (this.allDataPoints) {
    delete this.allDataPoints;
  }
}
var PackedBubbleLayout = class _PackedBubbleLayout extends ReingoldFruchtermanLayout_default {
  constructor() {
    super(...arguments);
    this.index = NaN;
    this.nodes = [];
    this.series = [];
  }
  static compose(ChartClass) {
    ReingoldFruchtermanLayout_default.compose(ChartClass);
    GraphLayoutComposition_default.integrations.packedbubble = PackedBubbleIntegration_default;
    GraphLayoutComposition_default.layouts.packedbubble = _PackedBubbleLayout;
    const chartProto = ChartClass.prototype;
    if (!chartProto.getSelectedParentNodes) {
      addEvent62(ChartClass, "beforeRedraw", onChartBeforeRedraw);
      chartProto.getSelectedParentNodes = chartGetSelectedParentNodes;
    }
    if (!chartProto.allParentNodes) {
      chartProto.allParentNodes = [];
    }
  }
  /* *
   *
   *  Functions
   *
   * */
  beforeStep() {
    if (this.options.marker) {
      this.series.forEach((series) => {
        if (series) {
          series.calculateParentRadius();
        }
      });
    }
  }
  // #14439, new stable check.
  isStable() {
    const tempDiff = Math.abs(this.prevSystemTemperature - this.systemTemperature);
    const upScaledTemperature = 10 * this.systemTemperature / Math.sqrt(this.nodes.length);
    return Math.abs(upScaledTemperature) < 1 && tempDiff < 1e-5 || this.temperature <= 0;
  }
  setCircularPositions() {
    const layout = this, box = layout.box, nodes = [
      ...layout.nodes,
      ...layout?.chart?.allParentNodes || []
    ], nodesLength = nodes.length + 1, angle = 2 * Math.PI / nodesLength, radius = layout.options.initialPositionRadius;
    let centerX, centerY, index = 0;
    for (const node of nodes) {
      if (this.resolveSplitSeries(node) && !node.isParentNode) {
        centerX = node.series.parentNode.plotX;
        centerY = node.series.parentNode.plotY;
      } else {
        centerX = box.width / 2;
        centerY = box.height / 2;
      }
      node.plotX = node.prevX = pick74(node.plotX, centerX + radius * Math.cos(node.index || index * angle));
      node.plotY = node.prevY = pick74(node.plotY, centerY + radius * Math.sin(node.index || index * angle));
      node.dispX = 0;
      node.dispY = 0;
      index++;
    }
  }
  repulsiveForces() {
    const layout = this, { options: options2, k } = layout, { bubblePadding = 0, seriesInteraction } = options2, nodes = [
      ...layout.nodes,
      ...layout?.chart?.allParentNodes || []
    ];
    for (const node of nodes) {
      const nodeSeries = node.series, fixedPosition = node.fixedPosition, paddedNodeRadius = (node.marker?.radius || 0) + bubblePadding;
      node.degree = node.mass;
      node.neighbours = 0;
      for (const repNode of nodes) {
        const repNodeSeries = repNode.series;
        if (
          // Node cannot repulse itself:
          node !== repNode && // Not dragged:
          !fixedPosition && (seriesInteraction || nodeSeries === repNodeSeries) && // Avoiding collision of parentNodes and parented points
          !(nodeSeries === repNodeSeries && (repNode.isParentNode || node.isParentNode))
        ) {
          const distanceXY = layout.getDistXY(node, repNode), distanceR = layout.vectorLength(distanceXY) - (paddedNodeRadius + (repNode.marker?.radius || 0));
          let forceTimesMass;
          if (distanceR < 0) {
            node.degree += 0.01;
            forceTimesMass = layout.repulsiveForce(-distanceR / Math.sqrt(++node.neighbours), k, node, repNode) * repNode.mass;
          }
          layout.force("repulsive", node, forceTimesMass || 0, distanceXY, repNode, distanceR);
        }
      }
    }
  }
  resolveSplitSeries(node) {
    const specificSeriesOpt = node.series?.options?.layoutAlgorithm?.splitSeries;
    return !defined55(specificSeriesOpt) && node.series.chart?.options?.plotOptions?.packedbubble?.layoutAlgorithm?.splitSeries || specificSeriesOpt || false;
  }
  applyLimitBox(node, box) {
    const layout = this, factor = 0.01;
    let distanceXY, distanceR;
    if (this.resolveSplitSeries(node) && !node.isParentNode && layout.options.parentNodeLimit) {
      distanceXY = layout.getDistXY(node, node.series.parentNode);
      distanceR = node.series.parentNodeRadius - node.marker.radius - layout.vectorLength(distanceXY);
      if (distanceR < 0 && distanceR > -2 * node.marker.radius) {
        node.plotX -= distanceXY.x * factor;
        node.plotY -= distanceXY.y * factor;
      }
    }
    super.applyLimitBox(node, box);
  }
};
GraphLayoutComposition_default.layouts.packedbubble = PackedBubbleLayout;
var PackedBubbleLayout_default = PackedBubbleLayout;

// node_modules/highcharts/es-modules/Series/SimulationSeriesUtilities.js
var { merge: merge67, syncTimeout: syncTimeout11 } = Utilities_default;
var { animObject: animObject12 } = AnimationUtilities_default;
function initDataLabelsDefer() {
  const dlOptions = this.options.dataLabels;
  if (!dlOptions?.defer || !this.options.layoutAlgorithm?.enableSimulation) {
    this.deferDataLabels = false;
  } else {
    syncTimeout11(() => {
      this.deferDataLabels = false;
    }, dlOptions ? animObject12(dlOptions.animation).defer : 0);
  }
}
function initDataLabels() {
  const series = this, dlOptions = series.options.dataLabels;
  if (!series.dataLabelsGroup) {
    const dataLabelsGroup = this.initDataLabelsGroup();
    if (!series.chart.styledMode && dlOptions?.style) {
      dataLabelsGroup.css(dlOptions.style);
    }
    dataLabelsGroup.attr({ opacity: 0 });
    if (series.visible) {
      dataLabelsGroup.show();
    }
    return dataLabelsGroup;
  }
  series.dataLabelsGroup.attr(merge67({ opacity: 1 }, this.getPlotBox("data-labels")));
  return series.dataLabelsGroup;
}
var DataLabelsDeferUtils = {
  initDataLabels,
  initDataLabelsDefer
};
var SimulationSeriesUtilities_default = DataLabelsDeferUtils;

// node_modules/highcharts/es-modules/Extensions/TextPath.js
var { deg2rad: deg2rad6 } = Globals_default;
var { addEvent: addEvent63, merge: merge68, uniqueKey: uniqueKey9, defined: defined56, extend: extend56 } = Utilities_default;
function setTextPath(path, textPathOptions) {
  textPathOptions = merge68(true, {
    enabled: true,
    attributes: {
      dy: -5,
      startOffset: "50%",
      textAnchor: "middle"
    }
  }, textPathOptions);
  const url = this.renderer.url, textWrapper = this.text || this, textPath = textWrapper.textPath, { attributes, enabled } = textPathOptions;
  path = path || textPath && textPath.path;
  if (textPath) {
    textPath.undo();
  }
  if (path && enabled) {
    const undo = addEvent63(textWrapper, "afterModifyTree", (e) => {
      if (path && enabled) {
        let textPathId = path.attr("id");
        if (!textPathId) {
          path.attr("id", textPathId = uniqueKey9());
        }
        const textAttribs = {
          // `dx`/`dy` options must by set on <text> (parent), the
          // rest should be set on <textPath>
          x: 0,
          y: 0
        };
        if (defined56(attributes.dx)) {
          textAttribs.dx = attributes.dx;
          delete attributes.dx;
        }
        if (defined56(attributes.dy)) {
          textAttribs.dy = attributes.dy;
          delete attributes.dy;
        }
        textWrapper.attr(textAttribs);
        this.attr({ transform: "" });
        if (this.box) {
          this.box = this.box.destroy();
        }
        const children = e.nodes.slice(0);
        e.nodes.length = 0;
        e.nodes[0] = {
          tagName: "textPath",
          attributes: extend56(attributes, {
            "text-anchor": attributes.textAnchor,
            href: `${url}#${textPathId}`
          }),
          children
        };
      }
    });
    textWrapper.textPath = { path, undo };
  } else {
    textWrapper.attr({ dx: 0, dy: 0 });
    delete textWrapper.textPath;
  }
  if (this.added) {
    textWrapper.textCache = "";
    this.renderer.buildText(textWrapper);
  }
  return this;
}
function setPolygon(event) {
  const bBox = event.bBox, tp = this.element?.querySelector("textPath");
  if (tp) {
    const polygon = [], { b, h } = this.renderer.fontMetrics(this.element), descender = h - b, lineCleanerRegex = new RegExp('(<tspan>|<tspan(?!\\sclass="highcharts-br")[^>]*>|<\\/tspan>)', "g"), lines = tp.innerHTML.replace(lineCleanerRegex, "").split(/<tspan class="highcharts-br"[^>]*>/), numOfLines = lines.length;
    const appendTopAndBottom = (charIndex, positionOfChar) => {
      const { x, y } = positionOfChar, rotation = (tp.getRotationOfChar(charIndex) - 90) * deg2rad6, cosRot = Math.cos(rotation), sinRot = Math.sin(rotation);
      return [
        [
          x - descender * cosRot,
          y - descender * sinRot
        ],
        [
          x + b * cosRot,
          y + b * sinRot
        ]
      ];
    };
    for (let i = 0, lineIndex = 0; lineIndex < numOfLines; lineIndex++) {
      const line2 = lines[lineIndex], lineLen = line2.length;
      for (let lineCharIndex = 0; lineCharIndex < lineLen; lineCharIndex += 5) {
        try {
          const srcCharIndex = i + lineCharIndex + lineIndex, [lower, upper] = appendTopAndBottom(srcCharIndex, tp.getStartPositionOfChar(srcCharIndex));
          if (lineCharIndex === 0) {
            polygon.push(upper);
            polygon.push(lower);
          } else {
            if (lineIndex === 0) {
              polygon.unshift(upper);
            }
            if (lineIndex === numOfLines - 1) {
              polygon.push(lower);
            }
          }
        } catch (e) {
          break;
        }
      }
      i += lineLen - 1;
      try {
        const srcCharIndex = i + lineIndex, charPos = tp.getEndPositionOfChar(srcCharIndex), [lower, upper] = appendTopAndBottom(srcCharIndex, charPos);
        polygon.unshift(upper);
        polygon.unshift(lower);
      } catch (e) {
        break;
      }
    }
    if (polygon.length) {
      polygon.push(polygon[0].slice());
    }
    bBox.polygon = polygon;
  }
  return bBox;
}
function drawTextPath(event) {
  const labelOptions = event.labelOptions, point = event.point, textPathOptions = labelOptions[point.formatPrefix + "TextPath"] || labelOptions.textPath;
  if (textPathOptions && !labelOptions.useHTML) {
    this.setTextPath(point.getDataLabelPath?.(this) || point.graphic, textPathOptions);
    if (point.dataLabelPath && !textPathOptions.enabled) {
      point.dataLabelPath = point.dataLabelPath.destroy();
    }
  }
}
function compose15(SVGElementClass) {
  addEvent63(SVGElementClass, "afterGetBBox", setPolygon);
  addEvent63(SVGElementClass, "beforeAddingDataLabel", drawTextPath);
  const svgElementProto = SVGElementClass.prototype;
  if (!svgElementProto.setTextPath) {
    svgElementProto.setTextPath = setTextPath;
  }
}
var TextPath = {
  compose: compose15
};
var TextPath_default = TextPath;

// node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubbleSeries.js
var { parse: color5 } = Color_default;
var { noop: noop14 } = Globals_default;
var { series: { prototype: seriesProto5 }, seriesTypes: { bubble: BubbleSeries2 } } = SeriesRegistry_default;
var { initDataLabels: initDataLabels2, initDataLabelsDefer: initDataLabelsDefer2 } = SimulationSeriesUtilities_default;
var { addEvent: addEvent64, clamp: clamp18, defined: defined57, extend: extend57, fireEvent: fireEvent38, isArray: isArray20, isNumber: isNumber53, merge: merge69, pick: pick75 } = Utilities_default;
TextPath_default.compose(SVGElement_default);
var PackedBubbleSeries = class extends BubbleSeries2 {
  constructor() {
    super(...arguments);
    this.parentNodeMass = 0;
    this.deferDataLabels = true;
  }
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(AxisClass, ChartClass, LegendClass) {
    BubbleSeries2.compose(AxisClass, ChartClass, LegendClass);
    DragNodesComposition_default.compose(ChartClass);
    PackedBubbleLayout_default.compose(ChartClass);
  }
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * Create a single array of all points from all series
   * @private
   */
  accumulateAllPoints() {
    const chart = this.chart, allDataPoints = [];
    for (const series of chart.series) {
      if (series.is("packedbubble") && // #13574
      series.reserveSpace()) {
        const valueData = series.getColumn("value");
        for (let j = 0; j < valueData.length; j++) {
          allDataPoints.push([
            null,
            null,
            valueData[j],
            series.index,
            j,
            {
              id: j,
              marker: {
                radius: 0
              }
            }
          ]);
        }
      }
    }
    return allDataPoints;
  }
  /**
   * Adding the basic layout to series points.
   * @private
   */
  addLayout() {
    const layoutOptions = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {}, layoutType = layoutOptions.type || "packedbubble", chartOptions = this.chart.options.chart;
    let graphLayoutsStorage = this.chart.graphLayoutsStorage, graphLayoutsLookup = this.chart.graphLayoutsLookup, layout;
    if (!graphLayoutsStorage) {
      this.chart.graphLayoutsStorage = graphLayoutsStorage = {};
      this.chart.graphLayoutsLookup = graphLayoutsLookup = [];
    }
    layout = graphLayoutsStorage[layoutType];
    if (!layout) {
      layoutOptions.enableSimulation = !defined57(chartOptions.forExport) ? layoutOptions.enableSimulation : !chartOptions.forExport;
      graphLayoutsStorage[layoutType] = layout = new GraphLayoutComposition_default.layouts[layoutType]();
      layout.init(layoutOptions);
      graphLayoutsLookup.splice(layout.index, 0, layout);
    }
    this.layout = layout;
    this.points.forEach((node) => {
      node.mass = 2;
      node.degree = 1;
      node.collisionNmb = 1;
    });
    layout.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);
    layout.addElementsToCollection([this], layout.series);
    layout.addElementsToCollection(this.points, layout.nodes);
  }
  /**
   * Function responsible for adding series layout, used for parent nodes.
   * @private
   */
  addSeriesLayout() {
    const layoutOptions = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {}, layoutType = layoutOptions.type || "packedbubble", graphLayoutsStorage = this.chart.graphLayoutsStorage, graphLayoutsLookup = this.chart.graphLayoutsLookup, parentNodeOptions = merge69(layoutOptions, layoutOptions.parentNodeOptions, {
      enableSimulation: this.layout.options.enableSimulation
    });
    let seriesLayout = graphLayoutsStorage[layoutType + "-series"];
    if (!seriesLayout) {
      graphLayoutsStorage[layoutType + "-series"] = seriesLayout = new GraphLayoutComposition_default.layouts[layoutType]();
      seriesLayout.init(parentNodeOptions);
      graphLayoutsLookup.splice(seriesLayout.index, 0, seriesLayout);
    }
    this.parentNodeLayout = seriesLayout;
    this.createParentNodes();
  }
  /**
   * The function responsible for calculating the parent node radius
   * based on the total surface of inside-bubbles and the group BBox
   * @private
   */
  calculateParentRadius() {
    const bBox = this.seriesBox(), parentPadding = 20, minParentRadius = 20;
    this.parentNodeRadius = clamp18(Math.sqrt(2 * this.parentNodeMass / Math.PI) + parentPadding, minParentRadius, bBox ? Math.max(Math.sqrt(Math.pow(bBox.width, 2) + Math.pow(bBox.height, 2)) / 2 + parentPadding, minParentRadius) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + parentPadding);
    if (this.parentNode) {
      this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius;
    }
  }
  /**
   * Calculate min and max bubble value for radius calculation.
   * @private
   */
  calculateZExtremes() {
    const chart = this.chart, allSeries = chart.series;
    let zMin = this.options.zMin, zMax = this.options.zMax, valMin = Infinity, valMax = -Infinity;
    if (zMin && zMax) {
      return [zMin, zMax];
    }
    allSeries.forEach((series) => {
      series.getColumn("value").forEach((y) => {
        if (defined57(y)) {
          if (y > valMax) {
            valMax = y;
          }
          if (y < valMin) {
            valMin = y;
          }
        }
      });
    });
    zMin = pick75(zMin, valMin);
    zMax = pick75(zMax, valMax);
    return [zMin, zMax];
  }
  /**
   * Check if two bubbles overlaps.
   * @private
   */
  checkOverlap(bubble1, bubble2) {
    const diffX = bubble1[0] - bubble2[0], diffY = bubble1[1] - bubble2[1], sumRad = bubble1[2] + bubble2[2];
    return Math.sqrt(diffX * diffX + diffY * diffY) - Math.abs(sumRad) < -1e-3;
  }
  /**
   * Creating parent nodes for split series, in which all the bubbles
   * are rendered.
   * @private
   */
  createParentNodes() {
    const PackedBubblePoint2 = this.pointClass, chart = this.chart, parentNodeLayout = this.parentNodeLayout, layoutOptions = this.layout.options;
    let nodeAdded, parentNode = this.parentNode, parentMarkerOptions = {
      radius: this.parentNodeRadius,
      lineColor: this.color,
      fillColor: color5(this.color).brighten(0.4).get()
    };
    if (layoutOptions.parentNodeOptions) {
      parentMarkerOptions = merge69(layoutOptions.parentNodeOptions.marker || {}, parentMarkerOptions);
    }
    this.parentNodeMass = 0;
    this.points.forEach((p) => {
      this.parentNodeMass += Math.PI * Math.pow(p.marker.radius, 2);
    });
    this.calculateParentRadius();
    parentNodeLayout.nodes.forEach((node) => {
      if (node.seriesIndex === this.index) {
        nodeAdded = true;
      }
    });
    parentNodeLayout.setArea(0, 0, chart.plotWidth, chart.plotHeight);
    if (!nodeAdded) {
      if (!parentNode) {
        parentNode = new PackedBubblePoint2(this, {
          mass: this.parentNodeRadius / 2,
          marker: parentMarkerOptions,
          dataLabels: {
            inside: false
          },
          states: {
            normal: {
              marker: parentMarkerOptions
            },
            hover: {
              marker: parentMarkerOptions
            }
          },
          dataLabelOnNull: true,
          degree: this.parentNodeRadius,
          isParentNode: true,
          seriesIndex: this.index
        });
        this.chart.allParentNodes.push(parentNode);
      }
      if (this.parentNode) {
        parentNode.plotX = this.parentNode.plotX;
        parentNode.plotY = this.parentNode.plotY;
      }
      this.parentNode = parentNode;
      parentNodeLayout.addElementsToCollection([this], parentNodeLayout.series);
      parentNodeLayout.addElementsToCollection([parentNode], parentNodeLayout.nodes);
    }
  }
  /**
   * Function responsible for adding all the layouts to the chart.
   * @private
   */
  deferLayout() {
    const layoutOptions = this.options.layoutAlgorithm;
    if (!this.visible) {
      return;
    }
    this.addLayout();
    if (layoutOptions.splitSeries) {
      this.addSeriesLayout();
    }
  }
  destroy() {
    if (this.chart.graphLayoutsLookup) {
      this.chart.graphLayoutsLookup.forEach((layout) => {
        layout.removeElementFromCollection(this, layout.series);
      }, this);
    }
    if (this.parentNode && this.parentNodeLayout) {
      this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes);
      if (this.parentNode.dataLabel) {
        this.parentNode.dataLabel = this.parentNode.dataLabel.destroy();
      }
    }
    seriesProto5.destroy.apply(this, arguments);
  }
  /**
   * Packedbubble has two separate collections of nodes if split, render
   * dataLabels for both sets:
   * @private
   */
  drawDataLabels() {
    if (this.deferDataLabels) {
      return;
    }
    seriesProto5.drawDataLabels.call(this, this.points);
    if (this.parentNode) {
      this.parentNode.formatPrefix = "parentNode";
      seriesProto5.drawDataLabels.call(this, [this.parentNode]);
    }
  }
  /**
   * Create Background/Parent Nodes for split series.
   * @private
   */
  drawGraph() {
    if (!this.layout || !this.layout.options.splitSeries) {
      return;
    }
    const chart = this.chart, nodeMarker = this.layout.options.parentNodeOptions.marker, parentOptions = {
      fill: nodeMarker.fillColor || color5(this.color).brighten(0.4).get(),
      opacity: nodeMarker.fillOpacity,
      stroke: nodeMarker.lineColor || this.color,
      "stroke-width": pick75(nodeMarker.lineWidth, this.options.lineWidth)
    };
    let parentAttribs = {};
    this.parentNodesGroup = this.plotGroup("parentNodesGroup", "parentNode", this.visible ? "inherit" : "hidden", 0.1, chart.seriesGroup);
    this.group?.attr({
      zIndex: 2
    });
    this.calculateParentRadius();
    if (this.parentNode && defined57(this.parentNode.plotX) && defined57(this.parentNode.plotY) && defined57(this.parentNodeRadius)) {
      parentAttribs = merge69({
        x: this.parentNode.plotX - this.parentNodeRadius,
        y: this.parentNode.plotY - this.parentNodeRadius,
        width: this.parentNodeRadius * 2,
        height: this.parentNodeRadius * 2
      }, parentOptions);
      if (!this.parentNode.graphic) {
        this.graph = this.parentNode.graphic = chart.renderer.symbol(parentOptions.symbol).add(this.parentNodesGroup);
      }
      this.parentNode.graphic.attr(parentAttribs);
    }
  }
  drawTracker() {
    const parentNode = this.parentNode;
    let dataLabels;
    super.drawTracker();
    if (parentNode) {
      dataLabels = isArray20(parentNode.dataLabels) ? parentNode.dataLabels : parentNode.dataLabel ? [parentNode.dataLabel] : [];
      if (parentNode.graphic) {
        parentNode.graphic.element.point = parentNode;
      }
      dataLabels.forEach((dataLabel) => {
        (dataLabel.div || dataLabel.element).point = parentNode;
      });
    }
  }
  /**
   * Calculate radius of bubbles in series.
   * @private
   */
  getPointRadius() {
    const chart = this.chart, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, seriesOptions = this.options, useSimulation = seriesOptions.useSimulation, smallestSize = Math.min(plotWidth, plotHeight), extremes = {}, radii = [], allDataPoints = chart.allDataPoints || [], allDataPointsLength = allDataPoints.length;
    let minSize, maxSize, value, radius;
    ["minSize", "maxSize"].forEach((prop) => {
      const length = parseInt(seriesOptions[prop], 10), isPercent = /%$/.test(seriesOptions[prop]);
      extremes[prop] = isPercent ? smallestSize * length / 100 : length * Math.sqrt(allDataPointsLength);
    });
    chart.minRadius = minSize = extremes.minSize / Math.sqrt(allDataPointsLength);
    chart.maxRadius = maxSize = extremes.maxSize / Math.sqrt(allDataPointsLength);
    const zExtremes = useSimulation ? this.calculateZExtremes() : [minSize, maxSize];
    allDataPoints.forEach((point, i) => {
      value = useSimulation ? clamp18(point[2], zExtremes[0], zExtremes[1]) : point[2];
      radius = this.getRadius(zExtremes[0], zExtremes[1], minSize, maxSize, value);
      if (radius === 0) {
        radius = null;
      }
      allDataPoints[i][2] = radius;
      radii.push(radius);
    });
    this.radii = radii;
  }
  init() {
    seriesProto5.init.apply(this, arguments);
    initDataLabelsDefer2.call(this);
    this.eventsToUnbind.push(addEvent64(this, "updatedData", function() {
      this.chart.series.forEach((s) => {
        if (s.type === this.type) {
          s.isDirty = true;
        }
      }, this);
    }));
    return this;
  }
  /**
   * Mouse up action, finalizing drag&drop.
   * @private
   * @param {Highcharts.Point} point The point that event occurred.
   */
  onMouseUp(dnPoint) {
    const point = dnPoint;
    if (point.fixedPosition && !point.removed) {
      const layout = this.layout, parentNodeLayout = this.parentNodeLayout;
      let distanceXY, distanceR;
      if (!point.isParentNode && parentNodeLayout && layout.options.dragBetweenSeries) {
        parentNodeLayout.nodes.forEach((node) => {
          if (point && point.marker && node !== point.series.parentNode) {
            distanceXY = layout.getDistXY(point, node);
            distanceR = layout.vectorLength(distanceXY) - node.marker.radius - point.marker.radius;
            if (distanceR < 0) {
              node.series.addPoint(merge69(point.options, {
                plotX: point.plotX,
                plotY: point.plotY
              }), false);
              layout.removeElementFromCollection(point, layout.nodes);
              point.remove();
            }
          }
        });
      }
      DragNodesComposition_default.onMouseUp.apply(this, arguments);
    }
  }
  /**
   * This is the main function responsible
   * for positioning all of the bubbles
   * allDataPoints - bubble array, in format [pixel x value,
   * pixel y value, radius,
   * related series index, related point index]
   * @private
   * @param {Array<Highcharts.PackedBubbleData>} allDataPoints All points from all series
   * @return {Array<Highcharts.PackedBubbleData>} Positions of all bubbles
   */
  placeBubbles(allDataPoints) {
    const checkOverlap = this.checkOverlap, positionBubble = this.positionBubble, bubblePos = [];
    let stage = 1, j = 0, k = 0, calculatedBubble, arr = [], i;
    const sortedArr = allDataPoints.sort((a, b) => b[2] - a[2]);
    if (sortedArr.length) {
      bubblePos.push([
        [
          0,
          // Starting in 0,0 coordinates
          0,
          sortedArr[0][2],
          // Radius
          sortedArr[0][3],
          // Series index
          sortedArr[0][4]
        ]
        // Point index
      ]);
      if (sortedArr.length > 1) {
        bubblePos.push([
          [
            0,
            0 - sortedArr[1][2] - sortedArr[0][2],
            // Move bubble above first one
            sortedArr[1][2],
            sortedArr[1][3],
            sortedArr[1][4]
          ]
        ]);
        for (i = 2; i < sortedArr.length; i++) {
          sortedArr[i][2] = sortedArr[i][2] || 1;
          calculatedBubble = positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]);
          if (checkOverlap(calculatedBubble, bubblePos[stage][0])) {
            bubblePos.push([]);
            k = 0;
            bubblePos[stage + 1].push(positionBubble(bubblePos[stage][j], bubblePos[stage][0], sortedArr[i]));
            stage++;
            j = 0;
          } else if (stage > 1 && bubblePos[stage - 1][k + 1] && checkOverlap(calculatedBubble, bubblePos[stage - 1][k + 1])) {
            k++;
            bubblePos[stage].push(positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]));
            j++;
          } else {
            j++;
            bubblePos[stage].push(calculatedBubble);
          }
        }
      }
      this.chart.stages = bubblePos;
      this.chart.rawPositions = [].concat.apply([], bubblePos);
      this.resizeRadius();
      arr = this.chart.rawPositions;
    }
    return arr;
  }
  /**
   * Function that checks for a parentMarker and sets the correct opacity.
   * @private
   * @param {Highcharts.Pack} point
   * Candidate point for opacity correction.
   * @param {string} [state]
   * The point state, can be either `hover`, `select` or 'normal'. If
   * undefined, normal state is assumed.
   *
   * @return {Highcharts.SVGAttributes}
   * The presentational attributes to be set on the point.
   */
  pointAttribs(point, state) {
    const options2 = this.options, hasParentMarker = point && point.isParentNode;
    let markerOptions = options2.marker;
    if (hasParentMarker && options2.layoutAlgorithm && options2.layoutAlgorithm.parentNodeOptions) {
      markerOptions = options2.layoutAlgorithm.parentNodeOptions.marker;
    }
    const fillOpacity = markerOptions.fillOpacity, attr18 = seriesProto5.pointAttribs.call(this, point, state);
    if (fillOpacity !== 1) {
      attr18["fill-opacity"] = fillOpacity;
    }
    return attr18;
  }
  /**
   * Function that is adding one bubble based on positions and sizes of
   * two other bubbles, lastBubble is the last added bubble, newOrigin is
   * the bubble for positioning new bubbles. nextBubble is the currently
   * added bubble for which we are calculating positions
   * @private
   * @param {Array<number>} lastBubble The closest last bubble
   * @param {Array<number>} newOrigin New bubble
   * @param {Array<number>} nextBubble The closest next bubble
   * @return {Array<number>} Bubble with correct positions
   */
  positionBubble(lastBubble, newOrigin, nextBubble) {
    const sqrt = Math.sqrt, asin = Math.asin, acos = Math.acos, pow = Math.pow, abs2 = Math.abs, distance = sqrt(
      // Dist between lastBubble and newOrigin
      pow(lastBubble[0] - newOrigin[0], 2) + pow(lastBubble[1] - newOrigin[1], 2)
    ), alfa = acos(
      // From cosinus theorem: alfa is an angle used for
      // calculating correct position
      (pow(distance, 2) + pow(nextBubble[2] + newOrigin[2], 2) - pow(nextBubble[2] + lastBubble[2], 2)) / (2 * (nextBubble[2] + newOrigin[2]) * distance)
    ), beta = asin(
      // From sinus theorem.
      abs2(lastBubble[0] - newOrigin[0]) / distance
    ), gamma = lastBubble[1] - newOrigin[1] < 0 ? 0 : Math.PI, delta = (lastBubble[0] - newOrigin[0]) * (lastBubble[1] - newOrigin[1]) < 0 ? 1 : -1, finalAngle = gamma + alfa + beta * delta, cosA = Math.cos(finalAngle), sinA = Math.sin(finalAngle), posX = newOrigin[0] + (newOrigin[2] + nextBubble[2]) * sinA, posY = newOrigin[1] - (newOrigin[2] + nextBubble[2]) * cosA;
    return [
      posX,
      posY,
      nextBubble[2],
      nextBubble[3],
      nextBubble[4]
    ];
  }
  render() {
    const dataLabels = [];
    seriesProto5.render.apply(this, arguments);
    if (!this.options.dataLabels.allowOverlap) {
      this.data.forEach((point) => {
        if (isArray20(point.dataLabels)) {
          point.dataLabels.forEach((dataLabel) => {
            dataLabels.push(dataLabel);
          });
        }
      });
      if (this.options.useSimulation) {
        this.chart.hideOverlappingLabels(dataLabels);
      }
    }
  }
  /**
   * The function responsible for resizing the bubble radius.
   * In shortcut: it is taking the initially
   * calculated positions of bubbles. Then it is calculating the min max
   * of both dimensions, creating something in shape of bBox.
   * The comparison of bBox and the size of plotArea
   * (later it may be also the size set by customer) is giving the
   * value how to recalculate the radius so it will match the size
   * @private
   */
  resizeRadius() {
    const chart = this.chart, positions = chart.rawPositions, min4 = Math.min, max4 = Math.max, plotLeft = chart.plotLeft, plotTop = chart.plotTop, chartHeight = chart.plotHeight, chartWidth = chart.plotWidth;
    let minX, maxX, minY, maxY, radius;
    minX = minY = Number.POSITIVE_INFINITY;
    maxX = maxY = Number.NEGATIVE_INFINITY;
    for (const position of positions) {
      radius = position[2];
      minX = min4(minX, position[0] - radius);
      maxX = max4(maxX, position[0] + radius);
      minY = min4(minY, position[1] - radius);
      maxY = max4(maxY, position[1] + radius);
    }
    const bBox = [maxX - minX, maxY - minY], spaceRatio = [
      (chartWidth - plotLeft) / bBox[0],
      (chartHeight - plotTop) / bBox[1]
    ], smallerDimension = min4.apply([], spaceRatio);
    if (Math.abs(smallerDimension - 1) > 1e-10) {
      for (const position of positions) {
        position[2] *= smallerDimension;
      }
      this.placeBubbles(positions);
    } else {
      chart.diffY = chartHeight / 2 + plotTop - minY - (maxY - minY) / 2;
      chart.diffX = chartWidth / 2 + plotLeft - minX - (maxX - minX) / 2;
    }
  }
  /**
   * The function responsible for calculating series bubble' s bBox.
   * Needed because of exporting failure when useSimulation
   * is set to false
   * @private
   */
  seriesBox() {
    const chart = this.chart, data = this.data, max4 = Math.max, min4 = Math.min, bBox = [
      chart.plotLeft,
      chart.plotLeft + chart.plotWidth,
      chart.plotTop,
      chart.plotTop + chart.plotHeight
    ];
    let radius;
    data.forEach((p) => {
      if (defined57(p.plotX) && defined57(p.plotY) && p.marker.radius) {
        radius = p.marker.radius;
        bBox[0] = min4(bBox[0], p.plotX - radius);
        bBox[1] = max4(bBox[1], p.plotX + radius);
        bBox[2] = min4(bBox[2], p.plotY - radius);
        bBox[3] = max4(bBox[3], p.plotY + radius);
      }
    });
    return isNumber53(bBox.width / bBox.height) ? bBox : null;
  }
  /**
   * Needed because of z-indexing issue if point is added in series.group
   * @private
   */
  setVisible() {
    const series = this;
    seriesProto5.setVisible.apply(series, arguments);
    if (series.parentNodeLayout && series.graph) {
      if (series.visible) {
        series.graph.show();
        if (series.parentNode.dataLabel) {
          series.parentNode.dataLabel.show();
        }
      } else {
        series.graph.hide();
        series.parentNodeLayout.removeElementFromCollection(series.parentNode, series.parentNodeLayout.nodes);
        if (series.parentNode.dataLabel) {
          series.parentNode.dataLabel.hide();
        }
      }
    } else if (series.layout) {
      if (series.visible) {
        series.layout.addElementsToCollection(series.points, series.layout.nodes);
      } else {
        series.points.forEach((node) => {
          series.layout.removeElementFromCollection(node, series.layout.nodes);
        });
      }
    }
  }
  /**
   * Extend the base translate method to handle bubble size,
   * and correct positioning them.
   * @private
   */
  translate() {
    const chart = this.chart, data = this.data, index = this.index, useSimulation = this.options.useSimulation;
    let point, radius, positions;
    this.generatePoints();
    if (!defined57(chart.allDataPoints)) {
      chart.allDataPoints = this.accumulateAllPoints();
      this.getPointRadius();
    }
    if (useSimulation) {
      positions = chart.allDataPoints;
    } else {
      positions = this.placeBubbles(chart.allDataPoints);
      this.options.draggable = false;
    }
    for (const position of positions) {
      if (position[3] === index) {
        point = data[position[4]];
        radius = pick75(position[2], void 0);
        if (!useSimulation) {
          point.plotX = position[0] - chart.plotLeft + chart.diffX;
          point.plotY = position[1] - chart.plotTop + chart.diffY;
        }
        if (isNumber53(radius)) {
          point.marker = extend57(point.marker, {
            radius,
            width: 2 * radius,
            height: 2 * radius
          });
          point.radius = radius;
        }
      }
    }
    if (useSimulation) {
      this.deferLayout();
    }
    fireEvent38(this, "afterTranslate");
  }
};
PackedBubbleSeries.defaultOptions = merge69(BubbleSeries2.defaultOptions, PackedBubbleSeriesDefaults_default);
extend57(PackedBubbleSeries.prototype, {
  pointClass: PackedBubblePoint_default,
  axisTypes: [],
  directTouch: true,
  forces: ["barycenter", "repulsive"],
  hasDraggableNodes: true,
  invertible: false,
  isCartesian: false,
  noSharedTooltip: true,
  pointArrayMap: ["value"],
  pointValKey: "value",
  requireSorting: false,
  trackerGroups: ["group", "dataLabelsGroup", "parentNodesGroup"],
  initDataLabels: initDataLabels2,
  alignDataLabel: seriesProto5.alignDataLabel,
  indexateNodes: noop14,
  onMouseDown: DragNodesComposition_default.onMouseDown,
  onMouseMove: DragNodesComposition_default.onMouseMove,
  redrawHalo: DragNodesComposition_default.redrawHalo,
  searchPoint: noop14
  // Solving #12287
});
SeriesRegistry_default.registerSeriesType("packedbubble", PackedBubbleSeries);
var PackedBubbleSeries_default = PackedBubbleSeries;

// node_modules/highcharts/es-modules/Series/Polygon/PolygonSeriesDefaults.js
var PolygonSeriesDefaults = {
  marker: {
    enabled: false,
    states: {
      hover: {
        enabled: false
      }
    }
  },
  stickyTracking: false,
  tooltip: {
    followPointer: true,
    pointFormat: ""
  },
  trackByArea: true,
  legendSymbol: "rectangle"
};
var PolygonSeriesDefaults_default = PolygonSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Polygon/PolygonSeries.js
var { noop: noop15 } = Globals_default;
var { area: AreaSeries4, line: LineSeries5, scatter: ScatterSeries3 } = SeriesRegistry_default.seriesTypes;
var { extend: extend58, merge: merge70 } = Utilities_default;
var PolygonSeries = class extends ScatterSeries3 {
  /* *
   *
   *  Functions
   *
   * */
  getGraphPath() {
    const graphPath = LineSeries5.prototype.getGraphPath.call(this);
    let i = graphPath.length + 1;
    while (i--) {
      if ((i === graphPath.length || graphPath[i][0] === "M") && i > 0) {
        graphPath.splice(i, 0, ["Z"]);
      }
    }
    this.areaPath = graphPath;
    return graphPath;
  }
  drawGraph() {
    this.options.fillColor = this.color;
    AreaSeries4.prototype.drawGraph.call(this);
  }
};
PolygonSeries.defaultOptions = merge70(ScatterSeries3.defaultOptions, PolygonSeriesDefaults_default);
extend58(PolygonSeries.prototype, {
  type: "polygon",
  drawTracker: LineSeries5.prototype.drawTracker,
  setStackedPoints: noop15
  // No stacking points on polygons (#5310)
});
SeriesRegistry_default.registerSeriesType("polygon", PolygonSeries);

// node_modules/highcharts/es-modules/Core/Axis/RadialAxisDefaults.js
var defaultCircularOptions = {
  gridLineWidth: 1,
  // Spokes
  labels: {
    align: void 0,
    // Auto
    x: 0,
    y: void 0
    // Auto
  },
  maxPadding: 0,
  minPadding: 0,
  showLastLabel: false,
  tickLength: 0
};
var defaultRadialGaugeOptions = {
  endOnTick: false,
  gridLineWidth: 0,
  labels: {
    align: "center",
    distance: -25,
    x: 0,
    y: void 0
    // Auto
  },
  lineWidth: 1,
  minorGridLineWidth: 0,
  minorTickInterval: "auto",
  minorTickLength: 10,
  minorTickPosition: "inside",
  minorTickWidth: 1,
  startOnTick: false,
  tickLength: 10,
  tickPixelInterval: 100,
  tickPosition: "inside",
  tickWidth: 2,
  title: {
    rotation: 0,
    text: ""
  },
  zIndex: 2
  // Behind dials, points in the series group
};
var defaultRadialOptions = {
  /**
   * In a polar chart, this is the angle of the Y axis in degrees, where
   * 0 is up and 90 is right. The angle determines the position of the
   * axis line and the labels, though the coordinate system is unaffected.
   * Since v8.0.0 this option is also applicable for X axis (inverted
   * polar).
   *
   * @sample {highcharts} highcharts/xaxis/angle/
   *         Custom X axis' angle on inverted polar chart
   * @sample {highcharts} highcharts/yaxis/angle/
   *         Dual axis polar chart
   *
   * @type      {number}
   * @default   0
   * @since     4.2.7
   * @product   highcharts
   * @apioption xAxis.angle
   */
  /**
   * Polar charts only. Whether the grid lines should draw as a polygon
   * with straight lines between categories, or as circles. Can be either
   * `circle` or `polygon`. Since v8.0.0 this option is also applicable
   * for X axis (inverted polar).
   *
   * @sample {highcharts} highcharts/demo/polar-spider/
   *         Polygon grid lines
   * @sample {highcharts} highcharts/xaxis/gridlineinterpolation/
   *         Circle and polygon on inverted polar
   * @sample {highcharts} highcharts/yaxis/gridlineinterpolation/
   *         Circle and polygon
   *
   * @type       {string}
   * @product    highcharts
   * @validvalue ["circle", "polygon"]
   * @apioption  xAxis.gridLineInterpolation
   */
  gridLineInterpolation: "circle",
  gridLineWidth: 1,
  labels: {
    align: "right",
    padding: 5,
    x: -3,
    y: -2
  },
  showLastLabel: false,
  title: {
    x: 4,
    text: null,
    rotation: 90
  }
};
var RadialAxisDefaults = {
  circular: defaultCircularOptions,
  radial: defaultRadialOptions,
  radialGauge: defaultRadialGaugeOptions
};
var RadialAxisDefaults_default = RadialAxisDefaults;

// node_modules/highcharts/es-modules/Core/Axis/RadialAxis.js
var { defaultOptions: defaultOptions17 } = Defaults_default;
var { composed: composed22, noop: noop16 } = Globals_default;
var { addEvent: addEvent65, correctFloat: correctFloat13, defined: defined58, extend: extend59, fireEvent: fireEvent39, isObject: isObject17, merge: merge71, pick: pick76, pushUnique: pushUnique25, relativeLength: relativeLength11, wrap: wrap6 } = Utilities_default;
var RadialAxis;
(function(RadialAxis2) {
  RadialAxis2.radialDefaultOptions = merge71(RadialAxisDefaults_default);
  function beforeSetTickPositions() {
    this.autoConnect = this.isCircular && typeof pick76(this.userMax, this.options.max) === "undefined" && correctFloat13(this.endAngleRad - this.startAngleRad) === correctFloat13(2 * Math.PI);
    if (!this.isCircular && this.chart.inverted) {
      this.max++;
    }
    if (this.autoConnect) {
      this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0;
    }
  }
  function compose27(AxisClass, TickClass) {
    if (pushUnique25(composed22, "Axis.Radial")) {
      addEvent65(AxisClass, "afterInit", onAxisAfterInit);
      addEvent65(AxisClass, "autoLabelAlign", onAxisAutoLabelAlign);
      addEvent65(AxisClass, "destroy", onAxisDestroy2);
      addEvent65(AxisClass, "init", onAxisInit4);
      addEvent65(AxisClass, "initialAxisTranslation", onAxisInitialAxisTranslation);
      addEvent65(TickClass, "afterGetLabelPosition", onTickAfterGetLabelPosition3);
      addEvent65(TickClass, "afterGetPosition", onTickAfterGetPosition);
      addEvent65(Globals_default, "setOptions", onGlobalSetOptions);
      wrap6(TickClass.prototype, "getMarkPath", wrapTickGetMarkPath2);
    }
    return AxisClass;
  }
  RadialAxis2.compose = compose27;
  function createLabelCollector() {
    return () => {
      if (this.isRadial && this.tickPositions && // Undocumented option for now, but working
      this.options.labels && this.options.labels.allowOverlap !== true) {
        return this.tickPositions.map((pos) => this.ticks[pos]?.label).filter((label) => Boolean(label));
      }
    };
  }
  function createLabelCollectorHidden() {
    return noop16;
  }
  function getCrosshairPosition(options2, x1, y1) {
    const center = this.pane.center;
    let value = options2.value, shapeArgs, end, x2, y2;
    if (this.isCircular) {
      if (!defined58(value)) {
        x2 = options2.chartX || 0;
        y2 = options2.chartY || 0;
        value = this.translate(Math.atan2(y2 - y1, x2 - x1) - this.startAngleRad, true);
      } else if (options2.point) {
        shapeArgs = options2.point.shapeArgs || {};
        if (shapeArgs.start) {
          value = this.chart.inverted ? this.translate(options2.point.rectPlotY, true) : options2.point.x;
        }
      }
      end = this.getPosition(value);
      x2 = end.x;
      y2 = end.y;
    } else {
      if (!defined58(value)) {
        x2 = options2.chartX;
        y2 = options2.chartY;
      }
      if (defined58(x2) && defined58(y2)) {
        y1 = center[1] + this.chart.plotTop;
        value = this.translate(Math.min(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), center[2] / 2) - center[3] / 2, true);
      }
    }
    return [value, x2 || 0, y2 || 0];
  }
  function getLinePath(_lineWidth, radius, innerRadius) {
    const center = this.pane.center, chart = this.chart, left = this.left || 0, top = this.top || 0;
    let end, r = pick76(radius, center[2] / 2 - this.offset), path;
    if (typeof innerRadius === "undefined") {
      innerRadius = this.horiz ? 0 : this.center && -this.center[3] / 2;
    }
    if (innerRadius) {
      r += innerRadius;
    }
    if (this.isCircular || typeof radius !== "undefined") {
      path = this.chart.renderer.symbols.arc(left + center[0], top + center[1], r, r, {
        start: this.startAngleRad,
        end: this.endAngleRad,
        open: true,
        innerR: 0
      });
      path.xBounds = [left + center[0]];
      path.yBounds = [top + center[1] - r];
    } else {
      end = this.postTranslate(this.angleRad, r);
      path = [
        [
          "M",
          this.center[0] + chart.plotLeft,
          this.center[1] + chart.plotTop
        ],
        ["L", end.x, end.y]
      ];
    }
    return path;
  }
  function getOffset2() {
    const axisProto = this.constructor.prototype;
    axisProto.getOffset.call(this);
    this.chart.axisOffset[this.side] = 0;
  }
  function getPlotBandPath(from, to, options2) {
    const chart = this.chart, radiusToPixels = (radius) => {
      if (typeof radius === "string") {
        let r = parseInt(radius, 10);
        if (percentRegex.test(radius)) {
          r = r * fullRadius / 100;
        }
        return r;
      }
      return radius;
    }, center = this.center, startAngleRad = this.startAngleRad, fullRadius = center[2] / 2, offset3 = Math.min(this.offset, 0), left = this.left || 0, top = this.top || 0, percentRegex = /%$/, isCircular = this.isCircular;
    let start, end, angle, xOnPerimeter, open2, path, outerRadius = pick76(radiusToPixels(options2.outerRadius), fullRadius), innerRadius = radiusToPixels(options2.innerRadius), thickness = pick76(radiusToPixels(options2.thickness), 10);
    if (this.options.gridLineInterpolation === "polygon") {
      path = this.getPlotLinePath({ value: from }).concat(this.getPlotLinePath({ value: to, reverse: true }));
    } else {
      from = Math.max(from, this.min);
      to = Math.min(to, this.max);
      const transFrom = this.translate(from), transTo = this.translate(to);
      if (!isCircular) {
        outerRadius = transFrom || 0;
        innerRadius = transTo || 0;
      }
      if (options2.shape === "circle" || !isCircular) {
        start = -Math.PI / 2;
        end = Math.PI * 1.5;
        open2 = true;
      } else {
        start = startAngleRad + (transFrom || 0);
        end = startAngleRad + (transTo || 0);
      }
      outerRadius -= offset3;
      thickness -= offset3;
      path = chart.renderer.symbols.arc(left + center[0], top + center[1], outerRadius, outerRadius, {
        // Math is for reversed yAxis (#3606)
        start: Math.min(start, end),
        end: Math.max(start, end),
        innerR: pick76(innerRadius, outerRadius - thickness),
        open: open2,
        borderRadius: options2.borderRadius
      });
      if (isCircular) {
        angle = (end + start) / 2;
        xOnPerimeter = left + center[0] + center[2] / 2 * Math.cos(angle);
        path.xBounds = angle > -Math.PI / 2 && angle < Math.PI / 2 ? (
          // Right hemisphere
          [xOnPerimeter, chart.plotWidth]
        ) : (
          // Left hemisphere
          [0, xOnPerimeter]
        );
        path.yBounds = [
          top + center[1] + center[2] / 2 * Math.sin(angle)
        ];
        path.yBounds[0] += angle > -Math.PI && angle < 0 || angle > Math.PI ? -10 : 10;
      }
    }
    return path;
  }
  function getPlotLinePath(options2) {
    const center = this.pane.center, chart = this.chart, inverted = chart.inverted, reverse = options2.reverse, background2 = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {}, innerRadius = background2.innerRadius || "0%", outerRadius = background2.outerRadius || "100%", x1 = center[0] + chart.plotLeft, y1 = center[1] + chart.plotTop, height = this.height, isCrosshair = options2.isCrosshair, paneInnerR = center[3] / 2;
    let value = options2.value, innerRatio, distance, a, b, otherAxis, xy, tickPositions, crossPos, path;
    const end = this.getPosition(value);
    let x2 = end.x, y2 = end.y;
    if (isCrosshair) {
      crossPos = this.getCrosshairPosition(options2, x1, y1);
      value = crossPos[0];
      x2 = crossPos[1];
      y2 = crossPos[2];
    }
    if (this.isCircular) {
      distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      a = typeof innerRadius === "string" ? relativeLength11(innerRadius, 1) : innerRadius / distance;
      b = typeof outerRadius === "string" ? relativeLength11(outerRadius, 1) : outerRadius / distance;
      if (center && paneInnerR) {
        innerRatio = paneInnerR / distance;
        if (a < innerRatio) {
          a = innerRatio;
        }
        if (b < innerRatio) {
          b = innerRatio;
        }
      }
      path = [
        ["M", x1 + a * (x2 - x1), y1 - a * (y1 - y2)],
        ["L", x2 - (1 - b) * (x2 - x1), y2 + (1 - b) * (y1 - y2)]
      ];
    } else {
      value = this.translate(value);
      if (value) {
        if (value < 0 || value > height) {
          value = 0;
        }
      }
      if (this.options.gridLineInterpolation === "circle") {
        path = this.getLinePath(0, value, paneInnerR);
      } else {
        path = [];
        chart[inverted ? "yAxis" : "xAxis"].forEach((a2) => {
          if (a2.pane === this.pane) {
            otherAxis = a2;
          }
        });
        if (otherAxis) {
          tickPositions = otherAxis.tickPositions;
          if (otherAxis.autoConnect) {
            tickPositions = tickPositions.concat([tickPositions[0]]);
          }
          if (reverse) {
            tickPositions = tickPositions.slice().reverse();
          }
          if (value) {
            value += paneInnerR;
          }
          for (let i = 0; i < tickPositions.length; i++) {
            xy = otherAxis.getPosition(tickPositions[i], value);
            path.push(i ? ["L", xy.x, xy.y] : ["M", xy.x, xy.y]);
          }
        }
      }
    }
    return path;
  }
  function getPosition(value, length) {
    const translatedVal = this.translate(value);
    return this.postTranslate(
      this.isCircular ? translatedVal : this.angleRad,
      // #2848
      // In case when translatedVal is negative, the 0 value must be
      // used instead, in order to deal with lines and labels that
      // fall out of the visible range near the center of a pane
      pick76(this.isCircular ? length : translatedVal < 0 ? 0 : translatedVal, this.center[2] / 2) - this.offset
    );
  }
  function getTitlePosition() {
    const center = this.center, chart = this.chart, titleOptions = this.options.title;
    return {
      x: chart.plotLeft + center[0] + (titleOptions.x || 0),
      y: chart.plotTop + center[1] - {
        high: 0.5,
        middle: 0.25,
        low: 0
      }[titleOptions.align] * center[2] + (titleOptions.y || 0)
    };
  }
  function modify(axis) {
    axis.beforeSetTickPositions = beforeSetTickPositions;
    axis.createLabelCollector = createLabelCollector;
    axis.getCrosshairPosition = getCrosshairPosition;
    axis.getLinePath = getLinePath;
    axis.getOffset = getOffset2;
    axis.getPlotBandPath = getPlotBandPath;
    axis.getPlotLinePath = getPlotLinePath;
    axis.getPosition = getPosition;
    axis.getTitlePosition = getTitlePosition;
    axis.postTranslate = postTranslate;
    axis.setAxisSize = setAxisSize;
    axis.setAxisTranslation = setAxisTranslation;
    axis.setOptions = setOptions6;
  }
  function modifyAsHidden(radialAxis) {
    radialAxis.isHidden = true;
    radialAxis.createLabelCollector = createLabelCollectorHidden;
    radialAxis.getOffset = noop16;
    radialAxis.redraw = renderHidden;
    radialAxis.render = renderHidden;
    radialAxis.setScale = noop16;
    radialAxis.setCategories = noop16;
    radialAxis.setTitle = noop16;
  }
  function onAxisAfterInit() {
    const chart = this.chart, options2 = this.options, isHidden = chart.angular && this.isXAxis, pane2 = this.pane, paneOptions = pane2?.options;
    if (!isHidden && pane2 && (chart.angular || chart.polar)) {
      const fullCircle = Math.PI * 2, start = (pick76(paneOptions.startAngle, 0) - 90) * Math.PI / 180, end = (pick76(paneOptions.endAngle, pick76(paneOptions.startAngle, 0) + 360) - 90) * Math.PI / 180;
      this.angleRad = (options2.angle || 0) * Math.PI / 180;
      this.startAngleRad = start;
      this.endAngleRad = end;
      this.offset = options2.offset || 0;
      let normalizedStart = (start % fullCircle + fullCircle) % fullCircle, normalizedEnd = (end % fullCircle + fullCircle) % fullCircle;
      if (normalizedStart > Math.PI) {
        normalizedStart -= fullCircle;
      }
      if (normalizedEnd > Math.PI) {
        normalizedEnd -= fullCircle;
      }
      this.normalizedStartAngleRad = normalizedStart;
      this.normalizedEndAngleRad = normalizedEnd;
    }
  }
  function onAxisAutoLabelAlign(e) {
    if (this.isRadial) {
      e.align = void 0;
      e.preventDefault();
    }
  }
  function onAxisDestroy2() {
    if (this.chart?.labelCollectors) {
      const index = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;
      if (index >= 0) {
        this.chart.labelCollectors.splice(index, 1);
      }
    }
  }
  function onAxisInit4(e) {
    const chart = this.chart, angular = chart.angular, polar = chart.polar, isX = this.isXAxis, coll = this.coll, isHidden = angular && isX, paneIndex = e.userOptions.pane || 0, pane2 = this.pane = chart.pane && chart.pane[paneIndex];
    let isCircular;
    if (coll === "colorAxis") {
      this.isRadial = false;
      return;
    }
    if (angular) {
      if (isHidden) {
        modifyAsHidden(this);
      } else {
        modify(this);
      }
      isCircular = !isX;
    } else if (polar) {
      modify(this);
      isCircular = this.horiz;
    }
    if (angular || polar) {
      this.isRadial = true;
      if (!this.labelCollector) {
        this.labelCollector = this.createLabelCollector();
      }
      if (this.labelCollector) {
        chart.labelCollectors.push(this.labelCollector);
      }
    } else {
      this.isRadial = false;
    }
    if (pane2 && isCircular) {
      pane2.axis = this;
    }
    this.isCircular = isCircular;
  }
  function onAxisInitialAxisTranslation() {
    if (this.isRadial) {
      this.beforeSetTickPositions();
    }
  }
  function onTickAfterGetLabelPosition3(e) {
    const label = this.label;
    if (!label) {
      return;
    }
    const axis = this.axis, labelBBox = label.getBBox(), labelOptions = axis.options.labels, angle = (axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360, correctAngle = Math.round(angle), labelYPosCorrection = !defined58(labelOptions.y) ? -labelBBox.height * 0.3 : 0;
    let optionsY = labelOptions.y, ret, centerSlot = 20, align = labelOptions.align, labelDir = "end", reducedAngle1 = correctAngle < 0 ? correctAngle + 360 : correctAngle, reducedAngle2 = reducedAngle1, translateY = 0, translateX = 0;
    if (axis.isRadial) {
      ret = axis.getPosition(this.pos, axis.center[2] / 2 + relativeLength11(pick76(labelOptions.distance, -25), axis.center[2] / 2, -axis.center[2] / 2));
      if (labelOptions.rotation === "auto") {
        label.attr({
          rotation: angle
        });
      } else if (!defined58(optionsY)) {
        optionsY = axis.chart.renderer.fontMetrics(label).b - labelBBox.height / 2;
      }
      if (!defined58(align)) {
        if (axis.isCircular) {
          if (labelBBox.width > axis.len * axis.tickInterval / (axis.max - axis.min)) {
            centerSlot = 0;
          }
          if (angle > centerSlot && angle < 180 - centerSlot) {
            align = "left";
          } else if (angle > 180 + centerSlot && angle < 360 - centerSlot) {
            align = "right";
          } else {
            align = "center";
          }
        } else {
          align = "center";
        }
        label.attr({
          align
        });
      }
      if (align === "auto" && axis.tickPositions.length === 2 && axis.isCircular) {
        if (reducedAngle1 > 90 && reducedAngle1 < 180) {
          reducedAngle1 = 180 - reducedAngle1;
        } else if (reducedAngle1 > 270 && reducedAngle1 <= 360) {
          reducedAngle1 = 540 - reducedAngle1;
        }
        if (reducedAngle2 > 180 && reducedAngle2 <= 360) {
          reducedAngle2 = 360 - reducedAngle2;
        }
        if (axis.pane.options.startAngle === correctAngle || axis.pane.options.startAngle === correctAngle + 360 || axis.pane.options.startAngle === correctAngle - 360) {
          labelDir = "start";
        }
        if (correctAngle >= -90 && correctAngle <= 90 || correctAngle >= -360 && correctAngle <= -270 || correctAngle >= 270 && correctAngle <= 360) {
          align = labelDir === "start" ? "right" : "left";
        } else {
          align = labelDir === "start" ? "left" : "right";
        }
        if (reducedAngle2 > 70 && reducedAngle2 < 110) {
          align = "center";
        }
        if (reducedAngle1 < 15 || reducedAngle1 >= 180 && reducedAngle1 < 195) {
          translateY = labelBBox.height * 0.3;
        } else if (reducedAngle1 >= 15 && reducedAngle1 <= 35) {
          translateY = labelDir === "start" ? 0 : labelBBox.height * 0.75;
        } else if (reducedAngle1 >= 195 && reducedAngle1 <= 215) {
          translateY = labelDir === "start" ? labelBBox.height * 0.75 : 0;
        } else if (reducedAngle1 > 35 && reducedAngle1 <= 90) {
          translateY = labelDir === "start" ? -labelBBox.height * 0.25 : labelBBox.height;
        } else if (reducedAngle1 > 215 && reducedAngle1 <= 270) {
          translateY = labelDir === "start" ? labelBBox.height : -labelBBox.height * 0.25;
        }
        if (reducedAngle2 < 15) {
          translateX = labelDir === "start" ? -labelBBox.height * 0.15 : labelBBox.height * 0.15;
        } else if (reducedAngle2 > 165 && reducedAngle2 <= 180) {
          translateX = labelDir === "start" ? labelBBox.height * 0.15 : -labelBBox.height * 0.15;
        }
        label.attr({ align });
        label.translate(translateX, translateY + labelYPosCorrection);
      }
      e.pos.x = ret.x + (labelOptions.x || 0);
      e.pos.y = ret.y + (optionsY || 0);
    }
  }
  function onTickAfterGetPosition(e) {
    if (this.axis.getPosition) {
      extend59(e.pos, this.axis.getPosition(this.pos));
    }
  }
  function onGlobalSetOptions({ options: options2 }) {
    if (options2.xAxis) {
      merge71(true, RadialAxis2.radialDefaultOptions.circular, options2.xAxis);
    }
    if (options2.yAxis) {
      merge71(true, RadialAxis2.radialDefaultOptions.radialGauge, options2.yAxis);
    }
  }
  function postTranslate(angle, radius) {
    const chart = this.chart, center = this.center;
    angle = this.startAngleRad + angle;
    return {
      x: chart.plotLeft + center[0] + Math.cos(angle) * radius,
      y: chart.plotTop + center[1] + Math.sin(angle) * radius
    };
  }
  function renderHidden() {
    this.isDirty = false;
  }
  function setAxisSize() {
    const axisProto = this.constructor.prototype;
    let center, start;
    axisProto.setAxisSize.call(this);
    if (this.isRadial) {
      this.pane.updateCenter(this);
      center = this.center = this.pane.center.slice();
      if (this.isCircular) {
        this.sector = this.endAngleRad - this.startAngleRad;
      } else {
        start = this.postTranslate(this.angleRad, center[3] / 2);
        center[0] = start.x - this.chart.plotLeft;
        center[1] = start.y - this.chart.plotTop;
      }
      this.len = this.width = this.height = (center[2] - center[3]) * pick76(this.sector, 1) / 2;
    }
  }
  function setAxisTranslation() {
    const axisProto = this.constructor.prototype;
    axisProto.setAxisTranslation.call(this);
    if (this.center) {
      if (this.isCircular) {
        this.transA = (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1);
      } else {
        this.transA = (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1);
      }
      if (this.isXAxis) {
        this.minPixelPadding = this.transA * this.minPointOffset;
      } else {
        this.minPixelPadding = 0;
      }
    }
  }
  function setOptions6(userOptions) {
    const { coll } = this;
    const { angular, inverted, polar } = this.chart;
    let defaultPolarOptions = {};
    if (angular) {
      if (!this.isXAxis) {
        defaultPolarOptions = merge71(defaultOptions17.yAxis, RadialAxis2.radialDefaultOptions.radialGauge);
      }
    } else if (polar) {
      defaultPolarOptions = this.horiz ? merge71(defaultOptions17.xAxis, RadialAxis2.radialDefaultOptions.circular) : merge71(coll === "xAxis" ? defaultOptions17.xAxis : defaultOptions17.yAxis, RadialAxis2.radialDefaultOptions.radial);
    }
    if (inverted && coll === "yAxis") {
      defaultPolarOptions.stackLabels = isObject17(defaultOptions17.yAxis, true) ? defaultOptions17.yAxis.stackLabels : {};
      defaultPolarOptions.reversedStacks = true;
    }
    const options2 = this.options = merge71(defaultPolarOptions, userOptions);
    if (!options2.plotBands) {
      options2.plotBands = [];
    }
    fireEvent39(this, "afterSetOptions");
  }
  function wrapTickGetMarkPath2(proceed, x, y, tickLength, tickWidth, horiz, renderer) {
    const axis = this.axis;
    let endPoint, ret;
    if (axis.isRadial) {
      endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);
      ret = [
        "M",
        x,
        y,
        "L",
        endPoint.x,
        endPoint.y
      ];
    } else {
      ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);
    }
    return ret;
  }
})(RadialAxis || (RadialAxis = {}));
var RadialAxis_default = RadialAxis;

// node_modules/highcharts/es-modules/Series/PolarComposition.js
var { animObject: animObject13 } = AnimationUtilities_default;
var { composed: composed23 } = Globals_default;
var { addEvent: addEvent66, defined: defined59, find: find14, isNumber: isNumber54, merge: merge72, pick: pick77, pushUnique: pushUnique26, relativeLength: relativeLength12, splat: splat15, uniqueKey: uniqueKey10, wrap: wrap7 } = Utilities_default;
function clipCircle(renderer, x, y, r, innerR) {
  const id = uniqueKey10(), clipPath = renderer.createElement("clipPath").attr({
    id
  }).add(renderer.defs), wrapper = innerR ? renderer.arc(x, y, r, innerR, 0, 2 * Math.PI).add(clipPath) : renderer.circle(x, y, r).add(clipPath);
  wrapper.id = id;
  wrapper.clipPath = clipPath;
  return wrapper;
}
function findAlignments(angle, options2) {
  let align, verticalAlign;
  if (options2.align === null) {
    if (angle > 20 && angle < 160) {
      align = "left";
    } else if (angle > 200 && angle < 340) {
      align = "right";
    } else {
      align = "center";
    }
    options2.align = align;
  }
  if (options2.verticalAlign === null) {
    if (angle < 45 || angle > 315) {
      verticalAlign = "bottom";
    } else if (angle > 135 && angle < 225) {
      verticalAlign = "top";
    } else {
      verticalAlign = "middle";
    }
    options2.verticalAlign = verticalAlign;
  }
  return options2;
}
function getConnectors(segment, index, calculateNeighbours, connectEnds) {
  const smoothing = 1.5, denom = smoothing + 1, addedNumber = connectEnds ? 1 : 0;
  let i, leftContX, leftContY, rightContX, rightContY, jointAngle;
  if (index >= 0 && index <= segment.length - 1) {
    i = index;
  } else if (index < 0) {
    i = segment.length - 1 + index;
  } else {
    i = 0;
  }
  const prevPointInd = i - 1 < 0 ? segment.length - (1 + addedNumber) : i - 1, nextPointInd = i + 1 > segment.length - 1 ? addedNumber : i + 1, previousPoint = segment[prevPointInd], nextPoint = segment[nextPointInd], previousX = previousPoint.plotX, previousY = previousPoint.plotY, nextX = nextPoint.plotX, nextY = nextPoint.plotY, plotX = segment[i].plotX, plotY = segment[i].plotY;
  leftContX = (smoothing * plotX + previousX) / denom;
  leftContY = (smoothing * plotY + previousY) / denom;
  rightContX = (smoothing * plotX + nextX) / denom;
  rightContY = (smoothing * plotY + nextY) / denom;
  const dLControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2)), dRControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2)), leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX), rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);
  jointAngle = Math.PI / 2 + (leftContAngle + rightContAngle) / 2;
  if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {
    jointAngle -= Math.PI;
  }
  leftContX = plotX + Math.cos(jointAngle) * dLControlPoint;
  leftContY = plotY + Math.sin(jointAngle) * dLControlPoint;
  rightContX = plotX + Math.cos(Math.PI + jointAngle) * dRControlPoint;
  rightContY = plotY + Math.sin(Math.PI + jointAngle) * dRControlPoint;
  const ret = {
    rightContX,
    rightContY,
    leftContX,
    leftContY,
    plotX,
    plotY
  };
  if (calculateNeighbours) {
    ret.prevPointCont = getConnectors(segment, prevPointInd, false, connectEnds);
  }
  return ret;
}
function onChartAfterDrawChartBox() {
  (this.pane || []).forEach((pane2) => {
    pane2.render();
  });
}
function onChartAfterInit2(event) {
  const xAxis2 = event.args[0].xAxis, yAxis2 = event.args[0].yAxis, chart = event.args[0].chart;
  if (xAxis2 && yAxis2) {
    if (yAxis2.gridLineInterpolation === "polygon") {
      xAxis2.startOnTick = true;
      xAxis2.endOnTick = true;
    } else if (xAxis2.gridLineInterpolation === "polygon" && chart.inverted) {
      yAxis2.startOnTick = true;
      yAxis2.endOnTick = true;
    }
  }
}
function onChartCreateAxes() {
  if (!this.pane) {
    this.pane = [];
  }
  this.options.pane = splat15(this.options.pane || {});
  this.options.pane.forEach((paneOptions) => {
    new Pane_default(
      // eslint-disable-line no-new
      paneOptions,
      this
    );
  }, this);
}
function onPointerGetSelectionBox(event) {
  const marker = event.args.marker, xAxis2 = this.chart.xAxis[0], yAxis2 = this.chart.yAxis[0], inverted = this.chart.inverted, radialAxis = inverted ? yAxis2 : xAxis2, linearAxis = inverted ? xAxis2 : yAxis2;
  if (this.chart.polar) {
    event.preventDefault();
    const start = (marker.attr ? marker.attr("start") : marker.start) - radialAxis.startAngleRad, r = marker.attr ? marker.attr("r") : marker.r, end = (marker.attr ? marker.attr("end") : marker.end) - radialAxis.startAngleRad, innerR = marker.attr ? marker.attr("innerR") : marker.innerR;
    event.result.x = start + radialAxis.pos;
    event.result.width = end - start;
    event.result.y = linearAxis.len + linearAxis.pos - r;
    event.result.height = r - innerR;
  }
}
function onPointerGetSelectionMarkerAttrs(event) {
  const chart = this.chart;
  if (chart.polar && chart.hoverPane && chart.hoverPane.axis) {
    event.preventDefault();
    const center = chart.hoverPane.center, mouseDownX = chart.mouseDownX || 0, mouseDownY = chart.mouseDownY || 0, chartY = event.args.chartY, chartX = event.args.chartX, fullCircle = Math.PI * 2, startAngleRad = chart.hoverPane.axis.startAngleRad, endAngleRad = chart.hoverPane.axis.endAngleRad, linearAxis = chart.inverted ? chart.xAxis[0] : chart.yAxis[0], attrs = {};
    let shapeType = "arc";
    attrs.x = center[0] + chart.plotLeft;
    attrs.y = center[1] + chart.plotTop;
    if (this.zoomHor) {
      const paneRadRange = startAngleRad > 0 ? endAngleRad - startAngleRad : Math.abs(startAngleRad) + Math.abs(endAngleRad);
      let startAngle = Math.atan2(mouseDownY - chart.plotTop - center[1], mouseDownX - chart.plotLeft - center[0]) - startAngleRad, endAngle = Math.atan2(chartY - chart.plotTop - center[1], chartX - chart.plotLeft - center[0]) - startAngleRad;
      attrs.r = center[2] / 2;
      attrs.innerR = center[3] / 2;
      if (startAngle <= 0) {
        startAngle += fullCircle;
      }
      if (endAngle <= 0) {
        endAngle += fullCircle;
      }
      if (endAngle < startAngle) {
        endAngle = [startAngle, startAngle = endAngle][0];
      }
      if (paneRadRange < fullCircle) {
        const swapAngle = endAngleRad + (fullCircle - paneRadRange) / 2;
        if (startAngleRad + endAngle > swapAngle) {
          endAngle = startAngle;
          startAngle = startAngleRad <= 0 ? startAngleRad : 0;
        }
      }
      const start = attrs.start = Math.max(startAngle + startAngleRad, startAngleRad), end = attrs.end = Math.min(endAngle + startAngleRad, endAngleRad);
      if (linearAxis.options.gridLineInterpolation === "polygon") {
        const radialAxis = chart.hoverPane.axis, min4 = start - radialAxis.startAngleRad + radialAxis.pos, max4 = end - start;
        let path = linearAxis.getPlotLinePath({
          value: linearAxis.max
        }), pathStart = radialAxis.toValue(min4), pathEnd = radialAxis.toValue(min4 + max4);
        if (pathStart < radialAxis.getExtremes().min) {
          const { min: min5, max: max5 } = radialAxis.getExtremes();
          pathStart = max5 - (min5 - pathStart);
        }
        if (pathEnd < radialAxis.getExtremes().min) {
          const { min: min5, max: max5 } = radialAxis.getExtremes();
          pathEnd = max5 - (min5 - pathEnd);
        }
        if (pathEnd < pathStart) {
          pathEnd = [pathStart, pathStart = pathEnd][0];
        }
        path = trimPath(path, pathStart, pathEnd, radialAxis);
        path.push([
          "L",
          center[0] + chart.plotLeft,
          chart.plotTop + center[1]
        ]);
        attrs.d = path;
        shapeType = "path";
      }
    }
    if (this.zoomVert) {
      const linearAxis2 = chart.inverted ? chart.xAxis[0] : chart.yAxis[0];
      let innerR = Math.sqrt(Math.pow(mouseDownX - chart.plotLeft - center[0], 2) + Math.pow(mouseDownY - chart.plotTop - center[1], 2)), r = Math.sqrt(Math.pow(chartX - chart.plotLeft - center[0], 2) + Math.pow(chartY - chart.plotTop - center[1], 2));
      if (r < innerR) {
        innerR = [r, r = innerR][0];
      }
      if (r > center[2] / 2) {
        r = center[2] / 2;
      }
      if (innerR < center[3] / 2) {
        innerR = center[3] / 2;
      }
      if (!this.zoomHor) {
        attrs.start = startAngleRad;
        attrs.end = endAngleRad;
      }
      attrs.r = r;
      attrs.innerR = innerR;
      if (linearAxis2.options.gridLineInterpolation === "polygon") {
        const end = linearAxis2.toValue(linearAxis2.len + linearAxis2.pos - innerR), start = linearAxis2.toValue(linearAxis2.len + linearAxis2.pos - r), path = linearAxis2.getPlotLinePath({
          value: start
        }).concat(linearAxis2.getPlotLinePath({
          value: end,
          reverse: true
        }));
        attrs.d = path;
        shapeType = "path";
      }
    }
    if (this.zoomHor && this.zoomVert && linearAxis.options.gridLineInterpolation === "polygon") {
      const radialAxis = chart.hoverPane.axis, start = attrs.start || 0, end = attrs.end || 0, min4 = start - radialAxis.startAngleRad + radialAxis.pos, max4 = end - start, pathStart = radialAxis.toValue(min4), pathEnd = radialAxis.toValue(min4 + max4);
      if (attrs.d instanceof Array) {
        let innerPath = attrs.d.slice(0, attrs.d.length / 2), outerPath = attrs.d.slice(attrs.d.length / 2, attrs.d.length);
        outerPath = [...outerPath].reverse();
        const radialAxis2 = chart.hoverPane.axis;
        innerPath = trimPath(innerPath, pathStart, pathEnd, radialAxis2);
        outerPath = trimPath(outerPath, pathStart, pathEnd, radialAxis2);
        if (outerPath) {
          outerPath[0][0] = "L";
        }
        outerPath = [...outerPath].reverse();
        attrs.d = innerPath.concat(outerPath);
        shapeType = "path";
      }
    }
    event.attrs = attrs;
    event.shapeType = shapeType;
  }
}
function onSeriesAfterInit() {
  const chart = this.chart;
  if (chart.polar) {
    this.polar = new PolarAdditions(this);
    if (chart.inverted) {
      this.isRadialSeries = true;
      if (this.is("column")) {
        this.isRadialBar = true;
      }
    }
  }
}
function onSeriesAfterTranslate() {
  if (this.chart.polar && this.xAxis) {
    const series = this, { xAxis: xAxis2, yAxis: yAxis2 } = series, chart = series.chart;
    series.kdByAngle = chart.tooltip && chart.tooltip.shared;
    if (series.kdByAngle || chart.inverted) {
      series.searchPoint = searchPointByAngleOrInverted;
    } else {
      series.options.findNearestPointBy = "xy";
    }
    const points = series.points;
    let i = points.length;
    while (i--) {
      if (!series.is("column") && !series.is("columnrange")) {
        series.polar.toXY(points[i]);
      }
      if (!chart.hasParallelCoordinates && !series.yAxis.reversed) {
        if (pick77(points[i].y, Number.MIN_VALUE) < yAxis2.min || points[i].x < xAxis2.min || points[i].x > xAxis2.max) {
          points[i].isNull = true;
          points[i].plotY = NaN;
        } else {
          points[i].isNull = points[i].isValid && !points[i].isValid();
        }
      }
    }
    if (!this.hasClipCircleSetter) {
      this.hasClipCircleSetter = !!series.eventsToUnbind.push(addEvent66(series, "afterRender", function() {
        let circ;
        if (chart.polar && this.options.clip !== false) {
          circ = this.yAxis.pane.center;
          if (!this.clipCircle) {
            this.clipCircle = clipCircle(chart.renderer, circ[0], circ[1], circ[2] / 2, circ[3] / 2);
          } else {
            this.clipCircle.animate({
              x: circ[0],
              y: circ[1],
              r: circ[2] / 2,
              innerR: circ[3] / 2
            });
          }
          this.group.clip(this.clipCircle);
          this.setClip = Globals_default.noop;
        }
      }));
    }
  }
}
function searchPointByAngleOrInverted(e) {
  const series = this, chart = series.chart, xAxis2 = series.xAxis, yAxis2 = series.yAxis, center = xAxis2.pane && xAxis2.pane.center, plotX = e.chartX - (center && center[0] || 0) - chart.plotLeft, plotY = e.chartY - (center && center[1] || 0) - chart.plotTop;
  const searchKDTreePoint = chart.inverted ? {
    clientX: e.chartX - yAxis2.pos,
    plotY: e.chartY - xAxis2.pos
  } : {
    clientX: 180 + Math.atan2(plotX, plotY) * (-180 / Math.PI)
  };
  return series.searchKDTree(searchKDTreePoint);
}
function trimPath(path, start, end, radialAxis) {
  const tickInterval = radialAxis.tickInterval, ticks = radialAxis.tickPositions;
  let lastTick = find14(ticks, (tick) => tick >= end), firstTick = find14([...ticks].reverse(), (tick) => tick <= start);
  if (!defined59(lastTick)) {
    lastTick = ticks[ticks.length - 1];
  }
  if (!defined59(firstTick)) {
    firstTick = ticks[0];
    lastTick += tickInterval;
    path[0][0] = "L";
    path.unshift(path[path.length - 3]);
  }
  path = path.slice(ticks.indexOf(firstTick), ticks.indexOf(lastTick) + 1);
  path[0][0] = "M";
  return path;
}
function wrapChartGet(proceed, id) {
  return find14(this.pane || [], (pane2) => (
    // @todo remove id or define id type:
    pane2.options.id === id
  )) || proceed.call(this, id);
}
function wrapColumnSeriesAlignDataLabel(proceed, point, dataLabel, options2, alignTo, isNew) {
  const chart = this.chart, inside = pick77(options2.inside, !!this.options.stacking);
  let angle, shapeArgs, labelPos;
  if (chart.polar) {
    angle = point.rectPlotX / Math.PI * 180;
    if (!chart.inverted) {
      options2 = findAlignments(angle, options2);
    } else {
      this.forceDL = chart.isInsidePlot(point.plotX, point.plotY);
      if (inside && point.shapeArgs) {
        shapeArgs = point.shapeArgs;
        labelPos = this.yAxis.postTranslate(
          // Angle
          ((shapeArgs.start || 0) + (shapeArgs.end || 0)) / 2 - this.xAxis.startAngleRad,
          // Radius
          point.barX + point.pointWidth / 2
        );
        alignTo = merge72(alignTo, {
          x: labelPos.x - chart.plotLeft,
          y: labelPos.y - chart.plotTop
        });
      } else if (point.tooltipPos) {
        alignTo = merge72(alignTo, {
          x: point.tooltipPos[0],
          y: point.tooltipPos[1]
        });
      }
      options2.align = pick77(options2.align, "center");
      options2.verticalAlign = pick77(options2.verticalAlign, "middle");
    }
    Series_default.prototype.alignDataLabel.call(this, point, dataLabel, options2, alignTo, isNew);
    if (this.isRadialBar && point.shapeArgs && point.shapeArgs.start === point.shapeArgs.end) {
      dataLabel.hide();
    } else {
      dataLabel.show();
    }
  } else {
    proceed.call(this, point, dataLabel, options2, alignTo, isNew);
  }
}
function onAfterColumnTranslate() {
  const series = this, options2 = series.options, stacking = options2.stacking, chart = series.chart, xAxis2 = series.xAxis, yAxis2 = series.yAxis, reversed = yAxis2.reversed, center = yAxis2.center, startAngleRad = xAxis2.startAngleRad, endAngleRad = xAxis2.endAngleRad, visibleRange = endAngleRad - startAngleRad;
  let threshold = options2.threshold, thresholdAngleRad = 0, points, point, i, yMin, yMax, start = 0, end = 0, tooltipPos, pointX, pointY, stackValues, stack, barX, innerR, r;
  if (xAxis2.isRadial) {
    points = series.points;
    i = points.length;
    yMin = yAxis2.translate(yAxis2.min);
    yMax = yAxis2.translate(yAxis2.max);
    threshold = options2.threshold || 0;
    if (chart.inverted) {
      if (isNumber54(threshold)) {
        thresholdAngleRad = yAxis2.translate(threshold);
        if (defined59(thresholdAngleRad)) {
          if (thresholdAngleRad < 0) {
            thresholdAngleRad = 0;
          } else if (thresholdAngleRad > visibleRange) {
            thresholdAngleRad = visibleRange;
          }
          series.translatedThreshold = thresholdAngleRad + startAngleRad;
        }
      }
    }
    while (i--) {
      point = points[i];
      barX = point.barX;
      pointX = point.x;
      pointY = point.y;
      point.shapeType = "arc";
      if (chart.inverted) {
        point.plotY = yAxis2.translate(pointY);
        if (stacking && yAxis2.stacking) {
          stack = yAxis2.stacking.stacks[(pointY < 0 ? "-" : "") + series.stackKey];
          if (series.visible && stack && stack[pointX]) {
            if (!point.isNull) {
              stackValues = stack[pointX].points[series.getStackIndicator(void 0, pointX, series.index).key];
              start = yAxis2.translate(stackValues[0]);
              end = yAxis2.translate(stackValues[1]);
              if (defined59(start)) {
                start = Utilities_default.clamp(start, 0, visibleRange);
              }
            }
          }
        } else {
          start = thresholdAngleRad;
          end = point.plotY;
        }
        if (start > end) {
          end = [start, start = end][0];
        }
        if (!reversed) {
          if (start < yMin) {
            start = yMin;
          } else if (end > yMax) {
            end = yMax;
          } else if (end < yMin || start > yMax) {
            start = end = 0;
          }
        } else {
          if (end > yMin) {
            end = yMin;
          } else if (start < yMax) {
            start = yMax;
          } else if (start > yMin || end < yMax) {
            start = end = visibleRange;
          }
        }
        if (yAxis2.min > yAxis2.max) {
          start = end = reversed ? visibleRange : 0;
        }
        start += startAngleRad;
        end += startAngleRad;
        if (center) {
          point.barX = barX += center[3] / 2;
        }
        innerR = Math.max(barX, 0);
        r = Math.max(barX + point.pointWidth, 0);
        const brOption = options2.borderRadius, brValue = typeof brOption === "object" ? brOption.radius : brOption, borderRadius = relativeLength12(brValue || 0, r - innerR);
        point.shapeArgs = {
          x: center[0],
          y: center[1],
          r,
          innerR,
          start,
          end,
          borderRadius
        };
        point.opacity = start === end ? 0 : void 0;
        point.plotY = (defined59(series.translatedThreshold) && (start < series.translatedThreshold ? start : end)) - startAngleRad;
      } else {
        start = barX + startAngleRad;
        point.shapeArgs = series.polar.arc(point.yBottom, point.plotY, start, start + point.pointWidth);
        point.shapeArgs.borderRadius = 0;
      }
      series.polar.toXY(point);
      if (chart.inverted) {
        tooltipPos = yAxis2.postTranslate(point.rectPlotY, barX + point.pointWidth / 2);
        point.tooltipPos = [
          tooltipPos.x - chart.plotLeft,
          tooltipPos.y - chart.plotTop
        ];
      } else {
        point.tooltipPos = [point.plotX, point.plotY];
      }
      if (center) {
        point.ttBelow = point.plotY > center[1];
      }
    }
  }
}
function wrapLineSeriesGetGraphPath(proceed, points) {
  const series = this;
  let firstValid, popLastPoint;
  if (this.chart.polar) {
    points = points || this.points;
    for (let i = 0; i < points.length; i++) {
      if (!points[i].isNull) {
        firstValid = i;
        break;
      }
    }
    if (this.options.connectEnds !== false && typeof firstValid !== "undefined") {
      this.connectEnds = true;
      points.splice(points.length, 0, points[firstValid]);
      popLastPoint = true;
    }
    points.forEach((point) => {
      if (typeof point.polarPlotY === "undefined") {
        series.polar.toXY(point);
      }
    });
  }
  const ret = proceed.apply(this, [].slice.call(arguments, 1));
  if (popLastPoint) {
    points.pop();
  }
  return ret;
}
function wrapPointerGetCoordinates(proceed, e) {
  const chart = this.chart;
  let ret = {
    xAxis: [],
    yAxis: []
  };
  if (chart.polar) {
    chart.axes.forEach((axis) => {
      if (axis.coll === "colorAxis") {
        return;
      }
      const isXAxis = axis.isXAxis, center = axis.center, x = e.chartX - center[0] - chart.plotLeft, y = e.chartY - center[1] - chart.plotTop;
      ret[isXAxis ? "xAxis" : "yAxis"].push({
        axis,
        value: axis.translate(isXAxis ? Math.PI - Math.atan2(x, y) : (
          // Angle
          // distance from center
          Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))
        ), true)
      });
    });
  } else {
    ret = proceed.call(this, e);
  }
  return ret;
}
function wrapPointerPinch(proceed, e) {
  if (this.chart.polar) {
    return;
  }
  proceed.call(this, e);
}
function wrapSeriesAnimate(proceed, init3) {
  const series = this, chart = this.chart, group = this.group, markerGroup = this.markerGroup, center = this.xAxis && this.xAxis.center, plotLeft = chart.plotLeft, plotTop = chart.plotTop;
  let animation = this.options.animation, attribs, paneInnerR, graphic, shapeArgs, r, innerR;
  if (chart.polar) {
    if (series.isRadialBar) {
      if (!init3) {
        series.startAngleRad = pick77(series.translatedThreshold, series.xAxis.startAngleRad);
        Globals_default.seriesTypes.pie.prototype.animate.call(series, init3);
      }
    } else {
      animation = animObject13(animation);
      if (series.is("column")) {
        if (!init3) {
          paneInnerR = center[3] / 2;
          series.points.forEach((point) => {
            graphic = point.graphic;
            shapeArgs = point.shapeArgs;
            r = shapeArgs && shapeArgs.r;
            innerR = shapeArgs && shapeArgs.innerR;
            if (graphic && shapeArgs) {
              graphic.attr({
                r: paneInnerR,
                innerR: paneInnerR
              });
              graphic.animate({
                r,
                innerR
              }, series.options.animation);
            }
          });
        }
      } else {
        if (init3) {
          attribs = {
            translateX: center[0] + plotLeft,
            translateY: center[1] + plotTop,
            scaleX: 1e-3,
            scaleY: 1e-3
          };
          group.attr(attribs);
          if (markerGroup) {
            markerGroup.attr(attribs);
          }
        } else {
          attribs = {
            translateX: plotLeft,
            translateY: plotTop,
            scaleX: 1,
            scaleY: 1
          };
          group.animate(attribs, animation);
          if (markerGroup) {
            markerGroup.animate(attribs, animation);
          }
        }
      }
    }
  } else {
    proceed.call(this, init3);
  }
}
function wrapSplineSeriesGetPointSpline(proceed, segment, point, i) {
  let ret, connectors;
  if (this.chart.polar) {
    if (!i) {
      ret = ["M", point.plotX, point.plotY];
    } else {
      connectors = getConnectors(segment, i, true, this.connectEnds);
      const rightContX = connectors.prevPointCont && connectors.prevPointCont.rightContX;
      const rightContY = connectors.prevPointCont && connectors.prevPointCont.rightContY;
      ret = [
        "C",
        isNumber54(rightContX) ? rightContX : connectors.plotX,
        isNumber54(rightContY) ? rightContY : connectors.plotY,
        isNumber54(connectors.leftContX) ? connectors.leftContX : connectors.plotX,
        isNumber54(connectors.leftContY) ? connectors.leftContY : connectors.plotY,
        connectors.plotX,
        connectors.plotY
      ];
    }
  } else {
    ret = proceed.call(this, segment, point, i);
  }
  return ret;
}
function wrapPointPos(proceed, chartCoordinates, plotY = this.plotY) {
  if (!this.destroyed) {
    const { plotX, series } = this, { chart } = series;
    if (chart.polar && isNumber54(plotX) && isNumber54(plotY)) {
      return [
        plotX + (chartCoordinates ? chart.plotLeft : 0),
        plotY + (chartCoordinates ? chart.plotTop : 0)
      ];
    }
    return proceed.call(this, chartCoordinates, plotY);
  }
}
var PolarAdditions = class {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(AxisClass, ChartClass, PointerClass, SeriesClass, TickClass, PointClass, AreaSplineRangeSeriesClass, ColumnSeriesClass, LineSeriesClass, SplineSeriesClass) {
    Pane_default.compose(ChartClass, PointerClass);
    RadialAxis_default.compose(AxisClass, TickClass);
    if (pushUnique26(composed23, "Polar")) {
      const chartProto = ChartClass.prototype, pointProto2 = PointClass.prototype, pointerProto = PointerClass.prototype, seriesProto7 = SeriesClass.prototype;
      addEvent66(ChartClass, "afterDrawChartBox", onChartAfterDrawChartBox);
      addEvent66(ChartClass, "createAxes", onChartCreateAxes);
      addEvent66(ChartClass, "init", onChartAfterInit2);
      wrap7(chartProto, "get", wrapChartGet);
      wrap7(pointerProto, "getCoordinates", wrapPointerGetCoordinates);
      wrap7(pointerProto, "pinch", wrapPointerPinch);
      addEvent66(PointerClass, "getSelectionMarkerAttrs", onPointerGetSelectionMarkerAttrs);
      addEvent66(PointerClass, "getSelectionBox", onPointerGetSelectionBox);
      addEvent66(SeriesClass, "afterInit", onSeriesAfterInit);
      addEvent66(
        SeriesClass,
        "afterTranslate",
        onSeriesAfterTranslate,
        { order: 2 }
        // Run after translation of ||-coords
      );
      addEvent66(SeriesClass, "afterColumnTranslate", onAfterColumnTranslate, { order: 4 });
      wrap7(seriesProto7, "animate", wrapSeriesAnimate);
      wrap7(pointProto2, "pos", wrapPointPos);
      if (ColumnSeriesClass) {
        const columnProto7 = ColumnSeriesClass.prototype;
        wrap7(columnProto7, "alignDataLabel", wrapColumnSeriesAlignDataLabel);
        wrap7(columnProto7, "animate", wrapSeriesAnimate);
      }
      if (LineSeriesClass) {
        const lineProto2 = LineSeriesClass.prototype;
        wrap7(lineProto2, "getGraphPath", wrapLineSeriesGetGraphPath);
      }
      if (SplineSeriesClass) {
        const splineProto2 = SplineSeriesClass.prototype;
        wrap7(splineProto2, "getPointSpline", wrapSplineSeriesGetPointSpline);
        if (AreaSplineRangeSeriesClass) {
          const areaSplineRangeProto = AreaSplineRangeSeriesClass.prototype;
          areaSplineRangeProto.getPointSpline = splineProto2.getPointSpline;
        }
      }
    }
  }
  /* *
   *
   *  Constructor
   *
   * */
  constructor(series) {
    this.series = series;
  }
  /* *
   *
   *  Functions
   *
   * */
  arc(low2, high2, start, end) {
    const series = this.series, center = series.xAxis.center, len = series.yAxis.len, paneInnerR = center[3] / 2;
    let r = len - high2 + paneInnerR, innerR = len - pick77(low2, len) + paneInnerR;
    if (series.yAxis.reversed) {
      if (r < 0) {
        r = paneInnerR;
      }
      if (innerR < 0) {
        innerR = paneInnerR;
      }
    }
    return {
      x: center[0],
      y: center[1],
      r,
      innerR,
      start,
      end
    };
  }
  /**
   * Translate a point's plotX and plotY from the internal angle and radius
   * measures to true plotX, plotY coordinates
   * @private
   */
  toXY(point) {
    const series = this.series, chart = series.chart, xAxis2 = series.xAxis, yAxis2 = series.yAxis, plotX = point.plotX, inverted = chart.inverted, pointY = point.y;
    let plotY = point.plotY, radius = inverted ? plotX : yAxis2.len - plotY, clientX;
    if (inverted && series && !series.isRadialBar) {
      point.plotY = plotY = isNumber54(pointY) ? yAxis2.translate(pointY) : 0;
    }
    point.rectPlotX = plotX;
    point.rectPlotY = plotY;
    if (yAxis2.center) {
      radius += yAxis2.center[3] / 2;
    }
    if (isNumber54(plotY)) {
      const xy = inverted ? yAxis2.postTranslate(plotY, radius) : xAxis2.postTranslate(plotX, radius);
      point.plotX = point.polarPlotX = xy.x - chart.plotLeft;
      point.plotY = point.polarPlotY = xy.y - chart.plotTop;
    }
    if (series.kdByAngle) {
      clientX = (plotX / Math.PI * 180 + xAxis2.pane.options.startAngle) % 360;
      if (clientX < 0) {
        clientX += 360;
      }
      point.clientX = clientX;
    } else {
      point.clientX = point.plotX;
    }
  }
};
var PolarComposition_default = PolarAdditions;

// node_modules/highcharts/es-modules/Core/Axis/WaterfallAxis.js
var { composed: composed24 } = Globals_default;
var { addEvent: addEvent67, objectEach: objectEach28, pushUnique: pushUnique27 } = Utilities_default;
var WaterfallAxis;
(function(WaterfallAxis2) {
  function compose27(AxisClass, ChartClass) {
    if (pushUnique27(composed24, "Axis.Waterfall")) {
      addEvent67(AxisClass, "init", onAxisInit4);
      addEvent67(AxisClass, "afterBuildStacks", onAxisAfterBuildStacks);
      addEvent67(AxisClass, "afterRender", onAxisAfterRender2);
      addEvent67(ChartClass, "beforeRedraw", onChartBeforeRedraw2);
    }
  }
  WaterfallAxis2.compose = compose27;
  function onAxisAfterBuildStacks() {
    const axis = this, stacks = axis.waterfall.stacks;
    if (stacks) {
      stacks.changed = false;
      delete stacks.alreadyChanged;
    }
  }
  function onAxisAfterRender2() {
    const axis = this, stackLabelOptions = axis.options.stackLabels;
    if (stackLabelOptions?.enabled && axis.waterfall.stacks) {
      axis.waterfall.renderStackTotals();
    }
  }
  function onAxisInit4() {
    const axis = this;
    if (!axis.waterfall) {
      axis.waterfall = new Composition(axis);
    }
  }
  function onChartBeforeRedraw2() {
    const axes = this.axes, series = this.series;
    for (const serie of series) {
      if (serie.options.stacking) {
        for (const axis of axes) {
          if (!axis.isXAxis) {
            axis.waterfall.stacks.changed = true;
          }
        }
        break;
      }
    }
  }
  class Composition {
    /* *
     *
     *  Constructors
     *
     * */
    constructor(axis) {
      this.axis = axis;
      this.stacks = {
        changed: false
      };
    }
    /* *
     *
     *  Functions
     *
     * */
    /**
     * Calls StackItem.prototype.render function that creates and renders
     * stack total label for each waterfall stack item.
     *
     * @private
     * @function Highcharts.Axis#renderWaterfallStackTotals
     */
    renderStackTotals() {
      const yAxis2 = this.axis, waterfallStacks = yAxis2.waterfall.stacks, stackTotalGroup = yAxis2.stacking?.stackTotalGroup, dummyStackItem = new StackItem_default(yAxis2, yAxis2.options.stackLabels || {}, false, 0, void 0);
      this.dummyStackItem = dummyStackItem;
      if (stackTotalGroup) {
        objectEach28(waterfallStacks, (type) => {
          objectEach28(type, (stackItem, key) => {
            dummyStackItem.total = stackItem.stackTotal;
            dummyStackItem.x = +key;
            if (stackItem.label) {
              dummyStackItem.label = stackItem.label;
            }
            StackItem_default.prototype.render.call(dummyStackItem, stackTotalGroup);
            stackItem.label = dummyStackItem.label;
            delete dummyStackItem.label;
          });
        });
      }
      dummyStackItem.total = null;
    }
  }
  WaterfallAxis2.Composition = Composition;
})(WaterfallAxis || (WaterfallAxis = {}));
var WaterfallAxis_default = WaterfallAxis;

// node_modules/highcharts/es-modules/Series/Waterfall/WaterfallPoint.js
var { isNumber: isNumber55 } = Utilities_default;
var WaterfallPoint = class extends ColumnSeries_default.prototype.pointClass {
  /* *
   *
   *  Functions
   *
   * */
  getClassName() {
    let className = Point_default.prototype.getClassName.call(this);
    if (this.isSum) {
      className += " highcharts-sum";
    } else if (this.isIntermediateSum) {
      className += " highcharts-intermediate-sum";
    }
    return className;
  }
  // Pass the null test in ColumnSeries.translate.
  isValid() {
    return isNumber55(this.y) || this.isSum || Boolean(this.isIntermediateSum);
  }
};
var WaterfallPoint_default = WaterfallPoint;

// node_modules/highcharts/es-modules/Series/Waterfall/WaterfallSeriesDefaults.js
var WaterfallSeriesDefaults = {
  /**
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @apioption plotOptions.waterfall.color
   */
  /**
   * The color used specifically for positive point columns. When not
   * specified, the general series color is used.
   *
   * In styled mode, the waterfall colors can be set with the
   * `.highcharts-point-negative`, `.highcharts-sum` and
   * `.highcharts-intermediate-sum` classes.
   *
   * @sample {highcharts} highcharts/demo/waterfall/
   *         Waterfall
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product   highcharts
   * @apioption plotOptions.waterfall.upColor
   */
  dataLabels: {
    inside: true
  },
  /**
   * The width of the line connecting waterfall columns.
   *
   * @product highcharts
   */
  lineWidth: 1,
  /**
   * The color of the line that connects columns in a waterfall series.
   *
   * In styled mode, the stroke can be set with the `.highcharts-graph`
   * class.
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since   3.0
   * @product highcharts
   */
  lineColor: "#333333",
  /**
   * A name for the dash style to use for the line connecting the columns
   * of the waterfall series. Possible values: Dash, DashDot, Dot,
   * LongDash, LongDashDot, LongDashDotDot, ShortDash, ShortDashDot,
   * ShortDashDotDot, ShortDot, Solid
   *
   * In styled mode, the stroke dash-array can be set with the
   * `.highcharts-graph` class.
   *
   * @type    {Highcharts.DashStyleValue}
   * @since   3.0
   * @product highcharts
   */
  dashStyle: "Dot",
  /**
   * The color of the border of each waterfall column.
   *
   * In styled mode, the border stroke can be set with the
   * `.highcharts-point` class.
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since   3.0
   * @product highcharts
   */
  borderColor: "#333333",
  states: {
    hover: {
      lineWidthPlus: 0
      // #3126
    }
  }
};
var WaterfallSeriesDefaults_default = WaterfallSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Waterfall/WaterfallSeries.js
var { column: ColumnSeries9, line: LineSeries6 } = SeriesRegistry_default.seriesTypes;
var { addEvent: addEvent68, arrayMax: arrayMax10, arrayMin: arrayMin9, correctFloat: correctFloat14, crisp: crisp13, extend: extend60, isNumber: isNumber56, merge: merge73, objectEach: objectEach29, pick: pick78 } = Utilities_default;
function ownProp(obj, key) {
  return Object.hasOwnProperty.call(obj, key);
}
var WaterfallSeries = class extends ColumnSeries9 {
  /* *
   *
   *  Functions
   *
   * */
  // After generating points, set y-values for all sums.
  generatePoints() {
    ColumnSeries9.prototype.generatePoints.apply(this);
    const processedYData = this.getColumn("y", true);
    for (let i = 0, len = this.points.length; i < len; i++) {
      const point = this.points[i], y = processedYData[i];
      if (isNumber56(y) && (point.isIntermediateSum || point.isSum)) {
        point.y = correctFloat14(y);
      }
    }
  }
  // Call default processData then override yData to reflect waterfall's
  // extremes on yAxis
  processData(force) {
    const series = this, options2 = series.options, yData = series.getColumn("y"), points = options2.data, dataLength = yData.length, threshold = options2.threshold || 0;
    let point, subSum, sum2, dataMin, dataMax, y;
    sum2 = subSum = dataMin = dataMax = 0;
    for (let i = 0; i < dataLength; i++) {
      y = yData[i];
      point = points?.[i] || {};
      if (y === "sum" || point.isSum) {
        yData[i] = correctFloat14(sum2);
      } else if (y === "intermediateSum" || point.isIntermediateSum) {
        yData[i] = correctFloat14(subSum);
        subSum = 0;
      } else {
        sum2 += y;
        subSum += y;
      }
      dataMin = Math.min(sum2, dataMin);
      dataMax = Math.max(sum2, dataMax);
    }
    super.processData.call(this, force);
    if (!options2.stacking) {
      series.dataMin = dataMin + threshold;
      series.dataMax = dataMax;
    }
    return;
  }
  // Return y value or string if point is sum
  toYData(pt) {
    if (pt.isSum) {
      return "sum";
    }
    if (pt.isIntermediateSum) {
      return "intermediateSum";
    }
    return pt.y;
  }
  // Postprocess mapping between options and SVG attributes
  pointAttribs(point, state) {
    const upColor = this.options.upColor;
    if (upColor && !point.options.color && isNumber56(point.y)) {
      point.color = point.y > 0 ? upColor : void 0;
    }
    const attr18 = ColumnSeries9.prototype.pointAttribs.call(this, point, state);
    delete attr18.dashstyle;
    return attr18;
  }
  // Return an empty path initially, because we need to know the stroke-width
  // in order to set the final path.
  getGraphPath() {
    return [["M", 0, 0]];
  }
  // Draw columns' connector lines
  getCrispPath() {
    const data = this.data.filter((d) => isNumber56(d.y)), yAxis2 = this.yAxis, length = data.length, graphLineWidth = this.graph?.strokeWidth() || 0, reversedXAxis = this.xAxis.reversed, reversedYAxis = this.yAxis.reversed, stacking = this.options.stacking, path = [];
    for (let i = 1; i < length; i++) {
      if (!// Skip lines that would pass over the null point (#18636)
      (this.options.connectNulls || isNumber56(this.data[data[i].index - 1].y))) {
        continue;
      }
      const box = data[i].box, prevPoint = data[i - 1], prevY = prevPoint.y || 0, prevBox = data[i - 1].box;
      if (!box || !prevBox) {
        continue;
      }
      const prevStack = yAxis2.waterfall.stacks[this.stackKey], isPos = prevY > 0 ? -prevBox.height : 0;
      if (prevStack && prevBox && box) {
        const prevStackX = prevStack[i - 1];
        let yPos;
        if (stacking) {
          const connectorThreshold = prevStackX.connectorThreshold;
          yPos = crisp13(yAxis2.translate(connectorThreshold, false, true, false, true) + (reversedYAxis ? isPos : 0), graphLineWidth);
        } else {
          yPos = crisp13(prevBox.y + (prevPoint.minPointLengthOffset || 0), graphLineWidth);
        }
        path.push([
          "M",
          (prevBox.x || 0) + (reversedXAxis ? 0 : prevBox.width || 0),
          yPos
        ], [
          "L",
          (box.x || 0) + (reversedXAxis ? box.width || 0 : 0),
          yPos
        ]);
      }
      if (prevBox && path.length && (!stacking && prevY < 0 && !reversedYAxis || prevY > 0 && reversedYAxis)) {
        const nextLast = path[path.length - 2];
        if (nextLast && typeof nextLast[2] === "number") {
          nextLast[2] += prevBox.height || 0;
        }
        const last = path[path.length - 1];
        if (last && typeof last[2] === "number") {
          last[2] += prevBox.height || 0;
        }
      }
    }
    return path;
  }
  // The graph is initially drawn with an empty definition, then updated with
  // crisp rendering.
  drawGraph() {
    LineSeries6.prototype.drawGraph.call(this);
    if (this.graph) {
      this.graph.attr({
        d: this.getCrispPath()
      });
    }
  }
  // Waterfall has stacking along the x-values too.
  setStackedPoints(axis) {
    const series = this, options2 = series.options, waterfallStacks = axis.waterfall?.stacks, seriesThreshold = options2.threshold || 0, stackKey = series.stackKey, xData = series.getColumn("x"), yData = series.getColumn("y"), xLength = xData.length;
    let stackThreshold = seriesThreshold, interSum = stackThreshold, actualStackX, totalYVal = 0, actualSum = 0, prevSum = 0, statesLen, posTotal, negTotal, xPoint, yVal, x, alreadyChanged, changed;
    const calculateStackState = (firstS, nextS, sInx, sOff) => {
      if (actualStackX) {
        if (!statesLen) {
          actualStackX.stackState[0] = firstS;
          statesLen = actualStackX.stackState.length;
        } else {
          for (sInx; sInx < statesLen; sInx++) {
            actualStackX.stackState[sInx] += sOff;
          }
        }
        actualStackX.stackState.push(actualStackX.stackState[statesLen - 1] + nextS);
      }
    };
    if (axis.stacking && waterfallStacks) {
      if (series.reserveSpace()) {
        changed = waterfallStacks.changed;
        alreadyChanged = waterfallStacks.alreadyChanged;
        if (alreadyChanged && alreadyChanged.indexOf(stackKey) < 0) {
          changed = true;
        }
        if (!waterfallStacks[stackKey]) {
          waterfallStacks[stackKey] = {};
        }
        const actualStack = waterfallStacks[stackKey];
        if (actualStack) {
          for (let i = 0; i < xLength; i++) {
            x = xData[i];
            if (!actualStack[x] || changed) {
              actualStack[x] = {
                negTotal: 0,
                posTotal: 0,
                stackTotal: 0,
                threshold: 0,
                stateIndex: 0,
                stackState: [],
                label: changed && actualStack[x] ? actualStack[x].label : void 0
              };
            }
            actualStackX = actualStack[x];
            yVal = yData[i];
            if (yVal >= 0) {
              actualStackX.posTotal += yVal;
            } else {
              actualStackX.negTotal += yVal;
            }
            xPoint = options2.data[i];
            posTotal = actualStackX.absolutePos = actualStackX.posTotal;
            negTotal = actualStackX.absoluteNeg = actualStackX.negTotal;
            actualStackX.stackTotal = posTotal + negTotal;
            statesLen = actualStackX.stackState.length;
            if (xPoint?.isIntermediateSum) {
              calculateStackState(prevSum, actualSum, 0, prevSum);
              prevSum = actualSum;
              actualSum = seriesThreshold;
              stackThreshold ^= interSum;
              interSum ^= stackThreshold;
              stackThreshold ^= interSum;
            } else if (xPoint?.isSum) {
              calculateStackState(seriesThreshold, totalYVal, statesLen, 0);
              stackThreshold = seriesThreshold;
            } else {
              calculateStackState(stackThreshold, yVal, 0, totalYVal);
              if (xPoint) {
                totalYVal += yVal;
                actualSum += yVal;
              }
            }
            actualStackX.stateIndex++;
            actualStackX.threshold = stackThreshold;
            stackThreshold += actualStackX.stackTotal;
          }
        }
        waterfallStacks.changed = false;
        if (!waterfallStacks.alreadyChanged) {
          waterfallStacks.alreadyChanged = [];
        }
        waterfallStacks.alreadyChanged.push(stackKey);
      }
    }
  }
  // Extremes for a non-stacked series are recorded in processData.
  // In case of stacking, use Series.stackedYData to calculate extremes.
  getExtremes() {
    const stacking = this.options.stacking;
    let yAxis2, waterfallStacks, stackedYNeg, stackedYPos;
    if (stacking) {
      yAxis2 = this.yAxis;
      waterfallStacks = yAxis2.waterfall.stacks;
      stackedYNeg = this.stackedYNeg = [];
      stackedYPos = this.stackedYPos = [];
      if (stacking === "overlap") {
        objectEach29(waterfallStacks[this.stackKey], function(stackX) {
          stackedYNeg.push(arrayMin9(stackX.stackState));
          stackedYPos.push(arrayMax10(stackX.stackState));
        });
      } else {
        objectEach29(waterfallStacks[this.stackKey], function(stackX) {
          stackedYNeg.push(stackX.negTotal + stackX.threshold);
          stackedYPos.push(stackX.posTotal + stackX.threshold);
        });
      }
      return {
        dataMin: arrayMin9(stackedYNeg),
        dataMax: arrayMax10(stackedYPos)
      };
    }
    return {
      dataMin: this.dataMin,
      dataMax: this.dataMax
    };
  }
};
WaterfallSeries.defaultOptions = merge73(ColumnSeries9.defaultOptions, WaterfallSeriesDefaults_default);
WaterfallSeries.compose = WaterfallAxis_default.compose;
extend60(WaterfallSeries.prototype, {
  pointValKey: "y",
  // Property needed to prevent lines between the columns from disappearing
  // when negativeColor is used.
  showLine: true,
  pointClass: WaterfallPoint_default
});
addEvent68(WaterfallSeries, "afterColumnTranslate", function() {
  const series = this, { options: options2, points, yAxis: yAxis2 } = series, minPointLength = pick78(options2.minPointLength, 5), halfMinPointLength = minPointLength / 2, threshold = options2.threshold || 0, stacking = options2.stacking, actualStack = yAxis2.waterfall.stacks[series.stackKey], processedYData = series.getColumn("y", true);
  let previousIntermediate = threshold, previousY = threshold, y, total, yPos, hPos;
  for (let i = 0; i < points.length; i++) {
    const point = points[i], yValue = processedYData[i], shapeArgs = point.shapeArgs, box = extend60({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }, shapeArgs || {});
    point.box = box;
    const range2 = [0, yValue], pointY = point.y || 0;
    if (stacking) {
      if (actualStack) {
        const actualStackX = actualStack[i];
        if (stacking === "overlap") {
          total = actualStackX.stackState[actualStackX.stateIndex--];
          y = pointY >= 0 ? total : total - pointY;
          if (ownProp(actualStackX, "absolutePos")) {
            delete actualStackX.absolutePos;
          }
          if (ownProp(actualStackX, "absoluteNeg")) {
            delete actualStackX.absoluteNeg;
          }
        } else {
          if (pointY >= 0) {
            total = actualStackX.threshold + actualStackX.posTotal;
            actualStackX.posTotal -= pointY;
            y = total;
          } else {
            total = actualStackX.threshold + actualStackX.negTotal;
            actualStackX.negTotal -= pointY;
            y = total - pointY;
          }
          if (!actualStackX.posTotal) {
            if (isNumber56(actualStackX.absolutePos) && ownProp(actualStackX, "absolutePos")) {
              actualStackX.posTotal = actualStackX.absolutePos;
              delete actualStackX.absolutePos;
            }
          }
          if (!actualStackX.negTotal) {
            if (isNumber56(actualStackX.absoluteNeg) && ownProp(actualStackX, "absoluteNeg")) {
              actualStackX.negTotal = actualStackX.absoluteNeg;
              delete actualStackX.absoluteNeg;
            }
          }
        }
        if (!point.isSum) {
          actualStackX.connectorThreshold = actualStackX.threshold + actualStackX.stackTotal;
        }
        if (yAxis2.reversed) {
          yPos = pointY >= 0 ? y - pointY : y + pointY;
          hPos = y;
        } else {
          yPos = y;
          hPos = y - pointY;
        }
        point.below = yPos <= threshold;
        box.y = yAxis2.translate(yPos, false, true, false, true);
        box.height = Math.abs(box.y - yAxis2.translate(hPos, false, true, false, true));
        const dummyStackItem = yAxis2.waterfall.dummyStackItem;
        if (dummyStackItem) {
          dummyStackItem.x = i;
          dummyStackItem.label = actualStack[i].label;
          dummyStackItem.setOffset(series.pointXOffset || 0, series.barW || 0, series.stackedYNeg[i], series.stackedYPos[i], void 0, this.xAxis);
        }
      }
    } else {
      y = Math.max(previousY, previousY + pointY) + range2[0];
      box.y = yAxis2.translate(y, false, true, false, true);
      if (point.isSum) {
        box.y = yAxis2.translate(range2[1], false, true, false, true);
        box.height = Math.min(yAxis2.translate(range2[0], false, true, false, true), yAxis2.len) - box.y;
        point.below = range2[1] <= threshold;
      } else if (point.isIntermediateSum) {
        if (pointY >= 0) {
          yPos = range2[1] + previousIntermediate;
          hPos = previousIntermediate;
        } else {
          yPos = previousIntermediate;
          hPos = range2[1] + previousIntermediate;
        }
        if (yAxis2.reversed) {
          yPos ^= hPos;
          hPos ^= yPos;
          yPos ^= hPos;
        }
        box.y = yAxis2.translate(yPos, false, true, false, true);
        box.height = Math.abs(box.y - Math.min(yAxis2.translate(hPos, false, true, false, true), yAxis2.len));
        previousIntermediate += range2[1];
        point.below = yPos <= threshold;
      } else {
        box.height = yValue > 0 ? yAxis2.translate(previousY, false, true, false, true) - box.y : yAxis2.translate(previousY, false, true, false, true) - yAxis2.translate(previousY - yValue, false, true, false, true);
        previousY += yValue;
        point.below = previousY < threshold;
      }
      if (box.height < 0) {
        box.y += box.height;
        box.height *= -1;
      }
    }
    point.plotY = box.y;
    point.yBottom = box.y + box.height;
    if (box.height <= minPointLength && !point.isNull) {
      box.height = minPointLength;
      box.y -= halfMinPointLength;
      point.yBottom = box.y + box.height;
      point.plotY = box.y;
      if (pointY < 0) {
        point.minPointLengthOffset = -halfMinPointLength;
      } else {
        point.minPointLengthOffset = halfMinPointLength;
      }
    } else {
      if (point.isNull) {
        box.width = 0;
      }
      point.minPointLengthOffset = 0;
    }
    const tooltipY = point.plotY + (point.negative ? box.height : 0);
    if (point.below) {
      point.plotY += box.height;
    }
    if (point.tooltipPos) {
      if (series.chart.inverted) {
        point.tooltipPos[0] = yAxis2.len - tooltipY;
      } else {
        point.tooltipPos[1] = tooltipY;
      }
    }
    point.isInside = this.isPointInside(point);
    const crispBottom = crisp13(point.yBottom, series.borderWidth);
    box.y = crisp13(box.y, series.borderWidth);
    box.height = crispBottom - box.y;
    merge73(true, point.shapeArgs, box);
  }
}, { order: 2 });
SeriesRegistry_default.registerSeriesType("waterfall", WaterfallSeries);
var WaterfallSeries_default = WaterfallSeries;

// node_modules/highcharts/es-modules/masters/highcharts-more.src.js
var G8 = Globals_default;
G8.RadialAxis = RadialAxis_default;
BubbleSeries_default.compose(G8.Axis, G8.Chart, G8.Legend);
PackedBubbleSeries_default.compose(G8.Axis, G8.Chart, G8.Legend);
Pane_default.compose(G8.Chart, G8.Pointer);
PolarComposition_default.compose(G8.Axis, G8.Chart, G8.Pointer, G8.Series, G8.Tick, G8.Point, SeriesRegistry_default.seriesTypes.areasplinerange, SeriesRegistry_default.seriesTypes.column, SeriesRegistry_default.seriesTypes.line, SeriesRegistry_default.seriesTypes.spline);
WaterfallSeries_default.compose(G8.Axis, G8.Chart);

// node_modules/highcharts/es-modules/Core/Math3D.js
var { deg2rad: deg2rad7 } = Globals_default;
var { pick: pick79 } = Utilities_default;
function rotate3D(x, y, z, angles) {
  return {
    x: angles.cosB * x - angles.sinB * z,
    y: -angles.sinA * angles.sinB * x + angles.cosA * y - angles.cosB * angles.sinA * z,
    z: angles.cosA * angles.sinB * x + angles.sinA * y + angles.cosA * angles.cosB * z
  };
}
function perspective(points, chart, insidePlotArea, useInvertedPersp) {
  const options3d = chart.options.chart.options3d, inverted = pick79(useInvertedPersp, insidePlotArea ? chart.inverted : false), origin = {
    x: chart.plotWidth / 2,
    y: chart.plotHeight / 2,
    z: options3d.depth / 2,
    vd: pick79(options3d.depth, 1) * pick79(options3d.viewDistance, 0)
  }, scale = chart.scale3d || 1, beta = deg2rad7 * options3d.beta * (inverted ? -1 : 1), alpha = deg2rad7 * options3d.alpha * (inverted ? -1 : 1), angles = {
    cosA: Math.cos(alpha),
    cosB: Math.cos(-beta),
    sinA: Math.sin(alpha),
    sinB: Math.sin(-beta)
  };
  if (!insidePlotArea) {
    origin.x += chart.plotLeft;
    origin.y += chart.plotTop;
  }
  return points.map(function(point) {
    const rotated = rotate3D((inverted ? point.y : point.x) - origin.x, (inverted ? point.x : point.y) - origin.y, (point.z || 0) - origin.z, angles), coordinate = perspective3D(rotated, origin, origin.vd);
    coordinate.x = coordinate.x * scale + origin.x;
    coordinate.y = coordinate.y * scale + origin.y;
    coordinate.z = rotated.z * scale + origin.z;
    return {
      x: inverted ? coordinate.y : coordinate.x,
      y: inverted ? coordinate.x : coordinate.y,
      z: coordinate.z
    };
  });
}
function perspective3D(coordinate, origin, distance) {
  const projection = distance > 0 && distance < Number.POSITIVE_INFINITY ? distance / (coordinate.z + origin.z + distance) : 1;
  return {
    x: coordinate.x * projection,
    y: coordinate.y * projection
  };
}
function pointCameraDistance(coordinates, chart) {
  const options3d = chart.options.chart.options3d, cameraPosition = {
    x: chart.plotWidth / 2,
    y: chart.plotHeight / 2,
    z: pick79(options3d.depth, 1) * pick79(options3d.viewDistance, 0) + options3d.depth
  }, distance = Math.sqrt(Math.pow(cameraPosition.x - pick79(coordinates.plotX, coordinates.x), 2) + Math.pow(cameraPosition.y - pick79(coordinates.plotY, coordinates.y), 2) + Math.pow(cameraPosition.z - pick79(coordinates.plotZ, coordinates.z), 2));
  return distance;
}
function shapeArea(vertexes) {
  let area = 0, i, j;
  for (i = 0; i < vertexes.length; i++) {
    j = (i + 1) % vertexes.length;
    area += vertexes[i].x * vertexes[j].y - vertexes[j].x * vertexes[i].y;
  }
  return area / 2;
}
function shapeArea3D(vertexes, chart, insidePlotArea) {
  return shapeArea(perspective(vertexes, chart, insidePlotArea));
}
var Math3D = {
  perspective,
  perspective3D,
  pointCameraDistance,
  shapeArea,
  shapeArea3D
};
var Math3D_default = Math3D;

// node_modules/highcharts/es-modules/Core/Chart/Chart3D.js
var { parse: color6 } = Color_default;
var { defaultOptions: genericDefaultOptions } = Defaults_default;
var { perspective: perspective2, shapeArea3D: shapeArea3D2 } = Math3D_default;
var { addEvent: addEvent69, isArray: isArray21, merge: merge74, pick: pick80, wrap: wrap8 } = Utilities_default;
var Chart3D;
(function(Chart3D2) {
  Chart3D2.defaultOptions = {
    chart: {
      /**
       * Options to render charts in 3 dimensions. This feature requires
       * `highcharts-3d.js`, found in the download package or online at
       * [code.highcharts.com/highcharts-3d.js](https://code.highcharts.com/highcharts-3d.js).
       *
       * @since    4.0
       * @product  highcharts
       * @requires highcharts-3d
       */
      options3d: {
        /**
         * Whether to render the chart using the 3D functionality.
         *
         * @since   4.0
         * @product highcharts
         */
        enabled: false,
        /**
         * One of the two rotation angles for the chart.
         *
         * @since   4.0
         * @product highcharts
         */
        alpha: 0,
        /**
         * One of the two rotation angles for the chart.
         *
         * @since   4.0
         * @product highcharts
         */
        beta: 0,
        /**
         * The total depth of the chart.
         *
         * @since   4.0
         * @product highcharts
         */
        depth: 100,
        /**
         * Whether the 3d box should automatically adjust to the chart
         * plot area.
         *
         * @since   4.2.4
         * @product highcharts
         */
        fitToPlot: true,
        /**
         * Defines the distance the viewer is standing in front of the
         * chart, this setting is important to calculate the perspective
         * effect in column and scatter charts. It is not used for 3D
         * pie charts.
         *
         * @since   4.0
         * @product highcharts
         */
        viewDistance: 25,
        /**
         * Set it to `"auto"` to automatically move the labels to the
         * best edge.
         *
         * @type    {"auto"|null}
         * @since   5.0.12
         * @product highcharts
         */
        axisLabelPosition: null,
        /**
         * Provides the option to draw a frame around the charts by
         * defining a bottom, front and back panel.
         *
         * @since    4.0
         * @product  highcharts
         * @requires highcharts-3d
         */
        frame: {
          /**
           * Whether the frames are visible.
           */
          visible: "default",
          /**
           * General pixel thickness for the frame faces.
           */
          size: 1,
          /**
           * The bottom of the frame around a 3D chart.
           *
           * @since    4.0
           * @product  highcharts
           * @requires highcharts-3d
           */
          /**
           * The color of the panel.
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default   transparent
           * @since     4.0
           * @product   highcharts
           * @apioption chart.options3d.frame.bottom.color
           */
          /**
           * The thickness of the panel.
           *
           * @type      {number}
           * @default   1
           * @since     4.0
           * @product   highcharts
           * @apioption chart.options3d.frame.bottom.size
           */
          /**
           * Whether to display the frame. Possible values are `true`,
           * `false`, `"auto"` to display only the frames behind the
           * data, and `"default"` to display faces behind the data
           * based on the axis layout, ignoring the point of view.
           *
           * @sample {highcharts} highcharts/3d/scatter-frame/
           *         Auto frames
           *
           * @type      {boolean|"default"|"auto"}
           * @default   default
           * @since     5.0.12
           * @product   highcharts
           * @apioption chart.options3d.frame.bottom.visible
           */
          /**
           * The bottom of the frame around a 3D chart.
           */
          bottom: {},
          /**
           * The top of the frame around a 3D chart.
           *
           * @extends chart.options3d.frame.bottom
           */
          top: {},
          /**
           * The left side of the frame around a 3D chart.
           *
           * @extends chart.options3d.frame.bottom
           */
          left: {},
          /**
           * The right of the frame around a 3D chart.
           *
           * @extends chart.options3d.frame.bottom
           */
          right: {},
          /**
           * The back side of the frame around a 3D chart.
           *
           * @extends chart.options3d.frame.bottom
           */
          back: {},
          /**
           * The front of the frame around a 3D chart.
           *
           * @extends chart.options3d.frame.bottom
           */
          front: {}
        }
      }
    }
  };
  function compose27(ChartClass, FxClass) {
    const chartProto = ChartClass.prototype;
    const fxProto = FxClass.prototype;
    chartProto.is3d = function() {
      return !!this.options.chart.options3d?.enabled;
    };
    chartProto.propsRequireDirtyBox.push("chart.options3d");
    chartProto.propsRequireUpdateSeries.push("chart.options3d");
    fxProto.matrixSetter = function() {
      let interpolated;
      if (this.pos < 1 && (isArray21(this.start) || isArray21(this.end))) {
        const start = this.start || [1, 0, 0, 1, 0, 0], end = this.end || [1, 0, 0, 1, 0, 0];
        interpolated = [];
        for (let i = 0; i < 6; i++) {
          interpolated.push(this.pos * end[i] + (1 - this.pos) * start[i]);
        }
      } else {
        interpolated = this.end;
      }
      this.elem.attr(this.prop, interpolated, null, true);
    };
    merge74(true, genericDefaultOptions, Chart3D2.defaultOptions);
    addEvent69(ChartClass, "init", onInit2);
    addEvent69(ChartClass, "addSeries", onAddSeries);
    addEvent69(ChartClass, "afterDrawChartBox", onAfterDrawChartBox);
    addEvent69(ChartClass, "afterGetContainer", onAfterGetContainer2);
    addEvent69(ChartClass, "afterInit", onAfterInit2);
    addEvent69(ChartClass, "afterSetChartSize", onAfterSetChartSize);
    addEvent69(ChartClass, "beforeRedraw", onBeforeRedraw);
    addEvent69(ChartClass, "beforeRender", onBeforeRender2);
    wrap8(chartProto, "isInsidePlot", wrapIsInsidePlot);
    wrap8(chartProto, "renderSeries", wrapRenderSeries);
    wrap8(chartProto, "setClassName", wrapSetClassName);
  }
  Chart3D2.compose = compose27;
  function onAddSeries(e) {
    if (this.is3d()) {
      if (e.options.type === "scatter") {
        e.options.type = "scatter3d";
      }
    }
  }
  function onAfterDrawChartBox() {
    if (this.chart3d && this.is3d()) {
      const chart = this, renderer = chart.renderer, options3d = chart.options.chart.options3d, frame = chart.chart3d.get3dFrame(), xm = chart.plotLeft, xp = chart.plotLeft + chart.plotWidth, ym = chart.plotTop, yp = chart.plotTop + chart.plotHeight, zm = 0, zp = options3d.depth, xmm = xm - (frame.left.visible ? frame.left.size : 0), xpp = xp + (frame.right.visible ? frame.right.size : 0), ymm = ym - (frame.top.visible ? frame.top.size : 0), ypp = yp + (frame.bottom.visible ? frame.bottom.size : 0), zmm = zm - (frame.front.visible ? frame.front.size : 0), zpp = zp + (frame.back.visible ? frame.back.size : 0), verb = chart.hasRendered ? "animate" : "attr";
      chart.chart3d.frame3d = frame;
      if (!chart.frameShapes) {
        chart.frameShapes = {
          bottom: renderer.polyhedron().add(),
          top: renderer.polyhedron().add(),
          left: renderer.polyhedron().add(),
          right: renderer.polyhedron().add(),
          back: renderer.polyhedron().add(),
          front: renderer.polyhedron().add()
        };
      }
      chart.frameShapes.bottom[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-bottom",
        zIndex: frame.bottom.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color6(frame.bottom.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }],
            enabled: frame.bottom.visible
          },
          {
            fill: color6(frame.bottom.color).brighten(0.1).get(),
            vertexes: [{
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zm
            }],
            enabled: frame.bottom.visible
          },
          {
            fill: color6(frame.bottom.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zm
            }],
            enabled: frame.bottom.visible && !frame.left.visible
          },
          {
            fill: color6(frame.bottom.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zp
            }],
            enabled: frame.bottom.visible && !frame.right.visible
          },
          {
            fill: color6(frame.bottom.color).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zm
            }],
            enabled: frame.bottom.visible && !frame.front.visible
          },
          {
            fill: color6(frame.bottom.color).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zp
            }],
            enabled: frame.bottom.visible && !frame.back.visible
          }
        ]
      });
      chart.frameShapes.top[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-top",
        zIndex: frame.top.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color6(frame.top.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }],
            enabled: frame.top.visible
          },
          {
            fill: color6(frame.top.color).brighten(0.1).get(),
            vertexes: [{
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: ym,
              z: zp
            }],
            enabled: frame.top.visible
          },
          {
            fill: color6(frame.top.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zp
            }],
            enabled: frame.top.visible && !frame.left.visible
          },
          {
            fill: color6(frame.top.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zm
            }],
            enabled: frame.top.visible && !frame.right.visible
          },
          {
            fill: color6(frame.top.color).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zm
            }],
            enabled: frame.top.visible && !frame.front.visible
          },
          {
            fill: color6(frame.top.color).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zp
            }],
            enabled: frame.top.visible && !frame.back.visible
          }
        ]
      });
      chart.frameShapes.left[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-left",
        zIndex: frame.left.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color6(frame.left.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }],
            enabled: frame.left.visible && !frame.bottom.visible
          },
          {
            fill: color6(frame.left.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }],
            enabled: frame.left.visible && !frame.top.visible
          },
          {
            fill: color6(frame.left.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zmm
            }],
            enabled: frame.left.visible
          },
          {
            fill: color6(frame.left.color).brighten(-0.1).get(),
            vertexes: [{
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zm
            }],
            enabled: frame.left.visible
          },
          {
            fill: color6(frame.left.color).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zm
            }],
            enabled: frame.left.visible && !frame.front.visible
          },
          {
            fill: color6(frame.left.color).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: ym,
              z: zp
            }],
            enabled: frame.left.visible && !frame.back.visible
          }
        ]
      });
      chart.frameShapes.right[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-right",
        zIndex: frame.right.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color6(frame.right.color).brighten(0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }],
            enabled: frame.right.visible && !frame.bottom.visible
          },
          {
            fill: color6(frame.right.color).brighten(0.1).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }],
            enabled: frame.right.visible && !frame.top.visible
          },
          {
            fill: color6(frame.right.color).brighten(-0.1).get(),
            vertexes: [{
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zp
            }],
            enabled: frame.right.visible
          },
          {
            fill: color6(frame.right.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }],
            enabled: frame.right.visible
          },
          {
            fill: color6(frame.right.color).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zm
            }],
            enabled: frame.right.visible && !frame.front.visible
          },
          {
            fill: color6(frame.right.color).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zp
            }],
            enabled: frame.right.visible && !frame.back.visible
          }
        ]
      });
      chart.frameShapes.back[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-back",
        zIndex: frame.back.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color6(frame.back.color).brighten(0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zp
            }],
            enabled: frame.back.visible && !frame.bottom.visible
          },
          {
            fill: color6(frame.back.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: ym,
              z: zp
            }],
            enabled: frame.back.visible && !frame.top.visible
          },
          {
            fill: color6(frame.back.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zp
            }],
            enabled: frame.back.visible && !frame.left.visible
          },
          {
            fill: color6(frame.back.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zp
            }],
            enabled: frame.back.visible && !frame.right.visible
          },
          {
            fill: color6(frame.back.color).get(),
            vertexes: [{
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zp
            }],
            enabled: frame.back.visible
          },
          {
            fill: color6(frame.back.color).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zpp
            }],
            enabled: frame.back.visible
          }
        ]
      });
      chart.frameShapes.front[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-front",
        zIndex: frame.front.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color6(frame.front.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zm
            }],
            enabled: frame.front.visible && !frame.bottom.visible
          },
          {
            fill: color6(frame.front.color).brighten(0.1).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zm
            }],
            enabled: frame.front.visible && !frame.top.visible
          },
          {
            fill: color6(frame.front.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zm
            }],
            enabled: frame.front.visible && !frame.left.visible
          },
          {
            fill: color6(frame.front.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zm
            }],
            enabled: frame.front.visible && !frame.right.visible
          },
          {
            fill: color6(frame.front.color).get(),
            vertexes: [{
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zm
            }],
            enabled: frame.front.visible
          },
          {
            fill: color6(frame.front.color).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }],
            enabled: frame.front.visible
          }
        ]
      });
    }
  }
  function onAfterGetContainer2() {
    if (this.styledMode) {
      [{
        name: "darker",
        slope: 0.6
      }, {
        name: "brighter",
        slope: 1.4
      }].forEach(function(cfg) {
        this.renderer.definition({
          tagName: "filter",
          attributes: {
            id: "highcharts-" + cfg.name
          },
          children: [{
            tagName: "feComponentTransfer",
            children: [{
              tagName: "feFuncR",
              attributes: {
                type: "linear",
                slope: cfg.slope
              }
            }, {
              tagName: "feFuncG",
              attributes: {
                type: "linear",
                slope: cfg.slope
              }
            }, {
              tagName: "feFuncB",
              attributes: {
                type: "linear",
                slope: cfg.slope
              }
            }]
          }]
        });
      }, this);
    }
  }
  function onAfterInit2() {
    const options2 = this.options;
    if (this.is3d()) {
      (options2.series || []).forEach(function(s) {
        const type = s.type || options2.chart.type || options2.chart.defaultSeriesType;
        if (type === "scatter") {
          s.type = "scatter3d";
        }
      });
    }
  }
  function onAfterSetChartSize() {
    const chart = this, options3d = chart.options.chart.options3d;
    if (chart.chart3d && chart.is3d()) {
      if (options3d) {
        options3d.alpha = options3d.alpha % 360 + (options3d.alpha >= 0 ? 0 : 360);
        options3d.beta = options3d.beta % 360 + (options3d.beta >= 0 ? 0 : 360);
      }
      const inverted = chart.inverted, clipBox = chart.clipBox, margin = chart.margin, x = inverted ? "y" : "x", y = inverted ? "x" : "y", w = inverted ? "height" : "width", h = inverted ? "width" : "height";
      clipBox[x] = -(margin[3] || 0);
      clipBox[y] = -(margin[0] || 0);
      clipBox[w] = chart.chartWidth + (margin[3] || 0) + (margin[1] || 0);
      clipBox[h] = chart.chartHeight + (margin[0] || 0) + (margin[2] || 0);
      chart.scale3d = 1;
      if (options3d.fitToPlot === true) {
        chart.scale3d = chart.chart3d.getScale(options3d.depth);
      }
      chart.chart3d.frame3d = chart.chart3d.get3dFrame();
    }
  }
  function onBeforeRedraw() {
    if (this.is3d()) {
      this.isDirtyBox = true;
    }
  }
  function onBeforeRender2() {
    if (this.chart3d && this.is3d()) {
      this.chart3d.frame3d = this.chart3d.get3dFrame();
    }
  }
  function onInit2() {
    if (!this.chart3d) {
      this.chart3d = new Additions(this);
    }
  }
  function wrapIsInsidePlot(proceed) {
    return this.is3d() || proceed.apply(this, [].slice.call(arguments, 1));
  }
  function wrapRenderSeries(proceed) {
    let series, i = this.series.length;
    if (this.is3d()) {
      while (i--) {
        series = this.series[i];
        series.translate();
        series.render();
      }
    } else {
      proceed.call(this);
    }
  }
  function wrapSetClassName(proceed) {
    proceed.apply(this, [].slice.call(arguments, 1));
    if (this.is3d()) {
      this.container.className += " highcharts-3d-chart";
    }
  }
  class Additions {
    /* *
     *
     *  Constructors
     *
     * */
    constructor(chart) {
      this.chart = chart;
    }
    /* *
     *
     *  Functions
     *
     * */
    get3dFrame() {
      const chart = this.chart, options3d = chart.options.chart.options3d, frameOptions = options3d.frame, xm = chart.plotLeft, xp = chart.plotLeft + chart.plotWidth, ym = chart.plotTop, yp = chart.plotTop + chart.plotHeight, zm = 0, zp = options3d.depth, faceOrientation = function(vertexes) {
        const area = shapeArea3D2(vertexes, chart);
        if (area > 0.5) {
          return 1;
        }
        if (area < -0.5) {
          return -1;
        }
        return 0;
      }, bottomOrientation = faceOrientation([
        { x: xm, y: yp, z: zp },
        { x: xp, y: yp, z: zp },
        { x: xp, y: yp, z: zm },
        { x: xm, y: yp, z: zm }
      ]), topOrientation = faceOrientation([
        { x: xm, y: ym, z: zm },
        { x: xp, y: ym, z: zm },
        { x: xp, y: ym, z: zp },
        { x: xm, y: ym, z: zp }
      ]), leftOrientation = faceOrientation([
        { x: xm, y: ym, z: zm },
        { x: xm, y: ym, z: zp },
        { x: xm, y: yp, z: zp },
        { x: xm, y: yp, z: zm }
      ]), rightOrientation = faceOrientation([
        { x: xp, y: ym, z: zp },
        { x: xp, y: ym, z: zm },
        { x: xp, y: yp, z: zm },
        { x: xp, y: yp, z: zp }
      ]), frontOrientation = faceOrientation([
        { x: xm, y: yp, z: zm },
        { x: xp, y: yp, z: zm },
        { x: xp, y: ym, z: zm },
        { x: xm, y: ym, z: zm }
      ]), backOrientation = faceOrientation([
        { x: xm, y: ym, z: zp },
        { x: xp, y: ym, z: zp },
        { x: xp, y: yp, z: zp },
        { x: xm, y: yp, z: zp }
      ]), defaultShowFront = false, defaultShowBack = true;
      let defaultShowBottom = false, defaultShowTop = false, defaultShowLeft = false, defaultShowRight = false;
      [].concat(chart.xAxis, chart.yAxis, chart.zAxis).forEach(function(axis) {
        if (axis) {
          if (axis.horiz) {
            if (axis.opposite) {
              defaultShowTop = true;
            } else {
              defaultShowBottom = true;
            }
          } else {
            if (axis.opposite) {
              defaultShowRight = true;
            } else {
              defaultShowLeft = true;
            }
          }
        }
      });
      const getFaceOptions = function(sources, faceOrientation2, defaultVisible) {
        const faceAttrs = ["size", "color", "visible"], options2 = {};
        for (let i = 0; i < faceAttrs.length; i++) {
          const attr18 = faceAttrs[i];
          for (let j = 0; j < sources.length; j++) {
            if (typeof sources[j] === "object") {
              const val = sources[j][attr18];
              if (typeof val !== "undefined" && val !== null) {
                options2[attr18] = val;
                break;
              }
            }
          }
        }
        let isVisible = defaultVisible;
        if (options2.visible === true || options2.visible === false) {
          isVisible = options2.visible;
        } else if (options2.visible === "auto") {
          isVisible = faceOrientation2 > 0;
        }
        return {
          size: pick80(options2.size, 1),
          color: pick80(options2.color, "none"),
          frontFacing: faceOrientation2 > 0,
          visible: isVisible
        };
      };
      const ret = {
        axes: {},
        // FIXME: Previously, left/right, top/bottom and front/back
        // pairs shared size and color.
        // For compatibility and consistency sake, when one face have
        // size/color/visibility set, the opposite face will default to
        // the same values. Also, left/right used to be called 'side',
        // so that's also added as a fallback.
        bottom: getFaceOptions([frameOptions.bottom, frameOptions.top, frameOptions], bottomOrientation, defaultShowBottom),
        top: getFaceOptions([frameOptions.top, frameOptions.bottom, frameOptions], topOrientation, defaultShowTop),
        left: getFaceOptions([
          frameOptions.left,
          frameOptions.right,
          frameOptions.side,
          frameOptions
        ], leftOrientation, defaultShowLeft),
        right: getFaceOptions([
          frameOptions.right,
          frameOptions.left,
          frameOptions.side,
          frameOptions
        ], rightOrientation, defaultShowRight),
        back: getFaceOptions([frameOptions.back, frameOptions.front, frameOptions], backOrientation, defaultShowBack),
        front: getFaceOptions([frameOptions.front, frameOptions.back, frameOptions], frontOrientation, defaultShowFront)
      };
      if (options3d.axisLabelPosition === "auto") {
        const isValidEdge = function(face1, face2) {
          return face1.visible !== face2.visible || face1.visible && face2.visible && face1.frontFacing !== face2.frontFacing;
        };
        const yEdges = [];
        if (isValidEdge(ret.left, ret.front)) {
          yEdges.push({
            y: (ym + yp) / 2,
            x: xm,
            z: zm,
            xDir: { x: 1, y: 0, z: 0 }
          });
        }
        if (isValidEdge(ret.left, ret.back)) {
          yEdges.push({
            y: (ym + yp) / 2,
            x: xm,
            z: zp,
            xDir: { x: 0, y: 0, z: -1 }
          });
        }
        if (isValidEdge(ret.right, ret.front)) {
          yEdges.push({
            y: (ym + yp) / 2,
            x: xp,
            z: zm,
            xDir: { x: 0, y: 0, z: 1 }
          });
        }
        if (isValidEdge(ret.right, ret.back)) {
          yEdges.push({
            y: (ym + yp) / 2,
            x: xp,
            z: zp,
            xDir: { x: -1, y: 0, z: 0 }
          });
        }
        const xBottomEdges = [];
        if (isValidEdge(ret.bottom, ret.front)) {
          xBottomEdges.push({
            x: (xm + xp) / 2,
            y: yp,
            z: zm,
            xDir: { x: 1, y: 0, z: 0 }
          });
        }
        if (isValidEdge(ret.bottom, ret.back)) {
          xBottomEdges.push({
            x: (xm + xp) / 2,
            y: yp,
            z: zp,
            xDir: { x: -1, y: 0, z: 0 }
          });
        }
        const xTopEdges = [];
        if (isValidEdge(ret.top, ret.front)) {
          xTopEdges.push({
            x: (xm + xp) / 2,
            y: ym,
            z: zm,
            xDir: { x: 1, y: 0, z: 0 }
          });
        }
        if (isValidEdge(ret.top, ret.back)) {
          xTopEdges.push({
            x: (xm + xp) / 2,
            y: ym,
            z: zp,
            xDir: { x: -1, y: 0, z: 0 }
          });
        }
        const zBottomEdges = [];
        if (isValidEdge(ret.bottom, ret.left)) {
          zBottomEdges.push({
            z: (zm + zp) / 2,
            y: yp,
            x: xm,
            xDir: { x: 0, y: 0, z: -1 }
          });
        }
        if (isValidEdge(ret.bottom, ret.right)) {
          zBottomEdges.push({
            z: (zm + zp) / 2,
            y: yp,
            x: xp,
            xDir: { x: 0, y: 0, z: 1 }
          });
        }
        const zTopEdges = [];
        if (isValidEdge(ret.top, ret.left)) {
          zTopEdges.push({
            z: (zm + zp) / 2,
            y: ym,
            x: xm,
            xDir: { x: 0, y: 0, z: -1 }
          });
        }
        if (isValidEdge(ret.top, ret.right)) {
          zTopEdges.push({
            z: (zm + zp) / 2,
            y: ym,
            x: xp,
            xDir: { x: 0, y: 0, z: 1 }
          });
        }
        const pickEdge = function(edges, axis, mult) {
          if (edges.length === 0) {
            return null;
          }
          if (edges.length === 1) {
            return edges[0];
          }
          const projections = perspective2(edges, chart, false);
          let best = 0;
          for (let i = 1; i < projections.length; i++) {
            if (mult * projections[i][axis] > mult * projections[best][axis]) {
              best = i;
            } else if (mult * projections[i][axis] === mult * projections[best][axis] && projections[i].z < projections[best].z) {
              best = i;
            }
          }
          return edges[best];
        };
        ret.axes = {
          y: {
            "left": pickEdge(yEdges, "x", -1),
            "right": pickEdge(yEdges, "x", 1)
          },
          x: {
            "top": pickEdge(xTopEdges, "y", -1),
            "bottom": pickEdge(xBottomEdges, "y", 1)
          },
          z: {
            "top": pickEdge(zTopEdges, "y", -1),
            "bottom": pickEdge(zBottomEdges, "y", 1)
          }
        };
      } else {
        ret.axes = {
          y: {
            "left": {
              x: xm,
              z: zm,
              xDir: { x: 1, y: 0, z: 0 }
            },
            "right": {
              x: xp,
              z: zm,
              xDir: { x: 0, y: 0, z: 1 }
            }
          },
          x: {
            "top": {
              y: ym,
              z: zm,
              xDir: { x: 1, y: 0, z: 0 }
            },
            "bottom": {
              y: yp,
              z: zm,
              xDir: { x: 1, y: 0, z: 0 }
            }
          },
          z: {
            "top": {
              x: defaultShowLeft ? xp : xm,
              y: ym,
              xDir: defaultShowLeft ? { x: 0, y: 0, z: 1 } : { x: 0, y: 0, z: -1 }
            },
            "bottom": {
              x: defaultShowLeft ? xp : xm,
              y: yp,
              xDir: defaultShowLeft ? { x: 0, y: 0, z: 1 } : { x: 0, y: 0, z: -1 }
            }
          }
        };
      }
      return ret;
    }
    /**
     * Calculate scale of the 3D view. That is required to fit chart's 3D
     * projection into the actual plotting area. Reported as #4933.
     *
     * **Note:**
     * This function should ideally take the plot values instead of a chart
     * object, but since the chart object is needed for perspective it is
     * not practical. Possible to make both getScale and perspective more
     * logical and also immutable.
     *
     * @private
     * @function getScale
     *
     * @param {number} depth
     * The depth of the chart
     *
     * @return {number}
     * The scale to fit the 3D chart into the plotting area.
     *
     * @requires highcharts-3d
     */
    getScale(depth) {
      const chart = this.chart, plotLeft = chart.plotLeft, plotRight = chart.plotWidth + plotLeft, plotTop = chart.plotTop, plotBottom = chart.plotHeight + plotTop, originX = plotLeft + chart.plotWidth / 2, originY = plotTop + chart.plotHeight / 2, bbox3d = {
        minX: Number.MAX_VALUE,
        maxX: -Number.MAX_VALUE,
        minY: Number.MAX_VALUE,
        maxY: -Number.MAX_VALUE
      };
      let corners, scale = 1;
      corners = [{
        x: plotLeft,
        y: plotTop,
        z: 0
      }, {
        x: plotLeft,
        y: plotTop,
        z: depth
      }];
      [0, 1].forEach(function(i) {
        corners.push({
          x: plotRight,
          y: corners[i].y,
          z: corners[i].z
        });
      });
      [0, 1, 2, 3].forEach(function(i) {
        corners.push({
          x: corners[i].x,
          y: plotBottom,
          z: corners[i].z
        });
      });
      corners = perspective2(corners, chart, false);
      corners.forEach(function(corner) {
        bbox3d.minX = Math.min(bbox3d.minX, corner.x);
        bbox3d.maxX = Math.max(bbox3d.maxX, corner.x);
        bbox3d.minY = Math.min(bbox3d.minY, corner.y);
        bbox3d.maxY = Math.max(bbox3d.maxY, corner.y);
      });
      if (plotLeft > bbox3d.minX) {
        scale = Math.min(scale, 1 - Math.abs((plotLeft + originX) / (bbox3d.minX + originX)) % 1);
      }
      if (plotRight < bbox3d.maxX) {
        scale = Math.min(scale, (plotRight - originX) / (bbox3d.maxX - originX));
      }
      if (plotTop > bbox3d.minY) {
        if (bbox3d.minY < 0) {
          scale = Math.min(scale, (plotTop + originY) / (-bbox3d.minY + plotTop + originY));
        } else {
          scale = Math.min(scale, 1 - (plotTop + originY) / (bbox3d.minY + originY) % 1);
        }
      }
      if (plotBottom < bbox3d.maxY) {
        scale = Math.min(scale, Math.abs((plotBottom - originY) / (bbox3d.maxY - originY)));
      }
      return scale;
    }
  }
  Chart3D2.Additions = Additions;
})(Chart3D || (Chart3D = {}));
var Chart3D_default = Chart3D;

// node_modules/highcharts/es-modules/Series/Area3D/Area3DSeries.js
var { composed: composed25 } = Globals_default;
var { perspective: perspective3 } = Math3D_default;
var { line: { prototype: lineProto } } = SeriesRegistry_default.seriesTypes;
var { pushUnique: pushUnique28, wrap: wrap9 } = Utilities_default;
function compose16(AreaSeriesClass) {
  if (pushUnique28(composed25, "Area3DSeries")) {
    wrap9(AreaSeriesClass.prototype, "getGraphPath", wrapAreaSeriesGetGraphPath);
  }
}
function wrapAreaSeriesGetGraphPath(proceed) {
  const series = this, svgPath = proceed.apply(series, [].slice.call(arguments, 1));
  if (!series.chart.is3d()) {
    return svgPath;
  }
  const getGraphPath = lineProto.getGraphPath, options2 = series.options, translatedThreshold = Math.round(
    // #10909
    series.yAxis.getThreshold(options2.threshold)
  );
  let bottomPoints = [];
  if (series.rawPointsX) {
    for (let i = 0; i < series.points.length; i++) {
      bottomPoints.push({
        x: series.rawPointsX[i],
        y: options2.stacking ? series.points[i].yBottom : translatedThreshold,
        z: series.zPadding
      });
    }
  }
  const options3d = series.chart.options.chart.options3d;
  bottomPoints = perspective3(bottomPoints, series.chart, true).map((point) => ({ plotX: point.x, plotY: point.y, plotZ: point.z }));
  if (series.group && options3d && options3d.depth && options3d.beta) {
    if (series.markerGroup) {
      series.markerGroup.add(series.group);
      series.markerGroup.attr({
        translateX: 0,
        translateY: 0
      });
    }
    series.group.attr({
      zIndex: Math.max(1, options3d.beta > 270 || options3d.beta < 90 ? options3d.depth - Math.round(series.zPadding || 0) : Math.round(series.zPadding || 0))
    });
  }
  bottomPoints.reversed = true;
  const bottomPath = getGraphPath.call(series, bottomPoints, true, true);
  if (bottomPath[0] && bottomPath[0][0] === "M") {
    bottomPath[0] = ["L", bottomPath[0][1], bottomPath[0][2]];
  }
  if (series.areaPath) {
    const areaPath = series.areaPath.splice(0, series.areaPath.length / 2).concat(bottomPath);
    areaPath.xMap = series.areaPath.xMap;
    series.areaPath = areaPath;
  }
  series.graphPath = svgPath;
  return svgPath;
}
var Area3DSeries = {
  compose: compose16
};
var Area3DSeries_default = Area3DSeries;

// node_modules/highcharts/es-modules/Core/Axis/Axis3DDefaults.js
var Axis3DDefaults = {
  labels: {
    /**
     * Defines how the labels are be repositioned according to the 3D
     * chart orientation.
     *
     * - `'offset'`: Maintain a fixed horizontal/vertical distance from
     *   the tick marks, despite the chart orientation. This is the
     *   backwards compatible behavior, and causes skewing of X and Z
     *   axes.
     *
     * - `'chart'`: Preserve 3D position relative to the chart. This
     *   looks nice, but hard to read if the text isn't forward-facing.
     *
     * - `'flap'`: Rotated text along the axis to compensate for the
     *   chart orientation. This tries to maintain text as legible as
     *   possible on all orientations.
     *
     * - `'ortho'`: Rotated text along the axis direction so that the
     *   labels are orthogonal to the axis. This is very similar to
     *   `'flap'`, but prevents skewing the labels (X and Y scaling are
     *   still present).
     *
     * @sample highcharts/3d/skewed-labels/
     *         Skewed labels
     *
     * @since      5.0.15
     * @validvalue ['offset', 'chart', 'flap', 'ortho']
     * @product    highcharts
     * @requires   highcharts-3d
     */
    position3d: "offset",
    /**
     * If enabled, the axis labels will skewed to follow the
     * perspective.
     *
     * This will fix overlapping labels and titles, but texts become
     * less legible due to the distortion.
     *
     * The final appearance depends heavily on `labels.position3d`.
     *
     * @sample highcharts/3d/skewed-labels/
     *         Skewed labels
     *
     * @since    5.0.15
     * @product  highcharts
     * @requires highcharts-3d
     */
    skew3d: false
  },
  title: {
    /**
     * Defines how the title is repositioned according to the 3D chart
     * orientation.
     *
     * - `'offset'`: Maintain a fixed horizontal/vertical distance from
     *   the tick marks, despite the chart orientation. This is the
     *   backwards compatible behavior, and causes skewing of X and Z
     *   axes.
     *
     * - `'chart'`: Preserve 3D position relative to the chart. This
     *   looks nice, but hard to read if the text isn't forward-facing.
     *
     * - `'flap'`: Rotated text along the axis to compensate for the
     *   chart orientation. This tries to maintain text as legible as
     *   possible on all orientations.
     *
     * - `'ortho'`: Rotated text along the axis direction so that the
     *   labels are orthogonal to the axis. This is very similar to
     *   `'flap'`, but prevents skewing the labels (X and Y scaling are
     *   still present).
     *
     * - `undefined`: Will use the config from `labels.position3d`
     *
     * @sample highcharts/3d/skewed-labels/
     *         Skewed labels
     *
     * @type     {"offset"|"chart"|"flap"|"ortho"|null}
     * @since    5.0.15
     * @product  highcharts
     * @requires highcharts-3d
     */
    position3d: null,
    /**
     * If enabled, the axis title will skewed to follow the perspective.
     *
     * This will fix overlapping labels and titles, but texts become
     * less legible due to the distortion.
     *
     * The final appearance depends heavily on `title.position3d`.
     *
     * A `null` value will use the config from `labels.skew3d`.
     *
     * @sample highcharts/3d/skewed-labels/
     *         Skewed labels
     *
     * @type     {boolean|null}
     * @since    5.0.15
     * @product  highcharts
     * @requires highcharts-3d
     */
    skew3d: null
  }
};
var Axis3DDefaults_default = Axis3DDefaults;

// node_modules/highcharts/es-modules/Core/Axis/Tick3DComposition.js
var { composed: composed26 } = Globals_default;
var { addEvent: addEvent70, extend: extend61, pushUnique: pushUnique29, wrap: wrap10 } = Utilities_default;
function compose17(TickClass) {
  if (pushUnique29(composed26, "Axis.Tick3D")) {
    addEvent70(TickClass, "afterGetLabelPosition", onTickAfterGetLabelPosition);
    wrap10(TickClass.prototype, "getMarkPath", wrapTickGetMarkPath);
  }
}
function onTickAfterGetLabelPosition(e) {
  const axis3D = this.axis.axis3D;
  if (axis3D) {
    extend61(e.pos, axis3D.fix3dPosition(e.pos));
  }
}
function wrapTickGetMarkPath(proceed) {
  const axis3D = this.axis.axis3D, path = proceed.apply(this, [].slice.call(arguments, 1));
  if (axis3D) {
    const start = path[0];
    const end = path[1];
    if (start[0] === "M" && end[0] === "L") {
      const pArr = [
        axis3D.fix3dPosition({ x: start[1], y: start[2], z: 0 }),
        axis3D.fix3dPosition({ x: end[1], y: end[2], z: 0 })
      ];
      return this.axis.chart.renderer.toLineSegments(pArr);
    }
  }
  return path;
}
var Tick3DAdditions = {
  compose: compose17
};
var Tick3DComposition_default = Tick3DAdditions;

// node_modules/highcharts/es-modules/Core/Axis/Axis3DComposition.js
var { defaultOptions: defaultOptions18 } = Defaults_default;
var { deg2rad: deg2rad8 } = Globals_default;
var { perspective: perspective4, perspective3D: perspective3D2, shapeArea: shapeArea2 } = Math3D_default;
var { addEvent: addEvent71, merge: merge75, pick: pick81, wrap: wrap11 } = Utilities_default;
function onAxisAfterSetOptions() {
  const axis = this, chart = axis.chart, options2 = axis.options;
  if (chart.is3d?.() && axis.coll !== "colorAxis") {
    options2.tickWidth = pick81(options2.tickWidth, 0);
    options2.gridLineWidth = pick81(options2.gridLineWidth, 1);
  }
}
function onAxisDrawCrosshair(e) {
  const axis = this;
  if (axis.chart.is3d() && axis.coll !== "colorAxis") {
    if (e.point) {
      e.point.crosshairPos = axis.isXAxis ? e.point.axisXpos : axis.len - e.point.axisYpos;
    }
  }
}
function onAxisInit3() {
  const axis = this;
  if (!axis.axis3D) {
    axis.axis3D = new Axis3DAdditions(axis);
  }
}
function wrapAxisGetLinePath(proceed) {
  const axis = this;
  if (!axis.chart.is3d() || axis.coll === "colorAxis") {
    return proceed.apply(axis, [].slice.call(arguments, 1));
  }
  return [];
}
function wrapAxisGetPlotBandPath(proceed) {
  if (!this.chart.is3d() || this.coll === "colorAxis") {
    return proceed.apply(this, [].slice.call(arguments, 1));
  }
  const args = arguments, from = args[1], to = args[2], path = [], fromPath = this.getPlotLinePath({ value: from }), toPath = this.getPlotLinePath({ value: to });
  if (fromPath && toPath) {
    for (let i = 0; i < fromPath.length; i += 2) {
      const fromStartSeg = fromPath[i], fromEndSeg = fromPath[i + 1], toStartSeg = toPath[i], toEndSeg = toPath[i + 1];
      if (fromStartSeg[0] === "M" && fromEndSeg[0] === "L" && toStartSeg[0] === "M" && toEndSeg[0] === "L") {
        path.push(
          fromStartSeg,
          fromEndSeg,
          toEndSeg,
          // `lineTo` instead of `moveTo`
          ["L", toStartSeg[1], toStartSeg[2]],
          ["Z"]
        );
      }
    }
  }
  return path;
}
function wrapAxisGetPlotLinePath(proceed) {
  const axis = this, axis3D = axis.axis3D, chart = axis.chart, path = proceed.apply(axis, [].slice.call(arguments, 1));
  if (axis.coll === "colorAxis" || !chart.chart3d || !chart.is3d()) {
    return path;
  }
  if (path === null) {
    return path;
  }
  const options3d = chart.options.chart.options3d, d = axis.isZAxis ? chart.plotWidth : options3d.depth, frame = chart.chart3d.frame3d, startSegment = path[0], endSegment = path[1];
  let pArr, pathSegments = [];
  if (startSegment[0] === "M" && endSegment[0] === "L") {
    pArr = [
      axis3D.swapZ({ x: startSegment[1], y: startSegment[2], z: 0 }),
      axis3D.swapZ({ x: startSegment[1], y: startSegment[2], z: d }),
      axis3D.swapZ({ x: endSegment[1], y: endSegment[2], z: 0 }),
      axis3D.swapZ({ x: endSegment[1], y: endSegment[2], z: d })
    ];
    if (!this.horiz) {
      if (frame.front.visible) {
        pathSegments.push(pArr[0], pArr[2]);
      }
      if (frame.back.visible) {
        pathSegments.push(pArr[1], pArr[3]);
      }
      if (frame.left.visible) {
        pathSegments.push(pArr[0], pArr[1]);
      }
      if (frame.right.visible) {
        pathSegments.push(pArr[2], pArr[3]);
      }
    } else if (this.isZAxis) {
      if (frame.left.visible) {
        pathSegments.push(pArr[0], pArr[2]);
      }
      if (frame.right.visible) {
        pathSegments.push(pArr[1], pArr[3]);
      }
      if (frame.top.visible) {
        pathSegments.push(pArr[0], pArr[1]);
      }
      if (frame.bottom.visible) {
        pathSegments.push(pArr[2], pArr[3]);
      }
    } else {
      if (frame.front.visible) {
        pathSegments.push(pArr[0], pArr[2]);
      }
      if (frame.back.visible) {
        pathSegments.push(pArr[1], pArr[3]);
      }
      if (frame.top.visible) {
        pathSegments.push(pArr[0], pArr[1]);
      }
      if (frame.bottom.visible) {
        pathSegments.push(pArr[2], pArr[3]);
      }
    }
    pathSegments = perspective4(pathSegments, this.chart, false);
  }
  return chart.renderer.toLineSegments(pathSegments);
}
function wrapAxisGetSlotWidth(proceed, tick) {
  const axis = this, { chart, gridGroup, tickPositions, ticks } = axis;
  if (axis.categories && chart.frameShapes && chart.is3d() && gridGroup && tick && tick.label) {
    const firstGridLine = gridGroup.element.childNodes[0].getBBox(), frame3DLeft = chart.frameShapes.left.getBBox(), options3d = chart.options.chart.options3d, origin = {
      x: chart.plotWidth / 2,
      y: chart.plotHeight / 2,
      z: options3d.depth / 2,
      vd: pick81(options3d.depth, 1) * pick81(options3d.viewDistance, 0)
    }, index = tickPositions.indexOf(tick.pos), prevTick = ticks[tickPositions[index - 1]], nextTick = ticks[tickPositions[index + 1]];
    let labelPos, prevLabelPos, nextLabelPos;
    if (prevTick?.label?.xy) {
      prevLabelPos = perspective3D2({
        x: prevTick.label.xy.x,
        y: prevTick.label.xy.y,
        z: null
      }, origin, origin.vd);
    }
    if (nextTick?.label?.xy) {
      nextLabelPos = perspective3D2({
        x: nextTick.label.xy.x,
        y: nextTick.label.xy.y,
        z: null
      }, origin, origin.vd);
    }
    labelPos = {
      x: tick.label.xy.x,
      y: tick.label.xy.y,
      z: null
    };
    labelPos = perspective3D2(labelPos, origin, origin.vd);
    return Math.abs(prevLabelPos ? labelPos.x - prevLabelPos.x : nextLabelPos ? nextLabelPos.x - labelPos.x : firstGridLine.x - frame3DLeft.x);
  }
  return proceed.apply(axis, [].slice.call(arguments, 1));
}
function wrapAxisGetTitlePosition(proceed) {
  const pos = proceed.apply(this, [].slice.call(arguments, 1));
  return this.axis3D ? this.axis3D.fix3dPosition(pos, true) : pos;
}
var Axis3DAdditions = class {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Extends axis class with 3D support.
   * @private
   */
  static compose(AxisClass, TickClass) {
    Tick3DComposition_default.compose(TickClass);
    if (!AxisClass.keepProps.includes("axis3D")) {
      merge75(true, defaultOptions18.xAxis, Axis3DDefaults_default);
      AxisClass.keepProps.push("axis3D");
      addEvent71(AxisClass, "init", onAxisInit3);
      addEvent71(AxisClass, "afterSetOptions", onAxisAfterSetOptions);
      addEvent71(AxisClass, "drawCrosshair", onAxisDrawCrosshair);
      const axisProto = AxisClass.prototype;
      wrap11(axisProto, "getLinePath", wrapAxisGetLinePath);
      wrap11(axisProto, "getPlotBandPath", wrapAxisGetPlotBandPath);
      wrap11(axisProto, "getPlotLinePath", wrapAxisGetPlotLinePath);
      wrap11(axisProto, "getSlotWidth", wrapAxisGetSlotWidth);
      wrap11(axisProto, "getTitlePosition", wrapAxisGetTitlePosition);
    }
  }
  /* *
   *
   *  Constructors
   *
   * */
  /**
   * @private
   */
  constructor(axis) {
    this.axis = axis;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   * @param {Highcharts.Axis} axis
   * Related axis.
   * @param {Highcharts.Position3DObject} pos
   * Position to fix.
   * @param {boolean} [isTitle]
   * Whether this is a title position.
   * @return {Highcharts.Position3DObject}
   * Fixed position.
   */
  fix3dPosition(pos, isTitle) {
    const axis3D = this;
    const axis = axis3D.axis;
    const chart = axis.chart;
    if (axis.coll === "colorAxis" || !chart.chart3d || !chart.is3d()) {
      return pos;
    }
    const alpha = deg2rad8 * chart.options.chart.options3d.alpha, beta = deg2rad8 * chart.options.chart.options3d.beta, positionMode = pick81(isTitle && axis.options.title.position3d, axis.options.labels.position3d), skew = pick81(isTitle && axis.options.title.skew3d, axis.options.labels.skew3d), frame = chart.chart3d.frame3d, plotLeft = chart.plotLeft, plotRight = chart.plotWidth + plotLeft, plotTop = chart.plotTop, plotBottom = chart.plotHeight + plotTop;
    let offsetX = 0, offsetY = 0, vecX, vecY = { x: 0, y: 1, z: 0 }, reverseFlap = false;
    pos = axis.axis3D.swapZ({ x: pos.x, y: pos.y, z: 0 });
    if (axis.isZAxis) {
      if (axis.opposite) {
        if (frame.axes.z.top === null) {
          return {};
        }
        offsetY = pos.y - plotTop;
        pos.x = frame.axes.z.top.x;
        pos.y = frame.axes.z.top.y;
        vecX = frame.axes.z.top.xDir;
        reverseFlap = !frame.top.frontFacing;
      } else {
        if (frame.axes.z.bottom === null) {
          return {};
        }
        offsetY = pos.y - plotBottom;
        pos.x = frame.axes.z.bottom.x;
        pos.y = frame.axes.z.bottom.y;
        vecX = frame.axes.z.bottom.xDir;
        reverseFlap = !frame.bottom.frontFacing;
      }
    } else if (axis.horiz) {
      if (axis.opposite) {
        if (frame.axes.x.top === null) {
          return {};
        }
        offsetY = pos.y - plotTop;
        pos.y = frame.axes.x.top.y;
        pos.z = frame.axes.x.top.z;
        vecX = frame.axes.x.top.xDir;
        reverseFlap = !frame.top.frontFacing;
      } else {
        if (frame.axes.x.bottom === null) {
          return {};
        }
        offsetY = pos.y - plotBottom;
        pos.y = frame.axes.x.bottom.y;
        pos.z = frame.axes.x.bottom.z;
        vecX = frame.axes.x.bottom.xDir;
        reverseFlap = !frame.bottom.frontFacing;
      }
    } else {
      if (axis.opposite) {
        if (frame.axes.y.right === null) {
          return {};
        }
        offsetX = pos.x - plotRight;
        pos.x = frame.axes.y.right.x;
        pos.z = frame.axes.y.right.z;
        vecX = frame.axes.y.right.xDir;
        vecX = { x: vecX.z, y: vecX.y, z: -vecX.x };
      } else {
        if (frame.axes.y.left === null) {
          return {};
        }
        offsetX = pos.x - plotLeft;
        pos.x = frame.axes.y.left.x;
        pos.z = frame.axes.y.left.z;
        vecX = frame.axes.y.left.xDir;
      }
    }
    if (positionMode === "chart") {
    } else if (positionMode === "flap") {
      if (!axis.horiz) {
        vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };
      } else {
        let sin2 = Math.sin(alpha);
        const cos2 = Math.cos(alpha);
        if (axis.opposite) {
          sin2 = -sin2;
        }
        if (reverseFlap) {
          sin2 = -sin2;
        }
        vecY = { x: vecX.z * sin2, y: cos2, z: -vecX.x * sin2 };
      }
    } else if (positionMode === "ortho") {
      if (!axis.horiz) {
        vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };
      } else {
        const sina = Math.sin(alpha);
        const cosa = Math.cos(alpha);
        const sinb = Math.sin(beta);
        const cosb = Math.cos(beta);
        const vecZ = { x: sinb * cosa, y: -sina, z: -cosa * cosb };
        vecY = {
          x: vecX.y * vecZ.z - vecX.z * vecZ.y,
          y: vecX.z * vecZ.x - vecX.x * vecZ.z,
          z: vecX.x * vecZ.y - vecX.y * vecZ.x
        };
        let scale = 1 / Math.sqrt(vecY.x * vecY.x + vecY.y * vecY.y + vecY.z * vecY.z);
        if (reverseFlap) {
          scale = -scale;
        }
        vecY = {
          x: scale * vecY.x,
          y: scale * vecY.y,
          z: scale * vecY.z
        };
      }
    } else {
      if (!axis.horiz) {
        vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };
      } else {
        vecY = {
          x: Math.sin(beta) * Math.sin(alpha),
          y: Math.cos(alpha),
          z: -Math.cos(beta) * Math.sin(alpha)
        };
      }
    }
    pos.x += offsetX * vecX.x + offsetY * vecY.x;
    pos.y += offsetX * vecX.y + offsetY * vecY.y;
    pos.z += offsetX * vecX.z + offsetY * vecY.z;
    const projected = perspective4([pos], axis.chart)[0];
    if (skew) {
      const isMirrored = shapeArea2(perspective4([
        pos,
        { x: pos.x + vecX.x, y: pos.y + vecX.y, z: pos.z + vecX.z },
        { x: pos.x + vecY.x, y: pos.y + vecY.y, z: pos.z + vecY.z }
      ], axis.chart)) < 0;
      if (isMirrored) {
        vecX = { x: -vecX.x, y: -vecX.y, z: -vecX.z };
      }
      const pointsProjected = perspective4([
        { x: pos.x, y: pos.y, z: pos.z },
        { x: pos.x + vecX.x, y: pos.y + vecX.y, z: pos.z + vecX.z },
        { x: pos.x + vecY.x, y: pos.y + vecY.y, z: pos.z + vecY.z }
      ], axis.chart);
      projected.matrix = [
        pointsProjected[1].x - pointsProjected[0].x,
        pointsProjected[1].y - pointsProjected[0].y,
        pointsProjected[2].x - pointsProjected[0].x,
        pointsProjected[2].y - pointsProjected[0].y,
        projected.x,
        projected.y
      ];
      projected.matrix[4] -= projected.x * projected.matrix[0] + projected.y * projected.matrix[2];
      projected.matrix[5] -= projected.x * projected.matrix[1] + projected.y * projected.matrix[3];
    }
    return projected;
  }
  /**
   * @private
   */
  swapZ(p, insidePlotArea) {
    const axis = this.axis;
    if (axis.isZAxis) {
      const plotLeft = insidePlotArea ? 0 : axis.chart.plotLeft;
      return {
        x: plotLeft + p.z,
        y: p.y,
        z: p.x - plotLeft
      };
    }
    return p;
  }
};
var Axis3DComposition_default = Axis3DAdditions;

// node_modules/highcharts/es-modules/Core/Series/Series3D.js
var { composed: composed27 } = Globals_default;
var { perspective: perspective5 } = Math3D_default;
var { addEvent: addEvent72, extend: extend62, isNumber: isNumber57, merge: merge76, pick: pick82, pushUnique: pushUnique30 } = Utilities_default;
var Series3D = class _Series3D extends Series_default {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(SeriesClass) {
    if (pushUnique30(composed27, "Core.Series3D")) {
      addEvent72(SeriesClass, "afterTranslate", function() {
        if (this.chart.is3d()) {
          this.translate3dPoints();
        }
      });
      extend62(SeriesClass.prototype, {
        translate3dPoints: _Series3D.prototype.translate3dPoints
      });
    }
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Translate the plotX, plotY properties and add plotZ.
   * @private
   */
  translate3dPoints() {
    const series = this, seriesOptions = series.options, chart = series.chart, zAxis = pick82(series.zAxis, chart.options.zAxis[0]), rawPoints = [], rawPointsX = [], stack = seriesOptions.stacking ? isNumber57(seriesOptions.stack) ? seriesOptions.stack : 0 : series.index || 0;
    let projectedPoint, zValue;
    series.zPadding = stack * (seriesOptions.depth || 0 + (seriesOptions.groupZPadding || 1));
    series.data.forEach((rawPoint) => {
      if (zAxis?.translate) {
        zValue = zAxis.logarithmic && zAxis.val2lin ? zAxis.val2lin(rawPoint.z) : rawPoint.z;
        rawPoint.plotZ = zAxis.translate(zValue);
        rawPoint.isInside = rawPoint.isInside ? zValue >= zAxis.min && zValue <= zAxis.max : false;
      } else {
        rawPoint.plotZ = series.zPadding;
      }
      rawPoint.axisXpos = rawPoint.plotX;
      rawPoint.axisYpos = rawPoint.plotY;
      rawPoint.axisZpos = rawPoint.plotZ;
      rawPoints.push({
        x: rawPoint.plotX,
        y: rawPoint.plotY,
        z: rawPoint.plotZ
      });
      rawPointsX.push(rawPoint.plotX || 0);
    });
    series.rawPointsX = rawPointsX;
    const projectedPoints = perspective5(rawPoints, chart, true);
    series.data.forEach((rawPoint, i) => {
      projectedPoint = projectedPoints[i];
      rawPoint.plotX = projectedPoint.x;
      rawPoint.plotY = projectedPoint.y;
      rawPoint.plotZ = projectedPoint.z;
    });
  }
};
Series3D.defaultOptions = merge76(Series_default.defaultOptions);
var Series3D_default = Series3D;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGElement3D.js
var { parse: color7 } = Color_default;
var { Element: SVGElement2 } = RendererRegistry_default.getRendererType().prototype;
var { defined: defined60, pick: pick83 } = Utilities_default;
var SVGElement3D = class extends SVGElement2 {
  constructor() {
    super(...arguments);
    this.parts = ["front", "top", "side"];
    this.pathType = "cuboid";
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * The init is used by base - renderer.Element
   * @private
   */
  initArgs(args) {
    const elem3d = this, renderer = elem3d.renderer, paths = renderer[elem3d.pathType + "Path"](args), zIndexes = paths.zIndexes;
    for (const part of elem3d.parts) {
      const attribs = {
        "class": "highcharts-3d-" + part,
        zIndex: zIndexes[part] || 0
      };
      if (renderer.styledMode) {
        if (part === "top") {
          attribs.filter = "url(#highcharts-brighter)";
        } else if (part === "side") {
          attribs.filter = "url(#highcharts-darker)";
        }
      }
      elem3d[part] = renderer.path(paths[part]).attr(attribs).add(elem3d);
    }
    elem3d.attr({
      "stroke-linejoin": "round",
      zIndex: zIndexes.group
    });
    elem3d.forcedSides = paths.forcedSides;
  }
  /**
   * Single property setter that applies options to each part
   * @private
   */
  singleSetterForParts(prop, val, values, verb, duration, complete) {
    const elem3d = this, newAttr = {}, optionsToApply = [null, null, verb || "attr", duration, complete], hasZIndexes = values?.zIndexes;
    if (!values) {
      newAttr[prop] = val;
      optionsToApply[0] = newAttr;
    } else {
      if (hasZIndexes?.group) {
        elem3d.attr({
          zIndex: hasZIndexes.group
        });
      }
      for (const part of Object.keys(values)) {
        newAttr[part] = {};
        newAttr[part][prop] = values[part];
        if (hasZIndexes) {
          newAttr[part].zIndex = values.zIndexes[part] || 0;
        }
      }
      optionsToApply[1] = newAttr;
    }
    return this.processParts.apply(elem3d, optionsToApply);
  }
  /**
   * Calls function for each part. Used for attr, animate and destroy.
   * @private
   */
  processParts(props, partsProps, verb, duration, complete) {
    const elem3d = this;
    for (const part of elem3d.parts) {
      if (partsProps) {
        props = pick83(partsProps[part], false);
      }
      if (props !== false) {
        elem3d[part][verb](props, duration, complete);
      }
    }
    return elem3d;
  }
  /**
   * Destroy all parts
   * @private
   */
  destroy() {
    this.processParts(null, null, "destroy");
    return super.destroy();
  }
  // Following functions are SVGElement3DCuboid (= base)
  attr(args, val, complete, continueAnimation) {
    if (typeof args === "string" && typeof val !== "undefined") {
      const key = args;
      args = {};
      args[key] = val;
    }
    if (args.shapeArgs || defined60(args.x)) {
      return this.singleSetterForParts("d", null, this.renderer[this.pathType + "Path"](args.shapeArgs || args));
    }
    return super.attr(args, void 0, complete, continueAnimation);
  }
  animate(args, duration, complete) {
    if (defined60(args.x) && defined60(args.y)) {
      const paths = this.renderer[this.pathType + "Path"](args), forcedSides = paths.forcedSides;
      this.singleSetterForParts("d", null, paths, "animate", duration, complete);
      this.attr({
        zIndex: paths.zIndexes.group
      });
      if (forcedSides !== this.forcedSides) {
        this.forcedSides = forcedSides;
        if (!this.renderer.styledMode) {
          this.fillSetter(this.fill);
        }
      }
    } else {
      super.animate(args, duration, complete);
    }
    return this;
  }
  fillSetter(fill) {
    const elem3d = this;
    elem3d.forcedSides = elem3d.forcedSides || [];
    elem3d.singleSetterForParts("fill", null, {
      front: fill,
      // Do not change color if side was forced to render.
      top: color7(fill).brighten(elem3d.forcedSides.indexOf("top") >= 0 ? 0 : 0.1).get(),
      side: color7(fill).brighten(elem3d.forcedSides.indexOf("side") >= 0 ? 0 : -0.1).get()
    });
    elem3d.color = elem3d.fill = fill;
    return elem3d;
  }
};
SVGElement3D.types = {
  base: SVGElement3D,
  cuboid: SVGElement3D
};
var SVGElement3D_default = SVGElement3D;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGRenderer3D.js
var { animObject: animObject14 } = AnimationUtilities_default;
var { parse: color8 } = Color_default;
var { charts: charts5, deg2rad: deg2rad9 } = Globals_default;
var { perspective: perspective6, shapeArea: shapeArea3 } = Math3D_default;
var { defined: defined61, extend: extend63, merge: merge77, pick: pick84 } = Utilities_default;
var cos = Math.cos;
var sin = Math.sin;
var PI = Math.PI;
var dFactor = 4 * (Math.sqrt(2) - 1) / 3 / (PI / 2);
function curveTo(cx, cy, rx, ry, start, end, dx, dy) {
  const arcAngle = end - start;
  let result = [];
  if (end > start && end - start > Math.PI / 2 + 1e-4) {
    result = result.concat(curveTo(cx, cy, rx, ry, start, start + Math.PI / 2, dx, dy));
    result = result.concat(curveTo(cx, cy, rx, ry, start + Math.PI / 2, end, dx, dy));
    return result;
  }
  if (end < start && start - end > Math.PI / 2 + 1e-4) {
    result = result.concat(curveTo(cx, cy, rx, ry, start, start - Math.PI / 2, dx, dy));
    result = result.concat(curveTo(cx, cy, rx, ry, start - Math.PI / 2, end, dx, dy));
    return result;
  }
  return [[
    "C",
    cx + rx * Math.cos(start) - rx * dFactor * arcAngle * Math.sin(start) + dx,
    cy + ry * Math.sin(start) + ry * dFactor * arcAngle * Math.cos(start) + dy,
    cx + rx * Math.cos(end) + rx * dFactor * arcAngle * Math.sin(end) + dx,
    cy + ry * Math.sin(end) - ry * dFactor * arcAngle * Math.cos(end) + dy,
    cx + rx * Math.cos(end) + dx,
    cy + ry * Math.sin(end) + dy
  ]];
}
var SVGRenderer3D;
(function(SVGRenderer3D2) {
  function compose27(SVGRendererClass) {
    const rendererProto = SVGRendererClass.prototype;
    if (!rendererProto.element3d) {
      extend63(rendererProto, {
        Element3D: SVGElement3D_default,
        arc3d,
        arc3dPath,
        cuboid,
        cuboidPath,
        element3d,
        face3d,
        polyhedron,
        toLinePath,
        toLineSegments
      });
    }
  }
  SVGRenderer3D2.compose = compose27;
  function toLinePath(points, closed) {
    const result = [];
    for (const point of points) {
      result.push(["L", point.x, point.y]);
    }
    if (points.length) {
      result[0][0] = "M";
      if (closed) {
        result.push(["Z"]);
      }
    }
    return result;
  }
  function toLineSegments(points) {
    const result = [];
    let m = true;
    for (const point of points) {
      result.push(m ? ["M", point.x, point.y] : ["L", point.x, point.y]);
      m = !m;
    }
    return result;
  }
  function face3d(args) {
    const renderer = this, elementProto = renderer.Element.prototype, ret = renderer.createElement("path");
    ret.vertexes = [];
    ret.insidePlotArea = false;
    ret.enabled = true;
    ret.attr = function(hash) {
      if (typeof hash === "object" && (defined61(hash.enabled) || defined61(hash.vertexes) || defined61(hash.insidePlotArea))) {
        this.enabled = pick84(hash.enabled, this.enabled);
        this.vertexes = pick84(hash.vertexes, this.vertexes);
        this.insidePlotArea = pick84(hash.insidePlotArea, this.insidePlotArea);
        delete hash.enabled;
        delete hash.vertexes;
        delete hash.insidePlotArea;
        const chart = charts5[renderer.chartIndex], vertexes2d = perspective6(this.vertexes, chart, this.insidePlotArea), path = renderer.toLinePath(vertexes2d, true), area = shapeArea3(vertexes2d);
        hash.d = path;
        hash.visibility = this.enabled && area > 0 ? "inherit" : "hidden";
      }
      return elementProto.attr.apply(this, arguments);
    };
    ret.animate = function(params) {
      if (typeof params === "object" && (defined61(params.enabled) || defined61(params.vertexes) || defined61(params.insidePlotArea))) {
        this.enabled = pick84(params.enabled, this.enabled);
        this.vertexes = pick84(params.vertexes, this.vertexes);
        this.insidePlotArea = pick84(params.insidePlotArea, this.insidePlotArea);
        delete params.enabled;
        delete params.vertexes;
        delete params.insidePlotArea;
        const chart = charts5[renderer.chartIndex], vertexes2d = perspective6(this.vertexes, chart, this.insidePlotArea), path = renderer.toLinePath(vertexes2d, true), area = shapeArea3(vertexes2d), visibility = this.enabled && area > 0 ? "visible" : "hidden";
        params.d = path;
        this.attr("visibility", visibility);
      }
      return elementProto.animate.apply(this, arguments);
    };
    return ret.attr(args);
  }
  function polyhedron(args) {
    const renderer = this, elementProto = renderer.Element.prototype, result = renderer.g(), destroy = result.destroy;
    if (!this.styledMode) {
      result.attr({
        "stroke-linejoin": "round"
      });
    }
    result.faces = [];
    result.destroy = function() {
      for (let i = 0; i < result.faces.length; i++) {
        result.faces[i].destroy();
      }
      return destroy.call(this);
    };
    result.attr = function(hash, val, complete, continueAnimation) {
      if (typeof hash === "object" && defined61(hash.faces)) {
        while (result.faces.length > hash.faces.length) {
          result.faces.pop().destroy();
        }
        while (result.faces.length < hash.faces.length) {
          result.faces.push(renderer.face3d().add(result));
        }
        for (let i = 0; i < hash.faces.length; i++) {
          if (renderer.styledMode) {
            delete hash.faces[i].fill;
          }
          result.faces[i].attr(hash.faces[i], null, complete, continueAnimation);
        }
        delete hash.faces;
      }
      return elementProto.attr.apply(this, arguments);
    };
    result.animate = function(params, duration, complete) {
      if (params?.faces) {
        while (result.faces.length > params.faces.length) {
          result.faces.pop().destroy();
        }
        while (result.faces.length < params.faces.length) {
          result.faces.push(renderer.face3d().add(result));
        }
        for (let i = 0; i < params.faces.length; i++) {
          result.faces[i].animate(params.faces[i], duration, complete);
        }
        delete params.faces;
      }
      return elementProto.animate.apply(this, arguments);
    };
    return result.attr(args);
  }
  function element3d(type, shapeArgs) {
    const elem3d = new SVGElement3D_default.types[type](this, "g");
    elem3d.initArgs(shapeArgs);
    return elem3d;
  }
  function cuboid(shapeArgs) {
    return this.element3d("cuboid", shapeArgs);
  }
  function cuboidPath(shapeArgs) {
    const x = shapeArgs.x || 0, y = shapeArgs.y || 0, z = shapeArgs.z || 0, h = shapeArgs.height || 0, w = shapeArgs.width || 0, d = shapeArgs.depth || 0, chart = charts5[this.chartIndex], options3d = chart.options.chart.options3d, alpha = options3d.alpha, incrementX = 1e6, incrementY = 10, incrementZ = 100, forcedSides = [];
    let shape, zIndex = 0, pArr = [{
      x,
      y,
      z
    }, {
      x: x + w,
      y,
      z
    }, {
      x: x + w,
      y: y + h,
      z
    }, {
      x,
      y: y + h,
      z
    }, {
      x,
      y: y + h,
      z: z + d
    }, {
      x: x + w,
      y: y + h,
      z: z + d
    }, {
      x: x + w,
      y,
      z: z + d
    }, {
      x,
      y,
      z: z + d
    }];
    pArr = perspective6(pArr, chart, shapeArgs.insidePlotArea);
    const mapSidePath = (i) => {
      if (h === 0 && i > 1 && i < 6) {
        return {
          x: pArr[i].x,
          // When height is 0 instead of cuboid we render plane
          // so it is needed to add fake 10 height to imitate
          // cuboid for side calculation
          y: pArr[i].y + 10,
          z: pArr[i].z
        };
      }
      if (pArr[0].x === pArr[7].x && i >= 4) {
        return {
          x: pArr[i].x + 10,
          // When height is 0 instead of cuboid we render plane
          // so it is needed to add fake 10 height to imitate
          // cuboid for side calculation
          y: pArr[i].y,
          z: pArr[i].z
        };
      }
      if (d === 0 && i < 2 || i > 5) {
        return {
          x: pArr[i].x,
          // When height is 0 instead of cuboid we render plane
          // so it is needed to add fake 10 height to imitate
          // cuboid for side calculation
          y: pArr[i].y,
          z: pArr[i].z + 10
        };
      }
      return pArr[i];
    }, mapPath = (i) => pArr[i], pickShape = (verticesIndex1, verticesIndex2, side) => {
      const face1 = verticesIndex1.map(mapPath), face2 = verticesIndex2.map(mapPath), dummyFace1 = verticesIndex1.map(mapSidePath), dummyFace2 = verticesIndex2.map(mapSidePath);
      let ret = [[], -1];
      if (shapeArea3(face1) < 0) {
        ret = [face1, 0];
      } else if (shapeArea3(face2) < 0) {
        ret = [face2, 1];
      } else if (side) {
        forcedSides.push(side);
        if (shapeArea3(dummyFace1) < 0) {
          ret = [face1, 0];
        } else if (shapeArea3(dummyFace2) < 0) {
          ret = [face2, 1];
        } else {
          ret = [face1, 0];
        }
      }
      return ret;
    };
    const front = [3, 2, 1, 0], back = [7, 6, 5, 4];
    shape = pickShape(front, back, "front");
    const path1 = shape[0], isFront = shape[1];
    const top = [1, 6, 7, 0], bottom = [4, 5, 2, 3];
    shape = pickShape(top, bottom, "top");
    const path2 = shape[0], isTop = shape[1];
    const right = [1, 2, 5, 6], left = [0, 7, 4, 3];
    shape = pickShape(right, left, "side");
    const path3 = shape[0], isRight = shape[1];
    if (isRight === 1) {
      zIndex += incrementX * (chart.plotWidth - x);
    } else if (!isRight) {
      zIndex += incrementX * x;
    }
    zIndex += incrementY * (!isTop || // Numbers checked empirically
    (alpha >= 0 && alpha <= 180 || alpha < 360 && alpha > 357.5) ? chart.plotHeight - y : 10 + y);
    if (isFront === 1) {
      zIndex += incrementZ * z;
    } else if (!isFront) {
      zIndex += incrementZ * (1e3 - z);
    }
    return {
      front: this.toLinePath(path1, true),
      top: this.toLinePath(path2, true),
      side: this.toLinePath(path3, true),
      zIndexes: {
        group: Math.round(zIndex)
      },
      forcedSides,
      // Additional info about zIndexes
      isFront,
      isTop
    };
  }
  function arc3d(attribs) {
    const renderer = this, wrapper = renderer.g(), elementProto = renderer.Element.prototype, customAttribs = [
      "alpha",
      "beta",
      "x",
      "y",
      "r",
      "innerR",
      "start",
      "end",
      "depth"
    ];
    function extractCustom(params) {
      const ca = {};
      params = merge77(params);
      let key;
      for (key in params) {
        if (customAttribs.indexOf(key) !== -1) {
          ca[key] = params[key];
          delete params[key];
        }
      }
      return Object.keys(ca).length ? [ca, params] : false;
    }
    attribs = merge77(attribs);
    attribs.alpha = (attribs.alpha || 0) * deg2rad9;
    attribs.beta = (attribs.beta || 0) * deg2rad9;
    wrapper.top = renderer.path();
    wrapper.side1 = renderer.path();
    wrapper.side2 = renderer.path();
    wrapper.inn = renderer.path();
    wrapper.out = renderer.path();
    wrapper.onAdd = function() {
      const parent = wrapper.parentGroup, className = wrapper.attr("class");
      wrapper.top.add(wrapper);
      for (const face of ["out", "inn", "side1", "side2"]) {
        wrapper[face].attr({
          "class": className + " highcharts-3d-side"
        }).add(parent);
      }
    };
    for (const fn of ["addClass", "removeClass"]) {
      wrapper[fn] = function() {
        const args = arguments;
        for (const face of ["top", "out", "inn", "side1", "side2"]) {
          wrapper[face][fn].apply(wrapper[face], args);
        }
      };
    }
    wrapper.setPaths = function(attribs2) {
      const paths = wrapper.renderer.arc3dPath(attribs2), zIndex = paths.zTop * 100;
      wrapper.attribs = attribs2;
      wrapper.top.attr({ d: paths.top, zIndex: paths.zTop });
      wrapper.inn.attr({ d: paths.inn, zIndex: paths.zInn });
      wrapper.out.attr({ d: paths.out, zIndex: paths.zOut });
      wrapper.side1.attr({ d: paths.side1, zIndex: paths.zSide1 });
      wrapper.side2.attr({ d: paths.side2, zIndex: paths.zSide2 });
      wrapper.zIndex = zIndex;
      wrapper.attr({ zIndex });
      if (attribs2.center) {
        wrapper.top.setRadialReference(attribs2.center);
        delete attribs2.center;
      }
    };
    wrapper.setPaths(attribs);
    wrapper.fillSetter = function(value) {
      const darker = color8(value).brighten(-0.1).get();
      this.fill = value;
      this.side1.attr({ fill: darker });
      this.side2.attr({ fill: darker });
      this.inn.attr({ fill: darker });
      this.out.attr({ fill: darker });
      this.top.attr({ fill: value });
      return this;
    };
    for (const setter of ["opacity", "translateX", "translateY", "visibility"]) {
      wrapper[setter + "Setter"] = function(value, key) {
        wrapper[key] = value;
        for (const el of ["out", "inn", "side1", "side2", "top"]) {
          wrapper[el].attr(key, value);
        }
      };
    }
    wrapper.attr = function(params) {
      if (typeof params === "object") {
        const paramArr = extractCustom(params);
        if (paramArr) {
          const ca = paramArr[0];
          arguments[0] = paramArr[1];
          if (ca.alpha !== void 0) {
            ca.alpha *= deg2rad9;
          }
          if (ca.beta !== void 0) {
            ca.beta *= deg2rad9;
          }
          extend63(wrapper.attribs, ca);
          if (wrapper.attribs) {
            wrapper.setPaths(wrapper.attribs);
          }
        }
      }
      return elementProto.attr.apply(wrapper, arguments);
    };
    wrapper.animate = function(params, animation, complete) {
      const from = this.attribs, randomProp = "data-" + Math.random().toString(26).substring(2, 9);
      delete params.center;
      delete params.z;
      const anim = animObject14(pick84(animation, this.renderer.globalAnimation));
      if (anim.duration) {
        const paramArr = extractCustom(params);
        wrapper[randomProp] = 0;
        params[randomProp] = 1;
        wrapper[randomProp + "Setter"] = Globals_default.noop;
        if (paramArr) {
          const to = paramArr[0], interpolate = (key, pos) => from[key] + (pick84(to[key], from[key]) - from[key]) * pos;
          anim.step = function(a, fx) {
            if (fx.prop === randomProp) {
              fx.elem.setPaths(merge77(from, {
                x: interpolate("x", fx.pos),
                y: interpolate("y", fx.pos),
                r: interpolate("r", fx.pos),
                innerR: interpolate("innerR", fx.pos),
                start: interpolate("start", fx.pos),
                end: interpolate("end", fx.pos),
                depth: interpolate("depth", fx.pos)
              }));
            }
          };
        }
        animation = anim;
      }
      return elementProto.animate.call(this, params, animation, complete);
    };
    wrapper.destroy = function() {
      this.top.destroy();
      this.out.destroy();
      this.inn.destroy();
      this.side1.destroy();
      this.side2.destroy();
      return elementProto.destroy.call(this);
    };
    wrapper.hide = function() {
      this.top.hide();
      this.out.hide();
      this.inn.hide();
      this.side1.hide();
      this.side2.hide();
    };
    wrapper.show = function(inherit) {
      this.top.show(inherit);
      this.out.show(inherit);
      this.inn.show(inherit);
      this.side1.show(inherit);
      this.side2.show(inherit);
    };
    return wrapper;
  }
  function arc3dPath(shapeArgs) {
    const cx = shapeArgs.x || 0, cy = shapeArgs.y || 0, start = shapeArgs.start || 0, end = (shapeArgs.end || 0) - 1e-5, r = shapeArgs.r || 0, ir = shapeArgs.innerR || 0, d = shapeArgs.depth || 0, alpha = shapeArgs.alpha || 0, beta = shapeArgs.beta || 0;
    const cs = Math.cos(start), ss = Math.sin(start), ce = Math.cos(end), se = Math.sin(end), rx = r * Math.cos(beta), ry = r * Math.cos(alpha), irx = ir * Math.cos(beta), iry = ir * Math.cos(alpha), dx = d * Math.sin(beta), dy = d * Math.sin(alpha);
    let top = [
      ["M", cx + rx * cs, cy + ry * ss]
    ];
    top = top.concat(curveTo(cx, cy, rx, ry, start, end, 0, 0));
    top.push([
      "L",
      cx + irx * ce,
      cy + iry * se
    ]);
    top = top.concat(curveTo(cx, cy, irx, iry, end, start, 0, 0));
    top.push(["Z"]);
    const b = beta > 0 ? Math.PI / 2 : 0, a = alpha > 0 ? 0 : Math.PI / 2;
    const start2 = start > -b ? start : end > -b ? -b : start, end2 = end < PI - a ? end : start < PI - a ? PI - a : end, midEnd = 2 * PI - a;
    let out = [
      ["M", cx + rx * cos(start2), cy + ry * sin(start2)]
    ];
    out = out.concat(curveTo(cx, cy, rx, ry, start2, end2, 0, 0));
    if (end > midEnd && start < midEnd) {
      out.push([
        "L",
        cx + rx * cos(end2) + dx,
        cy + ry * sin(end2) + dy
      ]);
      out = out.concat(curveTo(cx, cy, rx, ry, end2, midEnd, dx, dy));
      out.push([
        "L",
        cx + rx * cos(midEnd),
        cy + ry * sin(midEnd)
      ]);
      out = out.concat(curveTo(cx, cy, rx, ry, midEnd, end, 0, 0));
      out.push([
        "L",
        cx + rx * cos(end) + dx,
        cy + ry * sin(end) + dy
      ]);
      out = out.concat(curveTo(cx, cy, rx, ry, end, midEnd, dx, dy));
      out.push([
        "L",
        cx + rx * cos(midEnd),
        cy + ry * sin(midEnd)
      ]);
      out = out.concat(curveTo(cx, cy, rx, ry, midEnd, end2, 0, 0));
    } else if (end > PI - a && start < PI - a) {
      out.push([
        "L",
        cx + rx * Math.cos(end2) + dx,
        cy + ry * Math.sin(end2) + dy
      ]);
      out = out.concat(curveTo(cx, cy, rx, ry, end2, end, dx, dy));
      out.push([
        "L",
        cx + rx * Math.cos(end),
        cy + ry * Math.sin(end)
      ]);
      out = out.concat(curveTo(cx, cy, rx, ry, end, end2, 0, 0));
    }
    out.push([
      "L",
      cx + rx * Math.cos(end2) + dx,
      cy + ry * Math.sin(end2) + dy
    ]);
    out = out.concat(curveTo(cx, cy, rx, ry, end2, start2, dx, dy));
    out.push(["Z"]);
    let inn = [
      ["M", cx + irx * cs, cy + iry * ss]
    ];
    inn = inn.concat(curveTo(cx, cy, irx, iry, start, end, 0, 0));
    inn.push([
      "L",
      cx + irx * Math.cos(end) + dx,
      cy + iry * Math.sin(end) + dy
    ]);
    inn = inn.concat(curveTo(cx, cy, irx, iry, end, start, dx, dy));
    inn.push(["Z"]);
    const side1 = [
      ["M", cx + rx * cs, cy + ry * ss],
      ["L", cx + rx * cs + dx, cy + ry * ss + dy],
      ["L", cx + irx * cs + dx, cy + iry * ss + dy],
      ["L", cx + irx * cs, cy + iry * ss],
      ["Z"]
    ];
    const side2 = [
      ["M", cx + rx * ce, cy + ry * se],
      ["L", cx + rx * ce + dx, cy + ry * se + dy],
      ["L", cx + irx * ce + dx, cy + iry * se + dy],
      ["L", cx + irx * ce, cy + iry * se],
      ["Z"]
    ];
    const angleCorr = Math.atan2(dy, -dx);
    let angleEnd = Math.abs(end + angleCorr), angleStart = Math.abs(start + angleCorr), angleMid = Math.abs((start + end) / 2 + angleCorr);
    function toZeroPIRange(angle) {
      angle = angle % (2 * Math.PI);
      if (angle > Math.PI) {
        angle = 2 * Math.PI - angle;
      }
      return angle;
    }
    angleEnd = toZeroPIRange(angleEnd);
    angleStart = toZeroPIRange(angleStart);
    angleMid = toZeroPIRange(angleMid);
    const incPrecision = 1e5, a1 = angleMid * incPrecision, a2 = angleStart * incPrecision, a3 = angleEnd * incPrecision;
    return {
      top,
      // Max angle is PI, so this is always higher
      zTop: Math.PI * incPrecision + 1,
      out,
      zOut: Math.max(a1, a2, a3),
      inn,
      zInn: Math.max(a1, a2, a3),
      side1,
      // To keep below zOut and zInn in case of same values
      zSide1: a3 * 0.99,
      side2,
      zSide2: a2 * 0.99
    };
  }
})(SVGRenderer3D || (SVGRenderer3D = {}));
var SVGRenderer3D_default = SVGRenderer3D;

// node_modules/highcharts/es-modules/Core/Axis/ZAxis.js
var { defaultOptions: defaultOptions19 } = Defaults_default;
var { addEvent: addEvent73, merge: merge78, pick: pick85, splat: splat16 } = Utilities_default;
function chartAddZAxis(options2) {
  return new ZAxis(this, options2);
}
function onChartAfterCreateAxes() {
  const zAxisOptions = this.options.zAxis = splat16(this.options.zAxis || {});
  if (!this.is3d()) {
    return;
  }
  this.zAxis = [];
  zAxisOptions.forEach((axisOptions) => {
    this.addZAxis(axisOptions).setScale();
  });
}
var ZAxis = class extends Axis_default {
  constructor() {
    super(...arguments);
    this.isZAxis = true;
  }
  static compose(ChartClass) {
    const chartProto = ChartClass.prototype;
    if (!chartProto.addZAxis) {
      defaultOptions19.zAxis = merge78(defaultOptions19.xAxis, {
        offset: 0,
        lineWidth: 0
      });
      chartProto.addZAxis = chartAddZAxis;
      chartProto.collectionsWithInit.zAxis = [chartProto.addZAxis];
      chartProto.collectionsWithUpdate.push("zAxis");
      addEvent73(ChartClass, "afterCreateAxes", onChartAfterCreateAxes);
    }
  }
  /* *
   *
   *  Constructor
   *
   * */
  init(chart, userOptions) {
    this.isZAxis = true;
    super.init(chart, userOptions, "zAxis");
  }
  /* *
   *
   *  Functions
   *
   * */
  getSeriesExtremes() {
    this.hasVisibleSeries = false;
    this.dataMin = this.dataMax = this.ignoreMinPadding = this.ignoreMaxPadding = void 0;
    if (this.stacking) {
      this.stacking.buildStacks();
    }
    this.series.forEach((series) => {
      if (series.reserveSpace()) {
        let threshold = series.options.threshold;
        this.hasVisibleSeries = true;
        if (this.positiveValuesOnly && threshold <= 0) {
          threshold = void 0;
        }
        const zData = series.getColumn("z");
        if (zData.length) {
          this.dataMin = Math.min(pick85(this.dataMin, zData[0]), Math.min.apply(null, zData));
          this.dataMax = Math.max(pick85(this.dataMax, zData[0]), Math.max.apply(null, zData));
        }
      }
    });
  }
  /**
   * @private
   */
  setAxisSize() {
    const chart = this.chart;
    super.setAxisSize();
    this.width = this.len = chart.options.chart.options3d?.depth || 0;
    this.right = chart.chartWidth - this.width - this.left;
  }
};
var ZAxis_default = ZAxis;

// node_modules/highcharts/es-modules/Series/Column3D/Column3DComposition.js
var { composed: composed28 } = Globals_default;
var { perspective: perspective7 } = Math3D_default;
var { addEvent: addEvent74, extend: extend64, pick: pick86, pushUnique: pushUnique31, wrap: wrap12 } = Utilities_default;
function columnSeriesTranslate3dShapes() {
  const series = this, chart = series.chart, seriesOptions = series.options, depth = seriesOptions.depth, stack = seriesOptions.stacking ? seriesOptions.stack || 0 : series.index;
  let z = stack * (depth + (seriesOptions.groupZPadding || 1)), borderCrisp = series.borderWidth % 2 ? 0.5 : 0, point2dPos;
  if (chart.inverted && !series.yAxis.reversed) {
    borderCrisp *= -1;
  }
  if (seriesOptions.grouping !== false) {
    z = 0;
  }
  z += seriesOptions.groupZPadding || 1;
  for (const point of series.points) {
    point.outside3dPlot = null;
    if (point.y !== null) {
      const shapeArgs = extend64({ x: 0, y: 0, width: 0, height: 0 }, point.shapeArgs || {}), dimensions = [["x", "width"], ["y", "height"]], tooltipPos = point.tooltipPos;
      let borderlessBase;
      for (const d of dimensions) {
        borderlessBase = shapeArgs[d[0]] - borderCrisp;
        if (borderlessBase < 0) {
          shapeArgs[d[1]] += shapeArgs[d[0]] + borderCrisp;
          shapeArgs[d[0]] = -borderCrisp;
          borderlessBase = 0;
        }
        if (borderlessBase + shapeArgs[d[1]] > series[d[0] + "Axis"].len && // Do not change height/width of column if 0 (#6708)
        shapeArgs[d[1]] !== 0) {
          shapeArgs[d[1]] = series[d[0] + "Axis"].len - shapeArgs[d[0]];
        }
        if (
          // Do not remove columns with zero height/width.
          shapeArgs[d[1]] !== 0 && (shapeArgs[d[0]] >= series[d[0] + "Axis"].len || shapeArgs[d[0]] + shapeArgs[d[1]] <= borderCrisp)
        ) {
          for (const key in shapeArgs) {
            shapeArgs[key] = key === "y" ? -9999 : 0;
          }
          point.outside3dPlot = true;
        }
      }
      if (point.shapeType === "roundedRect") {
        point.shapeType = "cuboid";
      }
      point.shapeArgs = extend64(shapeArgs, {
        z,
        depth,
        insidePlotArea: true
      });
      point2dPos = {
        x: shapeArgs.x + shapeArgs.width / 2,
        y: shapeArgs.y,
        z: z + depth / 2
        // The center of column in Z dimension
      };
      if (chart.inverted) {
        point2dPos.x = shapeArgs.height;
        point2dPos.y = point.clientX || 0;
      }
      point.axisXpos = point2dPos.x;
      point.axisYpos = point2dPos.y;
      point.axisZpos = point2dPos.z;
      point.plot3d = perspective7([point2dPos], chart, true, false)[0];
      if (tooltipPos) {
        const translatedTTPos = perspective7([{
          x: tooltipPos[0],
          y: tooltipPos[1],
          z: z + depth / 2
          // The center of column in Z dimension
        }], chart, true, false)[0];
        point.tooltipPos = [translatedTTPos.x, translatedTTPos.y];
      }
    }
  }
  series.z = z;
}
function compose18(SeriesClass, StackItemClass) {
  if (pushUnique31(composed28, "Column3D")) {
    const seriesProto7 = SeriesClass.prototype, stackItemProto = StackItemClass.prototype, { column: ColumnSeriesClass, columnRange: ColumnRangeSeriesClass } = SeriesClass.types;
    wrap12(seriesProto7, "alignDataLabel", wrapSeriesAlignDataLabel);
    wrap12(seriesProto7, "justifyDataLabel", wrapSeriesJustifyDataLabel);
    wrap12(stackItemProto, "getStackBox", wrapStackItemGetStackBox);
    if (ColumnSeriesClass) {
      const columnSeriesProto = ColumnSeriesClass.prototype, columnPointProto = columnSeriesProto.pointClass.prototype;
      columnSeriesProto.translate3dPoints = () => void 0;
      columnSeriesProto.translate3dShapes = columnSeriesTranslate3dShapes;
      addEvent74(columnSeriesProto, "afterInit", onColumnSeriesAfterInit);
      wrap12(columnPointProto, "hasNewShapeType", wrapColumnPointHasNewShapeType);
      wrap12(columnSeriesProto, "animate", wrapColumnSeriesAnimate);
      wrap12(columnSeriesProto, "plotGroup", wrapColumnSeriesPlotGroup);
      wrap12(columnSeriesProto, "pointAttribs", wrapColumnSeriesPointAttribs);
      wrap12(columnSeriesProto, "setState", wrapColumnSeriesSetState);
      wrap12(columnSeriesProto, "setVisible", wrapColumnSeriesSetVisible);
      wrap12(columnSeriesProto, "translate", wrapColumnSeriesTranslate);
    }
    if (ColumnRangeSeriesClass) {
      const columnRangeSeriesProto = ColumnRangeSeriesClass.prototype, columnRangePointProto = columnRangeSeriesProto.pointClass.prototype;
      wrap12(columnRangePointProto, "hasNewShapeType", wrapColumnPointHasNewShapeType);
      wrap12(columnRangeSeriesProto, "plotGroup", wrapColumnSeriesPlotGroup);
      wrap12(columnRangeSeriesProto, "pointAttribs", wrapColumnSeriesPointAttribs);
      wrap12(columnRangeSeriesProto, "setState", wrapColumnSeriesSetState);
      wrap12(columnRangeSeriesProto, "setVisible", wrapColumnSeriesSetVisible);
    }
  }
}
function retrieveStacks(chart, stacking) {
  const series = chart.series, stacks = { totalStacks: 0 };
  let stackNumber, i = 1;
  series.forEach(function(s) {
    stackNumber = pick86(s.options.stack, stacking ? 0 : series.length - 1 - s.index);
    if (!stacks[stackNumber]) {
      stacks[stackNumber] = { series: [s], position: i };
      i++;
    } else {
      stacks[stackNumber].series.push(s);
    }
  });
  stacks.totalStacks = i + 1;
  return stacks;
}
function onColumnSeriesAfterInit() {
  if (this.chart.is3d()) {
    const series = this, seriesOptions = series.options, grouping = seriesOptions.grouping, stacking = seriesOptions.stacking, reversedStacks = series.yAxis.options.reversedStacks;
    let z = 0;
    if (!(typeof grouping !== "undefined" && !grouping)) {
      const stacks = retrieveStacks(this.chart, stacking), stack = seriesOptions.stack || 0;
      let i;
      for (i = 0; i < stacks[stack].series.length; i++) {
        if (stacks[stack].series[i] === this) {
          break;
        }
      }
      z = 10 * (stacks.totalStacks - stacks[stack].position) + (reversedStacks ? i : -i);
      if (!this.xAxis.reversed) {
        z = stacks.totalStacks * 10 - z;
      }
    }
    seriesOptions.depth = seriesOptions.depth || 25;
    series.z = series.z || 0;
    seriesOptions.zIndex = z;
  }
}
function wrapColumnPointHasNewShapeType(proceed, ...args) {
  return this.series.chart.is3d() ? this.graphic && this.graphic.element.nodeName !== "g" : proceed.apply(this, args);
}
function wrapColumnSeriesAnimate(proceed) {
  if (!this.chart.is3d()) {
    proceed.apply(this, [].slice.call(arguments, 1));
  } else {
    const args = arguments, init3 = args[1], yAxis2 = this.yAxis, series = this, reversed = this.yAxis.reversed;
    if (init3) {
      for (const point of series.points) {
        if (point.y !== null) {
          point.height = point.shapeArgs.height;
          point.shapey = point.shapeArgs.y;
          point.shapeArgs.height = 1;
          if (!reversed) {
            if (point.stackY) {
              point.shapeArgs.y = point.plotY + yAxis2.translate(point.stackY);
            } else {
              point.shapeArgs.y = point.plotY + (point.negative ? -point.height : point.height);
            }
          }
        }
      }
    } else {
      for (const point of series.points) {
        if (point.y !== null) {
          point.shapeArgs.height = point.height;
          point.shapeArgs.y = point.shapey;
          if (point.graphic) {
            point.graphic[point.outside3dPlot ? "attr" : "animate"](point.shapeArgs, series.options.animation);
          }
        }
      }
      this.drawDataLabels();
    }
  }
}
function wrapColumnSeriesPlotGroup(proceed, prop, _name, _visibility, _zIndex, parent) {
  if (prop !== "dataLabelsGroup" && prop !== "markerGroup") {
    if (this.chart.is3d()) {
      if (this[prop]) {
        delete this[prop];
      }
      if (parent) {
        if (!this.chart.columnGroup) {
          this.chart.columnGroup = this.chart.renderer.g("columnGroup").add(parent);
        }
        this[prop] = this.chart.columnGroup;
        this.chart.columnGroup.attr(this.getPlotBox());
        this[prop].survive = true;
        if (prop === "group") {
          arguments[3] = "visible";
        }
      }
    }
  }
  return proceed.apply(this, Array.prototype.slice.call(arguments, 1));
}
function wrapColumnSeriesPointAttribs(proceed) {
  const attr18 = proceed.apply(this, [].slice.call(arguments, 1));
  if (this.chart.is3d && this.chart.is3d()) {
    attr18.stroke = this.options.edgeColor || attr18.fill;
    attr18["stroke-width"] = pick86(this.options.edgeWidth, 1);
  }
  return attr18;
}
function wrapColumnSeriesSetState(proceed, state, inherit) {
  const is3d = this.chart.is3d && this.chart.is3d();
  if (is3d) {
    this.options.inactiveOtherPoints = true;
  }
  proceed.call(this, state, inherit);
  if (is3d) {
    this.options.inactiveOtherPoints = false;
  }
}
function wrapColumnSeriesSetVisible(proceed, vis) {
  const series = this;
  if (series.chart.is3d()) {
    for (const point of series.points) {
      point.visible = point.options.visible = vis = typeof vis === "undefined" ? !pick86(series.visible, point.visible) : vis;
      series.options.data[series.data.indexOf(point)] = point.options;
      if (point.graphic) {
        point.graphic.attr({
          visibility: vis ? "visible" : "hidden"
        });
      }
    }
  }
  proceed.apply(this, Array.prototype.slice.call(arguments, 1));
}
function wrapColumnSeriesTranslate(proceed) {
  proceed.apply(this, [].slice.call(arguments, 1));
  if (this.chart.is3d()) {
    this.translate3dShapes();
  }
}
function wrapSeriesAlignDataLabel(proceed, point, _dataLabel, options2, alignTo) {
  const chart = this.chart;
  options2.outside3dPlot = point.outside3dPlot;
  if (chart.is3d() && this.is("column")) {
    const series = this, seriesOptions = series.options, inside = pick86(options2.inside, !!series.options.stacking), options3d = chart.options.chart.options3d, xOffset = point.pointWidth / 2 || 0;
    let dLPosition = {
      x: alignTo.x + xOffset,
      y: alignTo.y,
      z: series.z + seriesOptions.depth / 2
    };
    if (chart.inverted) {
      if (inside) {
        alignTo.width = 0;
        dLPosition.x += point.shapeArgs.height / 2;
      }
      if (options3d.alpha >= 90 && options3d.alpha <= 270) {
        dLPosition.y += point.shapeArgs.width;
      }
    }
    dLPosition = perspective7([dLPosition], chart, true, false)[0];
    alignTo.x = dLPosition.x - xOffset;
    alignTo.y = point.outside3dPlot ? -9e9 : dLPosition.y;
  }
  proceed.apply(this, [].slice.call(arguments, 1));
}
function wrapSeriesJustifyDataLabel(proceed) {
  return !arguments[2].outside3dPlot ? proceed.apply(this, [].slice.call(arguments, 1)) : false;
}
function wrapStackItemGetStackBox(proceed, stackBoxProps) {
  const stackBox = proceed.apply(this, [].slice.call(arguments, 1));
  const stackItem = this, chart = this.axis.chart, { width: xWidth } = stackBoxProps;
  if (chart.is3d() && stackItem.base) {
    const baseSeriesInd = +stackItem.base.split(",")[0];
    const columnSeries = chart.series[baseSeriesInd];
    const options3d = chart.options.chart.options3d;
    if (columnSeries && columnSeries.type === "column") {
      let dLPosition = {
        x: stackBox.x + (chart.inverted ? stackBox.height : xWidth / 2),
        y: stackBox.y,
        z: columnSeries.options.depth / 2
      };
      if (chart.inverted) {
        stackBox.width = 0;
        if (options3d.alpha >= 90 && options3d.alpha <= 270) {
          dLPosition.y += xWidth;
        }
      }
      dLPosition = perspective7([dLPosition], chart, true, false)[0];
      stackBox.x = dLPosition.x - xWidth / 2;
      stackBox.y = dLPosition.y;
    }
  }
  return stackBox;
}
var Column3DComposition = {
  compose: compose18
};
var Column3DComposition_default = Column3DComposition;

// node_modules/highcharts/es-modules/Series/Pie3D/Pie3DPoint.js
var { pie: { prototype: { pointClass: PiePoint2 } } } = SeriesRegistry_default.seriesTypes;
var Pie3DPoint = class extends PiePoint2 {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  haloPath() {
    return this.series?.chart.is3d() ? [] : super.haloPath.apply(this, arguments);
  }
};
var Pie3DPoint_default = Pie3DPoint;

// node_modules/highcharts/es-modules/Series/Pie3D/Pie3DSeries.js
var { composed: composed29, deg2rad: deg2rad10 } = Globals_default;
var { pie: PieSeries2 } = SeriesRegistry_default.seriesTypes;
var { extend: extend65, pick: pick87, pushUnique: pushUnique32 } = Utilities_default;
var Pie3DSeries = class _Pie3DSeries extends PieSeries2 {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(SeriesClass) {
    if (pushUnique32(composed29, "Pie3D")) {
      SeriesClass.types.pie = _Pie3DSeries;
    }
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  addPoint() {
    super.addPoint.apply(this, arguments);
    if (this.chart.is3d()) {
      this.update(this.userOptions, true);
    }
  }
  /**
   * @private
   */
  animate(init3) {
    if (!this.chart.is3d()) {
      super.animate.apply(this, arguments);
    } else {
      const center = this.center, group = this.group, markerGroup = this.markerGroup;
      let animation = this.options.animation, attribs;
      if (animation === true) {
        animation = {};
      }
      if (init3) {
        group.oldtranslateX = pick87(group.oldtranslateX, group.translateX);
        group.oldtranslateY = pick87(group.oldtranslateY, group.translateY);
        attribs = {
          translateX: center[0],
          translateY: center[1],
          scaleX: 1e-3,
          // #1499
          scaleY: 1e-3
        };
        group.attr(attribs);
        if (markerGroup) {
          markerGroup.attrSetters = group.attrSetters;
          markerGroup.attr(attribs);
        }
      } else {
        attribs = {
          translateX: group.oldtranslateX,
          translateY: group.oldtranslateY,
          scaleX: 1,
          scaleY: 1
        };
        group.animate(attribs, animation);
        if (markerGroup) {
          markerGroup.animate(attribs, animation);
        }
      }
    }
  }
  /**
   * @private
   */
  getDataLabelPosition(point, distance) {
    const labelPosition = super.getDataLabelPosition(point, distance);
    if (this.chart.is3d()) {
      const options3d = this.chart.options.chart.options3d, shapeArgs = point.shapeArgs, r = shapeArgs.r, a1 = (shapeArgs.alpha || options3d?.alpha) * deg2rad10, b1 = (shapeArgs.beta || options3d?.beta) * deg2rad10, a2 = (shapeArgs.start + shapeArgs.end) / 2, connectorPosition = labelPosition.connectorPosition, yOffset = -r * (1 - Math.cos(a1)) * Math.sin(a2), xOffset = r * (Math.cos(b1) - 1) * Math.cos(a2);
      for (const coordinates of [
        labelPosition?.natural,
        connectorPosition.breakAt,
        connectorPosition.touchingSliceAt
      ]) {
        coordinates.x += xOffset;
        coordinates.y += yOffset;
      }
    }
    return labelPosition;
  }
  /**
   * @private
   */
  pointAttribs(point) {
    const attr18 = super.pointAttribs.apply(this, arguments), options2 = this.options;
    if (this.chart.is3d() && !this.chart.styledMode) {
      attr18.stroke = options2.edgeColor || point.color || this.color;
      attr18["stroke-width"] = pick87(options2.edgeWidth, 1);
    }
    return attr18;
  }
  /**
   * @private
   */
  translate() {
    super.translate.apply(this, arguments);
    if (!this.chart.is3d()) {
      return;
    }
    const series = this, seriesOptions = series.options, depth = seriesOptions.depth || 0, options3d = series.chart.options.chart.options3d, alpha = options3d.alpha, beta = options3d.beta;
    let z = seriesOptions.stacking ? (seriesOptions.stack || 0) * depth : series._i * depth;
    z += depth / 2;
    if (seriesOptions.grouping !== false) {
      z = 0;
    }
    for (const point of series.points) {
      const shapeArgs = point.shapeArgs;
      point.shapeType = "arc3d";
      shapeArgs.z = z;
      shapeArgs.depth = depth * 0.75;
      shapeArgs.alpha = alpha;
      shapeArgs.beta = beta;
      shapeArgs.center = series.center;
      const angle = (shapeArgs.end + shapeArgs.start) / 2;
      point.slicedTranslation = {
        translateX: Math.round(Math.cos(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad10)),
        translateY: Math.round(Math.sin(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad10))
      };
    }
  }
  /**
   * @private
   */
  drawTracker() {
    super.drawTracker.apply(this, arguments);
    if (!this.chart.is3d()) {
      return;
    }
    for (const point of this.points) {
      if (point.graphic) {
        for (const face of ["out", "inn", "side1", "side2"]) {
          if (point.graphic) {
            point.graphic[face].element.point = point;
          }
        }
      }
    }
  }
};
extend65(Pie3DSeries.prototype, {
  pointClass: Pie3DPoint_default
});
var Pie3DSeries_default = Pie3DSeries;

// node_modules/highcharts/es-modules/Series/Scatter3D/Scatter3DPoint.js
var { pointClass: ScatterPoint2 } = ScatterSeries_default.prototype;
var { defined: defined62 } = Utilities_default;
var Scatter3DPoint = class extends ScatterPoint2 {
  /* *
   *
   *  Functions
   *
   * */
  applyOptions() {
    super.applyOptions.apply(this, arguments);
    if (!defined62(this.z)) {
      this.z = 0;
    }
    return this;
  }
};
var Scatter3DPoint_default = Scatter3DPoint;

// node_modules/highcharts/es-modules/Series/Scatter3D/Scatter3DSeriesDefaults.js
var Scatter3DSeriesDefaults = {
  tooltip: {
    pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>"
  }
};
var Scatter3DSeriesDefaults_default = Scatter3DSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Scatter3D/Scatter3DSeries.js
var { pointCameraDistance: pointCameraDistance2 } = Math3D_default;
var { extend: extend66, merge: merge79 } = Utilities_default;
var Scatter3DSeries = class extends ScatterSeries_default {
  /* *
   *
   *  Functions
   *
   * */
  pointAttribs(point) {
    const attribs = super.pointAttribs.apply(this, arguments);
    if (this.chart.is3d() && point) {
      attribs.zIndex = pointCameraDistance2(point, this.chart);
    }
    return attribs;
  }
};
Scatter3DSeries.defaultOptions = merge79(ScatterSeries_default.defaultOptions, Scatter3DSeriesDefaults_default);
extend66(Scatter3DSeries.prototype, {
  axisTypes: ["xAxis", "yAxis", "zAxis"],
  // Require direct touch rather than using the k-d-tree, because the
  // k-d-tree currently doesn't take the xyz coordinate system into
  // account (#4552)
  directTouch: true,
  parallelArrays: ["x", "y", "z"],
  pointArrayMap: ["x", "y", "z"],
  pointClass: Scatter3DPoint_default
});
SeriesRegistry_default.registerSeriesType("scatter3d", Scatter3DSeries);

// node_modules/highcharts/es-modules/masters/highcharts-3d.src.js
var G9 = Globals_default;
Area3DSeries_default.compose(G9.Series.types.area);
Axis3DComposition_default.compose(G9.Axis, G9.Tick);
Chart3D_default.compose(G9.Chart, G9.Fx);
Column3DComposition_default.compose(G9.Series, StackItem_default);
Pie3DSeries_default.compose(G9.Series);
Series3D_default.compose(G9.Series);
SVGRenderer3D_default.compose(RendererRegistry_default.getRendererType());
ZAxis_default.compose(G9.Chart);

// node_modules/highcharts/es-modules/Core/HttpUtilities.js
var { win: win17 } = Globals_default;
var { discardElement: discardElement6, objectEach: objectEach30 } = Utilities_default;
function ajax(settings) {
  const headers = {
    json: "application/json",
    xml: "application/xml",
    text: "text/plain",
    octet: "application/octet-stream"
  }, r = new XMLHttpRequest();
  function handleError(xhr, err) {
    if (settings.error) {
      settings.error(xhr, err);
    } else {
    }
  }
  if (!settings.url) {
    return false;
  }
  r.open((settings.type || "get").toUpperCase(), settings.url, true);
  if (!settings.headers?.["Content-Type"]) {
    r.setRequestHeader("Content-Type", headers[settings.dataType || "json"] || headers.text);
  }
  objectEach30(settings.headers, function(val, key) {
    r.setRequestHeader(key, val);
  });
  if (settings.responseType) {
    r.responseType = settings.responseType;
  }
  r.onreadystatechange = function() {
    let res;
    if (r.readyState === 4) {
      if (r.status === 200) {
        if (settings.responseType !== "blob") {
          res = r.responseText;
          if (settings.dataType === "json") {
            try {
              res = JSON.parse(res);
            } catch (e) {
              if (e instanceof Error) {
                return handleError(r, e);
              }
            }
          }
        }
        return settings.success?.(res, r);
      }
      handleError(r, r.responseText);
    }
  };
  if (settings.data && typeof settings.data !== "string") {
    settings.data = JSON.stringify(settings.data);
  }
  r.send(settings.data);
}
function getJSON(url, success) {
  HttpUtilities.ajax({
    url,
    success,
    dataType: "json",
    headers: {
      // Override the Content-Type to avoid preflight problems with CORS
      // in the Highcharts demos
      "Content-Type": "text/plain"
    }
  });
}
function post(url, data, fetchOptions) {
  const formData = new win17.FormData();
  objectEach30(data, function(val, name) {
    formData.append(name, val);
  });
  formData.append("b64", "true");
  const { filename, type } = data;
  return win17.fetch(url, {
    method: "POST",
    body: formData,
    ...fetchOptions
  }).then((res) => {
    if (res.ok) {
      res.text().then((text) => {
        const link = document.createElement("a");
        link.href = `data:${type};base64,${text}`;
        link.download = filename;
        link.click();
        discardElement6(link);
      });
    }
  });
}
var HttpUtilities = {
  ajax,
  getJSON,
  post
};
var HttpUtilities_default = HttpUtilities;

// node_modules/highcharts/es-modules/Extensions/Data.js
var { getOptions: getOptions4 } = Defaults_default;
var { doc: doc26 } = Globals_default;
var { ajax: ajax2 } = HttpUtilities_default;
var { seriesTypes: seriesTypes6 } = SeriesRegistry_default;
var { addEvent: addEvent75, defined: defined63, extend: extend67, fireEvent: fireEvent40, isNumber: isNumber58, merge: merge80, objectEach: objectEach31, pick: pick88, splat: splat17 } = Utilities_default;
function getFreeIndexes(numberOfColumns, seriesBuilders) {
  const freeIndexes = [], freeIndexValues = [];
  let s, i, referencedIndexes;
  for (i = 0; i < numberOfColumns; i = i + 1) {
    freeIndexes.push(true);
  }
  for (s = 0; s < seriesBuilders.length; s = s + 1) {
    referencedIndexes = seriesBuilders[s].getReferencedColumnIndexes();
    for (i = 0; i < referencedIndexes.length; i = i + 1) {
      freeIndexes[referencedIndexes[i]] = false;
    }
  }
  for (i = 0; i < freeIndexes.length; i = i + 1) {
    if (freeIndexes[i]) {
      freeIndexValues.push(i);
    }
  }
  return freeIndexValues;
}
function hasURLOption(options2) {
  return Boolean(options2 && (options2.rowsURL || options2.csvURL || options2.columnsURL));
}
var Data = class _Data {
  /* *
   *
   *  Static Properties
   *
   * */
  /**
   * Creates a data object to parse data for a chart.
   *
   * @function Highcharts.data
   */
  static data(dataOptions, chartOptions = {}, chart) {
    return new _Data(dataOptions, chartOptions, chart);
  }
  /**
   * Reorganize rows into columns.
   *
   * @function Highcharts.Data.rowsToColumns
   */
  static rowsToColumns(rows) {
    let row, rowsLength, col, colsLength, columns;
    if (rows) {
      columns = [];
      rowsLength = rows.length;
      for (row = 0; row < rowsLength; row++) {
        colsLength = rows[row].length;
        for (col = 0; col < colsLength; col++) {
          if (!columns[col]) {
            columns[col] = [];
          }
          columns[col][row] = rows[row][col];
        }
      }
    }
    return columns;
  }
  /* *
   *
   *  Constructors
   *
   * */
  constructor(dataOptions, chartOptions = {}, chart) {
    this.rowsToColumns = _Data.rowsToColumns;
    this.dateFormats = {
      "YYYY/mm/dd": {
        regex: /^(\d{4})[\-\/\.](\d{1,2})[\-\/\.](\d{1,2})$/,
        parser: function(match) {
          return match ? Date.UTC(+match[1], +match[2] - 1, +match[3]) : NaN;
        }
      },
      "dd/mm/YYYY": {
        regex: /^(\d{1,2})[\-\/\.](\d{1,2})[\-\/\.](\d{4})$/,
        parser: function(match) {
          return match ? Date.UTC(+match[3], +match[2] - 1, +match[1]) : NaN;
        },
        alternative: "mm/dd/YYYY"
        // Different format with the same regex
      },
      "mm/dd/YYYY": {
        regex: /^(\d{1,2})[\-\/\.](\d{1,2})[\-\/\.](\d{4})$/,
        parser: function(match) {
          return match ? Date.UTC(+match[3], +match[1] - 1, +match[2]) : NaN;
        }
      },
      "dd/mm/YY": {
        regex: /^(\d{1,2})[\-\/\.](\d{1,2})[\-\/\.](\d{2})$/,
        parser: function(match) {
          if (!match) {
            return NaN;
          }
          const d = /* @__PURE__ */ new Date();
          let year = +match[3];
          if (year > d.getFullYear() - 2e3) {
            year += 1900;
          } else {
            year += 2e3;
          }
          return Date.UTC(year, +match[2] - 1, +match[1]);
        },
        alternative: "mm/dd/YY"
        // Different format with the same regex
      },
      "mm/dd/YY": {
        regex: /^(\d{1,2})[\-\/\.](\d{1,2})[\-\/\.](\d{2})$/,
        parser: function(match) {
          return match ? Date.UTC(+match[3] + 2e3, +match[1] - 1, +match[2]) : NaN;
        }
      }
    };
    this.chart = chart;
    this.chartOptions = chartOptions;
    this.options = dataOptions;
    this.rawColumns = [];
    this.init(dataOptions, chartOptions, chart);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Initialize the Data object with the given options
   *
   * @private
   * @function Highcharts.Data#init
   */
  init(dataOptions, chartOptions, chart) {
    let decimalPoint = dataOptions.decimalPoint, hasData;
    if (chartOptions) {
      this.chartOptions = chartOptions;
    }
    if (chart) {
      this.chart = chart;
    }
    if (decimalPoint !== "." && decimalPoint !== ",") {
      decimalPoint = void 0;
    }
    this.options = dataOptions;
    this.columns = dataOptions.columns || this.rowsToColumns(dataOptions.rows) || [];
    this.firstRowAsNames = pick88(dataOptions.firstRowAsNames, this.firstRowAsNames, true);
    this.decimalRegex = decimalPoint && new RegExp("^(-?[0-9]+)" + decimalPoint + "([0-9]+)$");
    if (this.liveDataTimeout !== void 0) {
      clearTimeout(this.liveDataTimeout);
    }
    this.rawColumns = [];
    if (this.columns.length) {
      this.dataFound();
      hasData = !hasURLOption(dataOptions);
    }
    if (!hasData) {
      hasData = this.fetchLiveData();
    }
    if (!hasData) {
      hasData = Boolean(this.parseCSV().length);
    }
    if (!hasData) {
      hasData = Boolean(this.parseTable().length);
    }
    if (!hasData) {
      hasData = this.parseGoogleSpreadsheet();
    }
    if (!hasData && dataOptions.afterComplete) {
      dataOptions.afterComplete(this);
    }
  }
  /**
   * Get the column distribution. For example, a line series takes a single
   * column for Y values. A range series takes two columns for low and high
   * values respectively, and an OHLC series takes four columns.
   *
   * @function Highcharts.Data#getColumnDistribution
   */
  getColumnDistribution() {
    const chartOptions = this.chartOptions, options2 = this.options, xColumns = [], getValueCount = function(type = "line") {
      return (seriesTypes6[type].prototype.pointArrayMap || [0]).length;
    }, getPointArrayMap = function(type = "line") {
      return seriesTypes6[type].prototype.pointArrayMap;
    }, globalType = chartOptions?.chart?.type, individualCounts = [], seriesBuilders = [], seriesMapping = options2?.seriesMapping || chartOptions?.series?.map(function() {
      return { x: 0 };
    }) || [];
    let seriesIndex = 0;
    (chartOptions?.series || []).forEach((series) => {
      individualCounts.push(getValueCount(series.type || globalType));
    });
    seriesMapping.forEach((mapping) => {
      xColumns.push(mapping.x || 0);
    });
    if (xColumns.length === 0) {
      xColumns.push(0);
    }
    seriesMapping.forEach((mapping) => {
      const builder = new SeriesBuilder(), numberOfValueColumnsNeeded = individualCounts[seriesIndex] || getValueCount(globalType), seriesArr = chartOptions?.series ?? [], series = seriesArr[seriesIndex] ?? {}, defaultPointArrayMap = getPointArrayMap(series.type || globalType), pointArrayMap = defaultPointArrayMap ?? ["y"];
      if (
        // User-defined x.mapping
        defined63(mapping.x) || // All non cartesian don't need 'x'
        series.isCartesian || // Except pie series:
        !defaultPointArrayMap
      ) {
        builder.addColumnReader(mapping.x, "x");
      }
      objectEach31(mapping, function(val, name) {
        if (name !== "x") {
          builder.addColumnReader(val, name);
        }
      });
      for (let i = 0; i < numberOfValueColumnsNeeded; i++) {
        if (!builder.hasReader(pointArrayMap[i])) {
          builder.addColumnReader(void 0, pointArrayMap[i]);
        }
      }
      seriesBuilders.push(builder);
      seriesIndex++;
    });
    let globalPointArrayMap = getPointArrayMap(globalType);
    if (typeof globalPointArrayMap === "undefined") {
      globalPointArrayMap = ["y"];
    }
    this.valueCount = {
      global: getValueCount(globalType),
      xColumns,
      individual: individualCounts,
      seriesBuilders,
      globalPointArrayMap
    };
  }
  /**
   * When the data is parsed into columns, either by CSV, table, GS or direct
   * input, continue with other operations.
   *
   * @private
   * @function Highcharts.Data#dataFound
   */
  dataFound() {
    if (this.options.switchRowsAndColumns) {
      this.columns = this.rowsToColumns(this.columns);
    }
    this.getColumnDistribution();
    this.parseTypes();
    if (this.parsed() !== false) {
      this.complete();
    }
  }
  /**
   * Parse a CSV input string
   *
   * @function Highcharts.Data#parseCSV
   */
  parseCSV(inOptions) {
    const self = this, columns = this.columns = [], options2 = inOptions || this.options, startColumn = options2.startColumn || 0, endColumn = options2.endColumn || Number.MAX_VALUE, dataTypes = [], potDelimiters = {
      ",": 0,
      ";": 0,
      "	": 0
    };
    let csv = options2.csv, startRow = options2.startRow || 0, endRow = options2.endRow || Number.MAX_VALUE, itemDelimiter, lines, rowIt = 0;
    function parseRow(columnStr, rowNumber, noAdd, callbacks) {
      let i = 0, c = "", cl = "", cn = "", token = "", actualColumn = 0, column2 = 0;
      function read(j) {
        c = columnStr[j];
        cl = columnStr[j - 1];
        cn = columnStr[j + 1];
      }
      function pushType(type) {
        if (dataTypes.length < column2 + 1) {
          dataTypes.push([type]);
        }
        if (dataTypes[column2][dataTypes[column2].length - 1] !== type) {
          dataTypes[column2].push(type);
        }
      }
      function push() {
        if (startColumn > actualColumn || actualColumn > endColumn) {
          ++actualColumn;
          token = "";
          return;
        }
        if (!options2.columnTypes) {
          if (!isNaN(parseFloat(token)) && isFinite(token)) {
            token = parseFloat(token);
            pushType("number");
          } else if (!isNaN(Date.parse(token))) {
            token = token.replace(/\//g, "-");
            pushType("date");
          } else {
            pushType("string");
          }
        }
        if (columns.length < column2 + 1) {
          columns.push([]);
        }
        if (!noAdd) {
          columns[column2][rowNumber] = token;
        }
        token = "";
        ++column2;
        ++actualColumn;
      }
      if (!columnStr.trim().length) {
        return;
      }
      if (columnStr.trim()[0] === "#") {
        return;
      }
      for (; i < columnStr.length; i++) {
        read(i);
        if (c === '"') {
          read(++i);
          while (i < columnStr.length) {
            if (c === '"' && cl !== '"' && cn !== '"') {
              break;
            }
            if (c !== '"' || c === '"' && cl !== '"') {
              token += c;
            }
            read(++i);
          }
        } else if (callbacks?.[c]) {
          if (callbacks[c](c, token)) {
            push();
          }
        } else if (c === itemDelimiter) {
          push();
        } else {
          token += c;
        }
      }
      push();
    }
    function guessDelimiter(lines2) {
      let points = 0, commas = 0, guessed = false;
      lines2.some(function(columnStr, i) {
        let inStr = false, c, cn, cl, token = "";
        if (i > 13) {
          return true;
        }
        for (let j = 0; j < columnStr.length; j++) {
          c = columnStr[j];
          cn = columnStr[j + 1];
          cl = columnStr[j - 1];
          if (c === "#") {
            return;
          }
          if (c === '"') {
            if (inStr) {
              if (cl !== '"' && cn !== '"') {
                while (cn === " " && j < columnStr.length) {
                  cn = columnStr[++j];
                }
                if (typeof potDelimiters[cn] !== "undefined") {
                  potDelimiters[cn]++;
                }
                inStr = false;
              }
            } else {
              inStr = true;
            }
          } else if (typeof potDelimiters[c] !== "undefined") {
            token = token.trim();
            if (!isNaN(Date.parse(token))) {
              potDelimiters[c]++;
            } else if (isNaN(token) || !isFinite(token)) {
              potDelimiters[c]++;
            }
            token = "";
          } else {
            token += c;
          }
          if (c === ",") {
            commas++;
          }
          if (c === ".") {
            points++;
          }
        }
      });
      if (potDelimiters[";"] > potDelimiters[","]) {
        guessed = ";";
      } else if (potDelimiters[","] > potDelimiters[";"]) {
        guessed = ",";
      } else {
        guessed = ",";
      }
      if (!options2.decimalPoint) {
        if (points > commas) {
          options2.decimalPoint = ".";
        } else {
          options2.decimalPoint = ",";
        }
        self.decimalRegex = new RegExp("^(-?[0-9]+)" + options2.decimalPoint + "([0-9]+)$");
      }
      return guessed;
    }
    function deduceDateFormat(data, limit) {
      const format18 = "YYYY/mm/dd", stable = [], max4 = [];
      let thing, guessedFormat = [], calculatedFormat, i = 0, madeDeduction = false, j;
      if (!limit || limit > data.length) {
        limit = data.length;
      }
      for (; i < limit; i++) {
        if (typeof data[i] !== "undefined" && data[i]?.length) {
          thing = data[i].trim().replace(/\//g, " ").replace(/\-/g, " ").replace(/\./g, " ").split(" ");
          guessedFormat = [
            "",
            "",
            ""
          ];
          for (j = 0; j < thing.length; j++) {
            if (j < guessedFormat.length) {
              thing[j] = parseInt(thing[j], 10);
              if (thing[j]) {
                max4[j] = !max4[j] || max4[j] < thing[j] ? thing[j] : max4[j];
                if (typeof stable[j] !== "undefined") {
                  if (stable[j] !== thing[j]) {
                    stable[j] = false;
                  }
                } else {
                  stable[j] = thing[j];
                }
                if (thing[j] > 31) {
                  if (thing[j] < 100) {
                    guessedFormat[j] = "YY";
                  } else {
                    guessedFormat[j] = "YYYY";
                  }
                } else if (thing[j] > 12 && thing[j] <= 31) {
                  guessedFormat[j] = "dd";
                  madeDeduction = true;
                } else if (!guessedFormat[j].length) {
                  guessedFormat[j] = "mm";
                }
              }
            }
          }
        }
      }
      if (madeDeduction) {
        for (j = 0; j < stable.length; j++) {
          if (stable[j] !== false) {
            if (max4[j] > 12 && guessedFormat[j] !== "YY" && guessedFormat[j] !== "YYYY") {
              guessedFormat[j] = "YY";
            }
          } else if (max4[j] > 12 && guessedFormat[j] === "mm") {
            guessedFormat[j] = "dd";
          }
        }
        if (guessedFormat.length === 3 && guessedFormat[1] === "dd" && guessedFormat[2] === "dd") {
          guessedFormat[2] = "YY";
        }
        calculatedFormat = guessedFormat.join("/");
        if (!(options2.dateFormats || self.dateFormats)[calculatedFormat]) {
          fireEvent40(self, "deduceDateFailed");
          return format18;
        }
        return calculatedFormat;
      }
      return format18;
    }
    if (csv && options2.beforeParse) {
      csv = options2.beforeParse.call(this, csv);
    }
    if (csv) {
      lines = csv.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split(options2.lineDelimiter || "\n");
      if (!startRow || startRow < 0) {
        startRow = 0;
      }
      if (!endRow || endRow >= lines.length) {
        endRow = lines.length - 1;
      }
      if (options2.itemDelimiter) {
        itemDelimiter = options2.itemDelimiter;
      } else {
        itemDelimiter = guessDelimiter(lines);
      }
      let offset3 = 0;
      for (rowIt = startRow; rowIt <= endRow; rowIt++) {
        if (lines[rowIt][0] === "#") {
          offset3++;
        } else {
          parseRow(lines[rowIt], rowIt - startRow - offset3);
        }
      }
      if ((!options2.columnTypes || options2.columnTypes.length === 0) && dataTypes.length && dataTypes[0].length && dataTypes[0][1] === "date" && !options2.dateFormat) {
        options2.dateFormat = deduceDateFormat(columns[0]);
      }
      this.dataFound();
    }
    return columns;
  }
  /**
   * Parse a HTML table
   *
   * @function Highcharts.Data#parseTable
   */
  parseTable() {
    const options2 = this.options, columns = this.columns || [], startRow = options2.startRow || 0, endRow = options2.endRow || Number.MAX_VALUE, startColumn = options2.startColumn || 0, endColumn = options2.endColumn || Number.MAX_VALUE;
    if (options2.table) {
      let table = options2.table;
      if (typeof table === "string") {
        table = doc26.getElementById(table);
      }
      [].forEach.call(table.getElementsByTagName("tr"), (tr, rowNo) => {
        if (rowNo >= startRow && rowNo <= endRow) {
          [].forEach.call(tr.children, (item, colNo) => {
            const row = columns[colNo - startColumn];
            let i = 1;
            if ((item.tagName === "TD" || item.tagName === "TH") && colNo >= startColumn && colNo <= endColumn) {
              if (!columns[colNo - startColumn]) {
                columns[colNo - startColumn] = [];
              }
              columns[colNo - startColumn][rowNo - startRow] = item.innerHTML;
              while (rowNo - startRow >= i && row[rowNo - startRow - i] === void 0) {
                row[rowNo - startRow - i] = null;
                i++;
              }
            }
          });
        }
      });
      this.dataFound();
    }
    return columns;
  }
  /**
   * Fetch or refetch live data
   *
   * @function Highcharts.Data#fetchLiveData
   *
   * @return {boolean}
   *         The URLs that were tried can be found in the options
   */
  fetchLiveData() {
    const data = this, chart = this.chart, options2 = this.options, maxRetries = 3, pollingEnabled = options2.enablePolling, originalOptions = merge80(options2);
    let currentRetries = 0, updateIntervalMs = (options2.dataRefreshRate || 2) * 1e3;
    if (!hasURLOption(options2)) {
      return false;
    }
    if (updateIntervalMs < 1e3) {
      updateIntervalMs = 1e3;
    }
    delete options2.csvURL;
    delete options2.rowsURL;
    delete options2.columnsURL;
    function performFetch(initialFetch) {
      function request(url, done, tp) {
        if (!url || !/^(http|\/|\.\/|\.\.\/)/.test(url)) {
          if (url && options2.error) {
            options2.error("Invalid URL");
          }
          return false;
        }
        if (initialFetch) {
          clearTimeout(data.liveDataTimeout);
          chart.liveDataURL = url;
        }
        function poll() {
          if (pollingEnabled && chart.liveDataURL === url) {
            data.liveDataTimeout = setTimeout(performFetch, updateIntervalMs);
          }
        }
        ajax2({
          url,
          dataType: tp || "json",
          success: function(res) {
            if (chart?.series) {
              done(res);
            }
            poll();
          },
          error: function(xhr, text) {
            if (++currentRetries < maxRetries) {
              poll();
            }
            return options2.error?.(text, xhr);
          }
        });
        return true;
      }
      if (!request(originalOptions.csvURL, function(res) {
        chart.update({
          data: {
            csv: res
          }
        });
      }, "text")) {
        if (!request(originalOptions.rowsURL, function(res) {
          chart.update({
            data: {
              rows: res
            }
          });
        })) {
          request(originalOptions.columnsURL, function(res) {
            chart.update({
              data: {
                columns: res
              }
            });
          });
        }
      }
    }
    performFetch(true);
    return hasURLOption(options2);
  }
  /**
   * Parse a Google spreadsheet.
   *
   * @function Highcharts.Data#parseGoogleSpreadsheet
   *
   * @return {boolean}
   *         Always returns false, because it is an intermediate fetch.
   */
  parseGoogleSpreadsheet() {
    const data = this, options2 = this.options, googleSpreadsheetKey = options2.googleSpreadsheetKey, chart = this.chart, refreshRate = Math.max((options2.dataRefreshRate || 2) * 1e3, 4e3);
    const getRange = () => {
      if (options2.googleSpreadsheetRange) {
        return options2.googleSpreadsheetRange;
      }
      const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const start = (alphabet.charAt(options2.startColumn || 0) || "A") + ((options2.startRow || 0) + 1);
      let end = alphabet.charAt(pick88(options2.endColumn, -1)) || "ZZ";
      if (defined63(options2.endRow)) {
        end += options2.endRow + 1;
      }
      return `${start}:${end}`;
    };
    function fetchSheet(fn) {
      const url = [
        "https://sheets.googleapis.com/v4/spreadsheets",
        googleSpreadsheetKey,
        "values",
        getRange(),
        "?alt=json&majorDimension=COLUMNS&valueRenderOption=UNFORMATTED_VALUE&dateTimeRenderOption=FORMATTED_STRING&key=" + options2.googleAPIKey
      ].join("/");
      ajax2({
        url,
        dataType: "json",
        success: function(json) {
          fn(json);
          if (options2.enablePolling) {
            data.liveDataTimeout = setTimeout(function() {
              fetchSheet(fn);
            }, refreshRate);
          }
        },
        error: function(xhr, text) {
          return options2.error?.(text, xhr);
        }
      });
    }
    if (googleSpreadsheetKey) {
      delete options2.googleSpreadsheetKey;
      fetchSheet(function(json) {
        const columns = json.values;
        if (!columns || columns.length === 0) {
          return false;
        }
        const rowCount = columns.reduce((rowCount2, column2) => Math.max(rowCount2, column2.length), 0);
        columns.forEach((column2) => {
          for (let i = 0; i < rowCount; i++) {
            if (typeof column2[i] === "undefined") {
              column2[i] = null;
            }
          }
        });
        if (chart?.series) {
          chart.update({
            data: {
              columns
            }
          });
        } else {
          data.columns = columns;
          data.dataFound();
        }
      });
    }
    return false;
  }
  /**
   * Trim a string from whitespaces.
   *
   * @function Highcharts.Data#trim
   *
   * @param {string} str
   *        String to trim
   *
   * @param {boolean} [inside=false]
   *        Remove all spaces between numbers.
   *
   * @return {string}
   *         Trimed string
   */
  trim(str, inside) {
    if (typeof str === "string") {
      str = str.replace(/^\s+|\s+$/g, "");
      if (inside && /[\d\s]+/.test(str)) {
        str = str.replace(/\s/g, "");
      }
      if (this.decimalRegex) {
        str = str.replace(this.decimalRegex, "$1.$2");
      }
    }
    return str;
  }
  /**
   * Parse numeric cells in to number types and date types in to true dates.
   *
   * @function Highcharts.Data#parseTypes
   */
  parseTypes() {
    const columns = this.columns || [];
    let col = columns.length;
    while (col--) {
      this.parseColumn(columns[col], col);
    }
  }
  /**
   * Parse a single column. Set properties like .isDatetime and .isNumeric.
   *
   * @function Highcharts.Data#parseColumn
   *
   * @param {Array<Highcharts.DataValueType>} column
   *        Column to parse
   *
   * @param {number} col
   *        Column index
   */
  parseColumn(column2, col) {
    const rawColumns = this.rawColumns, columns = this.columns = this.columns || [], firstRowAsNames = this.firstRowAsNames, isXColumn = this.valueCount?.xColumns.indexOf(col) !== -1, backup = [], chartOptions = this.chartOptions, columnTypes = this.options.columnTypes || [], columnType = columnTypes[col], forceCategory = isXColumn && (chartOptions?.xAxis && splat17(chartOptions.xAxis)[0].type === "category") || columnType === "string", columnHasName = defined63(column2.name);
    let row = column2.length, val, floatVal, trimVal, trimInsideVal, dateVal, diff, descending;
    if (!rawColumns[col]) {
      rawColumns[col] = [];
    }
    while (row--) {
      val = backup[row] || column2[row];
      trimVal = this.trim(val);
      trimInsideVal = this.trim(val, true);
      floatVal = parseFloat(trimInsideVal);
      if (typeof rawColumns[col][row] === "undefined") {
        rawColumns[col][row] = trimVal;
      }
      if (forceCategory || row === 0 && firstRowAsNames && !columnHasName) {
        column2[row] = "" + trimVal;
      } else if (+trimInsideVal === floatVal) {
        column2[row] = floatVal;
        if (floatVal > 365 * 24 * 3600 * 1e3 && columnType !== "float") {
          column2.isDatetime = true;
        } else {
          column2.isNumeric = true;
        }
        if (typeof column2[row + 1] !== "undefined") {
          descending = floatVal > column2[row + 1];
        }
      } else {
        if (trimVal?.length) {
          dateVal = this.parseDate(val);
        }
        if (isXColumn && isNumber58(dateVal) && columnType !== "float") {
          backup[row] = val;
          column2[row] = dateVal;
          column2.isDatetime = true;
          if (typeof column2[row + 1] !== "undefined") {
            diff = dateVal > column2[row + 1];
            if (diff !== descending && typeof descending !== "undefined") {
              if (this.alternativeFormat) {
                this.dateFormat = this.alternativeFormat;
                row = column2.length;
                this.alternativeFormat = this.dateFormats[this.dateFormat].alternative;
              } else {
                column2.unsorted = true;
              }
            }
            descending = diff;
          }
        } else {
          column2[row] = trimVal === "" ? null : trimVal;
          if (row !== 0 && (column2.isDatetime || column2.isNumeric)) {
            column2.mixed = true;
          }
        }
      }
    }
    if (isXColumn && column2.mixed) {
      columns[col] = rawColumns[col];
    }
    if (isXColumn && descending && this.options.sort) {
      for (col = 0; col < columns.length; col++) {
        columns[col].reverse();
        if (firstRowAsNames) {
          const poppedColumn = columns[col].pop();
          if (poppedColumn) {
            columns[col].unshift(poppedColumn);
          }
        }
      }
    }
  }
  /**
   * Parse a date and return it as a number. Overridable through
   * `options.parseDate`.
   *
   * @function Highcharts.Data#parseDate
   */
  parseDate(val) {
    const parseDate = this.options.parseDate;
    let ret, key, format18, dateFormat2 = this.options.dateFormat || this.dateFormat, match;
    if (parseDate) {
      ret = parseDate(val);
    } else if (typeof val === "string") {
      if (!dateFormat2) {
        for (key in this.dateFormats) {
          format18 = this.dateFormats[key];
          match = val.match(format18.regex);
          if (match) {
            this.dateFormat = dateFormat2 = key;
            this.alternativeFormat = format18.alternative;
            ret = format18.parser(match);
            break;
          }
        }
      } else {
        format18 = this.dateFormats[dateFormat2];
        if (!format18) {
          format18 = this.dateFormats["YYYY/mm/dd"];
        }
        match = val.match(format18.regex);
        if (match) {
          ret = format18.parser(match);
        }
      }
      if (!match) {
        if (val.match(/:.+(GMT|UTC|[Z+\-])/)) {
          val = val.replace(/\s*(?:GMT|UTC)?([+\-])(\d\d)(\d\d)$/, "$1$2:$3").replace(/(?:\s+|GMT|UTC)([+\-])/, "$1").replace(/(\d)\s*(?:GMT|UTC|Z)$/, "$1+00:00");
        }
        match = Date.parse(val);
        if (typeof match === "object" && match !== null && match.getTime) {
          ret = match.getTime() - match.getTimezoneOffset() * 6e4;
        } else if (isNumber58(match)) {
          ret = match - new Date(match).getTimezoneOffset() * 6e4;
        }
      }
    }
    return ret;
  }
  /**
   * Get the parsed data in a form that we can apply directly to the
   * `series.data` config. Array positions can be mapped using the
   * `series.keys` option.
   *
   * @example
   * const data = Highcharts.data({
   *   csv: document.getElementById('data').innerHTML
   * }).getData();
   *
   * @function Highcharts.Data#getData
   *
   * @return {Array<Array<DataValueType>>|undefined} Data rows
   */
  getData() {
    if (this.columns) {
      return this.rowsToColumns(this.columns)?.slice(1);
    }
  }
  /**
   * A hook for working directly on the parsed columns
   *
   * @function Highcharts.Data#parsed
   */
  parsed() {
    if (this.options.parsed) {
      return this.options.parsed.call(this, this.columns);
    }
  }
  /**
   * If a complete callback function is provided in the options, interpret the
   * columns into a Highcharts options object.
   *
   * The function requires that the context has the `valueCount` property set.
   *
   * @function Highcharts.Data#complete
   */
  complete() {
    const columns = this.columns = this.columns || [], xColumns = [], options2 = this.options, allSeriesBuilders = [];
    let type = "linear", series, data, i, j, r, seriesIndex, chartOptions, builder, freeIndexes, typeCol, index;
    xColumns.length = columns.length;
    if (options2.complete || options2.afterComplete) {
      if (this.firstRowAsNames) {
        for (i = 0; i < columns.length; i++) {
          const curCol = columns[i];
          if (!defined63(curCol.name)) {
            curCol.name = pick88(curCol.shift(), "").toString();
          }
        }
      }
      series = [];
      freeIndexes = getFreeIndexes(columns?.length || 0, this.valueCount.seriesBuilders);
      for (seriesIndex = 0; seriesIndex < this.valueCount.seriesBuilders.length; seriesIndex++) {
        builder = this.valueCount.seriesBuilders[seriesIndex];
        if (builder.populateColumns(freeIndexes)) {
          allSeriesBuilders.push(builder);
        }
      }
      while (freeIndexes.length > 0) {
        builder = new SeriesBuilder();
        builder.addColumnReader(0, "x");
        index = freeIndexes.indexOf(0);
        if (index !== -1) {
          freeIndexes.splice(index, 1);
        }
        for (i = 0; i < this.valueCount.global; i++) {
          builder.addColumnReader(void 0, this.valueCount.globalPointArrayMap[i]);
        }
        if (builder.populateColumns(freeIndexes)) {
          allSeriesBuilders.push(builder);
        }
      }
      if (allSeriesBuilders.length > 0 && allSeriesBuilders[0].readers.length > 0) {
        typeCol = columns?.[allSeriesBuilders[0].readers[0].columnIndex ?? -1];
        if (typeof typeCol !== "undefined") {
          if (typeCol.isDatetime) {
            type = "datetime";
          } else if (!typeCol.isNumeric) {
            type = "category";
          }
        }
      }
      if (type === "category") {
        for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {
          builder = allSeriesBuilders[seriesIndex];
          for (r = 0; r < builder.readers.length; r++) {
            if (builder.readers[r].configName === "x") {
              builder.readers[r].configName = "name";
            }
          }
        }
      }
      for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {
        builder = allSeriesBuilders[seriesIndex];
        data = [];
        for (j = 0; j < columns[0].length; j++) {
          data[j] = builder.read(columns, j);
        }
        series[seriesIndex] = {
          data,
          pointStart: data[0] && (builder.pointIsArray ? data[0]?.[0] : data[0]?.x) || void 0
        };
        if (builder.name) {
          series[seriesIndex].name = builder.name;
        }
        if (type === "category") {
          series[seriesIndex].turboThreshold = 0;
          series[seriesIndex].pointStart = 0;
        }
      }
      chartOptions = { series };
      if (type === "linear" && (!this.xAxisOptions || this.xAxisOptions.type === type)) {
        type = this.xAxisOptions = void 0;
      } else {
        this.xAxisOptions = { type };
        if (type === "category") {
          this.xAxisOptions.uniqueNames = false;
        }
      }
      if (!this.chart) {
        merge80(true, chartOptions, { xAxis: this.xAxisOptions || {} });
      }
      options2.complete?.(chartOptions);
      options2.afterComplete?.(this, chartOptions);
    }
  }
  /**
   * Sets properties directly on the xAxis object.
   *
   * @private
   */
  xAxisUpdateHandler(axis) {
    const options2 = this.xAxisOptions;
    if (!options2) {
      return;
    }
    if (!axis.options.type && options2.type) {
      axis.type = options2.type;
    }
    if (!axis.options.uniqueNames && options2.uniqueNames === false) {
      axis.uniqueNames = options2.uniqueNames;
    }
  }
  /**
   * Updates the chart with new data options.
   *
   * @function Highcharts.Data#update
   *
   * @param {Highcharts.DataOptions} options
   *        The new data options.
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart after the new options are set.
   */
  update(options2, redraw) {
    const chart = this.chart, chartOptions = chart.options;
    if (options2) {
      options2.afterComplete = function(dataInstance, dataOptions) {
        if (!dataOptions) {
          return;
        }
        const xAxis2 = chart.xAxis[0], xAxisOptions = dataInstance.xAxisOptions;
        if (xAxisOptions && xAxis2 && (xAxis2.type !== xAxisOptions.type && !xAxis2.options.type || xAxis2.uniqueNames && xAxisOptions.uniqueNames === false && xAxis2.options.uniqueNames === void 0)) {
          xAxis2.update({}, false);
        } else {
          (dataOptions?.series || []).forEach(function(seriesOptions) {
            delete seriesOptions.pointStart;
          });
        }
        chart.update(dataOptions, redraw, true);
      };
      merge80(true, chartOptions.data, options2);
      if (chartOptions.data?.googleSpreadsheetKey && !options2.columns) {
        delete chartOptions.data.columns;
      }
      this.init(chartOptions.data || {}, chartOptions);
    }
  }
};
addEvent75(Axis_default, "afterSetOptions", function() {
  if (this.isXAxis && // Init or update
  (!this.chart.xAxis.length || this.chart.xAxis[0] === this)) {
    this.chart.data?.xAxisUpdateHandler(this);
  }
});
addEvent75(Chart_default, "init", function(e) {
  const chart = this, callback = e.args[1], defaultDataOptions = getOptions4().data;
  let userOptions = e.args[0] || {};
  if ((defaultDataOptions || userOptions && userOptions.data) && !chart.hasDataDef) {
    chart.hasDataDef = true;
    const dataOptions = merge80(defaultDataOptions, userOptions.data);
    chart.data = new Data(extend67(dataOptions, {
      afterComplete: function(dataInstance, dataOptions2) {
        let i, series;
        if (Object.hasOwnProperty.call(userOptions, "series")) {
          if (typeof userOptions.series === "object") {
            i = Math.max(userOptions.series.length, dataOptions2?.series?.length ?? 0);
            while (i--) {
              series = userOptions.series[i] || {};
              userOptions.series[i] = merge80(series, dataOptions2?.series?.[i] ?? {});
            }
          } else {
            delete userOptions.series;
          }
        }
        userOptions = merge80(dataOptions2, userOptions);
        chart.data = dataInstance;
        chart.init(userOptions, callback);
      }
    }), userOptions, chart);
    e.preventDefault();
  }
});
var SeriesBuilder = class {
  constructor() {
    this.readers = [];
    this.pointIsArray = true;
  }
  /**
   * Populates readers with column indexes. A reader can be added without
   * a specific index and for those readers the index is taken sequentially
   * from the free columns (this is handled by the ColumnCursor instance).
   *
   * @function SeriesBuilder#populateColumns
   */
  populateColumns(freeIndexes) {
    const builder = this;
    let enoughColumns = true;
    builder.readers.forEach((reader) => {
      if (typeof reader.columnIndex === "undefined") {
        reader.columnIndex = freeIndexes.shift();
      }
    });
    builder.readers.forEach((reader) => {
      if (typeof reader.columnIndex === "undefined") {
        enoughColumns = false;
      }
    });
    return enoughColumns;
  }
  /**
   * Reads a row from the dataset and returns a point or array depending
   * on the names of the readers.
   *
   * @function SeriesBuilder#read<T>
   */
  read(columns, rowIndex) {
    const builder = this, pointIsArray = builder.pointIsArray, point = pointIsArray ? [] : {};
    builder.readers.forEach((reader) => {
      const value = columns[reader.columnIndex][rowIndex];
      if (pointIsArray) {
        point.push(value);
      } else {
        if (reader.configName.indexOf(".") > 0) {
          Point_default.prototype.setNestedProperty(point, value, reader.configName);
        } else {
          point[reader.configName] = value;
        }
      }
    });
    if (typeof this.name === "undefined" && builder.readers.length >= 2) {
      const columnIndexes = [];
      builder.readers.forEach(function(reader) {
        if (reader.configName === "x" || reader.configName === "name" || reader.configName === "y") {
          if (typeof reader.columnIndex !== "undefined") {
            columnIndexes.push(reader.columnIndex);
          }
        }
      });
      if (columnIndexes.length >= 2) {
        columnIndexes.shift();
        columnIndexes.sort(function(a, b) {
          return a - b;
        });
      }
      this.name = columns[pick88(columnIndexes.shift(), 0)].name;
    }
    return point;
  }
  /**
   * Creates and adds ColumnReader from the given columnIndex and configName.
   * ColumnIndex can be undefined and in that case the reader will be given
   * an index when columns are populated.
   *
   * @function SeriesBuilder#addColumnReader
   */
  addColumnReader(columnIndex, configName) {
    this.readers.push({
      columnIndex,
      configName
    });
    if (!(configName === "x" || configName === "y" || typeof configName === "undefined")) {
      this.pointIsArray = false;
    }
  }
  /**
   * Returns an array of column indexes that the builder will use when
   * reading data.
   *
   * @function SeriesBuilder#getReferencedColumnIndexes
   */
  getReferencedColumnIndexes() {
    const referencedColumnIndexes = [];
    let i, columnReader;
    for (i = 0; i < this.readers.length; i = i + 1) {
      columnReader = this.readers[i];
      if (typeof columnReader.columnIndex !== "undefined") {
        referencedColumnIndexes.push(columnReader.columnIndex);
      }
    }
    return referencedColumnIndexes;
  }
  /**
   * Returns true if the builder has a reader for the given configName.
   *
   * @function SeriesBuilder#hasReader
   */
  hasReader(configName) {
    let i, columnReader;
    for (i = 0; i < this.readers.length; i = i + 1) {
      columnReader = this.readers[i];
      if (columnReader.configName === configName) {
        return true;
      }
    }
  }
};
var Data_default = Data;

// node_modules/highcharts/es-modules/masters/modules/data.src.js
var G10 = Globals_default;
G10.Data = G10.Data || Data_default;
G10.HttpUtilities = G10.HttpUtilities || HttpUtilities_default;
G10.ajax = G10.HttpUtilities.ajax;
G10.data = G10.Data.data;
G10.getJSON = G10.HttpUtilities.getJSON;
G10.post = G10.HttpUtilities.post;

// node_modules/highcharts/es-modules/Extensions/Breadcrumbs/BreadcrumbsDefaults.js
var lang3 = {
  /**
   * @since   10.0.0
   * @product highcharts highmaps
   *
   * @private
   */
  mainBreadcrumb: "Main"
};
var options = {
  /**
   * A collection of attributes for the buttons. The object takes SVG
   * attributes like `fill`, `stroke`, `stroke-width`, as well as `style`,
   * a collection of CSS properties for the text.
   *
   * The object can also be extended with states, so you can set
   * presentational options for `hover`, `select` or `disabled` button
   * states.
   *
   * @sample {highcharts} highcharts/breadcrumbs/single-button
   *         Themed, single button
   *
   * @type    {Highcharts.SVGAttributes}
   * @since   10.0.0
   * @product highcharts
   */
  buttonTheme: {
    /** @ignore */
    fill: "none",
    /** @ignore */
    height: 18,
    /** @ignore */
    padding: 2,
    /** @ignore */
    "stroke-width": 0,
    /** @ignore */
    zIndex: 7,
    /** @ignore */
    states: {
      select: {
        fill: "none"
      }
    },
    style: {
      color: "#334eff"
      /* Palette.highlightColor80 */
    }
  },
  /**
   * The default padding for each button and separator in each direction.
   *
   * @type  {number}
   * @since 10.0.0
   */
  buttonSpacing: 5,
  /**
   * Fires when clicking on the breadcrumbs button. Two arguments are
   * passed to the function. First breadcrumb button as an SVG element.
   * Second is the breadcrumbs class, containing reference to the chart,
   * series etc.
   *
   * ```js
   * click: function(button, breadcrumbs) {
   *   console.log(button);
   * }
   * ```
   *
   * Return false to stop default buttons click action.
   *
   * @type      {Highcharts.BreadcrumbsClickCallbackFunction}
   * @since     10.0.0
   * @apioption navigation.breadcrumbs.events.click
   */
  /**
   * When the breadcrumbs are floating, the plot area will not move to
   * make space for it. By default, the chart will not make space for the
   * buttons. This property won't work when positioned in the middle.
   *
   * @sample highcharts/breadcrumbs/single-button
   *         Floating button
   *
   * @type  {boolean}
   * @since 10.0.0
   */
  floating: false,
  /**
   * A format string for the breadcrumbs button. Variables are enclosed by
   * curly brackets. Available values are passed in the declared point
   * options.
   *
   * @type      {string|undefined}
   * @since 10.0.0
   * @default   undefined
   * @sample {highcharts} highcharts/breadcrumbs/format Display custom
   *          values in breadcrumb button.
   */
  format: void 0,
  /**
   * Callback function to format the breadcrumb text from scratch.
   *
   * @type      {Highcharts.BreadcrumbsFormatterCallbackFunction}
   * @since     10.0.0
   * @default   undefined
   * @apioption navigation.breadcrumbs.formatter
   */
  /**
   * What box to align the button to. Can be either `plotBox` or
   * `spacingBox`.
   *
   * @type    {Highcharts.ButtonRelativeToValue}
   * @default plotBox
   * @since   10.0.0
   * @product highcharts highmaps
   */
  relativeTo: "plotBox",
  /**
   * Whether to reverse the order of buttons. This is common in Arabic
   * and Hebrew.
   *
   * @sample {highcharts} highcharts/breadcrumbs/rtl
   *         Breadcrumbs in RTL
   *
   * @type  {boolean}
   * @since 10.2.0
   */
  rtl: false,
  /**
   * Positioning for the button row. The breadcrumbs buttons will be
   * aligned properly for the default chart layout (title,  subtitle,
   * legend, range selector) for the custom chart layout set the position
   * properties.
   *
   * @sample  {highcharts} highcharts/breadcrumbs/single-button
   *          Single, right aligned button
   *
   * @type    {Highcharts.BreadcrumbsAlignOptions}
   * @since   10.0.0
   * @product highcharts highmaps
   */
  position: {
    /**
     * Horizontal alignment of the breadcrumbs buttons.
     *
     * @type {Highcharts.AlignValue}
     */
    align: "left",
    /**
     * Vertical alignment of the breadcrumbs buttons.
     *
     * @type {Highcharts.VerticalAlignValue}
     */
    verticalAlign: "top",
    /**
     * The X offset of the breadcrumbs button group.
     *
     * @type {number}
     */
    x: 0,
    /**
     * The Y offset of the breadcrumbs button group. When `undefined`,
     * and `floating` is `false`, the `y` position is adapted so that
     * the breadcrumbs are rendered outside the target area.
     *
     * @type {number|undefined}
     */
    y: void 0
  },
  /**
   * Options object for Breadcrumbs separator.
   *
   * @since 10.0.0
   */
  separator: {
    /**
     * @type    {string}
     * @since   10.0.0
     * @product highcharts
     */
    text: "/",
    /**
     * CSS styles for the breadcrumbs separator.
     *
     * In styled mode, the breadcrumbs separators are styled by the
     * `.highcharts-separator` rule with its different states.
     *  @type  {Highcharts.CSSObject}
     *  @since 10.0.0
     */
    style: {
      color: "#666666",
      fontSize: "0.8em"
    }
  },
  /**
   * Show full path or only a single button.
   *
   * @sample {highcharts} highcharts/breadcrumbs/single-button
   *         Single, styled button
   *
   * @type  {boolean}
   * @since 10.0.0
   */
  showFullPath: true,
  /**
   * CSS styles for all breadcrumbs.
   *
   * In styled mode, the breadcrumbs buttons are styled by the
   * `.highcharts-breadcrumbs-buttons .highcharts-button` rule with its
   * different states.
   *
   * @type  {Highcharts.SVGAttributes}
   * @since 10.0.0
   */
  style: {},
  /**
   * Whether to use HTML to render the breadcrumbs items texts.
   *
   * @type  {boolean}
   * @since 10.0.0
   */
  useHTML: false,
  /**
   * The z index of the breadcrumbs group.
   *
   * @type  {number}
   * @since 10.0.0
   */
  zIndex: 7
};
var BreadcrumbsDefaults = {
  lang: lang3,
  options
};
var BreadcrumbsDefaults_default = BreadcrumbsDefaults;

// node_modules/highcharts/es-modules/Extensions/Breadcrumbs/Breadcrumbs.js
var { format: format17 } = Templating_default;
var { composed: composed30 } = Globals_default;
var { addEvent: addEvent76, defined: defined64, extend: extend68, fireEvent: fireEvent41, isString: isString19, merge: merge81, objectEach: objectEach32, pick: pick89, pushUnique: pushUnique33 } = Utilities_default;
function onChartAfterShowResetZoom() {
  const chart = this;
  if (chart.breadcrumbs) {
    const bbox = chart.resetZoomButton && chart.resetZoomButton.getBBox(), breadcrumbsOptions = chart.breadcrumbs.options;
    if (bbox && breadcrumbsOptions.position.align === "right" && breadcrumbsOptions.relativeTo === "plotBox") {
      chart.breadcrumbs.alignBreadcrumbsGroup(-bbox.width - breadcrumbsOptions.buttonSpacing);
    }
  }
}
function onChartDestroy3() {
  if (this.breadcrumbs) {
    this.breadcrumbs.destroy();
    this.breadcrumbs = void 0;
  }
}
function onChartGetMargins2() {
  const breadcrumbs = this.breadcrumbs;
  if (breadcrumbs && !breadcrumbs.options.floating && breadcrumbs.level) {
    const breadcrumbsOptions = breadcrumbs.options, buttonTheme = breadcrumbsOptions.buttonTheme, breadcrumbsHeight = (buttonTheme.height || 0) + 2 * (buttonTheme.padding || 0) + breadcrumbsOptions.buttonSpacing, verticalAlign = breadcrumbsOptions.position.verticalAlign;
    if (verticalAlign === "bottom") {
      this.marginBottom = (this.marginBottom || 0) + breadcrumbsHeight;
      breadcrumbs.yOffset = breadcrumbsHeight;
    } else if (verticalAlign !== "middle") {
      this.plotTop += breadcrumbsHeight;
      breadcrumbs.yOffset = -breadcrumbsHeight;
    } else {
      breadcrumbs.yOffset = void 0;
    }
  }
}
function onChartRedraw() {
  this.breadcrumbs && this.breadcrumbs.redraw();
}
function onChartSelection(event) {
  if (event.resetSelection === true && this.breadcrumbs) {
    this.breadcrumbs.alignBreadcrumbsGroup();
  }
}
var Breadcrumbs = class _Breadcrumbs {
  /* *
   *
   *  Functions
   *
   * */
  static compose(ChartClass, highchartsDefaultOptions) {
    if (pushUnique33(composed30, "Breadcrumbs")) {
      addEvent76(ChartClass, "destroy", onChartDestroy3);
      addEvent76(ChartClass, "afterShowResetZoom", onChartAfterShowResetZoom);
      addEvent76(ChartClass, "getMargins", onChartGetMargins2);
      addEvent76(ChartClass, "redraw", onChartRedraw);
      addEvent76(ChartClass, "selection", onChartSelection);
      extend68(highchartsDefaultOptions.lang, BreadcrumbsDefaults_default.lang);
    }
  }
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart, userOptions) {
    this.elementList = {};
    this.isDirty = true;
    this.level = 0;
    this.list = [];
    const chartOptions = merge81(chart.options.drilldown && chart.options.drilldown.drillUpButton, _Breadcrumbs.defaultOptions, chart.options.navigation && chart.options.navigation.breadcrumbs, userOptions);
    this.chart = chart;
    this.options = chartOptions || {};
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Update Breadcrumbs properties, like level and list.
   *
   * @function Highcharts.Breadcrumbs#updateProperties
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  updateProperties(list) {
    this.setList(list);
    this.setLevel();
    this.isDirty = true;
  }
  /**
   * Set breadcrumbs list.
   * @function Highcharts.Breadcrumbs#setList
   *
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   * @param {Highcharts.BreadcrumbsOptions} list
   *        Breadcrumbs list.
   */
  setList(list) {
    this.list = list;
  }
  /**
   * Calculate level on which chart currently is.
   *
   * @function Highcharts.Breadcrumbs#setLevel
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  setLevel() {
    this.level = this.list.length && this.list.length - 1;
  }
  /**
   * Get Breadcrumbs level
   *
   * @function Highcharts.Breadcrumbs#getLevel
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  getLevel() {
    return this.level;
  }
  /**
   * Default button text formatter.
   *
   * @function Highcharts.Breadcrumbs#getButtonText
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   * @param {Highcharts.Breadcrumbs} breadcrumb
   *        Breadcrumb.
   * @return {string}
   *         Formatted text.
   */
  getButtonText(breadcrumb) {
    const breadcrumbs = this, chart = breadcrumbs.chart, breadcrumbsOptions = breadcrumbs.options, lang6 = chart.options.lang, textFormat = pick89(breadcrumbsOptions.format, breadcrumbsOptions.showFullPath ? "{level.name}" : " {level.name}"), defaultText = lang6 && pick89(lang6.drillUpText, lang6.mainBreadcrumb);
    let returnText = breadcrumbsOptions.formatter && breadcrumbsOptions.formatter(breadcrumb) || format17(textFormat, { level: breadcrumb.levelOptions }, chart) || "";
    if ((isString19(returnText) && !returnText.length || returnText === " ") && defined64(defaultText)) {
      returnText = !breadcrumbsOptions.showFullPath ? " " + defaultText : defaultText;
    }
    return returnText;
  }
  /**
   * Redraw.
   *
   * @function Highcharts.Breadcrumbs#redraw
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  redraw() {
    if (this.isDirty) {
      this.render();
    }
    if (this.group) {
      this.group.align();
    }
    this.isDirty = false;
  }
  /**
   * Create a group, then draw breadcrumbs together with the separators.
   *
   * @function Highcharts.Breadcrumbs#render
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  render() {
    const breadcrumbs = this, chart = breadcrumbs.chart, breadcrumbsOptions = breadcrumbs.options;
    if (!breadcrumbs.group && breadcrumbsOptions) {
      breadcrumbs.group = chart.renderer.g("breadcrumbs-group").addClass("highcharts-no-tooltip highcharts-breadcrumbs").attr({
        zIndex: breadcrumbsOptions.zIndex
      }).add();
    }
    if (breadcrumbsOptions.showFullPath) {
      this.renderFullPathButtons();
    } else {
      this.renderSingleButton();
    }
    this.alignBreadcrumbsGroup();
  }
  /**
   * Draw breadcrumbs together with the separators.
   *
   * @function Highcharts.Breadcrumbs#renderFullPathButtons
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  renderFullPathButtons() {
    this.destroySingleButton();
    this.resetElementListState();
    this.updateListElements();
    this.destroyListElements();
  }
  /**
   * Render Single button - when showFullPath is not used. The button is
   * similar to the old drillUpButton
   *
   * @function Highcharts.Breadcrumbs#renderSingleButton
   * @param {Highcharts.Breadcrumbs} this Breadcrumbs class.
   */
  renderSingleButton() {
    const breadcrumbs = this, chart = breadcrumbs.chart, list = breadcrumbs.list, breadcrumbsOptions = breadcrumbs.options, buttonSpacing = breadcrumbsOptions.buttonSpacing;
    this.destroyListElements();
    const posX = breadcrumbs.group ? breadcrumbs.group.getBBox().width : buttonSpacing, posY = buttonSpacing;
    const previousBreadcrumb = list[list.length - 2];
    if (!chart.drillUpButton && this.level > 0) {
      chart.drillUpButton = breadcrumbs.renderButton(previousBreadcrumb, posX, posY);
    } else if (chart.drillUpButton) {
      if (this.level > 0) {
        this.updateSingleButton();
      } else {
        this.destroySingleButton();
      }
    }
  }
  /**
   * Update group position based on align and it's width.
   *
   * @function Highcharts.Breadcrumbs#renderSingleButton
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  alignBreadcrumbsGroup(xOffset) {
    const breadcrumbs = this;
    if (breadcrumbs.group) {
      const breadcrumbsOptions = breadcrumbs.options, buttonTheme = breadcrumbsOptions.buttonTheme, positionOptions = breadcrumbsOptions.position, alignTo = breadcrumbsOptions.relativeTo === "chart" || breadcrumbsOptions.relativeTo === "spacingBox" ? void 0 : "plotBox", bBox = breadcrumbs.group.getBBox(), additionalSpace = 2 * (buttonTheme.padding || 0) + breadcrumbsOptions.buttonSpacing;
      positionOptions.width = bBox.width + additionalSpace;
      positionOptions.height = bBox.height + additionalSpace;
      const newPositions = merge81(positionOptions);
      if (xOffset) {
        newPositions.x += xOffset;
      }
      if (breadcrumbs.options.rtl) {
        newPositions.x += positionOptions.width;
      }
      newPositions.y = pick89(newPositions.y, this.yOffset, 0);
      breadcrumbs.group.align(newPositions, true, alignTo);
    }
  }
  /**
   * Render a button.
   *
   * @function Highcharts.Breadcrumbs#renderButton
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   * @param {Highcharts.Breadcrumbs} breadcrumb
   *        Current breadcrumb
   * @param {Highcharts.Breadcrumbs} posX
   *        Initial horizontal position
   * @param {Highcharts.Breadcrumbs} posY
   *        Initial vertical position
   * @return {SVGElement|void}
   *        Returns the SVG button
   */
  renderButton(breadcrumb, posX, posY) {
    const breadcrumbs = this, chart = this.chart, breadcrumbsOptions = breadcrumbs.options, buttonTheme = merge81(breadcrumbsOptions.buttonTheme);
    const button = chart.renderer.button(breadcrumbs.getButtonText(breadcrumb), posX, posY, function(e) {
      const buttonEvents = breadcrumbsOptions.events && breadcrumbsOptions.events.click;
      let callDefaultEvent;
      if (buttonEvents) {
        callDefaultEvent = buttonEvents.call(breadcrumbs, e, breadcrumb);
      }
      if (callDefaultEvent !== false) {
        if (!breadcrumbsOptions.showFullPath) {
          e.newLevel = breadcrumbs.level - 1;
        } else {
          e.newLevel = breadcrumb.level;
        }
        fireEvent41(breadcrumbs, "up", e);
      }
    }, buttonTheme).addClass("highcharts-breadcrumbs-button").add(breadcrumbs.group);
    if (!chart.styledMode) {
      button.attr(breadcrumbsOptions.style);
    }
    return button;
  }
  /**
   * Render a separator.
   *
   * @function Highcharts.Breadcrumbs#renderSeparator
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   * @param {Highcharts.Breadcrumbs} posX
   *        Initial horizontal position
   * @param {Highcharts.Breadcrumbs} posY
   *        Initial vertical position
   * @return {Highcharts.SVGElement}
   *        Returns the SVG button
   */
  renderSeparator(posX, posY) {
    const breadcrumbs = this, chart = this.chart, breadcrumbsOptions = breadcrumbs.options, separatorOptions = breadcrumbsOptions.separator;
    const separator = chart.renderer.label(separatorOptions.text, posX, posY, void 0, void 0, void 0, false).addClass("highcharts-breadcrumbs-separator").add(breadcrumbs.group);
    if (!chart.styledMode) {
      separator.css(separatorOptions.style);
    }
    return separator;
  }
  /**
   * Update.
   * @function Highcharts.Breadcrumbs#update
   *
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   * @param {Highcharts.BreadcrumbsOptions} options
   *        Breadcrumbs class.
   * @param {boolean} redraw
   *        Redraw flag
   */
  update(options2) {
    merge81(true, this.options, options2);
    this.destroy();
    this.isDirty = true;
  }
  /**
   * Update button text when the showFullPath set to false.
   * @function Highcharts.Breadcrumbs#updateSingleButton
   *
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  updateSingleButton() {
    const chart = this.chart, currentBreadcrumb = this.list[this.level - 1];
    if (chart.drillUpButton) {
      chart.drillUpButton.attr({
        text: this.getButtonText(currentBreadcrumb)
      });
    }
  }
  /**
   * Destroy the chosen breadcrumbs group
   *
   * @function Highcharts.Breadcrumbs#destroy
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  destroy() {
    this.destroySingleButton();
    this.destroyListElements(true);
    if (this.group) {
      this.group.destroy();
    }
    this.group = void 0;
  }
  /**
   * Destroy the elements' buttons and separators.
   *
   * @function Highcharts.Breadcrumbs#destroyListElements
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  destroyListElements(force) {
    const elementList = this.elementList;
    objectEach32(elementList, (element, level) => {
      if (force || !elementList[level].updated) {
        element = elementList[level];
        element.button && element.button.destroy();
        element.separator && element.separator.destroy();
        delete element.button;
        delete element.separator;
        delete elementList[level];
      }
    });
    if (force) {
      this.elementList = {};
    }
  }
  /**
   * Destroy the single button if exists.
   *
   * @function Highcharts.Breadcrumbs#destroySingleButton
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  destroySingleButton() {
    if (this.chart.drillUpButton) {
      this.chart.drillUpButton.destroy();
      this.chart.drillUpButton = void 0;
    }
  }
  /**
   * Reset state for all buttons in elementList.
   *
   * @function Highcharts.Breadcrumbs#resetElementListState
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  resetElementListState() {
    objectEach32(this.elementList, (element) => {
      element.updated = false;
    });
  }
  /**
   * Update rendered elements inside the elementList.
   *
   * @function Highcharts.Breadcrumbs#updateListElements
   *
   * @param {Highcharts.Breadcrumbs} this
   *        Breadcrumbs class.
   */
  updateListElements() {
    const breadcrumbs = this, elementList = breadcrumbs.elementList, buttonSpacing = breadcrumbs.options.buttonSpacing, posY = buttonSpacing, list = breadcrumbs.list, rtl = breadcrumbs.options.rtl, rtlFactor = rtl ? -1 : 1, updateXPosition = function(element, spacing) {
      return rtlFactor * element.getBBox().width + rtlFactor * spacing;
    }, adjustToRTL = function(element, posX2, posY2) {
      element.translate(posX2 - element.getBBox().width, posY2);
    };
    let posX = breadcrumbs.group ? updateXPosition(breadcrumbs.group, buttonSpacing) : buttonSpacing, currentBreadcrumb, breadcrumb;
    for (let i = 0, iEnd = list.length; i < iEnd; ++i) {
      const isLast = i === iEnd - 1;
      let button, separator;
      breadcrumb = list[i];
      if (elementList[breadcrumb.level]) {
        currentBreadcrumb = elementList[breadcrumb.level];
        button = currentBreadcrumb.button;
        if (!currentBreadcrumb.separator && !isLast) {
          posX += rtlFactor * buttonSpacing;
          currentBreadcrumb.separator = breadcrumbs.renderSeparator(posX, posY);
          if (rtl) {
            adjustToRTL(currentBreadcrumb.separator, posX, posY);
          }
          posX += updateXPosition(currentBreadcrumb.separator, buttonSpacing);
        } else if (currentBreadcrumb.separator && isLast) {
          currentBreadcrumb.separator.destroy();
          delete currentBreadcrumb.separator;
        }
        elementList[breadcrumb.level].updated = true;
      } else {
        button = breadcrumbs.renderButton(breadcrumb, posX, posY);
        if (rtl) {
          adjustToRTL(button, posX, posY);
        }
        posX += updateXPosition(button, buttonSpacing);
        if (!isLast) {
          separator = breadcrumbs.renderSeparator(posX, posY);
          if (rtl) {
            adjustToRTL(separator, posX, posY);
          }
          posX += updateXPosition(separator, buttonSpacing);
        }
        elementList[breadcrumb.level] = {
          button,
          separator,
          updated: true
        };
      }
      if (button) {
        button.setState(isLast ? 2 : 0);
      }
    }
  }
};
Breadcrumbs.defaultOptions = BreadcrumbsDefaults_default.options;
var Breadcrumbs_default = Breadcrumbs;

// node_modules/highcharts/es-modules/Extensions/Drilldown/DrilldownDefaults.js
var DrilldownDefaults = {
  /**
   * When this option is false, clicking a single point will drill down
   * all points in the same category, equivalent to clicking the X axis
   * label.
   *
   * @sample {highcharts} highcharts/drilldown/allowpointdrilldown-false/
   *         Don't allow point drilldown
   *
   * @type      {boolean}
   * @default   true
   * @since     4.1.7
   * @product   highcharts
   * @apioption drilldown.allowPointDrilldown
   */
  /**
   * Options for the breadcrumbs, the navigation at the top leading the way
   * up through the drilldown levels.
   *
   * @since 10.0.0
   * @product   highcharts highmaps
   * @extends   navigation.breadcrumbs
   * @optionparent drilldown.breadcrumbs
   */
  /**
   * An array of series configurations for the drill down. Each series
   * configuration uses the same syntax as the [series](#series) option set.
   * These drilldown series are hidden by default. The drilldown series is
   * linked to the parent series' point by its `id`.
   *
   * @type      {Array<Highcharts.SeriesOptionsType>}
   * @since     3.0.8
   * @product   highcharts highmaps
   * @apioption drilldown.series
   */
  /**
   * Additional styles to apply to the X axis label for a point that
   * has drilldown data. By default it is underlined and blue to invite
   * to interaction.
   *
   * In styled mode, active label styles can be set with the
   * `.highcharts-drilldown-axis-label` class.
   *
   * @sample {highcharts} highcharts/drilldown/labels/
   *         Label styles
   *
   * @type    {Highcharts.CSSObject}
   * @default { "cursor": "pointer", "color": "#003399", "fontWeight": "bold", "textDecoration": "underline" }
   * @since   3.0.8
   * @product highcharts highmaps
   */
  activeAxisLabelStyle: {
    /** @ignore-option */
    cursor: "pointer",
    /** @ignore-option */
    color: "#0022ff",
    /** @ignore-option */
    fontWeight: "bold",
    /** @ignore-option */
    textDecoration: "underline"
  },
  /**
   * Additional styles to apply to the data label of a point that has
   * drilldown data. By default it is underlined and blue to invite to
   * interaction.
   *
   * In styled mode, active data label styles can be applied with the
   * `.highcharts-drilldown-data-label` class.
   *
   * @sample {highcharts} highcharts/drilldown/labels/
   *         Label styles
   *
   * @type    {Highcharts.CSSObject}
   * @default { "cursor": "pointer", "color": "#003399", "fontWeight": "bold", "textDecoration": "underline" }
   * @since   3.0.8
   * @product highcharts highmaps
   */
  activeDataLabelStyle: {
    cursor: "pointer",
    color: "#0022ff",
    fontWeight: "bold",
    textDecoration: "underline"
  },
  /**
   * Set the animation for all drilldown animations. Animation of a drilldown
   * occurs when drilling between a column point and a column series,
   * or a pie slice and a full pie series. Drilldown can still be used
   * between series and points of different types, but animation will
   * not occur.
   *
   * The animation can either be set as a boolean or a configuration
   * object. If `true`, it will use the 'swing' jQuery easing and a duration
   * of 500 ms. If used as a configuration object, the following properties
   * are supported:
   *
   * - `duration`: The duration of the animation in milliseconds.
   *
   * - `easing`: A string reference to an easing function set on the `Math`
   *   object. See
   *   [the easing demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).
   *
   * @type    {boolean|Highcharts.AnimationOptionsObject}
   * @since   3.0.8
   * @product highcharts highmaps
   */
  animation: {
    /** @ignore-option */
    duration: 500
  },
  /**
   * Drill up button is deprecated since Highcharts v9.3.2. Use
   * [drilldown.breadcrumbs](#drilldown.breadcrumbs) instead.
   *
   * Options for the drill up button that appears when drilling down on a
   * series. The text for the button is defined in
   * [lang.drillUpText](#lang.drillUpText).
   *
   * @sample highcharts/breadcrumbs/single-button
   *         Breadcrumbs set up like a legacy button
   * @sample {highcharts} highcharts/drilldown/drillupbutton/ Drill up button
   * @sample {highmaps} highcharts/drilldown/drillupbutton/ Drill up button
   *
   * @since   3.0.8
   * @product highcharts highmaps
   *
   * @deprecated 9.3.2
   */
  drillUpButton: {
    /**
     * What box to align the button to. Can be either `plotBox` or
     * `spacingBox`.
     *
     * @type       {Highcharts.ButtonRelativeToValue}
     * @default    plotBox
     * @since      3.0.8
     * @product    highcharts highmaps
     * @apioption  drilldown.drillUpButton.relativeTo
     */
    /**
     * A collection of attributes for the button. The object takes SVG
     * attributes like `fill`, `stroke`, `stroke-width` or `r`, the border
     * radius. The theme also supports `style`, a collection of CSS
     * properties for the text. Equivalent attributes for the hover state
     * are given in `theme.states.hover`.
     *
     * In styled mode, drill-up button styles can be applied with the
     * `.highcharts-drillup-button` class.
     *
     * @sample {highcharts} highcharts/drilldown/drillupbutton/
     *         Button theming
     * @sample {highmaps} highcharts/drilldown/drillupbutton/
     *         Button theming
     *
     * @type      {Object}
     * @since     3.0.8
     * @product   highcharts highmaps
     * @apioption drilldown.drillUpButton.theme
     */
    /**
     * Positioning options for the button within the `relativeTo` box.
     * Available properties are `x`, `y`, `align` and `verticalAlign`.
     *
     * @type    {Highcharts.AlignObject}
     * @since   3.0.8
     * @product highcharts highmaps
     */
    position: {
      /**
       * Vertical alignment of the button.
       *
       * @type      {Highcharts.VerticalAlignValue}
       * @default   top
       * @product   highcharts highmaps
       * @apioption drilldown.drillUpButton.position.verticalAlign
       */
      /**
       * Horizontal alignment.
       *
       * @type {Highcharts.AlignValue}
       */
      align: "right",
      /**
       * The X offset of the button.
       */
      x: -10,
      /**
       * The Y offset of the button.
       */
      y: 10
    }
  },
  /**
   * Enable or disable zooming into a region of clicked map point you want to
   * drill into. If mapZooming is set to false the drilldown/drillup
   * animations only fade in/fade out without zooming to a specific map point.
   *
   * @sample    maps/demo/map-drilldown-preloaded/
   *            Map drilldown without async maps loading
   *
   * @type      {boolean}
   * @default   true
   * @since 11.0.0
   * @product   highmaps
   * @apioption drilldown.mapZooming
   */
  mapZooming: true
};
var DrilldownDefaults_default = DrilldownDefaults;

// node_modules/highcharts/es-modules/Extensions/Drilldown/DrilldownSeries.js
var { animObject: animObject15 } = AnimationUtilities_default;
var { addEvent: addEvent77, extend: extend69, fireEvent: fireEvent42, merge: merge82, pick: pick90, syncTimeout: syncTimeout12 } = Utilities_default;
function applyCursorCSS(element, cursor, addClass5, styledMode) {
  element[addClass5 ? "addClass" : "removeClass"]("highcharts-drilldown-point");
  if (!styledMode) {
    element.css({ cursor });
  }
}
function columnAnimateDrilldown(init3) {
  const series = this, chart = series.chart, drilldownLevels = chart.drilldownLevels, animationOptions = animObject15((chart.options.drilldown || {}).animation), xAxis2 = this.xAxis, styledMode = chart.styledMode;
  if (!init3) {
    let animateFrom;
    (drilldownLevels || []).forEach((level) => {
      if (series.options._ddSeriesId === level.lowerSeriesOptions._ddSeriesId) {
        animateFrom = level.shapeArgs;
        if (!styledMode && animateFrom) {
          animateFrom.fill = level.color;
        }
      }
    });
    animateFrom.x += pick90(xAxis2.oldPos, xAxis2.pos) - xAxis2.pos;
    series.points.forEach((point) => {
      const animateTo = point.shapeArgs;
      if (!styledMode) {
        animateTo.fill = point.color;
      }
      if (point.graphic) {
        point.graphic.attr(animateFrom).animate(extend69(point.shapeArgs, { fill: point.color || series.color }), animationOptions);
      }
    });
    if (chart.drilldown) {
      chart.drilldown.fadeInGroup(this.dataLabelsGroup);
    }
    delete this.animate;
  }
}
function columnAnimateDrillupFrom(level) {
  const series = this, animationOptions = animObject15((series.chart.options.drilldown || {}).animation);
  (series.trackerGroups || []).forEach((key) => {
    if (series[key]) {
      series[key].on("mouseover");
    }
  });
  let group = series.group;
  const removeGroup = group !== series.chart.columnGroup;
  if (removeGroup) {
    delete series.group;
  }
  (this.points || this.data).forEach((point) => {
    const graphic = point.graphic, animateTo = level.shapeArgs;
    if (graphic && animateTo) {
      const complete = () => {
        graphic.destroy();
        if (group && removeGroup) {
          group = group.destroy();
        }
      };
      delete point.graphic;
      if (!series.chart.styledMode) {
        animateTo.fill = level.color;
      }
      if (animationOptions.duration) {
        graphic.animate(animateTo, merge82(animationOptions, { complete }));
      } else {
        graphic.attr(animateTo);
        complete();
      }
    }
  });
}
function columnAnimateDrillupTo(init3) {
  const series = this, level = series.drilldownLevel;
  if (!init3) {
    series.points.forEach((point) => {
      const dataLabel = point.dataLabel;
      if (point.graphic) {
        point.graphic.hide();
      }
      if (dataLabel) {
        dataLabel.hidden = dataLabel.attr("visibility") === "hidden";
        if (!dataLabel.hidden) {
          dataLabel.hide();
          dataLabel.connector?.hide();
        }
      }
    });
    syncTimeout12(() => {
      if (series.points) {
        let pointsWithNodes = [];
        series.data.forEach((el) => {
          pointsWithNodes.push(el);
        });
        if (series.nodes) {
          pointsWithNodes = pointsWithNodes.concat(series.nodes);
        }
        pointsWithNodes.forEach((point, i) => {
          const verb = i === (level && level.pointIndex) ? "show" : "fadeIn", inherit = verb === "show" ? true : void 0, dataLabel = point.dataLabel;
          if (point.graphic && // #3407
          point.visible) {
            point.graphic[verb](inherit);
          }
          if (dataLabel && !dataLabel.hidden) {
            dataLabel.fadeIn();
            dataLabel.connector?.fadeIn();
          }
        });
      }
    }, Math.max(series.chart.options.drilldown.animation.duration - 50, 0));
    delete this.animate;
  }
}
function compose19(SeriesClass, seriesTypes7) {
  const PointClass = SeriesClass.prototype.pointClass, pointProto2 = PointClass.prototype;
  if (!pointProto2.doDrilldown) {
    const { column: ColumnSeriesClass, map: MapSeriesClass, pie: PieSeriesClass } = seriesTypes7;
    addEvent77(PointClass, "afterInit", onPointAfterInit);
    addEvent77(PointClass, "afterSetState", onPointAfterSetState);
    addEvent77(PointClass, "update", onPointUpdate);
    pointProto2.doDrilldown = pointDoDrilldown;
    pointProto2.runDrilldown = pointRunDrilldown;
    addEvent77(SeriesClass, "afterDrawDataLabels", onSeriesAfterDrawDataLabels);
    addEvent77(SeriesClass, "afterDrawTracker", onSeriesAfterDrawTracker);
    if (ColumnSeriesClass) {
      const columnProto7 = ColumnSeriesClass.prototype;
      columnProto7.animateDrilldown = columnAnimateDrilldown;
      columnProto7.animateDrillupFrom = columnAnimateDrillupFrom;
      columnProto7.animateDrillupTo = columnAnimateDrillupTo;
    }
    if (MapSeriesClass) {
      const mapProto = MapSeriesClass.prototype;
      mapProto.animateDrilldown = mapAnimateDrilldown;
      mapProto.animateDrillupFrom = mapAnimateDrillupFrom;
      mapProto.animateDrillupTo = mapAnimateDrillupTo;
    }
    if (PieSeriesClass) {
      const pieProto = PieSeriesClass.prototype;
      pieProto.animateDrilldown = pieAnimateDrilldown;
      pieProto.animateDrillupFrom = columnAnimateDrillupFrom;
      pieProto.animateDrillupTo = columnAnimateDrillupTo;
    }
  }
}
function mapAnimateDrilldown(init3) {
  const series = this, chart = series.chart, group = series.group;
  if (chart && group && series.options && chart.options.drilldown && chart.options.drilldown.animation) {
    if (init3 && chart.mapView) {
      group.attr({
        opacity: 0.01
      });
      chart.mapView.allowTransformAnimation = false;
      series.options.inactiveOtherPoints = true;
      series.options.enableMouseTracking = false;
    } else {
      group.animate({
        opacity: 1
      }, chart.options.drilldown.animation, () => {
        if (series.options) {
          series.options.inactiveOtherPoints = false;
          series.options.enableMouseTracking = pick90(series.userOptions && series.userOptions.enableMouseTracking, true);
        }
      });
      if (chart.drilldown) {
        chart.drilldown.fadeInGroup(this.dataLabelsGroup);
      }
    }
  }
}
function mapAnimateDrillupFrom() {
  const series = this, chart = series.chart;
  if (chart && chart.mapView) {
    chart.mapView.allowTransformAnimation = false;
  }
  if (series.options) {
    series.options.inactiveOtherPoints = true;
  }
}
function mapAnimateDrillupTo(init3) {
  const series = this, chart = series.chart, group = series.group;
  if (chart && group) {
    if (init3) {
      group.attr({
        opacity: 0.01
      });
      if (series.options) {
        series.options.inactiveOtherPoints = true;
      }
    } else {
      group.animate({ opacity: 1 }, (chart.options.drilldown || {}).animation);
      if (chart.drilldown) {
        chart.drilldown.fadeInGroup(series.dataLabelsGroup);
      }
    }
  }
}
function onPointAfterInit() {
  const point = this;
  if (point.drilldown && !point.unbindDrilldownClick) {
    point.unbindDrilldownClick = addEvent77(point, "click", onPointClick);
  }
  return point;
}
function onPointAfterSetState() {
  const point = this, series = point.series, styledMode = series.chart.styledMode;
  if (point.drilldown && series.halo && point.state === "hover") {
    applyCursorCSS(series.halo, "pointer", true, styledMode);
  } else if (series.halo) {
    applyCursorCSS(series.halo, "auto", false, styledMode);
  }
}
function onPointClick(e) {
  const point = this, series = point.series;
  if (series.xAxis && (series.chart.options.drilldown || {}).allowPointDrilldown === false) {
    series.xAxis.drilldownCategory(point.x, e);
  } else {
    point.runDrilldown(void 0, void 0, e);
  }
}
function onPointUpdate(e) {
  const point = this, options2 = e.options || {};
  if (options2.drilldown && !point.unbindDrilldownClick) {
    point.unbindDrilldownClick = addEvent77(point, "click", onPointClick);
  } else if (!options2.drilldown && options2.drilldown !== void 0 && point.unbindDrilldownClick) {
    point.unbindDrilldownClick = point.unbindDrilldownClick();
  }
}
function onSeriesAfterDrawDataLabels() {
  const series = this, chart = series.chart, css19 = chart.options.drilldown.activeDataLabelStyle, renderer = chart.renderer, styledMode = chart.styledMode;
  for (const point of series.points) {
    const dataLabelsOptions = point.options.dataLabels, pointCSS = pick90(point.dlOptions, dataLabelsOptions && dataLabelsOptions.style, {});
    if (point.drilldown && point.dataLabel) {
      if (css19.color === "contrast" && !styledMode) {
        pointCSS.color = renderer.getContrast(point.color || series.color);
      }
      if (dataLabelsOptions && dataLabelsOptions.color) {
        pointCSS.color = dataLabelsOptions.color;
      }
      point.dataLabel.addClass("highcharts-drilldown-data-label");
      if (!styledMode) {
        point.dataLabel.css(css19).css(pointCSS);
      }
    }
  }
}
function onSeriesAfterDrawTracker() {
  const series = this, styledMode = series.chart.styledMode;
  for (const point of series.points) {
    if (point.drilldown && point.graphic) {
      applyCursorCSS(point.graphic, "pointer", true, styledMode);
    }
  }
}
function pieAnimateDrilldown(init3) {
  const series = this, chart = series.chart, points = series.points, level = chart.drilldownLevels[chart.drilldownLevels.length - 1], animationOptions = chart.options.drilldown.animation;
  if (series.is("item")) {
    animationOptions.duration = 0;
  }
  if (series.center) {
    const animateFrom = level.shapeArgs, start = animateFrom.start, angle = animateFrom.end - start, startAngle = angle / series.points.length, styledMode = chart.styledMode;
    if (!init3) {
      let animateTo, point;
      for (let i = 0, iEnd = points.length; i < iEnd; ++i) {
        point = points[i];
        animateTo = point.shapeArgs;
        if (!styledMode) {
          animateFrom.fill = level.color;
          animateTo.fill = point.color;
        }
        if (point.graphic) {
          point.graphic.attr(merge82(animateFrom, {
            start: start + i * startAngle,
            end: start + (i + 1) * startAngle
          }))[animationOptions ? "animate" : "attr"](animateTo, animationOptions);
        }
      }
      if (chart.drilldown) {
        chart.drilldown.fadeInGroup(series.dataLabelsGroup);
      }
      delete series.animate;
    }
  }
}
function pointDoDrilldown() {
  this.runDrilldown();
}
function pointRunDrilldown(holdRedraw, category, originalEvent) {
  const point = this, series = point.series, chart = series.chart, drilldown = chart.options.drilldown || {};
  let i = (drilldown.series || []).length, seriesOptions;
  if (!chart.ddDupes) {
    chart.ddDupes = [];
  }
  chart.colorCounter = chart.symbolCounter = 0;
  while (i-- && !seriesOptions) {
    if (drilldown.series && drilldown.series[i].id === point.drilldown && point.drilldown && chart.ddDupes.indexOf(point.drilldown) === -1) {
      seriesOptions = drilldown.series[i];
      chart.ddDupes.push(point.drilldown);
    }
  }
  fireEvent42(chart, "drilldown", {
    point,
    seriesOptions,
    category,
    originalEvent,
    points: typeof category !== "undefined" && series.xAxis.getDDPoints(category).slice(0)
  }, (e) => {
    const chart2 = e.point.series && e.point.series.chart, seriesOptions2 = e.seriesOptions;
    if (chart2 && seriesOptions2) {
      if (holdRedraw) {
        chart2.addSingleSeriesAsDrilldown(e.point, seriesOptions2);
      } else {
        chart2.addSeriesAsDrilldown(e.point, seriesOptions2);
      }
    }
  });
}
var DrilldownSeries = {
  compose: compose19
};
var DrilldownSeries_default = DrilldownSeries;

// node_modules/highcharts/es-modules/Extensions/Drilldown/Drilldown.js
var { animObject: animObject16 } = AnimationUtilities_default;
var { noop: noop17 } = Globals_default;
var { addEvent: addEvent78, defined: defined65, diffObjects: diffObjects6, extend: extend70, fireEvent: fireEvent43, merge: merge83, objectEach: objectEach33, pick: pick91, removeEvent: removeEvent11, syncTimeout: syncTimeout13 } = Utilities_default;
var ddSeriesId = 1;
function axisDrilldownCategory(x, originalEvent) {
  this.getDDPoints(x).forEach(function(point) {
    if (point && point.series && point.series.visible && point.runDrilldown) {
      point.runDrilldown(true, x, originalEvent);
    }
  });
  this.chart.applyDrilldown();
}
function axisGetDDPoints(x) {
  return this.ddPoints && this.ddPoints[x] || [];
}
function createBreadcrumbsList(chart) {
  const list = [], drilldownLevels = chart.drilldownLevels;
  if (drilldownLevels && drilldownLevels.length) {
    if (!list[0]) {
      list.push({
        level: 0,
        levelOptions: drilldownLevels[0].seriesOptions
      });
    }
    drilldownLevels.forEach(function(level) {
      const lastBreadcrumb = list[list.length - 1];
      if (level.levelNumber + 1 > lastBreadcrumb.level) {
        list.push({
          level: level.levelNumber + 1,
          levelOptions: merge83({
            name: level.lowerSeries.name
          }, level.pointOptions)
        });
      }
    });
  }
  return list;
}
var ChartAdditions = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart) {
    this.chart = chart;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Add a series to the chart as drilldown from a specific point in the
   * parent series. This method is used for async drilldown, when clicking a
   * point in a series should result in loading and displaying a more
   * high-resolution series. When not async, the setup is simpler using the
   * [drilldown.series](https://api.highcharts.com/highcharts/drilldown.series)
   * options structure.
   *
   * @sample highcharts/drilldown/async/
   *         Async drilldown
   *
   * @function Highcharts.Chart#addSeriesAsDrilldown
   *
   * @param {Highcharts.Point} point
   * The point from which the drilldown will start.
   *
   * @param {Highcharts.SeriesOptionsType} options
   * The series options for the new, detailed series.
   */
  addSeriesAsDrilldown(point, options2) {
    const chart = this.chart || this;
    fireEvent43(this, "addSeriesAsDrilldown", { seriesOptions: options2 });
    if (chart.mapView) {
      point.series.isDrilling = true;
      chart.series.forEach((series) => {
        series.options.inactiveOtherPoints = true;
        series.dataLabelsGroup?.destroy();
        delete series.dataLabelsGroup;
      });
      if (chart.options.drilldown && !chart.mapView.projection.hasGeoProjection && DrilldownDefaults_default) {
        const userDrilldown = diffObjects6(chart.options.drilldown, DrilldownDefaults_default);
        if (!defined65(userDrilldown.mapZooming)) {
          chart.options.drilldown.mapZooming = false;
        }
      }
      if (chart.options.drilldown && chart.options.drilldown.animation && chart.options.drilldown.mapZooming) {
        chart.mapView.allowTransformAnimation = true;
        const animOptions = animObject16(chart.options.drilldown.animation);
        if (typeof animOptions !== "boolean") {
          const userComplete = animOptions.complete, drilldownComplete = function(obj) {
            if (obj && obj.applyDrilldown && chart.mapView) {
              chart.addSingleSeriesAsDrilldown(point, options2);
              chart.applyDrilldown();
              chart.mapView.allowTransformAnimation = false;
            }
          };
          animOptions.complete = function() {
            if (userComplete) {
              userComplete.apply(this, arguments);
            }
            drilldownComplete.apply(this, arguments);
          };
        }
        point.zoomTo(animOptions);
      } else {
        chart.addSingleSeriesAsDrilldown(point, options2);
        chart.applyDrilldown();
      }
    } else {
      chart.addSingleSeriesAsDrilldown(point, options2);
      chart.applyDrilldown();
    }
  }
  /** @private */
  addSingleSeriesAsDrilldown(point, ddOptions) {
    const chart = this.chart || this, oldSeries = point.series, xAxis2 = oldSeries.xAxis, yAxis2 = oldSeries.yAxis, colorProp = chart.styledMode ? { colorIndex: pick91(point.colorIndex, oldSeries.colorIndex) } : { color: point.color || oldSeries.color }, levelNumber = oldSeries.options._levelNumber || 0;
    if (!chart.drilldownLevels) {
      chart.drilldownLevels = [];
    }
    ddOptions = extend70(extend70({
      _ddSeriesId: ddSeriesId++
    }, colorProp), ddOptions);
    let levelSeries = [], levelSeriesOptions = [], last;
    last = chart.drilldownLevels[chart.drilldownLevels.length - 1];
    if (last && last.levelNumber !== levelNumber) {
      last = void 0;
    }
    oldSeries.chart.series.forEach((series) => {
      if (series.xAxis === xAxis2) {
        series.options._ddSeriesId = series.options._ddSeriesId || ddSeriesId++;
        series.options.colorIndex = series.colorIndex;
        series.options._levelNumber = series.options._levelNumber || levelNumber;
        if (last) {
          levelSeries = last.levelSeries;
          levelSeriesOptions = last.levelSeriesOptions;
        } else {
          levelSeries.push(series);
          series.purgedOptions = merge83({
            _ddSeriesId: series.options._ddSeriesId,
            _levelNumber: series.options._levelNumber,
            selected: series.options.selected
          }, series.userOptions);
          levelSeriesOptions.push(series.purgedOptions);
        }
      }
    });
    const level = extend70({
      levelNumber,
      seriesOptions: oldSeries.options,
      seriesPurgedOptions: oldSeries.purgedOptions,
      levelSeriesOptions,
      levelSeries,
      shapeArgs: point.shapeArgs,
      // No graphic in line series with markers disabled
      bBox: point.graphic ? point.graphic.getBBox() : {},
      color: point.isNull ? "rgba(0,0,0,0)" : colorProp.color,
      lowerSeriesOptions: ddOptions,
      pointOptions: point.options,
      pointIndex: point.index,
      oldExtremes: {
        xMin: xAxis2 && xAxis2.userMin,
        xMax: xAxis2 && xAxis2.userMax,
        yMin: yAxis2 && yAxis2.userMin,
        yMax: yAxis2 && yAxis2.userMax
      },
      resetZoomButton: last && last.levelNumber === levelNumber ? void 0 : chart.resetZoomButton
    }, colorProp);
    chart.drilldownLevels.push(level);
    if (xAxis2 && xAxis2.names) {
      xAxis2.names.length = 0;
    }
    const newSeries = level.lowerSeries = chart.addSeries(ddOptions, false);
    newSeries.options._levelNumber = levelNumber + 1;
    if (xAxis2) {
      xAxis2.oldPos = xAxis2.pos;
      xAxis2.userMin = xAxis2.userMax = null;
      yAxis2.userMin = yAxis2.userMax = null;
    }
    newSeries.isDrilling = true;
    if (oldSeries.type === newSeries.type) {
      newSeries.animate = newSeries.animateDrilldown || noop17;
      newSeries.options.animation = true;
    }
  }
  applyDrilldown() {
    const chart = this.chart || this, drilldownLevels = chart.drilldownLevels;
    let levelToRemove;
    if (drilldownLevels && drilldownLevels.length > 0) {
      levelToRemove = drilldownLevels[drilldownLevels.length - 1].levelNumber;
      chart.hasCartesianSeries = drilldownLevels.some(
        (level) => level.lowerSeries.isCartesian
        // #19725
      );
      (chart.drilldownLevels || []).forEach((level) => {
        if (chart.mapView && chart.options.drilldown && chart.options.drilldown.mapZooming) {
          chart.redraw();
          level.lowerSeries.isDrilling = false;
          chart.mapView.fitToBounds(level.lowerSeries.bounds);
          level.lowerSeries.isDrilling = true;
        }
        if (level.levelNumber === levelToRemove) {
          level.levelSeries.forEach((series) => {
            if (!chart.mapView) {
              if (series.options && series.options._levelNumber === levelToRemove) {
                series.remove(false);
              }
            } else if (series.options && series.options._levelNumber === levelToRemove && series.group) {
              let animOptions = {};
              if (chart.options.drilldown) {
                animOptions = chart.options.drilldown.animation;
              }
              series.group.animate({
                opacity: 0
              }, animOptions, () => {
                series.remove(false);
                if (!level.levelSeries.filter((el) => Object.keys(el).length).length) {
                  if (chart.resetZoomButton) {
                    chart.resetZoomButton.hide();
                    delete chart.resetZoomButton;
                  }
                  chart.pointer?.reset();
                  fireEvent43(chart, "afterDrilldown");
                  if (chart.mapView) {
                    chart.series.forEach((series2) => {
                      series2.isDirtyData = true;
                      series2.isDrilling = false;
                    });
                    chart.mapView.fitToBounds(void 0, void 0);
                    chart.mapView.allowTransformAnimation = true;
                  }
                  fireEvent43(chart, "afterApplyDrilldown");
                }
              });
            }
          });
        }
      });
    }
    if (!chart.mapView) {
      if (chart.resetZoomButton) {
        chart.resetZoomButton.hide();
        delete chart.resetZoomButton;
      }
      chart.pointer?.reset();
      fireEvent43(chart, "afterDrilldown");
      if (!chart.hasCartesianSeries) {
        chart.axes.forEach((axis) => {
          axis.destroy(true);
          axis.init(chart, merge83(axis.userOptions, axis.options));
        });
      }
      chart.redraw();
      fireEvent43(chart, "afterApplyDrilldown");
    }
  }
  /**
   * When the chart is drilled down to a child series, calling
   * `chart.drillUp()` will drill up to the parent series.
   *
   * @requires  modules/drilldown
   *
   * @function Highcharts.Chart#drillUp
   *
   * @sample {highcharts} highcharts/drilldown/programmatic
   *         Programmatic drilldown
   */
  drillUp(isMultipleDrillUp) {
    const chart = this.chart || this;
    if (!chart.drilldownLevels || chart.drilldownLevels.length === 0) {
      return;
    }
    fireEvent43(chart, "beforeDrillUp");
    const drilldownLevels = chart.drilldownLevels, levelNumber = drilldownLevels[drilldownLevels.length - 1].levelNumber, chartSeries = chart.series, drilldownLevelsNumber = chart.drilldownLevels.length, addSeries = (seriesOptions, oldSeries) => {
      let addedSeries;
      chartSeries.forEach((series) => {
        if (series.options._ddSeriesId === seriesOptions._ddSeriesId) {
          addedSeries = series;
        }
      });
      addedSeries = addedSeries || chart.addSeries(seriesOptions, false);
      if (addedSeries.type === oldSeries.type && addedSeries.animateDrillupTo) {
        addedSeries.animate = addedSeries.animateDrillupTo;
      }
      if (seriesOptions === level.seriesPurgedOptions) {
        return addedSeries;
      }
    }, removeSeries = (oldSeries) => {
      oldSeries.remove(false);
      chart.series.forEach((series) => {
        if (series.colorAxis) {
          series.isDirtyData = true;
        }
        series.options.inactiveOtherPoints = false;
      });
      chart.redraw();
    };
    let i = drilldownLevels.length, seriesI, level, oldExtremes;
    chart.symbolCounter = chart.colorCounter = 0;
    while (i--) {
      let oldSeries, newSeries;
      level = drilldownLevels[i];
      if (level.levelNumber === levelNumber) {
        drilldownLevels.pop();
        oldSeries = level.lowerSeries;
        if (!oldSeries.chart) {
          seriesI = chartSeries.length;
          while (seriesI--) {
            if (chartSeries[seriesI].options.id === level.lowerSeriesOptions.id && chartSeries[seriesI].options._levelNumber === levelNumber + 1) {
              oldSeries = chartSeries[seriesI];
              break;
            }
          }
        }
        oldSeries.dataTable.setColumn("x", []);
        if (oldSeries.xAxis && oldSeries.xAxis.names && (drilldownLevelsNumber === 0 || i === drilldownLevelsNumber - 1)) {
          oldSeries.xAxis.names.length = 0;
        }
        level.levelSeriesOptions.forEach((el) => {
          const addedSeries = addSeries(el, oldSeries);
          if (addedSeries) {
            newSeries = addedSeries;
          }
        });
        fireEvent43(chart, "drillup", {
          seriesOptions: level.seriesPurgedOptions || level.seriesOptions
        });
        if (newSeries) {
          if (newSeries.type === oldSeries.type) {
            newSeries.drilldownLevel = level;
            newSeries.options.animation = chart.options.drilldown.animation;
            if (oldSeries.animateDrillupFrom && oldSeries.chart) {
              oldSeries.animateDrillupFrom(level);
            }
          }
          newSeries.options._levelNumber = levelNumber;
        }
        const seriesToRemove = oldSeries;
        if (!chart.mapView) {
          seriesToRemove.remove(false);
        }
        if (newSeries && newSeries.xAxis) {
          oldExtremes = level.oldExtremes;
          newSeries.xAxis.setExtremes(oldExtremes.xMin, oldExtremes.xMax, false);
          newSeries.yAxis.setExtremes(oldExtremes.yMin, oldExtremes.yMax, false);
        }
        if (level.resetZoomButton) {
          chart.resetZoomButton = level.resetZoomButton;
        }
        if (!chart.mapView) {
          fireEvent43(chart, "afterDrillUp");
        } else {
          const shouldAnimate = level.levelNumber === levelNumber && isMultipleDrillUp, zoomingDrill = chart.options.drilldown && chart.options.drilldown.animation && chart.options.drilldown.mapZooming;
          if (shouldAnimate) {
            oldSeries.remove(false);
          } else {
            if (oldSeries.dataLabelsGroup) {
              oldSeries.dataLabelsGroup.destroy();
              delete oldSeries.dataLabelsGroup;
            }
            if (chart.mapView && newSeries) {
              if (zoomingDrill) {
                oldSeries.isDrilling = true;
                newSeries.isDrilling = true;
                chart.redraw(false);
                chart.mapView.fitToBounds(oldSeries.bounds, void 0, true, false);
              }
              chart.mapView.allowTransformAnimation = true;
              fireEvent43(chart, "afterDrillUp", {
                seriesOptions: newSeries ? newSeries.userOptions : void 0
              });
              if (zoomingDrill) {
                chart.mapView.setView(void 0, pick91(chart.mapView.minZoom, 1), true, {
                  complete: function() {
                    if (Object.prototype.hasOwnProperty.call(this, "complete")) {
                      removeSeries(oldSeries);
                    }
                  }
                });
                newSeries._hasTracking = false;
              } else {
                chart.mapView.allowTransformAnimation = false;
                if (oldSeries.group) {
                  oldSeries.group.animate({
                    opacity: 0
                  }, chart.options.drilldown.animation, () => {
                    removeSeries(oldSeries);
                    if (chart.mapView) {
                      chart.mapView.allowTransformAnimation = true;
                    }
                  });
                } else {
                  removeSeries(oldSeries);
                  chart.mapView.allowTransformAnimation = true;
                }
              }
              newSeries.isDrilling = false;
            }
          }
        }
      }
    }
    if (!chart.mapView && !isMultipleDrillUp) {
      chart.redraw();
    }
    if (chart.ddDupes) {
      chart.ddDupes.length = 0;
    }
    fireEvent43(chart, "drillupall");
  }
  /**
   * A function to fade in a group. First, the element is being hidden, then,
   * using `opactiy`, is faded in. Used for example by `dataLabelsGroup` where
   * simple SVGElement.fadeIn() is not enough, because of other features (e.g.
   * InactiveState) using `opacity` to fadeIn/fadeOut.
   *
   * @requires modules/drilldown
   *
   * @private
   * @param {SVGElement} [group]
   *        The SVG element to be faded in.
   */
  fadeInGroup(group) {
    const chart = this.chart, animationOptions = animObject16(chart.options.drilldown.animation);
    if (group) {
      group.hide();
      syncTimeout13(() => {
        if (group && group.added) {
          group.fadeIn();
        }
      }, Math.max(animationOptions.duration - 50, 0));
    }
  }
  /**
   * Update function to be called internally from Chart.update (#7600, #12855)
   * @private
   */
  update(options2, redraw) {
    const chart = this.chart;
    merge83(true, chart.options.drilldown, options2);
    if (pick91(redraw, true)) {
      chart.redraw();
    }
  }
};
var Drilldown;
(function(Drilldown2) {
  function compose27(AxisClass, ChartClass, highchartsDefaultOptions, SeriesClass, seriesTypes7, SVGRendererClass, TickClass) {
    DrilldownSeries_default.compose(SeriesClass, seriesTypes7);
    const DrilldownChart = ChartClass, chartProto = DrilldownChart.prototype;
    if (!chartProto.drillUp) {
      const SVGElementClass = SVGRendererClass.prototype.Element, addonProto = ChartAdditions.prototype, axisProto = AxisClass.prototype, elementProto = SVGElementClass.prototype, tickProto = TickClass.prototype;
      axisProto.drilldownCategory = axisDrilldownCategory;
      axisProto.getDDPoints = axisGetDDPoints;
      Breadcrumbs_default.compose(ChartClass, highchartsDefaultOptions);
      addEvent78(Breadcrumbs_default, "up", onBreadcrumbsUp);
      chartProto.addSeriesAsDrilldown = addonProto.addSeriesAsDrilldown;
      chartProto.addSingleSeriesAsDrilldown = addonProto.addSingleSeriesAsDrilldown;
      chartProto.applyDrilldown = addonProto.applyDrilldown;
      chartProto.drillUp = addonProto.drillUp;
      addEvent78(DrilldownChart, "afterDrilldown", onChartAfterDrilldown);
      addEvent78(DrilldownChart, "afterDrillUp", onChartAfterDrillUp);
      addEvent78(DrilldownChart, "afterInit", onChartAfterInit3);
      addEvent78(DrilldownChart, "drillup", onChartDrillup);
      addEvent78(DrilldownChart, "drillupall", onChartDrillupall);
      addEvent78(DrilldownChart, "render", onChartRender7);
      addEvent78(DrilldownChart, "update", onChartUpdate3);
      highchartsDefaultOptions.drilldown = DrilldownDefaults_default;
      elementProto.fadeIn = svgElementFadeIn;
      tickProto.drillable = tickDrillable;
    }
  }
  Drilldown2.compose = compose27;
  function onBreadcrumbsUp(e) {
    const chart = this.chart, drillUpsNumber = this.getLevel() - e.newLevel;
    let isMultipleDrillUp = drillUpsNumber > 1;
    for (let i = 0; i < drillUpsNumber; i++) {
      if (i === drillUpsNumber - 1) {
        isMultipleDrillUp = false;
      }
      chart.drillUp(isMultipleDrillUp);
    }
  }
  function onChartAfterDrilldown() {
    const chart = this, drilldownOptions = chart.options.drilldown, breadcrumbsOptions = drilldownOptions && drilldownOptions.breadcrumbs;
    if (!chart.breadcrumbs) {
      chart.breadcrumbs = new Breadcrumbs_default(chart, breadcrumbsOptions);
    }
    chart.breadcrumbs.updateProperties(createBreadcrumbsList(chart));
  }
  function onChartAfterDrillUp() {
    const chart = this;
    if (chart.breadcrumbs) {
      chart.breadcrumbs.updateProperties(createBreadcrumbsList(chart));
    }
  }
  function onChartAfterInit3() {
    this.drilldown = new ChartAdditions(this);
  }
  function onChartDrillup() {
    const chart = this;
    if (chart.resetZoomButton) {
      chart.resetZoomButton = chart.resetZoomButton.destroy();
    }
  }
  function onChartDrillupall() {
    const chart = this;
    if (chart.resetZoomButton) {
      chart.showResetZoom();
    }
  }
  function onChartRender7() {
    (this.xAxis || []).forEach((axis) => {
      axis.ddPoints = {};
      axis.series.forEach((series) => {
        const xData = series.getColumn("x"), points = series.points;
        for (let i = 0, iEnd = xData.length, p; i < iEnd; i++) {
          p = series.options.data[i];
          if (typeof p !== "number") {
            p = series.pointClass.prototype.optionsToObject.call({ series }, p);
            if (p.drilldown) {
              if (!axis.ddPoints[xData[i]]) {
                axis.ddPoints[xData[i]] = [];
              }
              const index = i - (series.cropStart || 0);
              axis.ddPoints[xData[i]].push(points && index >= 0 && index < points.length ? points[index] : true);
            }
          }
        }
      });
      objectEach33(axis.ticks, (tick) => tick.drillable());
    });
  }
  function onChartUpdate3(e) {
    const breadcrumbs = this.breadcrumbs, breadcrumbOptions = e.options.drilldown && e.options.drilldown.breadcrumbs;
    if (breadcrumbs && breadcrumbOptions) {
      breadcrumbs.update(breadcrumbOptions);
    }
  }
  function svgElementFadeIn(animation) {
    const elem = this;
    elem.attr({
      opacity: 0.1,
      visibility: "inherit"
    }).animate({
      opacity: pick91(elem.newOpacity, 1)
      // `newOpacity` used in maps
    }, animation || {
      duration: 250
    });
  }
  function tickDrillable() {
    const pos = this.pos, label = this.label, axis = this.axis, isDrillable = axis.coll === "xAxis" && axis.getDDPoints, ddPointsX = isDrillable && axis.getDDPoints(pos), styledMode = axis.chart.styledMode;
    if (isDrillable) {
      if (label && ddPointsX && ddPointsX.length) {
        label.drillable = true;
        if (!label.basicStyles && !styledMode) {
          label.basicStyles = merge83(label.styles);
        }
        label.addClass("highcharts-drilldown-axis-label");
        if (label.removeOnDrillableClick) {
          removeEvent11(label.element, "click");
        }
        label.removeOnDrillableClick = addEvent78(label.element, "click", function(e) {
          e.preventDefault();
          axis.drilldownCategory(pos, e);
        });
        if (!styledMode && axis.chart.options.drilldown) {
          label.css(axis.chart.options.drilldown.activeAxisLabelStyle || {});
        }
      } else if (label && label.drillable && label.removeOnDrillableClick) {
        if (!styledMode) {
          label.styles = {};
          label.element.removeAttribute("style");
          label.css(label.basicStyles);
        }
        label.removeOnDrillableClick();
        label.removeClass("highcharts-drilldown-axis-label");
      }
    }
  }
})(Drilldown || (Drilldown = {}));
var Drilldown_default = Drilldown;

// node_modules/highcharts/es-modules/masters/modules/drilldown.src.js
var G11 = Globals_default;
G11.Breadcrumbs = G11.Breadcrumbs || Breadcrumbs_default;
Drilldown_default.compose(G11.Axis, G11.Chart, G11.defaultOptions, G11.Series, G11.seriesTypes, G11.SVGRenderer, G11.Tick);

// node_modules/highcharts/es-modules/Extensions/Exporting/ExportingDefaults.js
var { isTouchDevice: isTouchDevice7 } = Globals_default;
var exporting = {
  /**
   * Experimental setting to allow HTML inside the chart (added through
   * the `useHTML` options), directly in the exported image. This allows
   * you to preserve complicated HTML structures like tables or bi-directional
   * text in exported charts.
   *
   * Disclaimer: The HTML is rendered in a `foreignObject` tag in the
   * generated SVG. The official export server is based on PhantomJS,
   * which supports this, but other SVG clients, like Batik, does not
   * support it. This also applies to downloaded SVG that you want to
   * open in a desktop client.
   *
   * @type      {boolean}
   * @default   false
   * @since     4.1.8
   * @apioption exporting.allowHTML
   */
  /**
   * Allows the end user to sort the data table by clicking on column headers.
   *
   * @since 10.3.3
   * @apioption exporting.allowTableSorting
   */
  allowTableSorting: true,
  /**
   * Allow exporting a chart retaining any user-applied CSS.
   *
   * Note that this is is default behavior in [styledMode](#chart.styledMode).
   *
   * @see [styledMode](#chart.styledMode)
   *
   * @sample {highcharts} highcharts/exporting/apply-stylesheets/
   *
   * @type      {boolean}
   * @default   false
   * @since 12.0.0
   * @apioption exporting.applyStyleSheets
   */
  /**
   * Additional chart options to be merged into the chart before exporting to
   * an image format. This does not apply to printing the chart via the export
   * menu.
   *
   * For example, a common use case is to add data labels to improve
   * readability of the exported chart, or to add a printer-friendly color
   * scheme to exported PDFs.
   *
   * @sample {highcharts} highcharts/exporting/chartoptions-data-labels/
   *         Added data labels
   * @sample {highstock} highcharts/exporting/chartoptions-data-labels/
   *         Added data labels
   *
   * @type      {Highcharts.Options}
   * @apioption exporting.chartOptions
   */
  /**
   * Whether to enable the exporting module. Disabling the module will
   * hide the context button, but API methods will still be available.
   *
   * @sample {highcharts} highcharts/exporting/enabled-false/
   *         Exporting module is loaded but disabled
   * @sample {highstock} highcharts/exporting/enabled-false/
   *         Exporting module is loaded but disabled
   *
   * @type      {boolean}
   * @default   true
   * @since     2.0
   * @apioption exporting.enabled
   */
  /**
   * Function to call if the offline-exporting module fails to export
   * a chart on the client side, and [fallbackToExportServer](
   * #exporting.fallbackToExportServer) is disabled. If left undefined, an
   * exception is thrown instead. Receives two parameters, the exporting
   * options, and the error from the module.
   *
   * @see [fallbackToExportServer](#exporting.fallbackToExportServer)
   *
   * @type      {Highcharts.ExportingErrorCallbackFunction}
   * @since     5.0.0
   * @requires  modules/exporting
   * @requires  modules/offline-exporting
   * @apioption exporting.error
   */
  /**
   * Whether or not to fall back to the export server if the offline-exporting
   * module is unable to export the chart on the client side. This happens for
   * certain browsers, and certain features (e.g.
   * [allowHTML](#exporting.allowHTML)), depending on the image type exporting
   * to. For very complex charts, it is possible that export can fail in
   * browsers that don't support Blob objects, due to data URL length limits.
   * It is recommended to define the [exporting.error](#exporting.error)
   * handler if disabling fallback, in order to notify users in case export
   * fails.
   *
   * @type      {boolean}
   * @default   true
   * @since     4.1.8
   * @requires  modules/exporting
   * @requires  modules/offline-exporting
   * @apioption exporting.fallbackToExportServer
   */
  /**
   * The filename, without extension, to use for the exported chart.
   *
   * @sample {highcharts} highcharts/exporting/filename/
   *         Custom file name
   * @sample {highstock} highcharts/exporting/filename/
   *         Custom file name
   *
   * @type      {string}
   * @default   chart
   * @since     2.0
   * @apioption exporting.filename
   */
  /**
   * Highcharts v11.2.0 and older. An object containing additional key value
   * data for the POST form that sends the SVG to the export server. For
   * example, a `target` can be set to make sure the generated image is
   * received in another frame, or a custom `enctype` or `encoding` can be
   * set.
   *
   * With Highcharts v11.3.0, the `fetch` API replaced the old HTML form. To
   * modify the request, now use [fetchOptions](#exporting.fetchOptions)
   * instead.
   *
   * @deprecated
   * @type      {Highcharts.HTMLAttributes}
   * @since     3.0.8
   * @apioption exporting.formAttributes
   */
  /**
   * Options for the fetch request used when sending the SVG to the export
   * server.
   *
   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/fetch)
   * for more information
   *
   * @type {Object}
   * @since 11.3.0
   * @apioption exporting.fetchOptions
   */
  /**
   * Path where Highcharts will look for export module dependencies to
   * load on demand if they don't already exist on `window`. Should currently
   * point to location of [CanVG](https://github.com/canvg/canvg) library,
   * [jsPDF](https://github.com/parallax/jsPDF) and
   * [svg2pdf.js](https://github.com/yWorks/svg2pdf.js), required for client
   * side export in certain browsers.
   *
   * @type      {string}
   * @default   https://code.highcharts.com/{version}/lib
   * @since     5.0.0
   * @apioption exporting.libURL
   */
  /**
   * Analogous to [sourceWidth](#exporting.sourceWidth).
   *
   * @type      {number}
   * @since     3.0
   * @apioption exporting.sourceHeight
   */
  /**
   * The width of the original chart when exported, unless an explicit
   * [chart.width](#chart.width) is set, or a pixel width is set on the
   * container. The width exported raster image is then multiplied by
   * [scale](#exporting.scale).
   *
   * @sample {highcharts} highcharts/exporting/sourcewidth/
   *         Source size demo
   * @sample {highstock} highcharts/exporting/sourcewidth/
   *         Source size demo
   * @sample {highmaps} maps/exporting/sourcewidth/
   *         Source size demo
   *
   * @type      {number}
   * @since     3.0
   * @apioption exporting.sourceWidth
   */
  /**
   * The pixel width of charts exported to PNG or JPG. As of Highcharts
   * 3.0, the default pixel width is a function of the [chart.width](
   * #chart.width) or [exporting.sourceWidth](#exporting.sourceWidth) and the
   * [exporting.scale](#exporting.scale).
   *
   * @sample {highcharts} highcharts/exporting/width/
   *         Export to 200px wide images
   * @sample {highstock} highcharts/exporting/width/
   *         Export to 200px wide images
   *
   * @type      {number}
   * @since     2.0
   * @apioption exporting.width
   */
  /**
   * Default MIME type for exporting if `chart.exportChart()` is called
   * without specifying a `type` option. Possible values are `image/png`,
   *  `image/jpeg`, `application/pdf` and `image/svg+xml`.
   *
   * @type  {Highcharts.ExportingMimeTypeValue}
   * @since 2.0
   */
  type: "image/png",
  /**
   * The URL for the server module converting the SVG string to an image
   * format. By default this points to Highchart's free web service.
   *
   * @since 2.0
   */
  url: `https://export-svg.highcharts.com?v=${Globals_default.version}`,
  /**
   * Settings for a custom font for the exported PDF, when using the
   * `offline-exporting` module. This is used for languages containing
   * non-ASCII characters, like Chinese, Russian, Japanese etc.
   *
   * As described in the [jsPDF
   * docs](https://github.com/parallax/jsPDF#use-of-unicode-characters--utf-8),
   * the 14 standard fonts in PDF are limited to the ASCII-codepage.
   * Therefore, in order to support other text in the exported PDF, one or
   * more TTF font files have to be passed on to the exporting module.
   *
   * See more in [the
   * docs](https://www.highcharts.com/docs/export-module/client-side-export).
   *
   * @sample {highcharts} highcharts/exporting/offline-download-pdffont/
   *         Download PDF in a language containing non-Latin characters.
   *
   * @since 10.0.0
   * @requires modules/offline-exporting
   */
  pdfFont: {
    /**
     * The TTF font file for normal `font-style`. If font variations like
     * `bold` or `italic` are not defined, the `normal` font will be used
     * for those too.
     *
     * @type string|undefined
     */
    normal: void 0,
    /**
     * The TTF font file for bold text.
     *
     * @type string|undefined
     */
    bold: void 0,
    /**
     * The TTF font file for bold and italic text.
     *
     * @type string|undefined
     */
    bolditalic: void 0,
    /**
     * The TTF font file for italic text.
     *
     * @type string|undefined
     */
    italic: void 0
  },
  /**
   * When printing the chart from the menu item in the burger menu, if
   * the on-screen chart exceeds this width, it is resized. After printing
   * or cancelled, it is restored. The default width makes the chart
   * fit into typical paper format. Note that this does not affect the
   * chart when printing the web page as a whole.
   *
   * @since 4.2.5
   */
  printMaxWidth: 780,
  /**
   * Defines the scale or zoom factor for the exported image compared
   * to the on-screen display. While for instance a 600px wide chart
   * may look good on a website, it will look bad in print. The default
   * scale of 2 makes this chart export to a 1200px PNG or JPG.
   *
   * @see [chart.width](#chart.width)
   * @see [exporting.sourceWidth](#exporting.sourceWidth)
   *
   * @sample {highcharts} highcharts/exporting/scale/
   *         Scale demonstrated
   * @sample {highstock} highcharts/exporting/scale/
   *         Scale demonstrated
   * @sample {highmaps} maps/exporting/scale/
   *         Scale demonstrated
   *
   * @since 3.0
   */
  scale: 2,
  /**
   * Options for the export related buttons, print and export. In addition
   * to the default buttons listed here, custom buttons can be added.
   * See [navigation.buttonOptions](#navigation.buttonOptions) for general
   * options.
   *
   * @type     {Highcharts.Dictionary<*>}
   * @requires modules/exporting
   */
  buttons: {
    /**
     * Options for the export button.
     *
     * In styled mode, export button styles can be applied with the
     * `.highcharts-contextbutton` class.
     *
     * @declare  Highcharts.ExportingButtonsOptionsObject
     * @extends  navigation.buttonOptions
     * @requires modules/exporting
     */
    contextButton: {
      /**
       * A click handler callback to use on the button directly instead of
       * the popup menu.
       *
       * @sample highcharts/exporting/buttons-contextbutton-onclick/
       *         Skip the menu and export the chart directly
       *
       * @type      {Function}
       * @since     2.0
       * @apioption exporting.buttons.contextButton.onclick
       */
      /**
       * See [navigation.buttonOptions.symbolFill](
       * #navigation.buttonOptions.symbolFill).
       *
       * @type      {Highcharts.ColorString}
       * @default   #666666
       * @since     2.0
       * @apioption exporting.buttons.contextButton.symbolFill
       */
      /**
       * The horizontal position of the button relative to the `align`
       * option.
       *
       * @type      {number}
       * @default   -10
       * @since     2.0
       * @apioption exporting.buttons.contextButton.x
       */
      /**
       * The class name of the context button.
       */
      className: "highcharts-contextbutton",
      /**
       * The class name of the menu appearing from the button.
       */
      menuClassName: "highcharts-contextmenu",
      /**
       * The symbol for the button. Points to a definition function in
       * the `Highcharts.Renderer.symbols` collection. The default
       * `menu` function is part of the exporting module. Possible
       * values are "circle", "square", "diamond", "triangle",
       * "triangle-down", "menu", "menuball" or custom shape.
       *
       * @sample highcharts/exporting/buttons-contextbutton-symbol/
       *         Use a circle for symbol
       * @sample highcharts/exporting/buttons-contextbutton-symbol-custom/
       *         Custom shape as symbol
       *
       * @type  {Highcharts.SymbolKeyValue|"menu"|"menuball"|string}
       * @since 2.0
       */
      symbol: "menu",
      /**
       * The key to a [lang](#lang) option setting that is used for the
       * button's title tooltip. When the key is `contextButtonTitle`, it
       * refers to [lang.contextButtonTitle](#lang.contextButtonTitle)
       * that defaults to "Chart context menu".
       *
       * @since 6.1.4
       */
      titleKey: "contextButtonTitle",
      /**
       * A collection of strings pointing to config options for the menu
       * items. The config options are defined in the
       * `menuItemDefinitions` option.
       *
       * By default, there is the "View in full screen" and "Print" menu
       * items, plus one menu item for each of the available export types.
       *
       * @sample {highcharts} highcharts/exporting/menuitemdefinitions/
       *         Menu item definitions
       * @sample {highstock} highcharts/exporting/menuitemdefinitions/
       *         Menu item definitions
       * @sample {highmaps} highcharts/exporting/menuitemdefinitions/
       *         Menu item definitions
       *
       * @type    {Array<string>}
       * @default ["viewFullscreen", "printChart", "separator", "downloadPNG", "downloadJPEG", "downloadSVG"]
       * @since   2.0
       */
      menuItems: [
        "viewFullscreen",
        "printChart",
        "separator",
        "downloadPNG",
        "downloadJPEG",
        "downloadSVG"
      ]
    }
  },
  /**
   * An object consisting of definitions for the menu items in the context
   * menu. Each key value pair has a `key` that is referenced in the
   * [menuItems](#exporting.buttons.contextButton.menuItems) setting,
   * and a `value`, which is an object with the following properties:
   *
   * - **onclick:** The click handler for the menu item
   *
   * - **text:** The text for the menu item
   *
   * - **textKey:** If internationalization is required, the key to a language
   *   string
   *
   * Custom text for the "exitFullScreen" can be set only in lang options
   * (it is not a separate button).
   *
   * @sample {highcharts} highcharts/exporting/menuitemdefinitions/
   *         Menu item definitions
   * @sample {highstock} highcharts/exporting/menuitemdefinitions/
   *         Menu item definitions
   * @sample {highmaps} highcharts/exporting/menuitemdefinitions/
   *         Menu item definitions
   *
   *
   * @type    {Highcharts.Dictionary<Highcharts.ExportingMenuObject>}
   * @default {"viewFullscreen": {}, "printChart": {}, "separator": {}, "downloadPNG": {}, "downloadJPEG": {}, "downloadPDF": {}, "downloadSVG": {}}
   * @since   5.0.13
   */
  menuItemDefinitions: {
    /**
     * @ignore
     */
    viewFullscreen: {
      textKey: "viewFullscreen",
      onclick: function() {
        if (this.fullscreen) {
          this.fullscreen.toggle();
        }
      }
    },
    /**
     * @ignore
     */
    printChart: {
      textKey: "printChart",
      onclick: function() {
        this.print();
      }
    },
    /**
     * @ignore
     */
    separator: {
      separator: true
    },
    /**
     * @ignore
     */
    downloadPNG: {
      textKey: "downloadPNG",
      onclick: function() {
        this.exportChart();
      }
    },
    /**
     * @ignore
     */
    downloadJPEG: {
      textKey: "downloadJPEG",
      onclick: function() {
        this.exportChart({
          type: "image/jpeg"
        });
      }
    },
    /**
     * @ignore
     */
    downloadPDF: {
      textKey: "downloadPDF",
      onclick: function() {
        this.exportChart({
          type: "application/pdf"
        });
      }
    },
    /**
     * @ignore
     */
    downloadSVG: {
      textKey: "downloadSVG",
      onclick: function() {
        this.exportChart({
          type: "image/svg+xml"
        });
      }
    }
  }
};
var lang4 = {
  /**
   * Exporting module only. The text for the menu item to view the chart
   * in full screen.
   *
   * @since 8.0.1
   */
  viewFullscreen: "View in full screen",
  /**
   * Exporting module only. The text for the menu item to exit the chart
   * from full screen.
   *
   * @since 8.0.1
   */
  exitFullscreen: "Exit from full screen",
  /**
   * Exporting module only. The text for the menu item to print the chart.
   *
   * @since    3.0.1
   * @requires modules/exporting
   */
  printChart: "Print chart",
  /**
   * Exporting module only. The text for the PNG download menu item.
   *
   * @since    2.0
   * @requires modules/exporting
   */
  downloadPNG: "Download PNG image",
  /**
   * Exporting module only. The text for the JPEG download menu item.
   *
   * @since    2.0
   * @requires modules/exporting
   */
  downloadJPEG: "Download JPEG image",
  /**
   * Exporting module only. The text for the PDF download menu item.
   *
   * @since    2.0
   * @requires modules/exporting
   */
  downloadPDF: "Download PDF document",
  /**
   * Exporting module only. The text for the SVG download menu item.
   *
   * @since    2.0
   * @requires modules/exporting
   */
  downloadSVG: "Download SVG vector image",
  /**
   * Exporting module menu. The tooltip title for the context menu holding
   * print and export menu items.
   *
   * @since    3.0
   * @requires modules/exporting
   */
  contextButtonTitle: "Chart context menu"
};
var navigation2 = {
  /**
   * A collection of options for buttons appearing in the exporting
   * module.
   *
   * In styled mode, the buttons are styled with the
   * `.highcharts-contextbutton` and `.highcharts-button-symbol` classes.
   *
   * @requires modules/exporting
   */
  buttonOptions: {
    /**
     * Whether to enable buttons.
     *
     * @sample highcharts/navigation/buttonoptions-enabled/
     *         Exporting module loaded but buttons disabled
     *
     * @type      {boolean}
     * @default   true
     * @since     2.0
     * @apioption navigation.buttonOptions.enabled
     */
    /**
     * The pixel size of the symbol on the button.
     *
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     *
     * @since 2.0
     */
    symbolSize: 14,
    /**
     * The x position of the center of the symbol inside the button.
     *
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     *
     * @since 2.0
     */
    symbolX: 14.5,
    /**
     * The y position of the center of the symbol inside the button.
     *
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     *
     * @since 2.0
     */
    symbolY: 13.5,
    /**
     * Alignment for the buttons.
     *
     * @sample highcharts/navigation/buttonoptions-align/
     *         Center aligned
     *
     * @type  {Highcharts.AlignValue}
     * @since 2.0
     */
    align: "right",
    /**
     * The pixel spacing between buttons, and between the context button and
     * the title.
     *
     * @sample highcharts/title/widthadjust
     *         Adjust the spacing when using text button
     * @since 2.0
     */
    buttonSpacing: 5,
    /**
     * Pixel height of the buttons.
     *
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     *
     * @since 2.0
     */
    height: 28,
    /**
     * A text string to add to the individual button.
     *
     * @sample highcharts/exporting/buttons-text/
     *         Full text button
     * @sample highcharts/exporting/buttons-text-usehtml/
     *         Icon using CSS font in text
     * @sample highcharts/exporting/buttons-text-symbol/
     *         Combined symbol and text
     *
     * @type      {string}
     * @default   null
     * @since     3.0
     * @apioption navigation.buttonOptions.text
     */
    /**
     * Whether to use HTML for rendering the button. HTML allows for things
     * like inline CSS or image-based icons.
     *
     * @sample highcharts/exporting/buttons-text-usehtml/
     *         Icon using CSS font in text
     *
     * @type      boolean
     * @default   false
     * @since 10.3.0
     * @apioption navigation.buttonOptions.useHTML
     */
    /**
     * The vertical offset of the button's position relative to its
     * `verticalAlign`. By default adjusted for the chart title alignment.
     *
     * @sample highcharts/navigation/buttonoptions-verticalalign/
     *         Buttons at lower right
     *
     * @since     2.0
     * @apioption navigation.buttonOptions.y
     */
    y: -5,
    /**
     * The vertical alignment of the buttons. Can be one of `"top"`,
     * `"middle"` or `"bottom"`.
     *
     * @sample highcharts/navigation/buttonoptions-verticalalign/
     *         Buttons at lower right
     *
     * @type  {Highcharts.VerticalAlignValue}
     * @since 2.0
     */
    verticalAlign: "top",
    /**
     * The pixel width of the button.
     *
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     *
     * @since 2.0
     */
    width: 28,
    /**
     * Fill color for the symbol within the button.
     *
     * @sample highcharts/navigation/buttonoptions-symbolfill/
     *         Blue symbol stroke for one of the buttons
     *
     * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @since 2.0
     */
    symbolFill: "#666666",
    /**
     * The color of the symbol's stroke or line.
     *
     * @sample highcharts/navigation/buttonoptions-symbolstroke/
     *         Blue symbol stroke
     *
     * @type  {Highcharts.ColorString}
     * @since 2.0
     */
    symbolStroke: "#666666",
    /**
     * The pixel stroke width of the symbol on the button.
     *
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     *
     * @since 2.0
     */
    symbolStrokeWidth: 3,
    /**
     * A configuration object for the button theme. The object accepts
     * SVG properties like `stroke-width`, `stroke` and `fill`.
     * Tri-state button styles are supported by the `states.hover` and
     * `states.select` objects.
     *
     * @sample highcharts/navigation/buttonoptions-theme/
     *         Theming the buttons
     *
     * @requires modules/exporting
     *
     * @since 3.0
     */
    theme: {
      /**
       * The default fill exists only to capture hover events.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      fill: "#ffffff",
      /**
       * Padding for the button.
       */
      padding: 5,
      /**
       * Default stroke for the buttons.
       *
       * @type      {Highcharts.ColorString}
       */
      stroke: "none",
      /**
       * Default stroke linecap for the buttons.
       */
      "stroke-linecap": "round"
    }
  },
  /**
   * CSS styles for the popup menu appearing by default when the export
   * icon is clicked. This menu is rendered in HTML.
   *
   * @see In styled mode, the menu is styled with the `.highcharts-menu`
   *      class.
   *
   * @sample highcharts/navigation/menustyle/
   *         Light gray menu background
   *
   * @type    {Highcharts.CSSObject}
   * @default {"background": "#ffffff", "borderRadius": "3px", "padding": "0.5em"}
   * @since   2.0
   */
  menuStyle: {
    /** @ignore-option */
    border: "none",
    /** @ignore-option */
    borderRadius: "3px",
    /** @ignore-option */
    background: "#ffffff",
    /** @ignore-option */
    padding: "0.5em"
  },
  /**
   * CSS styles for the individual items within the popup menu appearing
   * by default when the export icon is clicked. The menu items are
   * rendered in HTML. Font size defaults to `11px` on desktop and `14px`
   * on touch devices.
   *
   * @see In styled mode, the menu items are styled with the
   *      `.highcharts-menu-item` class.
   *
   * @sample {highcharts} highcharts/navigation/menuitemstyle/
   *         Add a grey stripe to the left
   *
   * @type    {Highcharts.CSSObject}
   * @default {"padding": "0.5em", "color": "#333333", "background": "none", "borderRadius": "3px", "fontSize": "0.8em", "transition": "background 250ms, color 250ms"}
   * @since   2.0
   */
  menuItemStyle: {
    /** @ignore-option */
    background: "none",
    /** @ignore-option */
    borderRadius: "3px",
    /** @ignore-option */
    color: "#333333",
    /** @ignore-option */
    padding: "0.5em",
    /** @ignore-option */
    fontSize: isTouchDevice7 ? "0.9em" : "0.8em",
    /** @ignore-option */
    transition: "background 250ms, color 250ms"
  },
  /**
   * CSS styles for the hover state of the individual items within the
   * popup menu appearing by default when the export icon is clicked. The
   * menu items are rendered in HTML.
   *
   * @see In styled mode, the menu items are styled with the
   *      `.highcharts-menu-item` class.
   *
   * @sample highcharts/navigation/menuitemhoverstyle/
   *         Bold text on hover
   *
   * @type    {Highcharts.CSSObject}
   * @default {"background": "#f2f2f2" }
   * @since   2.0
   */
  menuItemHoverStyle: {
    /** @ignore-option */
    background: "#f2f2f2"
    /* Palette.neutralColor5 */
  }
};
var ExportingDefaults = {
  exporting,
  lang: lang4,
  navigation: navigation2
};
var ExportingDefaults_default = ExportingDefaults;

// node_modules/highcharts/es-modules/Extensions/Exporting/ExportingSymbols.js
var ExportingSymbols;
(function(ExportingSymbols2) {
  const modifiedClasses = [];
  function compose27(SVGRendererClass) {
    if (modifiedClasses.indexOf(SVGRendererClass) === -1) {
      modifiedClasses.push(SVGRendererClass);
      const symbols3 = SVGRendererClass.prototype.symbols;
      symbols3.menu = menu;
      symbols3.menuball = menuball.bind(symbols3);
    }
  }
  ExportingSymbols2.compose = compose27;
  function menu(x, y, width, height) {
    const arr = [
      ["M", x, y + 2.5],
      ["L", x + width, y + 2.5],
      ["M", x, y + height / 2 + 0.5],
      ["L", x + width, y + height / 2 + 0.5],
      ["M", x, y + height - 1.5],
      ["L", x + width, y + height - 1.5]
    ];
    return arr;
  }
  function menuball(x, y, width, height) {
    const h = height / 3 - 2;
    let path = [];
    path = path.concat(this.circle(width - h, y, h, h), this.circle(width - h, y + h + 4, h, h), this.circle(width - h, y + 2 * (h + 4), h, h));
    return path;
  }
})(ExportingSymbols || (ExportingSymbols = {}));
var ExportingSymbols_default = ExportingSymbols;

// node_modules/highcharts/es-modules/Extensions/Exporting/Fullscreen.js
var { composed: composed31 } = Globals_default;
var { addEvent: addEvent79, fireEvent: fireEvent44, pushUnique: pushUnique34 } = Utilities_default;
function onChartBeforeRender3() {
  this.fullscreen = new Fullscreen(this);
}
var Fullscreen = class {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * Prepares the chart class to support fullscreen.
   *
   * @param {typeof_Highcharts.Chart} ChartClass
   * The chart class to decorate with fullscreen support.
   */
  static compose(ChartClass) {
    if (pushUnique34(composed31, "Fullscreen")) {
      addEvent79(ChartClass, "beforeRender", onChartBeforeRender3);
    }
  }
  /* *
   *
   *  Constructors
   *
   * */
  constructor(chart) {
    this.chart = chart;
    this.isOpen = false;
    const container = chart.renderTo;
    if (!this.browserProps) {
      if (typeof container.requestFullscreen === "function") {
        this.browserProps = {
          fullscreenChange: "fullscreenchange",
          requestFullscreen: "requestFullscreen",
          exitFullscreen: "exitFullscreen"
        };
      } else if (container.mozRequestFullScreen) {
        this.browserProps = {
          fullscreenChange: "mozfullscreenchange",
          requestFullscreen: "mozRequestFullScreen",
          exitFullscreen: "mozCancelFullScreen"
        };
      } else if (container.webkitRequestFullScreen) {
        this.browserProps = {
          fullscreenChange: "webkitfullscreenchange",
          requestFullscreen: "webkitRequestFullScreen",
          exitFullscreen: "webkitExitFullscreen"
        };
      } else if (container.msRequestFullscreen) {
        this.browserProps = {
          fullscreenChange: "MSFullscreenChange",
          requestFullscreen: "msRequestFullscreen",
          exitFullscreen: "msExitFullscreen"
        };
      }
    }
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Stops displaying the chart in fullscreen mode.
   * Exporting module required.
   *
   * @since       8.0.1
   *
   * @function    Highcharts.Fullscreen#close
   * @return      {void}
   * @requires    modules/full-screen
   */
  close() {
    const fullscreen = this, chart = fullscreen.chart, optionsChart = chart.options.chart;
    fireEvent44(chart, "fullscreenClose", null, function() {
      if (fullscreen.isOpen && fullscreen.browserProps && chart.container.ownerDocument instanceof Document) {
        chart.container.ownerDocument[fullscreen.browserProps.exitFullscreen]();
      }
      if (fullscreen.unbindFullscreenEvent) {
        fullscreen.unbindFullscreenEvent = fullscreen.unbindFullscreenEvent();
      }
      chart.setSize(fullscreen.origWidth, fullscreen.origHeight, false);
      fullscreen.origWidth = void 0;
      fullscreen.origHeight = void 0;
      optionsChart.width = fullscreen.origWidthOption;
      optionsChart.height = fullscreen.origHeightOption;
      fullscreen.origWidthOption = void 0;
      fullscreen.origHeightOption = void 0;
      fullscreen.isOpen = false;
      fullscreen.setButtonText();
    });
  }
  /**
   * Displays the chart in fullscreen mode.
   * When fired customly by user before exporting context button is created,
   * button's text will not be replaced - it's on the user side.
   * Exporting module required.
   *
   * @since       8.0.1
   *
   * @function Highcharts.Fullscreen#open
   * @return      {void}
   * @requires    modules/full-screen
   */
  open() {
    const fullscreen = this, chart = fullscreen.chart, optionsChart = chart.options.chart;
    fireEvent44(chart, "fullscreenOpen", null, function() {
      if (optionsChart) {
        fullscreen.origWidthOption = optionsChart.width;
        fullscreen.origHeightOption = optionsChart.height;
      }
      fullscreen.origWidth = chart.chartWidth;
      fullscreen.origHeight = chart.chartHeight;
      if (fullscreen.browserProps) {
        const unbindChange = addEvent79(
          chart.container.ownerDocument,
          // Chart's document
          fullscreen.browserProps.fullscreenChange,
          function() {
            if (fullscreen.isOpen) {
              fullscreen.isOpen = false;
              fullscreen.close();
            } else {
              chart.setSize(null, null, false);
              fullscreen.isOpen = true;
              fullscreen.setButtonText();
            }
          }
        );
        const unbindDestroy = addEvent79(chart, "destroy", unbindChange);
        fullscreen.unbindFullscreenEvent = () => {
          unbindChange();
          unbindDestroy();
        };
        const promise = chart.renderTo[fullscreen.browserProps.requestFullscreen]();
        if (promise) {
          promise["catch"](function() {
            alert(
              // eslint-disable-line no-alert
              "Full screen is not supported inside a frame."
            );
          });
        }
      }
    });
  }
  /**
   * Replaces the exporting context button's text when toogling the
   * fullscreen mode.
   *
   * @private
   *
   * @since 8.0.1
   *
   * @requires modules/full-screen
   */
  setButtonText() {
    const chart = this.chart, exportDivElements = chart.exportDivElements, exportingOptions = chart.options.exporting, menuItems = exportingOptions && exportingOptions.buttons && exportingOptions.buttons.contextButton.menuItems, lang6 = chart.options.lang;
    if (exportingOptions && exportingOptions.menuItemDefinitions && lang6 && lang6.exitFullscreen && lang6.viewFullscreen && menuItems && exportDivElements) {
      const exportDivElement = exportDivElements[menuItems.indexOf("viewFullscreen")];
      if (exportDivElement) {
        AST_default.setElementHTML(exportDivElement, !this.isOpen ? exportingOptions.menuItemDefinitions.viewFullscreen.text || lang6.viewFullscreen : lang6.exitFullscreen);
      }
    }
  }
  /**
   * Toggles displaying the chart in fullscreen mode.
   * By default, when the exporting module is enabled, a context button with
   * a drop down menu in the upper right corner accesses this function.
   * Exporting module required.
   *
   * @since 8.0.1
   *
   * @sample      highcharts/members/chart-togglefullscreen/
   *              Toggle fullscreen mode from a HTML button
   *
   * @function Highcharts.Fullscreen#toggle
   * @requires    modules/full-screen
   */
  toggle() {
    const fullscreen = this;
    if (!fullscreen.isOpen) {
      fullscreen.open();
    } else {
      fullscreen.close();
    }
  }
};
var Fullscreen_default = Fullscreen;

// node_modules/highcharts/es-modules/Extensions/Exporting/Exporting.js
var { defaultOptions: defaultOptions20 } = Defaults_default;
var { doc: doc27, SVG_NS: SVG_NS5, win: win18 } = Globals_default;
var { addEvent: addEvent80, css: css17, createElement: createElement15, discardElement: discardElement7, extend: extend71, find: find15, fireEvent: fireEvent45, isObject: isObject18, merge: merge84, objectEach: objectEach34, pick: pick92, removeEvent: removeEvent12, splat: splat18, uniqueKey: uniqueKey11 } = Utilities_default;
var Exporting;
(function(Exporting2) {
  const inlineDenylist = [
    /-/,
    // In Firefox, both hyphened and camelCased names are listed
    /^(clipPath|cssText|d|height|width)$/,
    // Full words
    /^font$/,
    // More specific props are set
    /[lL]ogical(Width|Height)$/,
    /^parentRule$/,
    /^(cssRules|ownerRules)$/,
    // #19516 read-only properties
    /perspective/,
    /TapHighlightColor/,
    /^transition/,
    /^length$/,
    // #7700
    /^\d+$/
    // #17538
  ];
  const inlineToAttributes = [
    "fill",
    "stroke",
    "strokeLinecap",
    "strokeLinejoin",
    "strokeWidth",
    "textAnchor",
    "x",
    "y"
  ];
  Exporting2.inlineAllowlist = [];
  const unstyledElements = [
    "clipPath",
    "defs",
    "desc"
  ];
  let printingChart;
  function addButton(options2) {
    const chart = this, renderer = chart.renderer, btnOptions = merge84(chart.options.navigation.buttonOptions, options2), onclick = btnOptions.onclick, menuItems = btnOptions.menuItems, symbolSize = btnOptions.symbolSize || 12;
    let symbol;
    if (!chart.btnCount) {
      chart.btnCount = 0;
    }
    if (!chart.exportDivElements) {
      chart.exportDivElements = [];
      chart.exportSVGElements = [];
    }
    if (btnOptions.enabled === false || !btnOptions.theme) {
      return;
    }
    const theme2 = chart.styledMode ? {} : btnOptions.theme;
    let callback;
    if (onclick) {
      callback = function(e) {
        if (e) {
          e.stopPropagation();
        }
        onclick.call(chart, e);
      };
    } else if (menuItems) {
      callback = function(e) {
        if (e) {
          e.stopPropagation();
        }
        chart.contextMenu(button.menuClassName, menuItems, button.translateX || 0, button.translateY || 0, button.width || 0, button.height || 0, button);
        button.setState(2);
      };
    }
    if (btnOptions.text && btnOptions.symbol) {
      theme2.paddingLeft = pick92(theme2.paddingLeft, 30);
    } else if (!btnOptions.text) {
      extend71(theme2, {
        width: btnOptions.width,
        height: btnOptions.height,
        padding: 0
      });
    }
    const button = renderer.button(btnOptions.text, 0, 0, callback, theme2, void 0, void 0, void 0, void 0, btnOptions.useHTML).addClass(options2.className).attr({
      title: pick92(chart.options.lang[btnOptions._titleKey || btnOptions.titleKey], "")
    });
    button.menuClassName = options2.menuClassName || "highcharts-menu-" + chart.btnCount++;
    if (btnOptions.symbol) {
      symbol = renderer.symbol(
        btnOptions.symbol,
        Math.round((btnOptions.symbolX || 0) - symbolSize / 2),
        Math.round((btnOptions.symbolY || 0) - symbolSize / 2),
        symbolSize,
        symbolSize,
        {
          width: symbolSize,
          height: symbolSize
        }
      ).addClass("highcharts-button-symbol").attr({
        zIndex: 1
      }).add(button);
      if (!chart.styledMode) {
        symbol.attr({
          stroke: btnOptions.symbolStroke,
          fill: btnOptions.symbolFill,
          "stroke-width": btnOptions.symbolStrokeWidth || 1
        });
      }
    }
    button.add(chart.exportingGroup).align(extend71(btnOptions, {
      width: button.width,
      x: pick92(btnOptions.x, chart.buttonOffset)
      // #1654
    }), true, "spacingBox");
    chart.buttonOffset += ((button.width || 0) + btnOptions.buttonSpacing) * (btnOptions.align === "right" ? -1 : 1);
    chart.exportSVGElements.push(button, symbol);
  }
  function afterPrint() {
    const chart = this;
    if (!chart.printReverseInfo) {
      return void 0;
    }
    const { childNodes, origDisplay, resetParams } = chart.printReverseInfo;
    chart.moveContainers(chart.renderTo);
    [].forEach.call(childNodes, function(node, i) {
      if (node.nodeType === 1) {
        node.style.display = origDisplay[i] || "";
      }
    });
    chart.isPrinting = false;
    if (resetParams) {
      chart.setSize.apply(chart, resetParams);
    }
    delete chart.printReverseInfo;
    printingChart = void 0;
    fireEvent45(chart, "afterPrint");
  }
  function beforePrint() {
    const chart = this, body = doc27.body, printMaxWidth = chart.options.exporting.printMaxWidth, printReverseInfo = {
      childNodes: body.childNodes,
      origDisplay: [],
      resetParams: void 0
    };
    chart.isPrinting = true;
    chart.pointer?.reset(void 0, 0);
    fireEvent45(chart, "beforePrint");
    const handleMaxWidth = printMaxWidth && chart.chartWidth > printMaxWidth;
    if (handleMaxWidth) {
      printReverseInfo.resetParams = [
        chart.options.chart.width,
        void 0,
        false
      ];
      chart.setSize(printMaxWidth, void 0, false);
    }
    [].forEach.call(printReverseInfo.childNodes, function(node, i) {
      if (node.nodeType === 1) {
        printReverseInfo.origDisplay[i] = node.style.display;
        node.style.display = "none";
      }
    });
    chart.moveContainers(body);
    chart.printReverseInfo = printReverseInfo;
  }
  function chartCallback2(chart) {
    const composition = chart;
    composition.renderExporting();
    addEvent80(chart, "redraw", composition.renderExporting);
    addEvent80(chart, "destroy", composition.destroyExport);
  }
  function compose27(ChartClass, SVGRendererClass) {
    ExportingSymbols_default.compose(SVGRendererClass);
    Fullscreen_default.compose(ChartClass);
    const chartProto = ChartClass.prototype;
    if (!chartProto.exportChart) {
      chartProto.afterPrint = afterPrint;
      chartProto.exportChart = exportChart;
      chartProto.inlineStyles = inlineStyles;
      chartProto.print = print;
      chartProto.sanitizeSVG = sanitizeSVG;
      chartProto.getChartHTML = getChartHTML;
      chartProto.getSVG = getSVG;
      chartProto.getSVGForExport = getSVGForExport;
      chartProto.getFilename = getFilename;
      chartProto.moveContainers = moveContainers;
      chartProto.beforePrint = beforePrint;
      chartProto.contextMenu = contextMenu;
      chartProto.addButton = addButton;
      chartProto.destroyExport = destroyExport;
      chartProto.renderExporting = renderExporting;
      chartProto.resolveCSSVariables = resolveCSSVariables;
      chartProto.callbacks.push(chartCallback2);
      addEvent80(ChartClass, "init", onChartInit);
      addEvent80(ChartClass, "layOutTitle", onChartLayOutTitle);
      if (Globals_default.isSafari) {
        win18.matchMedia("print").addListener(function(mqlEvent) {
          if (!printingChart) {
            return void 0;
          }
          if (mqlEvent.matches) {
            printingChart.beforePrint();
          } else {
            printingChart.afterPrint();
          }
        });
      }
      defaultOptions20.exporting = merge84(ExportingDefaults_default.exporting, defaultOptions20.exporting);
      defaultOptions20.lang = merge84(ExportingDefaults_default.lang, defaultOptions20.lang);
      defaultOptions20.navigation = merge84(ExportingDefaults_default.navigation, defaultOptions20.navigation);
    }
  }
  Exporting2.compose = compose27;
  function contextMenu(className, items, x, y, width, height, button) {
    const chart = this, navOptions = chart.options.navigation, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, cacheName = "cache-" + className, menuPadding = Math.max(width, height);
    let innerMenu, menu = chart[cacheName];
    if (!menu) {
      chart.exportContextMenu = chart[cacheName] = menu = createElement15("div", {
        className
      }, {
        position: "absolute",
        zIndex: 1e3,
        padding: menuPadding + "px",
        pointerEvents: "auto",
        ...chart.renderer.style
      }, chart.scrollablePlotArea?.fixedDiv || chart.container);
      innerMenu = createElement15("ul", { className: "highcharts-menu" }, chart.styledMode ? {} : {
        listStyle: "none",
        margin: 0,
        padding: 0
      }, menu);
      if (!chart.styledMode) {
        css17(innerMenu, extend71({
          MozBoxShadow: "3px 3px 10px #888",
          WebkitBoxShadow: "3px 3px 10px #888",
          boxShadow: "3px 3px 10px #888"
        }, navOptions.menuStyle));
      }
      menu.hideMenu = function() {
        css17(menu, { display: "none" });
        if (button) {
          button.setState(0);
        }
        chart.openMenu = false;
        css17(chart.renderTo, { overflow: "hidden" });
        css17(chart.container, { overflow: "hidden" });
        Utilities_default.clearTimeout(menu.hideTimer);
        fireEvent45(chart, "exportMenuHidden");
      };
      chart.exportEvents.push(
        addEvent80(menu, "mouseleave", function() {
          menu.hideTimer = win18.setTimeout(menu.hideMenu, 500);
        }),
        addEvent80(menu, "mouseenter", function() {
          Utilities_default.clearTimeout(menu.hideTimer);
        }),
        // Hide it on clicking or touching outside the menu (#2258,
        // #2335, #2407)
        addEvent80(doc27, "mouseup", function(e) {
          if (!chart.pointer?.inClass(e.target, className)) {
            menu.hideMenu();
          }
        }),
        addEvent80(menu, "click", function() {
          if (chart.openMenu) {
            menu.hideMenu();
          }
        })
      );
      items.forEach(function(item) {
        if (typeof item === "string") {
          item = chart.options.exporting.menuItemDefinitions[item];
        }
        if (isObject18(item, true)) {
          let element;
          if (item.separator) {
            element = createElement15("hr", void 0, void 0, innerMenu);
          } else {
            if (item.textKey === "viewData" && chart.isDataTableVisible) {
              item.textKey = "hideData";
            }
            element = createElement15("li", {
              className: "highcharts-menu-item",
              onclick: function(e) {
                if (e) {
                  e.stopPropagation();
                }
                menu.hideMenu();
                if (typeof item !== "string" && item.onclick) {
                  item.onclick.apply(chart, arguments);
                }
              }
            }, void 0, innerMenu);
            AST_default.setElementHTML(element, item.text || chart.options.lang[item.textKey]);
            if (!chart.styledMode) {
              element.onmouseover = function() {
                css17(this, navOptions.menuItemHoverStyle);
              };
              element.onmouseout = function() {
                css17(this, navOptions.menuItemStyle);
              };
              css17(element, extend71({
                cursor: "pointer"
              }, navOptions.menuItemStyle || {}));
            }
          }
          chart.exportDivElements.push(element);
        }
      });
      chart.exportDivElements.push(innerMenu, menu);
      chart.exportMenuWidth = menu.offsetWidth;
      chart.exportMenuHeight = menu.offsetHeight;
    }
    const menuStyle = { display: "block" };
    if (x + (chart.exportMenuWidth || 0) > chartWidth) {
      menuStyle.right = chartWidth - x - width - menuPadding + "px";
    } else {
      menuStyle.left = x - menuPadding + "px";
    }
    if (y + height + (chart.exportMenuHeight || 0) > chartHeight && button.alignOptions?.verticalAlign !== "top") {
      menuStyle.bottom = chartHeight - y - menuPadding + "px";
    } else {
      menuStyle.top = y + height - menuPadding + "px";
    }
    css17(menu, menuStyle);
    css17(chart.renderTo, { overflow: "" });
    css17(chart.container, { overflow: "" });
    chart.openMenu = true;
    fireEvent45(chart, "exportMenuShown");
  }
  function destroyExport(e) {
    const chart = e ? e.target : this, exportSVGElements = chart.exportSVGElements, exportDivElements = chart.exportDivElements, exportEvents = chart.exportEvents;
    let cacheName;
    if (exportSVGElements) {
      exportSVGElements.forEach((elem, i) => {
        if (elem) {
          elem.onclick = elem.ontouchstart = null;
          cacheName = "cache-" + elem.menuClassName;
          if (chart[cacheName]) {
            delete chart[cacheName];
          }
          exportSVGElements[i] = elem.destroy();
        }
      });
      exportSVGElements.length = 0;
    }
    if (chart.exportingGroup) {
      chart.exportingGroup.destroy();
      delete chart.exportingGroup;
    }
    if (exportDivElements) {
      exportDivElements.forEach(function(elem, i) {
        if (elem) {
          Utilities_default.clearTimeout(elem.hideTimer);
          removeEvent12(elem, "mouseleave");
          exportDivElements[i] = elem.onmouseout = elem.onmouseover = elem.ontouchstart = elem.onclick = null;
          discardElement7(elem);
        }
      });
      exportDivElements.length = 0;
    }
    if (exportEvents) {
      exportEvents.forEach(function(unbind) {
        unbind();
      });
      exportEvents.length = 0;
    }
  }
  function exportChart(exportingOptions, chartOptions) {
    const svg4 = this.getSVGForExport(exportingOptions, chartOptions);
    exportingOptions = merge84(this.options.exporting, exportingOptions);
    HttpUtilities_default.post(exportingOptions.url, {
      filename: exportingOptions.filename ? exportingOptions.filename.replace(/\//g, "-") : this.getFilename(),
      type: exportingOptions.type,
      width: exportingOptions.width,
      scale: exportingOptions.scale,
      svg: svg4
    }, exportingOptions.fetchOptions);
  }
  function getChartHTML(applyStyleSheets) {
    if (applyStyleSheets) {
      this.inlineStyles();
    }
    this.resolveCSSVariables();
    return this.container.innerHTML;
  }
  function getFilename() {
    const s = this.userOptions.title && this.userOptions.title.text;
    let filename = this.options.exporting.filename;
    if (filename) {
      return filename.replace(/\//g, "-");
    }
    if (typeof s === "string") {
      filename = s.toLowerCase().replace(/<\/?[^>]+(>|$)/g, "").replace(/[\s_]+/g, "-").replace(/[^a-z\d\-]/g, "").replace(/^[\-]+/g, "").replace(/[\-]+/g, "-").substr(0, 24).replace(/[\-]+$/g, "");
    }
    if (!filename || filename.length < 5) {
      filename = "chart";
    }
    return filename;
  }
  function getSVG(chartOptions) {
    const chart = this;
    let svg4, seriesOptions, options2 = merge84(chart.options, chartOptions);
    options2.plotOptions = merge84(chart.userOptions.plotOptions, chartOptions && chartOptions.plotOptions);
    options2.time = merge84(chart.userOptions.time, chartOptions && chartOptions.time);
    const sandbox = createElement15("div", null, {
      position: "absolute",
      top: "-9999em",
      width: chart.chartWidth + "px",
      height: chart.chartHeight + "px"
    }, doc27.body);
    const cssWidth = chart.renderTo.style.width, cssHeight = chart.renderTo.style.height, sourceWidth = options2.exporting.sourceWidth || options2.chart.width || /px$/.test(cssWidth) && parseInt(cssWidth, 10) || (options2.isGantt ? 800 : 600), sourceHeight = options2.exporting.sourceHeight || options2.chart.height || /px$/.test(cssHeight) && parseInt(cssHeight, 10) || 400;
    extend71(options2.chart, {
      animation: false,
      renderTo: sandbox,
      forExport: true,
      renderer: "SVGRenderer",
      width: sourceWidth,
      height: sourceHeight
    });
    options2.exporting.enabled = false;
    delete options2.data;
    options2.series = [];
    chart.series.forEach(function(serie) {
      seriesOptions = merge84(serie.userOptions, {
        animation: false,
        // Turn off animation
        enableMouseTracking: false,
        showCheckbox: false,
        visible: serie.visible
      });
      if (!seriesOptions.isInternal) {
        options2.series.push(seriesOptions);
      }
    });
    const colls = {};
    chart.axes.forEach(function(axis) {
      if (!axis.userOptions.internalKey) {
        axis.userOptions.internalKey = uniqueKey11();
      }
      if (!axis.options.isInternal) {
        if (!colls[axis.coll]) {
          colls[axis.coll] = true;
          options2[axis.coll] = [];
        }
        options2[axis.coll].push(merge84(axis.userOptions, {
          visible: axis.visible,
          // Force some options that could have be set directly on
          // the axis while missing in the userOptions or options.
          type: axis.type,
          uniqueNames: axis.uniqueNames
        }));
      }
    });
    options2.colorAxis = chart.userOptions.colorAxis;
    const chartCopy = new chart.constructor(options2, chart.callback);
    if (chartOptions) {
      ["xAxis", "yAxis", "series"].forEach(function(coll) {
        const collOptions = {};
        if (chartOptions[coll]) {
          collOptions[coll] = chartOptions[coll];
          chartCopy.update(collOptions);
        }
      });
    }
    chart.axes.forEach(function(axis) {
      const axisCopy = find15(chartCopy.axes, (copy) => copy.options.internalKey === axis.userOptions.internalKey);
      if (axisCopy) {
        const extremes = axis.getExtremes(), exportOverride = splat18(chartOptions?.[axis.coll] || {})[0], userMin = "min" in exportOverride ? exportOverride.min : extremes.userMin, userMax = "max" in exportOverride ? exportOverride.max : extremes.userMax;
        if (typeof userMin !== "undefined" && userMin !== axisCopy.min || typeof userMax !== "undefined" && userMax !== axisCopy.max) {
          axisCopy.setExtremes(userMin ?? void 0, userMax ?? void 0, true, false);
        }
      }
    });
    svg4 = chartCopy.getChartHTML(chart.styledMode || options2.exporting?.applyStyleSheets);
    fireEvent45(this, "getSVG", { chartCopy });
    svg4 = chart.sanitizeSVG(svg4, options2);
    options2 = null;
    chartCopy.destroy();
    discardElement7(sandbox);
    return svg4;
  }
  function getSVGForExport(options2, chartOptions) {
    const chartExportingOptions = this.options.exporting;
    return this.getSVG(merge84({ chart: { borderRadius: 0 } }, chartExportingOptions.chartOptions, chartOptions, {
      exporting: {
        sourceWidth: options2 && options2.sourceWidth || chartExportingOptions.sourceWidth,
        sourceHeight: options2 && options2.sourceHeight || chartExportingOptions.sourceHeight
      }
    }));
  }
  function hyphenate(prop) {
    return prop.replace(/[A-Z]/g, function(match) {
      return "-" + match.toLowerCase();
    });
  }
  function inlineStyles() {
    const denylist = inlineDenylist, allowlist = Exporting2.inlineAllowlist, defaultStyles = {};
    let dummySVG;
    const iframe = doc27.createElement("iframe");
    css17(iframe, {
      width: "1px",
      height: "1px",
      visibility: "hidden"
    });
    doc27.body.appendChild(iframe);
    const iframeDoc = iframe.contentWindow && iframe.contentWindow.document;
    if (iframeDoc) {
      iframeDoc.body.appendChild(iframeDoc.createElementNS(SVG_NS5, "svg"));
    }
    function recurse(node) {
      const filteredStyles = {};
      let styles, parentStyles, dummy, denylisted, allowlisted, i;
      function filterStyles(val, prop) {
        denylisted = allowlisted = false;
        if (allowlist.length) {
          i = allowlist.length;
          while (i-- && !allowlisted) {
            allowlisted = allowlist[i].test(prop);
          }
          denylisted = !allowlisted;
        }
        if (prop === "transform" && val === "none") {
          denylisted = true;
        }
        i = denylist.length;
        while (i-- && !denylisted) {
          if (prop.length > 1e3) {
            throw new Error("Input too long");
          }
          denylisted = denylist[i].test(prop) || typeof val === "function";
        }
        if (!denylisted) {
          if ((parentStyles[prop] !== val || node.nodeName === "svg") && defaultStyles[node.nodeName][prop] !== val) {
            if (!inlineToAttributes || inlineToAttributes.indexOf(prop) !== -1) {
              if (val) {
                node.setAttribute(hyphenate(prop), val);
              }
            } else {
              filteredStyles[prop] = val;
            }
          }
        }
      }
      if (iframeDoc && node.nodeType === 1 && unstyledElements.indexOf(node.nodeName) === -1) {
        styles = win18.getComputedStyle(node, null);
        parentStyles = node.nodeName === "svg" ? {} : win18.getComputedStyle(node.parentNode, null);
        if (!defaultStyles[node.nodeName]) {
          dummySVG = iframeDoc.getElementsByTagName("svg")[0];
          dummy = iframeDoc.createElementNS(node.namespaceURI, node.nodeName);
          dummySVG.appendChild(dummy);
          const s = win18.getComputedStyle(dummy, null), defaults = {};
          for (const key in s) {
            if (key.length < 1e3 && typeof s[key] === "string" && !/^\d+$/.test(key)) {
              defaults[key] = s[key];
            }
          }
          defaultStyles[node.nodeName] = defaults;
          if (node.nodeName === "text") {
            delete defaultStyles.text.fill;
          }
          dummySVG.removeChild(dummy);
        }
        for (const p in styles) {
          if (
            // Some browsers put lots of styles on the prototype...
            Globals_default.isFirefox || Globals_default.isMS || Globals_default.isSafari || // #16902
            // ... Chrome puts them on the instance
            Object.hasOwnProperty.call(styles, p)
          ) {
            filterStyles(styles[p], p);
          }
        }
        css17(node, filteredStyles);
        if (node.nodeName === "svg") {
          node.setAttribute("stroke-width", "1px");
        }
        if (node.nodeName === "text") {
          return;
        }
        [].forEach.call(node.children || node.childNodes, recurse);
      }
    }
    function tearDown() {
      dummySVG.parentNode.removeChild(dummySVG);
      iframe.parentNode.removeChild(iframe);
    }
    recurse(this.container.querySelector("svg"));
    tearDown();
  }
  function resolveCSSVariables() {
    const svgElements = this.container.querySelectorAll("*"), colorAttributes = ["color", "fill", "stop-color", "stroke"];
    Array.from(svgElements).forEach((element) => {
      colorAttributes.forEach((attr18) => {
        const attrValue = element.getAttribute(attr18);
        if (attrValue?.includes("var(")) {
          element.setAttribute(attr18, getComputedStyle(element).getPropertyValue(attr18));
        }
      });
    });
  }
  function moveContainers(moveTo) {
    const { scrollablePlotArea } = this;
    // When scrollablePlotArea is active (#9533)
    (scrollablePlotArea ? [
      scrollablePlotArea.fixedDiv,
      scrollablePlotArea.scrollingContainer
    ] : [this.container]).forEach(function(div) {
      moveTo.appendChild(div);
    });
  }
  function onChartInit() {
    const chart = this, update = (prop, options2, redraw) => {
      chart.isDirtyExporting = true;
      merge84(true, chart.options[prop], options2);
      if (pick92(redraw, true)) {
        chart.redraw();
      }
    };
    chart.exporting = {
      update: function(options2, redraw) {
        update("exporting", options2, redraw);
      }
    };
    ChartNavigationComposition_default.compose(chart).navigation.addUpdate((options2, redraw) => {
      update("navigation", options2, redraw);
    });
  }
  function onChartLayOutTitle({ alignTo, key, textPxLength }) {
    const exportingOptions = this.options.exporting, { align, buttonSpacing = 0, verticalAlign, width = 0 } = merge84(this.options.navigation?.buttonOptions, exportingOptions?.buttons?.contextButton), space = alignTo.width - textPxLength, widthAdjust = width + buttonSpacing;
    if ((exportingOptions?.enabled ?? true) && key === "title" && align === "right" && verticalAlign === "top") {
      if (space < 2 * widthAdjust) {
        if (space < widthAdjust) {
          alignTo.width -= widthAdjust;
        } else if (this.title?.alignValue !== "left") {
          alignTo.x -= widthAdjust - space / 2;
        }
      }
    }
  }
  function print() {
    const chart = this;
    if (chart.isPrinting) {
      return;
    }
    printingChart = chart;
    if (!Globals_default.isSafari) {
      chart.beforePrint();
    }
    setTimeout(() => {
      win18.focus();
      win18.print();
      if (!Globals_default.isSafari) {
        setTimeout(() => {
          chart.afterPrint();
        }, 1e3);
      }
    }, 1);
  }
  function renderExporting() {
    const chart = this, exportingOptions = chart.options.exporting, buttons = exportingOptions.buttons, isDirty = chart.isDirtyExporting || !chart.exportSVGElements;
    chart.buttonOffset = 0;
    if (chart.isDirtyExporting) {
      chart.destroyExport();
    }
    if (isDirty && exportingOptions.enabled !== false) {
      chart.exportEvents = [];
      chart.exportingGroup = chart.exportingGroup || chart.renderer.g("exporting-group").attr({
        zIndex: 3
        // #4955, // #8392
      }).add();
      objectEach34(buttons, function(button) {
        chart.addButton(button);
      });
      chart.isDirtyExporting = false;
    }
  }
  function sanitizeSVG(svg4, options2) {
    const split = svg4.indexOf("</svg>") + 6, useForeignObject = svg4.indexOf("<foreignObject") > -1;
    let html2 = svg4.substr(split);
    svg4 = svg4.substr(0, split);
    if (useForeignObject) {
      svg4 = svg4.replace(/(<(?:img|br).*?(?=\>))>/g, "$1 />");
    } else if (html2 && options2?.exporting?.allowHTML) {
      html2 = '<foreignObject x="0" y="0" width="' + options2.chart.width + '" height="' + options2.chart.height + '"><body xmlns="http://www.w3.org/1999/xhtml">' + // Some tags needs to be closed in xhtml (#13726)
      html2.replace(/(<(?:img|br).*?(?=\>))>/g, "$1 />") + "</body></foreignObject>";
      svg4 = svg4.replace("</svg>", html2 + "</svg>");
    }
    svg4 = svg4.replace(/zIndex="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery\d+="[^"]+"/g, "").replace(/url\(("|&quot;)(.*?)("|&quot;)\;?\)/g, "url($2)").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (NS\d+\:)?href=/g, " xlink:href=").replace(/\n+/g, " ").replace(/&nbsp;/g, "").replace(/&shy;/g, "");
    return svg4;
  }
})(Exporting || (Exporting = {}));
var Exporting_default = Exporting;

// node_modules/highcharts/es-modules/masters/modules/exporting.src.js
var G12 = Globals_default;
G12.HttpUtilities = G12.HttpUtilities || HttpUtilities_default;
G12.ajax = G12.HttpUtilities.ajax;
G12.getJSON = G12.HttpUtilities.getJSON;
G12.post = G12.HttpUtilities.post;
Exporting_default.compose(G12.Chart, G12.Renderer);

// node_modules/highcharts/es-modules/Series/Funnel/FunnelSeriesDefaults.js
var FunnelSeriesDefaults = {
  /**
   * Initial animation is by default disabled for the funnel chart.
   */
  animation: false,
  /**
   * The corner radius of the border surrounding all points or series. A
   * number signifies pixels. A percentage string, like for example `50%`,
   * signifies a size relative to the series width.
   *
   * @sample highcharts/plotoptions/funnel-border-radius
   *         Funnel and pyramid with rounded border
   */
  borderRadius: 0,
  /**
   * The center of the series. By default, it is centered in the middle
   * of the plot area, so it fills the plot area height.
   *
   * @type    {Array<number|string>}
   * @default ["50%", "50%"]
   * @since   3.0
   */
  center: ["50%", "50%"],
  /**
   * The width of the funnel compared to the width of the plot area,
   * or the pixel width if it is a number.
   *
   * @type  {number|string}
   * @since 3.0
   */
  width: "90%",
  /**
   * The width of the neck, the lower part of the funnel. A number defines
   * pixel width, a percentage string defines a percentage of the plot
   * area width.
   *
   * @sample {highcharts} highcharts/demo/funnel/
   *         Funnel demo
   *
   * @type  {number|string}
   * @since 3.0
   */
  neckWidth: "30%",
  /**
   * The height of the funnel or pyramid. If it is a number it defines
   * the pixel height, if it is a percentage string it is the percentage
   * of the plot area height.
   *
   * @sample {highcharts} highcharts/demo/funnel/
   *         Funnel demo
   *
   * @type  {number|string}
   * @since 3.0
   */
  height: "100%",
  /**
   * The height of the neck, the lower part of the funnel. A number
   * defines pixel width, a percentage string defines a percentage of the
   * plot area height.
   *
   * @type {number|string}
   */
  neckHeight: "25%",
  /**
   * A reversed funnel has the widest area down. A reversed funnel with
   * no neck width and neck height is a pyramid.
   *
   * @since 3.0.10
   */
  reversed: false,
  /**
   * To avoid adapting the data label size in Pie.drawDataLabels.
   * @ignore-option
   */
  size: true,
  dataLabels: {
    connectorWidth: 1,
    verticalAlign: "middle"
  },
  /**
   * Options for the series states.
   */
  states: {
    /**
     * @excluding halo, marker, lineWidth, lineWidthPlus
     * @apioption plotOptions.funnel.states.hover
     */
    /**
     * Options for a selected funnel item.
     *
     * @excluding halo, marker, lineWidth, lineWidthPlus
     */
    select: {
      /**
       * A specific color for the selected point.
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      color: "#cccccc",
      /**
       * A specific border color for the selected point.
       *
       * @type {Highcharts.ColorString}
       */
      borderColor: "#000000"
      /* Palette.neutralColor100 */
    }
  }
};
var FunnelSeriesDefaults_default = FunnelSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Funnel/FunnelSeries.js
var { composed: composed32, noop: noop18 } = Globals_default;
var { column: ColumnSeries10, pie: PieSeries3 } = SeriesRegistry_default.seriesTypes;
var { addEvent: addEvent81, correctFloat: correctFloat15, extend: extend72, fireEvent: fireEvent46, isArray: isArray22, merge: merge85, pick: pick93, pushUnique: pushUnique35, relativeLength: relativeLength13, splat: splat19 } = Utilities_default;
var baseAlignDataLabel = SeriesRegistry_default.series.prototype.alignDataLabel;
function getLength(length, relativeTo) {
  return /%$/.test(length) ? relativeTo * parseInt(length, 10) / 100 : parseInt(length, 10);
}
var FunnelSeries = class extends PieSeries3 {
  /* *
   *
   *  Functions
   *
   * */
  /* eslint-disable valid-jsdoc */
  /**
   * @private
   */
  alignDataLabel(point, dataLabel, options2, alignTo, isNew) {
    const series = point.series, reversed = series.options.reversed, dlBox = point.dlBox || point.shapeArgs, { align, padding = 0, verticalAlign } = options2, inside = ((series.options || {}).dataLabels || {}).inside, centerY = series.center[1], plotY = point.plotY || 0, pointPlotY = reversed ? 2 * centerY - plotY : plotY, dataLabelHeight = dataLabel.height ?? dataLabel.getBBox().height, widthAtLabel = series.getWidthAt(pointPlotY - dlBox.height / 2 + dataLabelHeight), offset3 = verticalAlign === "middle" ? (dlBox.topWidth - dlBox.bottomWidth) / 4 : (widthAtLabel - dlBox.bottomWidth) / 2;
    let y = dlBox.y, x = dlBox.x;
    if (verticalAlign === "middle") {
      y = dlBox.y - dlBox.height / 2 + dataLabelHeight / 2;
    } else if (verticalAlign === "top") {
      y = dlBox.y - dlBox.height + dataLabelHeight + padding;
    }
    if (verticalAlign === "top" && !reversed || verticalAlign === "bottom" && reversed || verticalAlign === "middle") {
      if (align === "right") {
        x = dlBox.x - padding + offset3;
      } else if (align === "left") {
        x = dlBox.x + padding - offset3;
      }
    }
    alignTo = {
      x,
      y: reversed ? y - dlBox.height : y,
      width: dlBox.bottomWidth,
      height: dlBox.height
    };
    options2.verticalAlign = "bottom";
    if (inside) {
      options2.distance = void 0;
    }
    if (inside && point.visible) {
      baseAlignDataLabel.call(series, point, dataLabel, options2, alignTo, isNew);
    }
    if (inside) {
      if (!point.visible && point.dataLabel) {
        point.dataLabel.placed = false;
      }
      if (point.contrastColor) {
        dataLabel.css({
          color: point.contrastColor
        });
      }
    }
  }
  /**
   * Extend the data label method.
   * @private
   */
  drawDataLabels() {
    (splat19(this.options.dataLabels || {})[0].inside ? ColumnSeries10 : PieSeries3).prototype.drawDataLabels.call(this);
  }
  /** @private */
  getDataLabelPosition(point, distance) {
    const y = point.plotY || 0, sign = point.half ? 1 : -1, x = this.getX(y, !!point.half, point);
    return {
      distance,
      // Initial position of the data label - it's utilized for finding
      // the final position for the label
      natural: {
        x: 0,
        y
      },
      computed: {
        // Used for generating connector path - initialized later in
        // drawDataLabels function x: undefined, y: undefined
      },
      // Left - funnel on the left side of the data label
      // Right - funnel on the right side of the data label
      alignment: point.half ? "right" : "left",
      connectorPosition: {
        breakAt: {
          x: x + (distance - 5) * sign,
          y
        },
        touchingSliceAt: {
          x: x + distance * sign,
          y
        }
      }
    };
  }
  /**
   * Overrides the pie translate method.
   * @private
   */
  translate() {
    const series = this, chart = series.chart, options2 = series.options, reversed = options2.reversed, ignoreHiddenPoint = options2.ignoreHiddenPoint, borderRadiusObject = BorderRadius_default.optionsToObject(options2.borderRadius), plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, center = options2.center, centerX = getLength(center[0], plotWidth), centerY = getLength(center[1], plotHeight), width = getLength(options2.width, plotWidth), height = getLength(options2.height, plotHeight), neckWidth = getLength(options2.neckWidth, plotWidth), neckHeight = getLength(options2.neckHeight, plotHeight), neckY = centerY - height / 2 + height - neckHeight, points = series.points, borderRadius = relativeLength13(borderRadiusObject.radius, width), radiusScope = borderRadiusObject.scope, half = options2.dataLabels.position === "left" ? 1 : 0, roundingFactors = (angle) => {
      const tan = Math.tan(angle / 2), cosA = Math.cos(alpha), sinA = Math.sin(alpha);
      let r = borderRadius, t = r / tan, k = Math.tan((Math.PI - angle) / 3.2104);
      if (t > maxT) {
        t = maxT;
        r = t * tan;
      }
      k *= r;
      return {
        dx: [t * cosA, (t - k) * cosA, t - k, t],
        dy: [t * sinA, (t - k) * sinA, t - k, t].map((i) => reversed ? -i : i)
      };
    };
    let sum2 = 0, cumulative = 0, tempWidth, path, fraction, alpha, maxT, x1, y1, x2, x3, y3, x4, y5;
    series.getWidthAt = function(y) {
      const top = centerY - height / 2;
      return y > neckY || height === neckHeight ? neckWidth : neckWidth + (width - neckWidth) * (1 - (y - top) / (height - neckHeight));
    };
    series.getX = function(y, half2, point) {
      return centerX + (half2 ? -1 : 1) * (series.getWidthAt(reversed ? 2 * centerY - y : y) / 2 + (point.dataLabel?.dataLabelPosition?.distance ?? relativeLength13(this.options.dataLabels?.distance || 0, width)));
    };
    series.center = [centerX, centerY, height];
    series.centerX = centerX;
    for (const point of points) {
      if (point.y && point.isValid() && (!ignoreHiddenPoint || point.visible !== false)) {
        sum2 += point.y;
      }
    }
    for (const point of points) {
      y5 = null;
      fraction = sum2 ? point.y / sum2 : 0;
      y1 = centerY - height / 2 + cumulative * height;
      y3 = y1 + fraction * height;
      tempWidth = series.getWidthAt(y1);
      x1 = centerX - tempWidth / 2;
      x2 = x1 + tempWidth;
      tempWidth = series.getWidthAt(y3);
      x3 = centerX - tempWidth / 2;
      x4 = x3 + tempWidth;
      if (correctFloat15(y1) >= neckY) {
        x1 = x3 = centerX - neckWidth / 2;
        x2 = x4 = centerX + neckWidth / 2;
      } else if (y3 > neckY) {
        y5 = y3;
        tempWidth = series.getWidthAt(neckY);
        x3 = centerX - tempWidth / 2;
        x4 = x3 + tempWidth;
        y3 = neckY;
      }
      if (reversed) {
        y1 = 2 * centerY - y1;
        y3 = 2 * centerY - y3;
        if (y5 !== null) {
          y5 = 2 * centerY - y5;
        }
      }
      if (borderRadius && (radiusScope === "point" || point.index === 0 || point.index === points.length - 1 || y5 !== null)) {
        const h = Math.abs(y3 - y1), xSide = x2 - x4, lBase = x4 - x3, lSide = Math.sqrt(xSide * xSide + h * h);
        alpha = Math.atan(xSide !== 0 ? h / xSide : Infinity);
        maxT = lSide / 2;
        if (y5 !== null) {
          maxT = Math.min(maxT, Math.abs(y5 - y3) / 2);
        }
        if (lBase >= 1) {
          maxT = Math.min(maxT, lBase / 2);
        }
        let f = roundingFactors(alpha);
        if (radiusScope === "stack" && point.index !== 0) {
          path = [
            ["M", x1, y1],
            ["L", x2, y1]
          ];
        } else {
          path = [
            ["M", x1 + f.dx[0], y1 + f.dy[0]],
            [
              "C",
              x1 + f.dx[1],
              y1 + f.dy[1],
              x1 + f.dx[2],
              y1,
              x1 + f.dx[3],
              y1
            ],
            ["L", x2 - f.dx[3], y1],
            [
              "C",
              x2 - f.dx[2],
              y1,
              x2 - f.dx[1],
              y1 + f.dy[1],
              x2 - f.dx[0],
              y1 + f.dy[0]
            ]
          ];
        }
        if (y5 !== null) {
          const fr = roundingFactors(Math.PI / 2);
          f = roundingFactors(Math.PI / 2 + alpha);
          path.push(["L", x4 + f.dx[0], y3 - f.dy[0]], [
            "C",
            x4 + f.dx[1],
            y3 - f.dy[1],
            x4,
            y3 + f.dy[2],
            x4,
            y3 + f.dy[3]
          ]);
          if (radiusScope === "stack" && point.index !== points.length - 1) {
            path.push(["L", x4, y5], ["L", x3, y5]);
          } else {
            path.push(["L", x4, y5 - fr.dy[3]], [
              "C",
              x4,
              y5 - fr.dy[2],
              x4 - fr.dx[2],
              y5,
              x4 - fr.dx[3],
              y5
            ], ["L", x3 + fr.dx[3], y5], [
              "C",
              x3 + fr.dx[2],
              y5,
              x3,
              y5 - fr.dy[2],
              x3,
              y5 - fr.dy[3]
            ]);
          }
          path.push(["L", x3, y3 + f.dy[3]], [
            "C",
            x3,
            y3 + f.dy[2],
            x3 - f.dx[1],
            y3 - f.dy[1],
            x3 - f.dx[0],
            y3 - f.dy[0]
          ]);
        } else if (lBase >= 1) {
          f = roundingFactors(Math.PI - alpha);
          if (radiusScope === "stack" && point.index === 0) {
            path.push(["L", x4, y3], ["L", x3, y3]);
          } else {
            path.push(["L", x4 + f.dx[0], y3 - f.dy[0]], [
              "C",
              x4 + f.dx[1],
              y3 - f.dy[1],
              x4 - f.dx[2],
              y3,
              x4 - f.dx[3],
              y3
            ], ["L", x3 + f.dx[3], y3], [
              "C",
              x3 + f.dx[2],
              y3,
              x3 - f.dx[1],
              y3 - f.dy[1],
              x3 - f.dx[0],
              y3 - f.dy[0]
            ]);
          }
        } else {
          f = roundingFactors(Math.PI - alpha * 2);
          path.push(["L", x3 + f.dx[0], y3 - f.dy[0]], [
            "C",
            x3 + f.dx[1],
            y3 - f.dy[1],
            x3 - f.dx[1],
            y3 - f.dy[1],
            x3 - f.dx[0],
            y3 - f.dy[0]
          ]);
        }
      } else {
        path = [
          ["M", x1, y1],
          ["L", x2, y1],
          ["L", x4, y3]
        ];
        if (y5 !== null) {
          path.push(["L", x4, y5], ["L", x3, y5]);
        }
        path.push(["L", x3, y3]);
      }
      path.push(["Z"]);
      point.shapeType = "path";
      point.shapeArgs = { d: path };
      point.percentage = fraction * 100;
      point.plotX = centerX;
      point.plotY = (y1 + (y5 || y3)) / 2;
      point.tooltipPos = [
        centerX,
        point.plotY
      ];
      point.dlBox = {
        x: x3,
        y: y1,
        topWidth: x2 - x1,
        bottomWidth: x4 - x3,
        height: Math.abs(pick93(y5, y3) - y1),
        width: NaN
      };
      point.slice = noop18;
      point.half = half;
      if (point.isValid() && (!ignoreHiddenPoint || point.visible !== false)) {
        cumulative += fraction;
      }
    }
    fireEvent46(series, "afterTranslate");
  }
  /**
   * Funnel items don't have angles (#2289).
   * @private
   */
  sortByAngle(points) {
    points.sort((a, b) => a.plotY - b.plotY);
  }
};
FunnelSeries.defaultOptions = merge85(PieSeries3.defaultOptions, FunnelSeriesDefaults_default);
extend72(FunnelSeries.prototype, {
  animate: noop18
});
(function(FunnelSeries2) {
  function compose27(ChartClass) {
    if (pushUnique35(composed32, "FunnelSeries")) {
      addEvent81(ChartClass, "afterHideAllOverlappingLabels", onChartAfterHideAllOverlappingLabels);
    }
  }
  FunnelSeries2.compose = compose27;
  function onChartAfterHideAllOverlappingLabels() {
    for (const series of this.series) {
      let dataLabelsOptions = series.options && series.options.dataLabels;
      if (isArray22(dataLabelsOptions)) {
        dataLabelsOptions = dataLabelsOptions[0];
      }
      if (series.is("pie") && series.placeDataLabels && dataLabelsOptions && !dataLabelsOptions.inside) {
        series.placeDataLabels();
      }
    }
  }
})(FunnelSeries || (FunnelSeries = {}));
SeriesRegistry_default.registerSeriesType("funnel", FunnelSeries);
var FunnelSeries_default = FunnelSeries;

// node_modules/highcharts/es-modules/Series/Pyramid/PyramidSeriesDefaults.js
var PyramidSeriesDefaults = {
  /**
   * The pyramid neck height is zero by default, as opposed to the funnel,
   * which shares the same layout logic.
   *
   * @since 3.0.10
   */
  neckHeight: "0%",
  /**
   * The pyramid neck width is zero by default, as opposed to the funnel,
   * which shares the same layout logic.
   *
   * @since 3.0.10
   */
  neckWidth: "0%",
  /**
   * The pyramid is reversed by default, as opposed to the funnel, which
   * shares the layout engine, and is not reversed.
   *
   * @since 3.0.10
   */
  reversed: true
};
var PyramidSeriesDefaults_default = PyramidSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Pyramid/PyramidSeries.js
var { merge: merge86 } = Utilities_default;
var PyramidSeries = class extends FunnelSeries_default {
};
PyramidSeries.defaultOptions = merge86(FunnelSeries_default.defaultOptions, PyramidSeriesDefaults_default);
SeriesRegistry_default.registerSeriesType("pyramid", PyramidSeries);

// node_modules/highcharts/es-modules/masters/modules/funnel.src.js
var G13 = Globals_default;
FunnelSeries_default.compose(G13.Chart);

// node_modules/highcharts/es-modules/Core/Axis/Color/ColorAxisComposition.js
var { parse: color9 } = Color_default;
var { addEvent: addEvent82, extend: extend73, merge: merge87, pick: pick94, splat: splat20 } = Utilities_default;
var ColorAxisComposition;
(function(ColorAxisComposition2) {
  let ColorAxisConstructor;
  function compose27(ColorAxisClass, ChartClass, FxClass, LegendClass, SeriesClass) {
    const chartProto = ChartClass.prototype, fxProto = FxClass.prototype, seriesProto7 = SeriesClass.prototype;
    if (!chartProto.collectionsWithUpdate.includes("colorAxis")) {
      ColorAxisConstructor = ColorAxisClass;
      chartProto.collectionsWithUpdate.push("colorAxis");
      chartProto.collectionsWithInit.colorAxis = [
        chartProto.addColorAxis
      ];
      addEvent82(ChartClass, "afterCreateAxes", onChartAfterCreateAxes2);
      wrapChartCreateAxis(ChartClass);
      fxProto.fillSetter = wrapFxFillSetter;
      fxProto.strokeSetter = wrapFxStrokeSetter;
      addEvent82(LegendClass, "afterGetAllItems", onLegendAfterGetAllItems2);
      addEvent82(LegendClass, "afterColorizeItem", onLegendAfterColorizeItem);
      addEvent82(LegendClass, "afterUpdate", onLegendAfterUpdate);
      extend73(seriesProto7, {
        optionalAxis: "colorAxis",
        translateColors: seriesTranslateColors
      });
      extend73(seriesProto7.pointClass.prototype, {
        setVisible: pointSetVisible
      });
      addEvent82(SeriesClass, "afterTranslate", onSeriesAfterTranslate2, { order: 1 });
      addEvent82(SeriesClass, "bindAxes", onSeriesBindAxes);
    }
  }
  ColorAxisComposition2.compose = compose27;
  function onChartAfterCreateAxes2() {
    const { userOptions } = this;
    this.colorAxis = [];
    if (userOptions.colorAxis) {
      userOptions.colorAxis = splat20(userOptions.colorAxis);
      userOptions.colorAxis.map((axisOptions) => new ColorAxisConstructor(this, axisOptions));
    }
  }
  function onLegendAfterGetAllItems2(e) {
    const colorAxes = this.chart.colorAxis || [], destroyItem = (item) => {
      const i2 = e.allItems.indexOf(item);
      if (i2 !== -1) {
        this.destroyItem(e.allItems[i2]);
        e.allItems.splice(i2, 1);
      }
    };
    let colorAxisItems = [], options2, i;
    colorAxes.forEach(function(colorAxis) {
      options2 = colorAxis.options;
      if (options2?.showInLegend) {
        if (options2.dataClasses && options2.visible) {
          colorAxisItems = colorAxisItems.concat(colorAxis.getDataClassLegendSymbols());
        } else if (options2.visible) {
          colorAxisItems.push(colorAxis);
        }
        colorAxis.series.forEach(function(series) {
          if (!series.options.showInLegend || options2.dataClasses) {
            if (series.options.legendType === "point") {
              series.points.forEach(function(point) {
                destroyItem(point);
              });
            } else {
              destroyItem(series);
            }
          }
        });
      }
    });
    i = colorAxisItems.length;
    while (i--) {
      e.allItems.unshift(colorAxisItems[i]);
    }
  }
  function onLegendAfterColorizeItem(e) {
    if (e.visible && e.item.legendColor) {
      e.item.legendItem.symbol.attr({
        fill: e.item.legendColor
      });
    }
  }
  function onLegendAfterUpdate(e) {
    this.chart.colorAxis?.forEach((colorAxis) => {
      colorAxis.update({}, e.redraw);
    });
  }
  function onSeriesAfterTranslate2() {
    if (this.chart.colorAxis?.length || this.colorAttribs) {
      this.translateColors();
    }
  }
  function onSeriesBindAxes() {
    const axisTypes = this.axisTypes;
    if (!axisTypes) {
      this.axisTypes = ["colorAxis"];
    } else if (axisTypes.indexOf("colorAxis") === -1) {
      axisTypes.push("colorAxis");
    }
  }
  function pointSetVisible(vis) {
    const point = this, method = vis ? "show" : "hide";
    point.visible = point.options.visible = Boolean(vis);
    ["graphic", "dataLabel"].forEach(function(key) {
      if (point[key]) {
        point[key][method]();
      }
    });
    this.series.buildKDTree();
  }
  ColorAxisComposition2.pointSetVisible = pointSetVisible;
  function seriesTranslateColors() {
    const series = this, points = this.getPointsCollection(), nullColor = this.options.nullColor, colorAxis = this.colorAxis, colorKey = this.colorKey;
    points.forEach((point) => {
      const value = point.getNestedProperty(colorKey), color14 = point.options.color || (point.isNull || point.value === null ? nullColor : colorAxis && typeof value !== "undefined" ? colorAxis.toColor(value, point) : point.color || series.color);
      if (color14 && point.color !== color14) {
        point.color = color14;
        if (series.options.legendType === "point" && point.legendItem && point.legendItem.label) {
          series.chart.legend.colorizeItem(point, point.visible);
        }
      }
    });
  }
  function wrapChartCreateAxis(ChartClass) {
    const superCreateAxis = ChartClass.prototype.createAxis;
    ChartClass.prototype.createAxis = function(type, options2) {
      const chart = this;
      if (type !== "colorAxis") {
        return superCreateAxis.apply(chart, arguments);
      }
      const axis = new ColorAxisConstructor(chart, merge87(options2.axis, {
        index: chart[type].length,
        isX: false
      }));
      chart.isDirtyLegend = true;
      chart.axes.forEach((axis2) => {
        axis2.series = [];
      });
      chart.series.forEach((series) => {
        series.bindAxes();
        series.isDirtyData = true;
      });
      if (pick94(options2.redraw, true)) {
        chart.redraw(options2.animation);
      }
      return axis;
    };
  }
  function wrapFxFillSetter() {
    this.elem.attr("fill", color9(this.start).tweenTo(color9(this.end), this.pos), void 0, true);
  }
  function wrapFxStrokeSetter() {
    this.elem.attr("stroke", color9(this.start).tweenTo(color9(this.end), this.pos), void 0, true);
  }
})(ColorAxisComposition || (ColorAxisComposition = {}));
var ColorAxisComposition_default = ColorAxisComposition;

// node_modules/highcharts/es-modules/Core/Axis/Color/ColorAxisDefaults.js
var colorAxisDefaults = {
  /**
   * Whether to allow decimals on the color axis.
   * @type      {boolean}
   * @default   true
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.allowDecimals
   */
  /**
   * Determines how to set each data class' color if no individual
   * color is set. The default value, `tween`, computes intermediate
   * colors between `minColor` and `maxColor`. The other possible
   * value, `category`, pulls colors from the global or chart specific
   * [colors](#colors) array.
   *
   * @sample {highmaps} maps/coloraxis/dataclasscolor/
   *         Category colors
   *
   * @type       {string}
   * @default    tween
   * @product    highcharts highstock highmaps
   * @validvalue ["tween", "category"]
   * @apioption  colorAxis.dataClassColor
   */
  /**
   * An array of data classes or ranges for the choropleth map. If
   * none given, the color axis is scalar and values are distributed
   * as a gradient between the minimum and maximum colors.
   *
   * @sample {highmaps} maps/demo/data-class-ranges/
   *         Multiple ranges
   *
   * @sample {highmaps} maps/demo/data-class-two-ranges/
   *         Two ranges
   *
   * @type      {Array<*>}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.dataClasses
   */
  /**
   * The layout of the color axis. Can be `'horizontal'` or `'vertical'`.
   * If none given, the color axis has the same layout as the legend.
   *
   * @sample highcharts/coloraxis/horizontal-layout/
   *         Horizontal color axis layout with vertical legend
   *
   * @type      {string|undefined}
   * @since     7.2.0
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.layout
   */
  /**
   * The color of each data class. If not set, the color is pulled
   * from the global or chart-specific [colors](#colors) array. In
   * styled mode, this option is ignored. Instead, use colors defined
   * in CSS.
   *
   * @sample {highmaps} maps/demo/data-class-two-ranges/
   *         Explicit colors
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.dataClasses.color
   */
  /**
   * The start of the value range that the data class represents,
   * relating to the point value.
   *
   * The range of each `dataClass` is closed in both ends, but can be
   * overridden by the next `dataClass`.
   *
   * @type      {number}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.dataClasses.from
   */
  /**
   * The name of the data class as it appears in the legend.
   * If no name is given, it is automatically created based on the
   * `from` and `to` values. For full programmatic control,
   * [legend.labelFormatter](#legend.labelFormatter) can be used.
   * In the formatter, `this.from` and `this.to` can be accessed.
   *
   * @sample {highmaps} maps/coloraxis/dataclasses-name/
   *         Named data classes
   *
   * @sample {highmaps} maps/coloraxis/dataclasses-labelformatter/
   *         Formatted data classes
   *
   * @type      {string}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.dataClasses.name
   */
  /**
   * The end of the value range that the data class represents,
   * relating to the point value.
   *
   * The range of each `dataClass` is closed in both ends, but can be
   * overridden by the next `dataClass`.
   *
   * @type      {number}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.dataClasses.to
   */
  /** @ignore-option */
  lineWidth: 0,
  /**
   * Padding of the min value relative to the length of the axis. A
   * padding of 0.05 will make a 100px axis 5px longer.
   *
   * @product highcharts highstock highmaps
   */
  minPadding: 0,
  /**
   * The maximum value of the axis in terms of map point values. If
   * `null`, the max value is automatically calculated. If the
   * `endOnTick` option is true, the max value might be rounded up.
   *
   * @sample {highmaps} maps/coloraxis/gridlines/
   *         Explicit min and max to reduce the effect of outliers
   *
   * @type      {number}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.max
   */
  /**
   * The minimum value of the axis in terms of map point values. If
   * `null`, the min value is automatically calculated. If the
   * `startOnTick` option is true, the min value might be rounded
   * down.
   *
   * @sample {highmaps} maps/coloraxis/gridlines/
   *         Explicit min and max to reduce the effect of outliers
   *
   * @type      {number}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.min
   */
  /**
   * Padding of the max value relative to the length of the axis. A
   * padding of 0.05 will make a 100px axis 5px longer.
   *
   * @product highcharts highstock highmaps
   */
  maxPadding: 0,
  /**
   * Color of the grid lines extending from the axis across the
   * gradient.
   *
   * @sample {highmaps} maps/coloraxis/gridlines/
   *         Grid lines demonstrated
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product   highcharts highstock highmaps
   */
  gridLineColor: "#ffffff",
  /**
   * The width of the grid lines extending from the axis across the
   * gradient of a scalar color axis.
   *
   * @sample {highmaps} maps/coloraxis/gridlines/
   *         Grid lines demonstrated
   *
   * @product highcharts highstock highmaps
   */
  gridLineWidth: 1,
  /**
   * The interval of the tick marks in axis units. When `null`, the
   * tick interval is computed to approximately follow the
   * `tickPixelInterval`.
   *
   * @type      {number}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.tickInterval
   */
  /**
   * If [tickInterval](#colorAxis.tickInterval) is `null` this option
   * sets the approximate pixel interval of the tick marks.
   *
   * @product highcharts highstock highmaps
   */
  tickPixelInterval: 72,
  /**
   * Whether to force the axis to start on a tick. Use this option
   * with the `maxPadding` option to control the axis start.
   *
   * @product highcharts highstock highmaps
   */
  startOnTick: true,
  /**
   * Whether to force the axis to end on a tick. Use this option with
   * the [maxPadding](#colorAxis.maxPadding) option to control the
   * axis end.
   *
   * @product highcharts highstock highmaps
   */
  endOnTick: true,
  /** @ignore */
  offset: 0,
  /**
   * The triangular marker on a scalar color axis that points to the
   * value of the hovered area. To disable the marker, set
   * `marker: null`.
   *
   * @sample {highmaps} maps/coloraxis/marker/
   *         Black marker
   *
   * @declare Highcharts.PointMarkerOptionsObject
   * @product highcharts highstock highmaps
   */
  marker: {
    /**
     * Animation for the marker as it moves between values. Set to
     * `false` to disable animation. Defaults to `{ duration: 50 }`.
     *
     * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}
     * @product highcharts highstock highmaps
     */
    animation: {
      /** @internal */
      duration: 50
    },
    /** @internal */
    width: 0.01,
    /**
     * The color of the marker.
     *
     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @product highcharts highstock highmaps
     */
    color: "#999999"
    /* Palette.neutralColor40 */
  },
  /**
   * The axis labels show the number for each tick.
   *
   * For more live examples on label options, see [xAxis.labels in the
   * Highcharts API.](/highcharts#xAxis.labels)
   *
   * @extends xAxis.labels
   * @product highcharts highstock highmaps
   */
  labels: {
    distance: 8,
    /**
     * How to handle overflowing labels on horizontal color axis. If set
     * to `"allow"`, it will not be aligned at all. By default it
     * `"justify"` labels inside the chart area. If there is room to
     * move it, it will be aligned to the edge, else it will be removed.
     *
     * @validvalue ["allow", "justify"]
     * @product    highcharts highstock highmaps
     */
    overflow: "justify",
    rotation: 0
  },
  /**
   * The color to represent the minimum of the color axis. Unless
   * [dataClasses](#colorAxis.dataClasses) or
   * [stops](#colorAxis.stops) are set, the gradient starts at this
   * value.
   *
   * If dataClasses are set, the color is based on minColor and
   * maxColor unless a color is set for each data class, or the
   * [dataClassColor](#colorAxis.dataClassColor) is set.
   *
   * @sample {highmaps} maps/coloraxis/mincolor-maxcolor/
   *         Min and max colors on scalar (gradient) axis
   * @sample {highmaps} maps/coloraxis/mincolor-maxcolor-dataclasses/
   *         On data classes
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product highcharts highstock highmaps
   */
  minColor: "#e6e9ff",
  /**
   * The color to represent the maximum of the color axis. Unless
   * [dataClasses](#colorAxis.dataClasses) or
   * [stops](#colorAxis.stops) are set, the gradient ends at this
   * value.
   *
   * If dataClasses are set, the color is based on minColor and
   * maxColor unless a color is set for each data class, or the
   * [dataClassColor](#colorAxis.dataClassColor) is set.
   *
   * @sample {highmaps} maps/coloraxis/mincolor-maxcolor/
   *         Min and max colors on scalar (gradient) axis
   * @sample {highmaps} maps/coloraxis/mincolor-maxcolor-dataclasses/
   *         On data classes
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product highcharts highstock highmaps
   */
  maxColor: "#0022ff",
  /**
   * Color stops for the gradient of a scalar color axis. Use this in
   * cases where a linear gradient between a `minColor` and `maxColor`
   * is not sufficient. The stops is an array of tuples, where the
   * first item is a float between 0 and 1 assigning the relative
   * position in the gradient, and the second item is the color.
   *
   * @sample highcharts/coloraxis/coloraxis-stops/
   *         Color axis stops
   * @sample highcharts/coloraxis/color-key-with-stops/
   *         Color axis stops with custom colorKey
   * @sample {highmaps} maps/demo/heatmap/
   *         Heatmap with three color stops
   *
   * @type      {Array<Array<number,Highcharts.ColorString>>}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.stops
   */
  /**
   * The pixel length of the main tick marks on the color axis.
   */
  tickLength: 5,
  /**
   * The type of interpolation to use for the color axis. Can be
   * `linear` or `logarithmic`.
   *
   * @sample highcharts/coloraxis/logarithmic-with-emulate-negative-values/
   *         Logarithmic color axis with extension to emulate negative
   *         values
   *
   * @type      {Highcharts.ColorAxisTypeValue}
   * @default   linear
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.type
   */
  /**
   * Whether to reverse the axis so that the highest number is closest
   * to the origin. Defaults to `false` in a horizontal legend and
   * `true` in a vertical legend, where the smallest value starts on
   * top.
   *
   * @type      {boolean}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.reversed
   */
  /**
   * @product   highcharts highstock highmaps
   * @excluding afterBreaks, pointBreak, pointInBreak
   * @apioption colorAxis.events
   */
  /**
   * Fires when the legend item belonging to the colorAxis is clicked.
   * One parameter, `event`, is passed to the function.
   *
   * **Note:** This option is deprecated in favor of
   * [legend.events.itemClick](#legend.events.itemClick).
   *
   * @deprecated 11.4.4
   * @type       {Function}
   * @product    highcharts highstock highmaps
   * @apioption  colorAxis.events.legendItemClick
   */
  /**
   * The width of the color axis. If it's a number, it is interpreted as
   * pixels.
   *
   * If it's a percentage string, it is interpreted as percentages of the
   * total plot width.
   *
   * @sample    highcharts/coloraxis/width-and-height
   *            Percentage width and pixel height for color axis
   *
   * @type      {number|string}
   * @since     11.3.0
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.width
   */
  /**
   * The height of the color axis. If it's a number, it is interpreted as
   * pixels.
   *
   * If it's a percentage string, it is interpreted as percentages of the
   * total plot height.
   *
   * @sample    highcharts/coloraxis/width-and-height
   *            Percentage width and pixel height for color axis
   *
   * @type      {number|string}
   * @since     11.3.0
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.height
   */
  /**
   * Whether to display the colorAxis in the legend.
   *
   * @sample highcharts/coloraxis/hidden-coloraxis-with-3d-chart/
   *         Hidden color axis with 3d chart
   *
   * @see [heatmap.showInLegend](#series.heatmap.showInLegend)
   *
   * @since   4.2.7
   * @product highcharts highstock highmaps
   */
  showInLegend: true
};
var ColorAxisDefaults_default = colorAxisDefaults;

// node_modules/highcharts/es-modules/Core/Axis/Color/ColorAxisLike.js
var { parse: color10 } = Color_default;
var { merge: merge88 } = Utilities_default;
var ColorAxisLike;
(function(ColorAxisLike2) {
  function initDataClasses(userOptions) {
    const axis = this, chart = axis.chart, legendItem = axis.legendItem = axis.legendItem || {}, options2 = axis.options, userDataClasses = userOptions.dataClasses || [];
    let dataClass, dataClasses, colorCount = chart.options.chart.colorCount, colorCounter = 0, colors;
    axis.dataClasses = dataClasses = [];
    legendItem.labels = [];
    for (let i = 0, iEnd = userDataClasses.length; i < iEnd; ++i) {
      dataClass = userDataClasses[i];
      dataClass = merge88(dataClass);
      dataClasses.push(dataClass);
      if (!chart.styledMode && dataClass.color) {
        continue;
      }
      if (options2.dataClassColor === "category") {
        if (!chart.styledMode) {
          colors = chart.options.colors || [];
          colorCount = colors.length;
          dataClass.color = colors[colorCounter];
        }
        dataClass.colorIndex = colorCounter;
        colorCounter++;
        if (colorCounter === colorCount) {
          colorCounter = 0;
        }
      } else {
        dataClass.color = color10(options2.minColor).tweenTo(
          color10(options2.maxColor),
          iEnd < 2 ? 0.5 : i / (iEnd - 1)
          // #3219
        );
      }
    }
  }
  ColorAxisLike2.initDataClasses = initDataClasses;
  function initStops() {
    const axis = this, options2 = axis.options, stops = axis.stops = options2.stops || [
      [0, options2.minColor || ""],
      [1, options2.maxColor || ""]
    ];
    for (let i = 0, iEnd = stops.length; i < iEnd; ++i) {
      stops[i].color = color10(stops[i][1]);
    }
  }
  ColorAxisLike2.initStops = initStops;
  function normalizedValue(value) {
    const axis = this, max4 = axis.max || 0, min4 = axis.min || 0;
    if (axis.logarithmic) {
      value = axis.logarithmic.log2lin(value);
    }
    return 1 - (max4 - value) / (max4 - min4 || 1);
  }
  ColorAxisLike2.normalizedValue = normalizedValue;
  function toColor(value, point) {
    const axis = this;
    const dataClasses = axis.dataClasses;
    const stops = axis.stops;
    let pos, from, to, color14, dataClass, i;
    if (dataClasses) {
      i = dataClasses.length;
      while (i--) {
        dataClass = dataClasses[i];
        from = dataClass.from;
        to = dataClass.to;
        if ((typeof from === "undefined" || value >= from) && (typeof to === "undefined" || value <= to)) {
          color14 = dataClass.color;
          if (point) {
            point.dataClass = i;
            point.colorIndex = dataClass.colorIndex;
          }
          break;
        }
      }
    } else {
      pos = axis.normalizedValue(value);
      i = stops.length;
      while (i--) {
        if (pos > stops[i][0]) {
          break;
        }
      }
      from = stops[i] || stops[i + 1];
      to = stops[i + 1] || from;
      pos = 1 - (to[0] - pos) / (to[0] - from[0] || 1);
      color14 = from.color.tweenTo(to.color, pos);
    }
    return color14;
  }
  ColorAxisLike2.toColor = toColor;
})(ColorAxisLike || (ColorAxisLike = {}));
var ColorAxisLike_default = ColorAxisLike;

// node_modules/highcharts/es-modules/Core/Axis/Color/ColorAxis.js
var { defaultOptions: defaultOptions21 } = Defaults_default;
var { series: Series8 } = SeriesRegistry_default;
var { defined: defined66, extend: extend74, fireEvent: fireEvent47, isArray: isArray23, isNumber: isNumber59, merge: merge89, pick: pick95, relativeLength: relativeLength14 } = Utilities_default;
defaultOptions21.colorAxis = merge89(defaultOptions21.xAxis, ColorAxisDefaults_default);
var ColorAxis = class _ColorAxis extends Axis_default {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(ChartClass, FxClass, LegendClass, SeriesClass) {
    ColorAxisComposition_default.compose(_ColorAxis, ChartClass, FxClass, LegendClass, SeriesClass);
  }
  /* *
   *
   *  Constructors
   *
   * */
  /**
   * @private
   */
  constructor(chart, userOptions) {
    super(chart, userOptions);
    this.coll = "colorAxis";
    this.visible = true;
    this.init(chart, userOptions);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Initializes the color axis.
   *
   * @function Highcharts.ColorAxis#init
   *
   * @param {Highcharts.Chart} chart
   * The related chart of the color axis.
   *
   * @param {Highcharts.ColorAxisOptions} userOptions
   * The color axis options for initialization.
   */
  init(chart, userOptions) {
    const axis = this;
    const legend = chart.options.legend || {}, horiz = userOptions.layout ? userOptions.layout !== "vertical" : legend.layout !== "vertical";
    axis.side = userOptions.side || horiz ? 2 : 1;
    axis.reversed = userOptions.reversed || !horiz;
    axis.opposite = !horiz;
    super.init(chart, userOptions, "colorAxis");
    this.userOptions = userOptions;
    if (isArray23(chart.userOptions.colorAxis)) {
      chart.userOptions.colorAxis[this.index] = userOptions;
    }
    if (userOptions.dataClasses) {
      axis.initDataClasses(userOptions);
    }
    axis.initStops();
    axis.horiz = horiz;
    axis.zoomEnabled = false;
  }
  /**
   * Returns true if the series has points at all.
   *
   * @function Highcharts.ColorAxis#hasData
   *
   * @return {boolean}
   * True, if the series has points, otherwise false.
   */
  hasData() {
    return !!(this.tickPositions || []).length;
  }
  /**
   * Override so that ticks are not added in data class axes (#6914)
   * @private
   */
  setTickPositions() {
    if (!this.dataClasses) {
      return super.setTickPositions();
    }
  }
  /**
   * Extend the setOptions method to process extreme colors and color stops.
   * @private
   */
  setOptions(userOptions) {
    const options2 = merge89(
      defaultOptions21.colorAxis,
      userOptions,
      // Forced options
      {
        showEmpty: false,
        title: null,
        visible: this.chart.options.legend.enabled && userOptions.visible !== false
      }
    );
    super.setOptions(options2);
    this.options.crosshair = this.options.marker;
  }
  /**
   * @private
   */
  setAxisSize() {
    const axis = this, chart = axis.chart, symbol = axis.legendItem?.symbol;
    let { width, height } = axis.getSize();
    if (symbol) {
      this.left = +symbol.attr("x");
      this.top = +symbol.attr("y");
      this.width = width = +symbol.attr("width");
      this.height = height = +symbol.attr("height");
      this.right = chart.chartWidth - this.left - width;
      this.bottom = chart.chartHeight - this.top - height;
      this.pos = this.horiz ? this.left : this.top;
    }
    this.len = (this.horiz ? width : height) || _ColorAxis.defaultLegendLength;
  }
  /**
   * Override the getOffset method to add the whole axis groups inside the
   * legend.
   * @private
   */
  getOffset() {
    const axis = this;
    const group = axis.legendItem?.group;
    const sideOffset = axis.chart.axisOffset[axis.side];
    if (group) {
      axis.axisParent = group;
      super.getOffset();
      const legend = this.chart.legend;
      legend.allItems.forEach(function(item) {
        if (item instanceof _ColorAxis) {
          item.drawLegendSymbol(legend, item);
        }
      });
      legend.render();
      this.chart.getMargins(true);
      if (!this.chart.series.some((series) => series.isDrilling)) {
        axis.isDirty = true;
      }
      if (!axis.added) {
        axis.added = true;
        axis.labelLeft = 0;
        axis.labelRight = axis.width;
      }
      axis.chart.axisOffset[axis.side] = sideOffset;
    }
  }
  /**
   * Create the color gradient.
   * @private
   */
  setLegendColor() {
    const axis = this;
    const horiz = axis.horiz;
    const reversed = axis.reversed;
    const one = reversed ? 1 : 0;
    const zero = reversed ? 0 : 1;
    const grad = horiz ? [one, 0, zero, 0] : [0, zero, 0, one];
    axis.legendColor = {
      linearGradient: {
        x1: grad[0],
        y1: grad[1],
        x2: grad[2],
        y2: grad[3]
      },
      stops: axis.stops
    };
  }
  /**
   * The color axis appears inside the legend and has its own legend symbol.
   * @private
   */
  drawLegendSymbol(legend, item) {
    const axis = this, legendItem = item.legendItem || {}, padding = legend.padding, legendOptions = legend.options, labelOptions = axis.options.labels, itemDistance = pick95(legendOptions.itemDistance, 10), horiz = axis.horiz, { width, height } = axis.getSize(), labelPadding = pick95(
      // @todo: This option is not documented, nor implemented when
      // vertical
      legendOptions.labelPadding,
      horiz ? 16 : 30
    );
    this.setLegendColor();
    if (!legendItem.symbol) {
      legendItem.symbol = this.chart.renderer.symbol("roundedRect").attr({
        r: legendOptions.symbolRadius ?? 3,
        zIndex: 1
      }).add(legendItem.group);
    }
    legendItem.symbol.attr({
      x: 0,
      y: (legend.baseline || 0) - 11,
      width,
      height
    });
    legendItem.labelWidth = width + padding + (horiz ? itemDistance : pick95(labelOptions.x, labelOptions.distance) + (this.maxLabelLength || 0));
    legendItem.labelHeight = height + padding + (horiz ? labelPadding : 0);
  }
  /**
   * Fool the legend.
   * @private
   */
  setState(state) {
    this.series.forEach(function(series) {
      series.setState(state);
    });
  }
  /**
   * @private
   */
  setVisible() {
  }
  /**
   * @private
   */
  getSeriesExtremes() {
    const axis = this;
    const series = axis.series;
    let colorValArray, colorKey, calculatedExtremes, cSeries, i = series.length;
    this.dataMin = Infinity;
    this.dataMax = -Infinity;
    while (i--) {
      cSeries = series[i];
      colorKey = cSeries.colorKey = pick95(cSeries.options.colorKey, cSeries.colorKey, cSeries.pointValKey, cSeries.zoneAxis, "y");
      calculatedExtremes = cSeries[colorKey + "Min"] && cSeries[colorKey + "Max"];
      for (const key of [colorKey, "value", "y"]) {
        colorValArray = cSeries.getColumn(key);
        if (colorValArray.length) {
          break;
        }
      }
      if (calculatedExtremes) {
        cSeries.minColorValue = cSeries[colorKey + "Min"];
        cSeries.maxColorValue = cSeries[colorKey + "Max"];
      } else {
        const cExtremes = Series8.prototype.getExtremes.call(cSeries, colorValArray);
        cSeries.minColorValue = cExtremes.dataMin;
        cSeries.maxColorValue = cExtremes.dataMax;
      }
      if (defined66(cSeries.minColorValue) && defined66(cSeries.maxColorValue)) {
        this.dataMin = Math.min(this.dataMin, cSeries.minColorValue);
        this.dataMax = Math.max(this.dataMax, cSeries.maxColorValue);
      }
      if (!calculatedExtremes) {
        Series8.prototype.applyExtremes.call(cSeries);
      }
    }
  }
  /**
   * Internal function to draw a crosshair.
   *
   * @function Highcharts.ColorAxis#drawCrosshair
   *
   * @param {Highcharts.PointerEventObject} [e]
   *        The event arguments from the modified pointer event, extended with
   *        `chartX` and `chartY`
   *
   * @param {Highcharts.Point} [point]
   *        The Point object if the crosshair snaps to points.
   *
   * @emits Highcharts.ColorAxis#event:afterDrawCrosshair
   * @emits Highcharts.ColorAxis#event:drawCrosshair
   */
  drawCrosshair(e, point) {
    const axis = this, legendItem = axis.legendItem || {}, plotX = point?.plotX, plotY = point?.plotY, axisPos = axis.pos, axisLen = axis.len;
    let crossPos;
    if (point) {
      crossPos = axis.toPixels(point.getNestedProperty(point.series.colorKey));
      if (crossPos < axisPos) {
        crossPos = axisPos - 2;
      } else if (crossPos > axisPos + axisLen) {
        crossPos = axisPos + axisLen + 2;
      }
      point.plotX = crossPos;
      point.plotY = axis.len - crossPos;
      super.drawCrosshair(e, point);
      point.plotX = plotX;
      point.plotY = plotY;
      if (axis.cross && !axis.cross.addedToColorAxis && legendItem.group) {
        axis.cross.addClass("highcharts-coloraxis-marker").add(legendItem.group);
        axis.cross.addedToColorAxis = true;
        if (!axis.chart.styledMode && typeof axis.crosshair === "object") {
          axis.cross.attr({
            fill: axis.crosshair.color
          });
        }
      }
    }
  }
  /**
   * @private
   */
  getPlotLinePath(options2) {
    const axis = this, left = axis.left, pos = options2.translatedValue, top = axis.top;
    return isNumber59(pos) ? (
      // `pos` can be 0 (#3969)
      axis.horiz ? [
        ["M", pos - 4, top - 6],
        ["L", pos + 4, top - 6],
        ["L", pos, top],
        ["Z"]
      ] : [
        ["M", left, pos],
        ["L", left - 6, pos + 6],
        ["L", left - 6, pos - 6],
        ["Z"]
      ]
    ) : super.getPlotLinePath(options2);
  }
  /**
   * Updates a color axis instance with a new set of options. The options are
   * merged with the existing options, so only new or altered options need to
   * be specified.
   *
   * @function Highcharts.ColorAxis#update
   *
   * @param {Highcharts.ColorAxisOptions} newOptions
   * The new options that will be merged in with existing options on the color
   * axis.
   *
   * @param {boolean} [redraw]
   * Whether to redraw the chart after the color axis is altered. If doing
   * more operations on the chart, it is a good idea to set redraw to `false`
   * and call {@link Highcharts.Chart#redraw} after.
   */
  update(newOptions, redraw) {
    const axis = this, chart = axis.chart, legend = chart.legend;
    this.series.forEach((series) => {
      series.isDirtyData = true;
    });
    if (newOptions.dataClasses && legend.allItems || axis.dataClasses) {
      axis.destroyItems();
    }
    super.update(newOptions, redraw);
    if (axis.legendItem?.label) {
      axis.setLegendColor();
      legend.colorizeItem(this, true);
    }
  }
  /**
   * Destroy color axis legend items.
   * @private
   */
  destroyItems() {
    const axis = this, chart = axis.chart, legendItem = axis.legendItem || {};
    if (legendItem.label) {
      chart.legend.destroyItem(axis);
    } else if (legendItem.labels) {
      for (const item of legendItem.labels) {
        chart.legend.destroyItem(item);
      }
    }
    chart.isDirtyLegend = true;
  }
  //   Removing the whole axis (#14283)
  destroy() {
    this.chart.isDirtyLegend = true;
    this.destroyItems();
    super.destroy(...[].slice.call(arguments));
  }
  /**
   * Removes the color axis and the related legend item.
   *
   * @function Highcharts.ColorAxis#remove
   *
   * @param {boolean} [redraw=true]
   *        Whether to redraw the chart following the remove.
   */
  remove(redraw) {
    this.destroyItems();
    super.remove(redraw);
  }
  /**
   * Get the legend item symbols for data classes.
   * @private
   */
  getDataClassLegendSymbols() {
    const axis = this, chart = axis.chart, legendItems = axis.legendItem && axis.legendItem.labels || [], legendOptions = chart.options.legend, valueDecimals = pick95(legendOptions.valueDecimals, -1), valueSuffix = pick95(legendOptions.valueSuffix, "");
    const getPointsInDataClass = (i) => axis.series.reduce((points, s) => {
      points.push(...s.points.filter((point) => point.dataClass === i));
      return points;
    }, []);
    let name;
    if (!legendItems.length) {
      axis.dataClasses.forEach((dataClass, i) => {
        const from = dataClass.from, to = dataClass.to, { numberFormatter } = chart;
        let vis = true;
        name = "";
        if (typeof from === "undefined") {
          name = "< ";
        } else if (typeof to === "undefined") {
          name = "> ";
        }
        if (typeof from !== "undefined") {
          name += numberFormatter(from, valueDecimals) + valueSuffix;
        }
        if (typeof from !== "undefined" && typeof to !== "undefined") {
          name += " - ";
        }
        if (typeof to !== "undefined") {
          name += numberFormatter(to, valueDecimals) + valueSuffix;
        }
        legendItems.push(extend74({
          chart,
          name,
          options: {},
          drawLegendSymbol: LegendSymbol_default.rectangle,
          visible: true,
          isDataClass: true,
          // Override setState to set either normal or inactive
          // state to all points in this data class
          setState: (state) => {
            for (const point of getPointsInDataClass(i)) {
              point.setState(state);
            }
          },
          // Override setState to show or hide all points in this
          // data class
          setVisible: function() {
            this.visible = vis = axis.visible = !vis;
            const affectedSeries = [];
            for (const point of getPointsInDataClass(i)) {
              point.setVisible(vis);
              point.hiddenInDataClass = !vis;
              if (affectedSeries.indexOf(point.series) === -1) {
                affectedSeries.push(point.series);
              }
            }
            chart.legend.colorizeItem(this, vis);
            affectedSeries.forEach((series) => {
              fireEvent47(series, "afterDataClassLegendClick");
            });
          }
        }, dataClass));
      });
    }
    return legendItems;
  }
  /**
   * Get size of color axis symbol.
   * @private
   */
  getSize() {
    const axis = this, { chart, horiz } = axis, { height: colorAxisHeight, width: colorAxisWidth } = axis.options, { legend: legendOptions } = chart.options, width = pick95(defined66(colorAxisWidth) ? relativeLength14(colorAxisWidth, chart.chartWidth) : void 0, legendOptions?.symbolWidth, horiz ? _ColorAxis.defaultLegendLength : 12), height = pick95(defined66(colorAxisHeight) ? relativeLength14(colorAxisHeight, chart.chartHeight) : void 0, legendOptions?.symbolHeight, horiz ? 12 : _ColorAxis.defaultLegendLength);
    return {
      width,
      height
    };
  }
};
ColorAxis.defaultLegendLength = 200;
ColorAxis.keepProps = [
  "legendItem"
];
extend74(ColorAxis.prototype, ColorAxisLike_default);
Array.prototype.push.apply(Axis_default.keepProps, ColorAxis.keepProps);
var ColorAxis_default = ColorAxis;

// node_modules/highcharts/es-modules/masters/modules/coloraxis.src.js
var G14 = Globals_default;
G14.ColorAxis = G14.ColorAxis || ColorAxis_default;
G14.ColorAxis.compose(G14.Chart, G14.Fx, G14.Legend, G14.Series);

// node_modules/highcharts/es-modules/Series/ColorMapComposition.js
var { column: { prototype: columnProto6 } } = SeriesRegistry_default.seriesTypes;
var { addEvent: addEvent83, defined: defined67 } = Utilities_default;
var ColorMapComposition;
(function(ColorMapComposition2) {
  ColorMapComposition2.pointMembers = {
    dataLabelOnNull: true,
    moveToTopOnHover: true,
    isValid: pointIsValid
  };
  ColorMapComposition2.seriesMembers = {
    colorKey: "value",
    axisTypes: ["xAxis", "yAxis", "colorAxis"],
    parallelArrays: ["x", "y", "value"],
    pointArrayMap: ["value"],
    trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
    colorAttribs: seriesColorAttribs,
    pointAttribs: columnProto6.pointAttribs
  };
  function compose27(SeriesClass) {
    const PointClass = SeriesClass.prototype.pointClass;
    addEvent83(PointClass, "afterSetState", onPointAfterSetState2);
    return SeriesClass;
  }
  ColorMapComposition2.compose = compose27;
  function onPointAfterSetState2(e) {
    const point = this, series = point.series, renderer = series.chart.renderer;
    if (point.moveToTopOnHover && point.graphic) {
      if (!series.stateMarkerGraphic) {
        series.stateMarkerGraphic = new SVGElement_default(renderer, "use").css({
          pointerEvents: "none"
        }).add(point.graphic.parentGroup);
      }
      if (e?.state === "hover") {
        point.graphic.attr({
          id: this.id
        });
        series.stateMarkerGraphic.attr({
          href: `${renderer.url}#${this.id}`,
          visibility: "visible"
        });
      } else {
        series.stateMarkerGraphic.attr({
          href: ""
        });
      }
    }
  }
  function pointIsValid() {
    return this.value !== null && this.value !== Infinity && this.value !== -Infinity && // Undefined is allowed, but NaN is not (#17279)
    (this.value === void 0 || !isNaN(this.value));
  }
  function seriesColorAttribs(point) {
    const ret = {};
    if (defined67(point.color) && (!point.state || point.state === "normal")) {
      ret[this.colorProp || "fill"] = point.color;
    }
    return ret;
  }
})(ColorMapComposition || (ColorMapComposition = {}));
var ColorMapComposition_default = ColorMapComposition;

// node_modules/highcharts/es-modules/Series/Heatmap/HeatmapPoint.js
var { scatter: { prototype: { pointClass: ScatterPoint3 } } } = SeriesRegistry_default.seriesTypes;
var { clamp: clamp19, defined: defined68, extend: extend75, pick: pick96 } = Utilities_default;
var HeatmapPoint = class extends ScatterPoint3 {
  /* *
   *
   *  Functions
   *
   * */
  /** @private */
  applyOptions(options2, x) {
    if (this.isNull || this.value === null) {
      delete this.color;
    }
    super.applyOptions(options2, x);
    this.formatPrefix = this.isNull || this.value === null ? "null" : "point";
    return this;
  }
  /** @private */
  getCellAttributes() {
    const point = this, series = point.series, seriesOptions = series.options, xPad = (seriesOptions.colsize || 1) / 2, yPad = (seriesOptions.rowsize || 1) / 2, xAxis2 = series.xAxis, yAxis2 = series.yAxis, markerOptions = point.options.marker || series.options.marker, pointPlacement = series.pointPlacementToXValue(), pointPadding = pick96(point.pointPadding, seriesOptions.pointPadding, 0), cellAttr = {
      x1: clamp19(Math.round(xAxis2.len - xAxis2.translate(point.x - xPad, false, true, false, true, -pointPlacement)), -xAxis2.len, 2 * xAxis2.len),
      x2: clamp19(Math.round(xAxis2.len - xAxis2.translate(point.x + xPad, false, true, false, true, -pointPlacement)), -xAxis2.len, 2 * xAxis2.len),
      y1: clamp19(Math.round(yAxis2.translate(point.y - yPad, false, true, false, true)), -yAxis2.len, 2 * yAxis2.len),
      y2: clamp19(Math.round(yAxis2.translate(point.y + yPad, false, true, false, true)), -yAxis2.len, 2 * yAxis2.len)
    };
    const dimensions = [["width", "x"], ["height", "y"]];
    for (const dimension of dimensions) {
      const prop = dimension[0], direction = dimension[1];
      let start = direction + "1", end = direction + "2";
      const side = Math.abs(cellAttr[start] - cellAttr[end]), borderWidth = markerOptions && markerOptions.lineWidth || 0, plotPos = Math.abs(cellAttr[start] + cellAttr[end]) / 2, widthOrHeight = markerOptions && markerOptions[prop];
      if (defined68(widthOrHeight) && widthOrHeight < side) {
        const halfCellSize = widthOrHeight / 2 + borderWidth / 2;
        cellAttr[start] = plotPos - halfCellSize;
        cellAttr[end] = plotPos + halfCellSize;
      }
      if (pointPadding) {
        if (direction === "x" && xAxis2.reversed || direction === "y" && !yAxis2.reversed) {
          start = end;
          end = direction + "1";
        }
        cellAttr[start] += pointPadding;
        cellAttr[end] -= pointPadding;
      }
    }
    return cellAttr;
  }
  /**
   * @private
   */
  haloPath(size) {
    if (!size) {
      return [];
    }
    const { x = 0, y = 0, width = 0, height = 0 } = this.shapeArgs || {};
    return [
      ["M", x - size, y - size],
      ["L", x - size, y + height + size],
      ["L", x + width + size, y + height + size],
      ["L", x + width + size, y - size],
      ["Z"]
    ];
  }
  /**
   * Color points have a value option that determines whether or not it is
   * a null point
   * @private
   */
  isValid() {
    return this.value !== Infinity && this.value !== -Infinity;
  }
};
extend75(HeatmapPoint.prototype, {
  dataLabelOnNull: true,
  moveToTopOnHover: true,
  ttBelow: false
});
var HeatmapPoint_default = HeatmapPoint;

// node_modules/highcharts/es-modules/Series/Heatmap/HeatmapSeriesDefaults.js
var { isNumber: isNumber60 } = Utilities_default;
var HeatmapSeriesDefaults = {
  /**
   * Animation is disabled by default on the heatmap series.
   */
  animation: false,
  /**
   * The border radius for each heatmap item. The border's color and
   * width can be set in marker options.
   *
   * @see [lineColor](#plotOptions.heatmap.marker.lineColor)
   * @see [lineWidth](#plotOptions.heatmap.marker.lineWidth)
   */
  borderRadius: 0,
  /**
   * The border width for each heatmap item.
   */
  borderWidth: 0,
  /**
   * Padding between the points in the heatmap.
   *
   * @type      {number}
   * @default   0
   * @since     6.0
   * @apioption plotOptions.heatmap.pointPadding
   */
  /**
   * @default   value
   * @apioption plotOptions.heatmap.colorKey
   */
  /**
   * The main color of the series. In heat maps this color is rarely used,
   * as we mostly use the color to denote the value of each point. Unless
   * options are set in the [colorAxis](#colorAxis), the default value
   * is pulled from the [options.colors](#colors) array.
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     4.0
   * @product   highcharts
   * @apioption plotOptions.heatmap.color
   */
  /**
   * The column size - how many X axis units each column in the heatmap
   * should span.
   *
   * @sample {highcharts} maps/demo/heatmap/
   *         One day
   * @sample {highmaps} maps/demo/heatmap/
   *         One day
   *
   * @type      {number}
   * @default   1
   * @since     4.0
   * @product   highcharts highmaps
   * @apioption plotOptions.heatmap.colsize
   */
  /**
   * The row size - how many Y axis units each heatmap row should span.
   *
   * @sample {highcharts} maps/demo/heatmap/
   *         1 by default
   * @sample {highmaps} maps/demo/heatmap/
   *         1 by default
   *
   * @type      {number}
   * @default   1
   * @since     4.0
   * @product   highcharts highmaps
   * @apioption plotOptions.heatmap.rowsize
   */
  /**
   * Make the heatmap render its data points as an interpolated image.
   *
   * @sample highcharts/demo/heatmap-interpolation
   *   Interpolated heatmap image displaying user activity on a website
   * @sample highcharts/series-heatmap/interpolation
   *   Interpolated heatmap toggle
   *
   */
  interpolation: false,
  /**
   * The color applied to null points. In styled mode, a general CSS class
   * is applied instead.
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  nullColor: "#f7f7f7",
  dataLabels: {
    formatter: function() {
      const { numberFormatter } = this.series.chart;
      const { value } = this.point;
      return isNumber60(value) ? numberFormatter(value, -1) : "";
    },
    inside: true,
    verticalAlign: "middle",
    crop: false,
    /**
     * @ignore-option
     */
    overflow: "allow",
    padding: 0
    // #3837
  },
  /**
   * @excluding radius, enabledThreshold
   * @since     8.1
   */
  marker: {
    /**
     * A predefined shape or symbol for the marker. When undefined, the
     * symbol is pulled from options.symbols. Other possible values are
     * `'circle'`, `'square'`,`'diamond'`, `'triangle'`,
     * `'triangle-down'`, `'rect'`, and `'ellipse'`.
     *
     * Additionally, the URL to a graphic can be given on this form:
     * `'url(graphic.png)'`. Note that for the image to be applied to
     * exported charts, its URL needs to be accessible by the export
     * server.
     *
     * Custom callbacks for symbol path generation can also be added to
     * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
     * used by its method name, as shown in the demo.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
     *         Predefined, graphic and custom markers
     * @sample {highstock} highcharts/plotoptions/series-marker-symbol/
     *         Predefined, graphic and custom markers
     */
    symbol: "rect",
    /** @ignore-option */
    radius: 0,
    lineColor: void 0,
    states: {
      /**
       * @excluding radius, radiusPlus
       */
      hover: {
        /**
         * Set the marker's fixed width on hover state.
         *
         * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-width
         *         70px fixed marker's width and height on hover
         *
         * @type      {number|undefined}
         * @default   undefined
         * @product   highcharts highmaps
         * @apioption plotOptions.heatmap.marker.states.hover.width
         */
        /**
         * Set the marker's fixed height on hover state.
         *
         * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-width
         *         70px fixed marker's width and height on hover
         *
         * @type      {number|undefined}
         * @default   undefined
         * @product   highcharts highmaps
         * @apioption plotOptions.heatmap.marker.states.hover.height
         */
        /**
         * The number of pixels to increase the width of the
         * selected point.
         *
         * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-widthplus
         *         20px greater width and height on hover
         *
         * @type      {number|undefined}
         * @default   undefined
         * @product   highcharts highmaps
         * @apioption plotOptions.heatmap.marker.states.hover.widthPlus
         */
        /**
         * The number of pixels to increase the height of the
         * selected point.
         *
         * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-widthplus
        *          20px greater width and height on hover
            *
            * @type      {number|undefined}
            * @default   undefined
            * @product   highcharts highmaps
            * @apioption plotOptions.heatmap.marker.states.hover.heightPlus
            */
        /**
         * The additional line width for a hovered point.
         *
         * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-linewidthplus
         *         5 pixels wider lineWidth on hover
         * @sample {highmaps} maps/plotoptions/heatmap-marker-states-hover-linewidthplus
         *         5 pixels wider lineWidth on hover
         */
        lineWidthPlus: 0
      },
      /**
       * @excluding radius
       */
      select: {
        /**
         * Set the marker's fixed width on select state.
         *
         * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-width
         *         70px fixed marker's width and height on hover
         *
         * @type      {number|undefined}
         * @default   undefined
         * @product   highcharts highmaps
         * @apioption plotOptions.heatmap.marker.states.select.width
         */
        /**
         * Set the marker's fixed height on select state.
         *
         * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-width
         *         70px fixed marker's width and height on hover
         *
         * @type      {number|undefined}
         * @default   undefined
         * @product   highcharts highmaps
         * @apioption plotOptions.heatmap.marker.states.select.height
         */
        /**
         * The number of pixels to increase the width of the
         * selected point.
         *
         * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-widthplus
         *         20px greater width and height on hover
         *
         * @type      {number|undefined}
         * @default   undefined
         * @product   highcharts highmaps
         * @apioption plotOptions.heatmap.marker.states.select.widthPlus
         */
        /**
         * The number of pixels to increase the height of the
         * selected point.
         *
         * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-widthplus
         *         20px greater width and height on hover
         *
         * @type      {number|undefined}
         * @default   undefined
         * @product   highcharts highmaps
         * @apioption plotOptions.heatmap.marker.states.select.heightPlus
         */
      }
    }
  },
  clip: true,
  /** @ignore-option */
  pointRange: null,
  // Dynamically set to colsize by default
  tooltip: {
    pointFormat: "{point.x}, {point.y}: {point.value}<br/>"
  },
  states: {
    hover: {
      /** @ignore-option */
      halo: false,
      // #3406, halo is disabled on heatmaps by default
      /**
       * How much to brighten the point on interaction. Requires the
       * main color to be defined in hex or rgb(a) format.
       *
       * In styled mode, the hover brightening is by default replaced
       * with a fill-opacity set in the `.highcharts-point:hover`
       * rule.
       */
      brightness: 0.2
    }
  },
  legendSymbol: "rectangle"
};
var HeatmapSeriesDefaults_default = HeatmapSeriesDefaults;

// node_modules/highcharts/es-modules/Series/InterpolationUtilities.js
var { doc: doc28 } = Globals_default;
var { defined: defined69, pick: pick97 } = Utilities_default;
function colorFromPoint(value, point) {
  const colorAxis = point.series.colorAxis;
  if (colorAxis) {
    const rgba = colorAxis.toColor(value || 0, point).split(")")[0].split("(")[1].split(",").map((s) => pick97(parseFloat(s), parseInt(s, 10)));
    rgba[3] = pick97(rgba[3], 1) * 255;
    if (!defined69(value) || !point.visible) {
      rgba[3] = 0;
    }
    return rgba;
  }
  return [0, 0, 0, 0];
}
function getContext(series) {
  const { canvas, context } = series;
  if (canvas && context) {
    context.clearRect(0, 0, canvas.width, canvas.height);
  } else {
    series.canvas = doc28.createElement("canvas");
    series.context = series.canvas.getContext("2d", {
      willReadFrequently: true
    }) || void 0;
    return series.context;
  }
  return context;
}
var InterpolationUtilities = {
  colorFromPoint,
  getContext
};
var InterpolationUtilities_default = InterpolationUtilities;

// node_modules/highcharts/es-modules/Series/Heatmap/HeatmapSeries.js
var { series: Series9, seriesTypes: { column: ColumnSeries11, scatter: ScatterSeries4 } } = SeriesRegistry_default;
var { prototype: { symbols: symbols2 } } = SVGRenderer_default;
var { addEvent: addEvent84, extend: extend76, fireEvent: fireEvent48, isNumber: isNumber61, merge: merge90, pick: pick98 } = Utilities_default;
var { colorFromPoint: colorFromPoint2, getContext: getContext2 } = InterpolationUtilities_default;
var HeatmapSeries = class extends ScatterSeries4 {
  constructor() {
    super(...arguments);
    this.valueMax = NaN;
    this.valueMin = NaN;
    this.isDirtyCanvas = true;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  drawPoints() {
    const series = this, seriesOptions = series.options, interpolation = seriesOptions.interpolation, seriesMarkerOptions = seriesOptions.marker || {};
    if (interpolation) {
      const { image, chart, xAxis: xAxis2, yAxis: yAxis2 } = series, { reversed: xRev = false, len: width } = xAxis2, { reversed: yRev = false, len: height } = yAxis2, dimensions = { width, height };
      if (!image || series.isDirtyData || series.isDirtyCanvas) {
        const ctx = getContext2(series), { canvas, options: { colsize = 1, rowsize = 1 }, points, points: { length } } = series, pointsLen = length - 1, colorAxis = chart.colorAxis && chart.colorAxis[0];
        if (canvas && ctx && colorAxis) {
          const { min: xMin, max: xMax } = xAxis2.getExtremes(), { min: yMin, max: yMax } = yAxis2.getExtremes(), xDelta = xMax - xMin, yDelta = yMax - yMin, imgMultiple = 8, lastX = Math.round(imgMultiple * (xDelta / colsize / imgMultiple)), lastY = Math.round(imgMultiple * (yDelta / rowsize / imgMultiple)), [transformX, transformY] = [
            [lastX, lastX / xDelta, xRev, "ceil"],
            [lastY, lastY / yDelta, !yRev, "floor"]
          ].map(([last, scale, rev, rounding]) => rev ? (v) => Math[rounding](last - scale * v) : (v) => Math[rounding](scale * v)), canvasWidth = canvas.width = lastX + 1, canvasHeight = canvas.height = lastY + 1, canvasArea = canvasWidth * canvasHeight, pixelToPointScale = pointsLen / canvasArea, pixelData = new Uint8ClampedArray(canvasArea * 4), pointInPixels = (x, y) => Math.ceil(canvasWidth * transformY(y - yMin) + transformX(x - xMin)) * 4;
          series.buildKDTree();
          for (let i = 0; i < canvasArea; i++) {
            const point = points[Math.ceil(pixelToPointScale * i)], { x, y } = point;
            pixelData.set(colorFromPoint2(point.value, point), pointInPixels(x, y));
          }
          ctx.putImageData(new ImageData(pixelData, canvasWidth), 0, 0);
          if (image) {
            image.attr({
              ...dimensions,
              href: canvas.toDataURL("image/png", 1)
            });
          } else {
            series.directTouch = false;
            series.image = chart.renderer.image(canvas.toDataURL("image/png", 1)).attr(dimensions).add(series.group);
          }
        }
        series.isDirtyCanvas = false;
      } else if (image.width !== width || image.height !== height) {
        image.attr(dimensions);
      }
    } else if (seriesMarkerOptions.enabled || series._hasPointMarkers) {
      Series9.prototype.drawPoints.call(series);
      series.points.forEach((point) => {
        if (point.graphic) {
          point.graphic[series.chart.styledMode ? "css" : "animate"](series.colorAttribs(point));
          if (point.value === null) {
            point.graphic.addClass("highcharts-null-point");
          }
        }
      });
    }
  }
  /**
   * @private
   */
  getExtremes() {
    const { dataMin, dataMax } = Series9.prototype.getExtremes.call(this, this.getColumn("value"));
    if (isNumber61(dataMin)) {
      this.valueMin = dataMin;
    }
    if (isNumber61(dataMax)) {
      this.valueMax = dataMax;
    }
    return Series9.prototype.getExtremes.call(this);
  }
  /**
   * Override to also allow null points, used when building the k-d-tree for
   * tooltips in boost mode.
   * @private
   */
  getValidPoints(points, insideOnly) {
    return Series9.prototype.getValidPoints.call(this, points, insideOnly, true);
  }
  /**
   * Define hasData function for non-cartesian series. Returns true if the
   * series has points at all.
   * @private
   */
  hasData() {
    return !!this.dataTable.rowCount;
  }
  /**
   * Override the init method to add point ranges on both axes.
   * @private
   */
  init() {
    super.init.apply(this, arguments);
    const options2 = this.options;
    options2.pointRange = pick98(options2.pointRange, options2.colsize || 1);
    this.yAxis.axisPointRange = options2.rowsize || 1;
    symbols2.ellipse = symbols2.circle;
    if (options2.marker && isNumber61(options2.borderRadius)) {
      options2.marker.r = options2.borderRadius;
    }
  }
  /**
   * @private
   */
  markerAttribs(point, state) {
    const shapeArgs = point.shapeArgs || {};
    if (point.hasImage) {
      return {
        x: point.plotX,
        y: point.plotY
      };
    }
    if (state && state !== "normal") {
      const pointMarkerOptions = point.options.marker || {}, seriesMarkerOptions = this.options.marker || {}, seriesStateOptions = seriesMarkerOptions.states?.[state] || {}, pointStateOptions = pointMarkerOptions.states?.[state] || {};
      const width = (pointStateOptions.width || seriesStateOptions.width || shapeArgs.width || 0) + (pointStateOptions.widthPlus || seriesStateOptions.widthPlus || 0);
      const height = (pointStateOptions.height || seriesStateOptions.height || shapeArgs.height || 0) + (pointStateOptions.heightPlus || seriesStateOptions.heightPlus || 0);
      const x = (shapeArgs.x || 0) + ((shapeArgs.width || 0) - width) / 2, y = (shapeArgs.y || 0) + ((shapeArgs.height || 0) - height) / 2;
      return { x, y, width, height };
    }
    return shapeArgs;
  }
  /**
   * @private
   */
  pointAttribs(point, state) {
    const series = this, attr18 = Series9.prototype.pointAttribs.call(series, point, state), seriesOptions = series.options || {}, plotOptions = series.chart.options.plotOptions || {}, seriesPlotOptions = plotOptions.series || {}, heatmapPlotOptions = plotOptions.heatmap || {}, borderColor = point?.options.borderColor || seriesOptions.borderColor || heatmapPlotOptions.borderColor || seriesPlotOptions.borderColor, borderWidth = point?.options.borderWidth || seriesOptions.borderWidth || heatmapPlotOptions.borderWidth || seriesPlotOptions.borderWidth || attr18["stroke-width"];
    attr18.stroke = point?.marker?.lineColor || seriesOptions.marker?.lineColor || borderColor || this.color;
    attr18["stroke-width"] = borderWidth;
    if (state && state !== "normal") {
      const stateOptions = merge90(seriesOptions.states?.[state], seriesOptions.marker?.states?.[state], point?.options.states?.[state] || {});
      attr18.fill = stateOptions.color || Color_default.parse(attr18.fill).brighten(stateOptions.brightness || 0).get();
      attr18.stroke = stateOptions.lineColor || attr18.stroke;
    }
    return attr18;
  }
  /**
   * @private
   */
  translate() {
    const series = this, options2 = series.options, { borderRadius, marker } = options2, symbol = marker?.symbol || "rect", shape = symbols2[symbol] ? symbol : "rect", hasRegularShape = ["circle", "square"].indexOf(shape) !== -1;
    series.generatePoints();
    for (const point of series.points) {
      const cellAttr = point.getCellAttributes();
      let x = Math.min(cellAttr.x1, cellAttr.x2), y = Math.min(cellAttr.y1, cellAttr.y2), width = Math.max(Math.abs(cellAttr.x2 - cellAttr.x1), 0), height = Math.max(Math.abs(cellAttr.y2 - cellAttr.y1), 0);
      point.hasImage = (point.marker?.symbol || symbol || "").indexOf("url") === 0;
      if (hasRegularShape) {
        const sizeDiff = Math.abs(width - height);
        x = Math.min(cellAttr.x1, cellAttr.x2) + (width < height ? 0 : sizeDiff / 2);
        y = Math.min(cellAttr.y1, cellAttr.y2) + (width < height ? sizeDiff / 2 : 0);
        width = height = Math.min(width, height);
      }
      if (point.hasImage) {
        point.marker = { width, height };
      }
      point.plotX = point.clientX = (cellAttr.x1 + cellAttr.x2) / 2;
      point.plotY = (cellAttr.y1 + cellAttr.y2) / 2;
      point.shapeType = "path";
      point.shapeArgs = merge90(true, { x, y, width, height }, {
        d: symbols2[shape](x, y, width, height, { r: isNumber61(borderRadius) ? borderRadius : 0 })
      });
    }
    fireEvent48(series, "afterTranslate");
  }
};
HeatmapSeries.defaultOptions = merge90(ScatterSeries4.defaultOptions, HeatmapSeriesDefaults_default);
addEvent84(HeatmapSeries, "afterDataClassLegendClick", function() {
  this.isDirtyCanvas = true;
  this.drawPoints();
});
extend76(HeatmapSeries.prototype, {
  axisTypes: ColorMapComposition_default.seriesMembers.axisTypes,
  colorKey: ColorMapComposition_default.seriesMembers.colorKey,
  directTouch: true,
  getExtremesFromAll: true,
  keysAffectYAxis: ["y"],
  parallelArrays: ColorMapComposition_default.seriesMembers.parallelArrays,
  pointArrayMap: ["y", "value"],
  pointClass: HeatmapPoint_default,
  specialGroup: "group",
  trackerGroups: ColorMapComposition_default.seriesMembers.trackerGroups,
  /**
   * @private
   */
  alignDataLabel: ColumnSeries11.prototype.alignDataLabel,
  colorAttribs: ColorMapComposition_default.seriesMembers.colorAttribs,
  getSymbol: Series9.prototype.getSymbol
});
ColorMapComposition_default.compose(HeatmapSeries);
SeriesRegistry_default.registerSeriesType("heatmap", HeatmapSeries);

// node_modules/highcharts/es-modules/Core/Axis/SolidGaugeAxis.js
var { extend: extend77 } = Utilities_default;
function init2(axis) {
  extend77(axis, ColorAxisLike_default);
}
var SolidGaugeAxis = {
  init: init2
};
var SolidGaugeAxis_default = SolidGaugeAxis;

// node_modules/highcharts/es-modules/Series/SolidGauge/SolidGaugeSeriesDefaults.js
var SolidGaugeSeriesDefaults = {
  /**
   * The inner radius for points in a solid gauge. Can be given only in
   * percentage, either as a number or a string like `"50%"`.
   *
   * @sample {highcharts} highcharts/plotoptions/solidgauge-radius/
   *         Individual radius and innerRadius
   *
   * @type      {string}
   * @default   "60%"
   * @since     4.1.6
   * @product   highcharts
   * @apioption plotOptions.solidgauge.innerRadius
   */
  /**
   * Whether the strokes of the solid gauge should be `round` or `square`.
   *
   * @sample {highcharts} highcharts/demo/gauge-multiple-kpi/
   *         Rounded gauge
   *
   * @type       {string}
   * @default    round
   * @since      4.2.2
   * @product    highcharts
   * @validvalue ["square", "round"]
   * @apioption  plotOptions.solidgauge.linecap
   */
  /**
   * Allow the gauge to overshoot the end of the perimeter axis by this
   * many degrees. Say if the gauge axis goes from 0 to 60, a value of
   * 100, or 1000, will show 5 degrees beyond the end of the axis when this
   * option is set to 5.
   *
   * @type      {number}
   * @default   0
   * @since     3.0.10
   * @product   highcharts
   * @apioption plotOptions.solidgauge.overshoot
   */
  /**
   * The outer radius for points in a solid gauge. Can be given only in
   * percentage, either as a number or a string like `"100%"`.
   *
   * @sample {highcharts} highcharts/plotoptions/solidgauge-radius/
   *         Individual radius and innerRadius
   *
   * @type      {string}
   * @default   "100%"
   * @since     4.1.6
   * @product   highcharts
   * @apioption plotOptions.solidgauge.radius
   */
  /**
   * Whether to draw rounded edges on the gauge. This options adds the radius
   * of the rounding to the ends of the arc, so it extends past the actual
   * values. When `borderRadius` is set, it takes precedence over `rounded`. A
   * `borderRadius` of 50% behaves like `rounded`, except the shape is not
   * extended past its value.
   *
   * @sample {highcharts} highcharts/demo/gauge-multiple-kpi/
   *         Gauge showing multiple KPIs
   *
   * @type      {boolean}
   * @default   false
   * @since     5.0.8
   * @product   highcharts
   * @apioption plotOptions.solidgauge.rounded
   */
  /**
   * The threshold or base level for the gauge.
   *
   * @sample {highcharts} highcharts/plotoptions/solidgauge-threshold/
   *         Zero threshold with negative and positive values
   *
   * @type      {number|null}
   * @since     5.0.3
   * @product   highcharts
   * @apioption plotOptions.solidgauge.threshold
   */
  /**
   * Whether to give each point an individual color.
   */
  colorByPoint: true,
  dataLabels: {
    y: 0
  }
};
var SolidGaugeSeriesDefaults_default = SolidGaugeSeriesDefaults;

// node_modules/highcharts/es-modules/Series/SolidGauge/SolidGaugeSeries.js
var { gauge: GaugeSeries2, pie: PieSeries4 } = SeriesRegistry_default.seriesTypes;
var { clamp: clamp20, extend: extend78, isNumber: isNumber62, merge: merge91, pick: pick99, pInt: pInt9 } = Utilities_default;
var SolidGaugeSeries = class extends GaugeSeries2 {
  /* *
   *
   *  Functions
   *
   * */
  // Extend the translate function to extend the Y axis with the necessary
  // decoration (#5895).
  translate() {
    const axis = this.yAxis;
    SolidGaugeAxis_default.init(axis);
    if (!axis.dataClasses && axis.options.dataClasses) {
      axis.initDataClasses(axis.options);
    }
    axis.initStops();
    GaugeSeries2.prototype.translate.call(this);
  }
  // Draw the points where each point is one needle.
  drawPoints() {
    const series = this, yAxis2 = series.yAxis, center = yAxis2.center, options2 = series.options, renderer = series.chart.renderer, overshoot = options2.overshoot, rounded = options2.rounded && options2.borderRadius === void 0, overshootVal = isNumber62(overshoot) ? overshoot / 180 * Math.PI : 0;
    let thresholdAngleRad;
    if (isNumber62(options2.threshold)) {
      thresholdAngleRad = yAxis2.startAngleRad + yAxis2.translate(options2.threshold, void 0, void 0, void 0, true);
    }
    this.thresholdAngleRad = pick99(thresholdAngleRad, yAxis2.startAngleRad);
    for (const point of series.points) {
      if (!point.isNull) {
        const radius = pInt9(pick99(
          point.options.radius,
          options2.radius,
          100
          // %
        )) * center[2] / 200, innerRadius = pInt9(pick99(
          point.options.innerRadius,
          options2.innerRadius,
          60
          // %
        )) * center[2] / 200, axisMinAngle = Math.min(yAxis2.startAngleRad, yAxis2.endAngleRad), axisMaxAngle = Math.max(yAxis2.startAngleRad, yAxis2.endAngleRad);
        let graphic = point.graphic, rotation = yAxis2.startAngleRad + yAxis2.translate(point.y, void 0, void 0, void 0, true), shapeArgs, d, toColor = yAxis2.toColor(point.y, point);
        if (toColor === "none") {
          toColor = point.color || series.color || "none";
        }
        if (toColor !== "none") {
          point.color = toColor;
        }
        rotation = clamp20(rotation, axisMinAngle - overshootVal, axisMaxAngle + overshootVal);
        if (options2.wrap === false) {
          rotation = clamp20(rotation, axisMinAngle, axisMaxAngle);
        }
        const angleOfRounding = rounded ? (radius - innerRadius) / 2 / radius : 0, start = Math.min(rotation, series.thresholdAngleRad) - angleOfRounding;
        let end = Math.max(rotation, series.thresholdAngleRad) + angleOfRounding;
        if (end - start > 2 * Math.PI) {
          end = start + 2 * Math.PI;
        }
        let borderRadius = rounded ? "50%" : 0;
        if (options2.borderRadius) {
          borderRadius = BorderRadius_default.optionsToObject(options2.borderRadius).radius;
        }
        point.shapeArgs = shapeArgs = {
          x: center[0],
          y: center[1],
          r: radius,
          innerR: innerRadius,
          start,
          end,
          borderRadius
        };
        point.startR = radius;
        if (graphic) {
          d = shapeArgs.d;
          graphic.animate(extend78({ fill: toColor }, shapeArgs));
          if (d) {
            shapeArgs.d = d;
          }
        } else {
          point.graphic = graphic = renderer.arc(shapeArgs).attr({
            fill: toColor,
            "sweep-flag": 0
          }).add(series.group);
        }
        if (!series.chart.styledMode) {
          if (options2.linecap !== "square") {
            graphic.attr({
              "stroke-linecap": "round",
              "stroke-linejoin": "round"
            });
          }
          graphic.attr({
            stroke: options2.borderColor || "none",
            "stroke-width": options2.borderWidth || 0
          });
        }
        if (graphic) {
          graphic.addClass(point.getClassName(), true);
        }
      }
    }
  }
  // Extend the pie slice animation by animating from start angle and up.
  animate(init3) {
    if (!init3) {
      this.startAngleRad = this.thresholdAngleRad;
      PieSeries4.prototype.animate.call(this, init3);
    }
  }
};
SolidGaugeSeries.defaultOptions = merge91(GaugeSeries2.defaultOptions, SolidGaugeSeriesDefaults_default);
SeriesRegistry_default.registerSeriesType("solidgauge", SolidGaugeSeries);

// node_modules/highcharts/es-modules/Series/Treemap/TreemapAlgorithmGroup.js
var TreemapAlgorithmGroup = class {
  /* *
   *
   *  Constructor
   *
   * */
  constructor(h, w, d, p) {
    this.height = h;
    this.width = w;
    this.plot = p;
    this.direction = d;
    this.startDirection = d;
    this.total = 0;
    this.nW = 0;
    this.lW = 0;
    this.nH = 0;
    this.lH = 0;
    this.elArr = [];
    this.lP = {
      total: 0,
      lH: 0,
      nH: 0,
      lW: 0,
      nW: 0,
      nR: 0,
      lR: 0,
      aspectRatio: function(w2, h2) {
        return Math.max(w2 / h2, h2 / w2);
      }
    };
  }
  /* *
   *
   *  Functions
   *
   * */
  addElement(el) {
    this.lP.total = this.elArr[this.elArr.length - 1];
    this.total = this.total + el;
    if (this.direction === 0) {
      this.lW = this.nW;
      this.lP.lH = this.lP.total / this.lW;
      this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH);
      this.nW = this.total / this.height;
      this.lP.nH = this.lP.total / this.nW;
      this.lP.nR = this.lP.aspectRatio(this.nW, this.lP.nH);
    } else {
      this.lH = this.nH;
      this.lP.lW = this.lP.total / this.lH;
      this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH);
      this.nH = this.total / this.width;
      this.lP.nW = this.lP.total / this.nH;
      this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH);
    }
    this.elArr.push(el);
  }
  reset() {
    this.nW = 0;
    this.lW = 0;
    this.elArr = [];
    this.total = 0;
  }
};
var TreemapAlgorithmGroup_default = TreemapAlgorithmGroup;

// node_modules/highcharts/es-modules/Series/Treemap/TreemapNode.js
var TreemapNode = class {
  constructor() {
    this.childrenTotal = 0;
    this.visible = false;
  }
  /* *
   *
   *  Functions
   *
   * */
  init(id, i, children, height, level, series, parent) {
    this.id = id;
    this.i = i;
    this.children = children;
    this.height = height;
    this.level = level;
    this.series = series;
    this.parent = parent;
    return this;
  }
};
var TreemapNode_default = TreemapNode;

// node_modules/highcharts/es-modules/Series/DrawPointUtilities.js
function draw(point, params) {
  const { animatableAttribs, onComplete, css: css19, renderer } = params;
  const animation = point.series && point.series.chart.hasRendered ? (
    // Chart-level animation on updates
    void 0
  ) : (
    // Series-level animation on new points
    point.series && point.series.options.animation
  );
  let graphic = point.graphic;
  params.attribs = {
    ...params.attribs,
    "class": point.getClassName()
  };
  if (point.shouldDraw()) {
    if (!graphic) {
      if (params.shapeType === "text") {
        graphic = renderer.text();
      } else if (params.shapeType === "image") {
        graphic = renderer.image(params.imageUrl || "").attr(params.shapeArgs || {});
      } else {
        graphic = renderer[params.shapeType](params.shapeArgs || {});
      }
      point.graphic = graphic;
      graphic.add(params.group);
    }
    if (css19) {
      graphic.css(css19);
    }
    graphic.attr(params.attribs).animate(animatableAttribs, params.isNew ? false : animation, onComplete);
  } else if (graphic) {
    const destroy = () => {
      point.graphic = graphic = graphic && graphic.destroy();
      if (typeof onComplete === "function") {
        onComplete();
      }
    };
    if (Object.keys(animatableAttribs).length) {
      graphic.animate(animatableAttribs, void 0, () => destroy());
    } else {
      destroy();
    }
  }
}
var DrawPointUtilities = {
  draw
};
var DrawPointUtilities_default = DrawPointUtilities;

// node_modules/highcharts/es-modules/Series/Treemap/TreemapPoint.js
var { pie: { prototype: { pointClass: PiePoint3 } }, scatter: { prototype: { pointClass: ScatterPoint4 } } } = SeriesRegistry_default.seriesTypes;
var { extend: extend79, isNumber: isNumber63, pick: pick100 } = Utilities_default;
var TreemapPoint = class extends ScatterPoint4 {
  constructor() {
    super(...arguments);
    this.groupedPointsAmount = 0;
    this.shapeType = "rect";
  }
  /* *
   *
   *  Functions
   *
   * */
  draw(params) {
    DrawPointUtilities_default.draw(this, params);
  }
  getClassName() {
    const series = this.series, options2 = series.options;
    let className = super.getClassName();
    if (this.node.level <= series.nodeMap[series.rootNode].level && this.node.children.length) {
      className += " highcharts-above-level";
    } else if (!this.node.isGroup && !this.node.isLeaf && !series.nodeMap[series.rootNode].isGroup && !pick100(options2.interactByLeaf, !options2.allowTraversingTree)) {
      className += " highcharts-internal-node-interactive";
    } else if (!this.node.isGroup && !this.node.isLeaf && !series.nodeMap[series.rootNode].isGroup) {
      className += " highcharts-internal-node";
    }
    return className;
  }
  /**
   * A tree point is valid if it has han id too, assume it may be a parent
   * item.
   *
   * @private
   * @function Highcharts.Point#isValid
   */
  isValid() {
    return Boolean(this.id || isNumber63(this.value));
  }
  setState(state) {
    super.setState.apply(this, arguments);
    if (this.graphic) {
      this.graphic.attr({
        zIndex: state === "hover" ? 1 : 0
      });
    }
  }
  shouldDraw() {
    return isNumber63(this.plotY) && this.y !== null;
  }
};
extend79(TreemapPoint.prototype, {
  setVisible: PiePoint3.prototype.setVisible
});
var TreemapPoint_default = TreemapPoint;

// node_modules/highcharts/es-modules/Series/Treemap/TreemapSeriesDefaults.js
var { isString: isString20 } = Utilities_default;
var TreemapSeriesDefaults = {
  /**
   * When enabled the user can click on a point which is a parent and
   * zoom in on its children. Deprecated and replaced by
   * [allowTraversingTree](#plotOptions.treemap.allowTraversingTree).
   *
   * @sample {highcharts} highcharts/plotoptions/treemap-allowdrilltonode/
   *         Enabled
   *
   * @deprecated
   * @type      {boolean}
   * @default   false
   * @since     4.1.0
   * @product   highcharts
   * @apioption plotOptions.treemap.allowDrillToNode
   */
  /**
   * When enabled the user can click on a point which is a parent and
   * zoom in on its children.
   *
   * @sample {highcharts} highcharts/plotoptions/treemap-allowtraversingtree/
   *         Enabled
   * @sample {highcharts} highcharts/plotoptions/treemap-grouping-traversing/
   *         Traversing to Grouped Points node
   *
   * @since     7.0.3
   * @product   highcharts
   */
  allowTraversingTree: false,
  animationLimit: 250,
  /**
   * The border radius for each treemap item.
   */
  borderRadius: 0,
  /**
   * Options for the breadcrumbs, the navigation at the top leading the
   * way up through the traversed levels.
   *
   *
   * @since 10.0.0
   * @product   highcharts
   * @extends   navigation.breadcrumbs
   * @apioption plotOptions.treemap.breadcrumbs
   */
  /**
   * When the series contains less points than the crop threshold, all
   * points are drawn, event if the points fall outside the visible plot
   * area at the current zoom. The advantage of drawing all points
   * (including markers and columns), is that animation is performed on
   * updates. On the other hand, when the series contains more points than
   * the crop threshold, the series data is cropped to only contain points
   * that fall within the plot area. The advantage of cropping away
   * invisible points is to increase performance on large series.
   *
   * @type      {number}
   * @default   300
   * @since     4.1.0
   * @product   highcharts
   * @apioption plotOptions.treemap.cropThreshold
   */
  /**
   * Fires on a request for change of root node for the tree, before the
   * update is made. An event object is passed to the function, containing
   * additional properties `newRootId`, `previousRootId`, `redraw` and
   * `trigger`.
   *
   * @sample {highcharts} highcharts/plotoptions/treemap-events-setrootnode/
   *         Alert update information on setRootNode event.
   *
   * @type {Function}
   * @default undefined
   * @since 7.0.3
   * @product highcharts
   * @apioption plotOptions.treemap.events.setRootNode
   */
  /**
   * This option decides if the user can interact with the parent nodes
   * or just the leaf nodes. When this option is undefined, it will be
   * true by default. However when allowTraversingTree is true, then it
   * will be false by default.
   *
   * @sample {highcharts} highcharts/plotoptions/treemap-interactbyleaf-false/
   *         False
   * @sample {highcharts} highcharts/plotoptions/treemap-interactbyleaf-true-and-allowtraversingtree/
   *         InteractByLeaf and allowTraversingTree is true
   *
   * @type      {boolean}
   * @since     4.1.2
   * @product   highcharts
   * @apioption plotOptions.treemap.interactByLeaf
   */
  /**
   * The sort index of the point inside the treemap level.
   *
   * @sample {highcharts} highcharts/plotoptions/treemap-sortindex/
   *         Sort by years
   *
   * @type      {number}
   * @since     4.1.10
   * @product   highcharts
   * @apioption plotOptions.treemap.sortIndex
   */
  /**
   * A series specific or series type specific color set to apply instead
   * of the global [colors](#colors) when
   * [colorByPoint](#plotOptions.treemap.colorByPoint) is true.
   *
   * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
   * @since     3.0
   * @product   highcharts
   * @apioption plotOptions.treemap.colors
   */
  /**
   * Whether to display this series type or specific series item in the
   * legend.
   */
  showInLegend: false,
  /**
   * @ignore-option
   */
  marker: void 0,
  /**
   * When using automatic point colors pulled from the `options.colors`
   * collection, this option determines whether the chart should receive
   * one color per series or one color per point.
   *
   * @see [series colors](#plotOptions.treemap.colors)
   *
   * @since     2.0
   * @product   highcharts
   * @apioption plotOptions.treemap.colorByPoint
   */
  colorByPoint: false,
  /**
   * @since 4.1.0
   */
  dataLabels: {
    enabled: true,
    formatter: function() {
      const point = this && this.point ? this.point : {}, name = isString20(point.name) ? point.name : "";
      return name;
    },
    /**
     * Whether the data label should act as a group-level header. For leaf
     * nodes, headers are not supported and the data label will be rendered
     * inside.
     *
     * @sample {highcharts} highcharts/series-treemap/headers
     *         Headers for parent nodes
     *
     * @since 12.2.0
     */
    headers: false,
    inside: true,
    padding: 2,
    verticalAlign: "middle",
    style: {
      textOverflow: "ellipsis"
    }
  },
  tooltip: {
    headerFormat: "",
    pointFormat: "<b>{point.name}</b>: {point.value}<br/>",
    /**
     * The HTML of the grouped point's nodes in the tooltip. Works only for
     * Treemap series grouping and analogously to
     * [pointFormat](#tooltip.pointFormat).
     *
     * The grouped nodes point tooltip can be also formatted using
     * `tooltip.formatter` callback function and `point.isGroupNode` flag.
     *
     * @type      {string}
     * @default   '+ {point.groupedPointsAmount} more...'
     * @apioption tooltip.clusterFormat
     */
    clusterFormat: "+ {point.groupedPointsAmount} more...<br/>"
  },
  /**
   * Whether to ignore hidden points when the layout algorithm runs.
   * If `false`, hidden points will leave open spaces.
   *
   * @since 5.0.8
   */
  ignoreHiddenPoint: true,
  /**
   * This option decides which algorithm is used for setting position
   * and dimensions of the points.
   *
   * @see [How to write your own algorithm](https://www.highcharts.com/docs/chart-and-series-types/treemap)
   *
   * @sample {highcharts} highcharts/plotoptions/treemap-layoutalgorithm-sliceanddice/
   *         SliceAndDice by default
   * @sample {highcharts} highcharts/plotoptions/treemap-layoutalgorithm-stripes/
   *         Stripes
   * @sample {highcharts} highcharts/plotoptions/treemap-layoutalgorithm-squarified/
   *         Squarified
   * @sample {highcharts} highcharts/plotoptions/treemap-layoutalgorithm-strip/
   *         Strip
   *
   * @since      4.1.0
   * @validvalue ["sliceAndDice", "stripes", "squarified", "strip"]
   */
  layoutAlgorithm: "sliceAndDice",
  /**
   * Defines which direction the layout algorithm will start drawing.
   *
   * @since       4.1.0
   * @validvalue ["vertical", "horizontal"]
   */
  layoutStartingDirection: "vertical",
  /**
   * Enabling this option will make the treemap alternate the drawing
   * direction between vertical and horizontal. The next levels starting
   * direction will always be the opposite of the previous.
   *
   * @sample {highcharts} highcharts/plotoptions/treemap-alternatestartingdirection-true/
   *         Enabled
   *
   * @since 4.1.0
   */
  alternateStartingDirection: false,
  /**
   * Used together with the levels and allowTraversingTree options. When
   * set to false the first level visible to be level one, which is
   * dynamic when traversing the tree. Otherwise the level will be the
   * same as the tree structure.
   *
   * @since 4.1.0
   */
  levelIsConstant: true,
  /**
   * Options for the button appearing when traversing down in a treemap.
   *
   * Since v9.3.3 the `traverseUpButton` is replaced by `breadcrumbs`.
   *
   * @deprecated
   */
  traverseUpButton: {
    /**
     * The position of the button.
     */
    position: {
      /**
       * Vertical alignment of the button.
       *
       * @type      {Highcharts.VerticalAlignValue}
       * @default   top
       * @product   highcharts
       * @apioption plotOptions.treemap.traverseUpButton.position.verticalAlign
       */
      /**
       * Horizontal alignment of the button.
       *
       * @type {Highcharts.AlignValue}
       */
      align: "right",
      /**
       * Horizontal offset of the button.
       */
      x: -10,
      /**
       * Vertical offset of the button.
       */
      y: 10
    }
  },
  /**
   * Group padding for parent elements in terms of pixels. See also the
   * `nodeSizeBy` option that controls how the leaf nodes' size is affected by
   * the padding.
   *
   * @sample    {highcharts} highcharts/series-treemap/grouppadding/
   *            Group padding
   * @type      {number}
   * @since 12.2.0
   * @product   highcharts
   * @apioption plotOptions.treemap.groupPadding
   */
  /**
   * Set options on specific levels. Takes precedence over series options,
   * but not point options.
   *
   * @sample {highcharts} highcharts/plotoptions/treemap-levels/
   *         Styling dataLabels and borders
   * @sample {highcharts} highcharts/demo/treemap-with-levels/
   *         Different layoutAlgorithm
   *
   * @type      {Array<*>}
   * @since     4.1.0
   * @product   highcharts
   * @apioption plotOptions.treemap.levels
   */
  /**
   * Experimental. How to set the size of child nodes when a header or padding
   * is present. When `leaf`, the group is expanded to make room for headers
   * and padding in order to preserve the relative sizes between leaves. When
   * `group`, the leaves are navely fit into the remaining area after the
   * header and padding are subtracted.
   *
   * @sample    {highcharts} highcharts/series-treemap/nodesizeby/
   *            Node sizing
   * @since 12.2.0
   * @type      {string}
   * @validvalue ["group", "leaf"]
   * @default   group
   * @apioption plotOptions.treemap.nodeSizeBy
   */
  /**
   * Can set a `borderColor` on all points which lies on the same level.
   *
   * @type      {Highcharts.ColorString}
   * @since     4.1.0
   * @product   highcharts
   * @apioption plotOptions.treemap.levels.borderColor
   */
  /**
   * Set the dash style of the border of all the point which lies on the
   * level. See
   * [plotOptions.scatter.dashStyle](#plotoptions.scatter.dashstyle)
   * for possible options.
   *
   * @type      {Highcharts.DashStyleValue}
   * @since     4.1.0
   * @product   highcharts
   * @apioption plotOptions.treemap.levels.borderDashStyle
   */
  /**
   * Can set the borderWidth on all points which lies on the same level.
   *
   * @type      {number}
   * @since     4.1.0
   * @product   highcharts
   * @apioption plotOptions.treemap.levels.borderWidth
   */
  /**
   * Can set a color on all points which lies on the same level.
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     4.1.0
   * @product   highcharts
   * @apioption plotOptions.treemap.levels.color
   */
  /**
   * A configuration object to define how the color of a child varies from
   * the parent's color. The variation is distributed among the children
   * of node. For example when setting brightness, the brightness change
   * will range from the parent's original brightness on the first child,
   * to the amount set in the `to` setting on the last node. This allows a
   * gradient-like color scheme that sets children out from each other
   * while highlighting the grouping on treemaps and sectors on sunburst
   * charts.
   *
   * @sample highcharts/demo/sunburst/
   *         Sunburst with color variation
   *
   * @sample highcharts/series-treegraph/color-variation
   *         Treegraph nodes with color variation
   *
   * @since     6.0.0
   * @product   highcharts
   * @apioption plotOptions.treemap.levels.colorVariation
   */
  /**
   * The key of a color variation. Currently supports `brightness` only.
   *
   * @type       {string}
   * @since      6.0.0
   * @product    highcharts
   * @validvalue ["brightness"]
   * @apioption  plotOptions.treemap.levels.colorVariation.key
   */
  /**
   * The ending value of a color variation. The last sibling will receive
   * this value.
   *
   * @type      {number}
   * @since     6.0.0
   * @product   highcharts
   * @apioption plotOptions.treemap.levels.colorVariation.to
   */
  /**
   * Can set the options of dataLabels on each point which lies on the
   * level.
   * [plotOptions.treemap.dataLabels](#plotOptions.treemap.dataLabels) for
   * possible values.
   *
   * @extends   plotOptions.treemap.dataLabels
   * @since     4.1.0
   * @product   highcharts
   * @apioption plotOptions.treemap.levels.dataLabels
   */
  /**
   * Can set the layoutAlgorithm option on a specific level.
   *
   * @type       {string}
   * @since      4.1.0
   * @product    highcharts
   * @validvalue ["sliceAndDice", "stripes", "squarified", "strip"]
   * @apioption  plotOptions.treemap.levels.layoutAlgorithm
   */
  /**
   * Can set the layoutStartingDirection option on a specific level.
   *
   * @type       {string}
   * @since      4.1.0
   * @product    highcharts
   * @validvalue ["vertical", "horizontal"]
   * @apioption  plotOptions.treemap.levels.layoutStartingDirection
   */
  /**
   * Decides which level takes effect from the options set in the levels
   * object.
   *
   * @sample {highcharts} highcharts/plotoptions/treemap-levels/
   *         Styling of both levels
   *
   * @type      {number}
   * @since     4.1.0
   * @product   highcharts
   * @apioption plotOptions.treemap.levels.level
   */
  // Presentational options
  /**
   * The color of the border surrounding each tree map item.
   *
   * @type {Highcharts.ColorString}
   */
  borderColor: "#e6e6e6",
  /**
   * The width of the border surrounding each tree map item.
   */
  borderWidth: 1,
  colorKey: "colorValue",
  /**
   * The opacity of grouped points in treemap. When a point has children, the
   * group point is covering the children, and is given this opacity. The
   * visibility of the children is determined by the opacity.
   *
   * @since 4.2.4
   */
  opacity: 0.15,
  /**
   * A wrapper object for all the series options in specific states.
   *
   * @extends plotOptions.heatmap.states
   */
  states: {
    /**
     * Options for the hovered series
     *
     * @extends   plotOptions.heatmap.states.hover
     * @excluding halo
     */
    hover: {
      /**
       * The border color for the hovered state.
       */
      borderColor: "#999999",
      /**
       * Brightness for the hovered point. Defaults to 0 if the
       * heatmap series is loaded first, otherwise 0.1.
       *
       * @type    {number}
       * @default undefined
       */
      brightness: SeriesRegistry_default.seriesTypes.heatmap ? 0 : 0.1,
      /**
       * @extends plotOptions.heatmap.states.hover.halo
       */
      halo: false,
      /**
       * The opacity of a point in treemap. When a point has children,
       * the visibility of the children is determined by the opacity.
       *
       * @since 4.2.4
       */
      opacity: 0.75,
      /**
       * The shadow option for hovered state.
       */
      shadow: false
    }
  },
  legendSymbol: "rectangle",
  /**
   * This option enables automatic traversing to the last child level upon
   * node interaction. This feature simplifies navigation by immediately
   * focusing on the deepest layer of the data structure without intermediate
   * steps.
   *
   * @sample {highcharts} highcharts/plotoptions/treemap-traverse-to-leaf/
   *         Traverse to leaf enabled
   *
   * @since   11.4.4
   *
   * @product highcharts
   */
  traverseToLeaf: false,
  /**
   * An option to optimize treemap series rendering by grouping smaller leaf
   * nodes below a certain square area threshold in pixels. If the square area
   * of a point becomes smaller than the specified threshold, determined by
   * the `pixelWidth` and/or `pixelHeight` options, then this point is moved
   * into one group point per series.
   *
   * @sample {highcharts} highcharts/plotoptions/treemap-grouping-simple
   *         Simple demo of Treemap grouping
   * @sample {highcharts} highcharts/plotoptions/treemap-grouping-multiple-parents
   *         Treemap grouping with multiple parents
   * @sample {highcharts} highcharts/plotoptions/treemap-grouping-advanced
   *         Advanced demo of Treemap grouping
   *
   * @since 12.1.0
   *
   * @excluding allowOverlap, animation, dataLabels, drillToCluster, events,
   * layoutAlgorithm, marker, states, zones
   *
   * @product highcharts
   */
  cluster: {
    /**
     * An additional, individual class name for the grouped point's graphic
     * representation.
     *
     * @type      string
     * @product   highcharts
     */
    className: void 0,
    /**
     * Individual color for the grouped point. By default the color is
     * pulled from the parent color.
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @product   highcharts
     */
    color: void 0,
    /**
     * Enable or disable Treemap grouping.
     *
     * @type {boolean}
     * @since 12.1.0
     * @product highcharts
     */
    enabled: false,
    /**
     * The pixel threshold width of area, which is used in Treemap grouping.
     *
     * @type {number}
     * @since 12.1.0
     * @product highcharts
     */
    pixelWidth: void 0,
    /**
     * The pixel threshold height of area, which is used in Treemap
     * grouping.
     *
     * @type {number}
     * @since 12.1.0
     * @product highcharts
     */
    pixelHeight: void 0,
    /**
     * The name of the point of grouped nodes shown in the tooltip,
     * dataLabels, etc. By default it is set to '+ n', where n is number of
     * grouped points.
     *
     * @type {string}
     * @since 12.1.0
     * @product highcharts
     */
    name: void 0,
    /**
     * A configuration property that specifies the factor by which the value
     * and size of a grouped node are reduced. This can be particularly
     * useful when a grouped node occupies a disproportionately large
     * portion of the graph, ensuring better visual balance and readability.
     *
     * @type {number}
     * @since 12.1.0
     * @product highcharts
     */
    reductionFactor: void 0,
    /**
     * Defines the minimum number of child nodes required to create a group
     * of small nodes.
     *
     * @type {number}
     * @since 12.1.0
     * @product highcharts
     */
    minimumClusterSize: 5,
    layoutAlgorithm: {
      distance: 0,
      gridSize: 0,
      kmeansThreshold: 0
    },
    marker: {
      lineWidth: 0,
      radius: 0
    }
  }
};
var TreemapSeriesDefaults_default = TreemapSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Treemap/TreemapUtilities.js
var TreemapUtilities;
(function(TreemapUtilities2) {
  function recursive(item, func, context) {
    const next = func.call(context || this, item);
    if (next !== false) {
      recursive(next, func, context);
    }
  }
  TreemapUtilities2.recursive = recursive;
})(TreemapUtilities || (TreemapUtilities = {}));
var TreemapUtilities_default = TreemapUtilities;

// node_modules/highcharts/es-modules/Series/TreeUtilities.js
var { extend: extend80, isArray: isArray24, isNumber: isNumber64, isObject: isObject19, merge: merge92, pick: pick101, relativeLength: relativeLength15 } = Utilities_default;
function getColor(node, options2) {
  const index = options2.index, mapOptionsToLevel = options2.mapOptionsToLevel, parentColor = options2.parentColor, parentColorIndex = options2.parentColorIndex, series = options2.series, colors = options2.colors, siblings = options2.siblings, points = series.points, chartOptionsChart = series.chart.options.chart;
  let getColorByPoint, point, level, colorByPoint, colorIndexByPoint, color14, colorIndex;
  const variateColor = (color15) => {
    const colorVariation = level && level.colorVariation;
    if (colorVariation && colorVariation.key === "brightness" && index && siblings) {
      return Color_default.parse(color15).brighten(colorVariation.to * (index / siblings)).get();
    }
    return color15;
  };
  if (node) {
    point = points[node.i];
    level = mapOptionsToLevel[node.level] || {};
    getColorByPoint = point && level.colorByPoint;
    if (getColorByPoint) {
      colorIndexByPoint = point.index % (colors ? colors.length : chartOptionsChart.colorCount);
      colorByPoint = colors && colors[colorIndexByPoint];
    }
    if (!series.chart.styledMode) {
      color14 = pick101(point && point.options.color, level && level.color, colorByPoint, parentColor && variateColor(parentColor), series.color);
    }
    colorIndex = pick101(point && point.options.colorIndex, level && level.colorIndex, colorIndexByPoint, parentColorIndex, options2.colorIndex);
  }
  return {
    color: color14,
    colorIndex
  };
}
function getLevelOptions(params) {
  const result = {};
  let defaults, converted, i, from, to, levels;
  if (isObject19(params)) {
    from = isNumber64(params.from) ? params.from : 1;
    levels = params.levels;
    converted = {};
    defaults = isObject19(params.defaults) ? params.defaults : {};
    if (isArray24(levels)) {
      converted = levels.reduce((obj, item) => {
        let level, levelIsConstant, options2;
        if (isObject19(item) && isNumber64(item.level)) {
          options2 = merge92({}, item);
          levelIsConstant = pick101(options2.levelIsConstant, defaults.levelIsConstant);
          delete options2.levelIsConstant;
          delete options2.level;
          level = item.level + (levelIsConstant ? 0 : from - 1);
          if (isObject19(obj[level])) {
            merge92(true, obj[level], options2);
          } else {
            obj[level] = options2;
          }
        }
        return obj;
      }, {});
    }
    to = isNumber64(params.to) ? params.to : 1;
    for (i = 0; i <= to; i++) {
      result[i] = merge92({}, defaults, isObject19(converted[i]) ? converted[i] : {});
    }
  }
  return result;
}
function setTreeValues(tree, options2) {
  const before = options2.before, idRoot = options2.idRoot, mapIdToNode = options2.mapIdToNode, nodeRoot = mapIdToNode[idRoot], levelIsConstant = options2.levelIsConstant !== false, points = options2.points, point = points[tree.i], optionsPoint = point && point.options || {}, children = [];
  let childrenTotal = 0;
  tree.levelDynamic = tree.level - (levelIsConstant ? 0 : nodeRoot.level);
  tree.name = pick101(point && point.name, "");
  tree.visible = idRoot === tree.id || options2.visible === true;
  if (typeof before === "function") {
    tree = before(tree, options2);
  }
  tree.children.forEach((child, i) => {
    const newOptions = extend80({}, options2);
    extend80(newOptions, {
      index: i,
      siblings: tree.children.length,
      visible: tree.visible
    });
    child = setTreeValues(child, newOptions);
    children.push(child);
    if (child.visible) {
      childrenTotal += child.val;
    }
  });
  const value = pick101(optionsPoint.value, childrenTotal);
  tree.visible = value >= 0 && (childrenTotal > 0 || tree.visible);
  tree.children = children;
  tree.childrenTotal = childrenTotal;
  tree.isLeaf = tree.visible && !childrenTotal;
  tree.val = value;
  return tree;
}
function updateRootId(series) {
  let rootId, options2;
  if (isObject19(series)) {
    options2 = isObject19(series.options) ? series.options : {};
    rootId = pick101(series.rootNode, options2.rootId, "");
    if (isObject19(series.userOptions)) {
      series.userOptions.rootId = rootId;
    }
    series.rootNode = rootId;
  }
  return rootId;
}
function getNodeWidth(series, columnCount) {
  const { chart, options: options2 } = series, { nodeDistance = 0, nodeWidth = 0 } = options2, { plotSizeX = 1 } = chart;
  if (nodeWidth === "auto") {
    if (typeof nodeDistance === "string" && /%$/.test(nodeDistance)) {
      const fraction = parseFloat(nodeDistance) / 100, total = columnCount + fraction * (columnCount - 1);
      return plotSizeX / total;
    }
    const nDistance = Number(nodeDistance);
    return (plotSizeX + nDistance) / (columnCount || 1) - nDistance;
  }
  return relativeLength15(nodeWidth, plotSizeX);
}
var TreeUtilities = {
  getColor,
  getLevelOptions,
  getNodeWidth,
  setTreeValues,
  updateRootId
};
var TreeUtilities_default = TreeUtilities;

// node_modules/highcharts/es-modules/Series/Treemap/TreemapSeries.js
var { parse: color11 } = Color_default;
var { composed: composed33, noop: noop19 } = Globals_default;
var { column: ColumnSeries12, scatter: ScatterSeries5 } = SeriesRegistry_default.seriesTypes;
var { getColor: getColor2, getLevelOptions: getLevelOptions2, updateRootId: updateRootId2 } = TreeUtilities_default;
var { addEvent: addEvent85, arrayMax: arrayMax11, clamp: clamp21, correctFloat: correctFloat16, crisp: crisp14, defined: defined70, error: error10, extend: extend81, fireEvent: fireEvent49, isArray: isArray25, isNumber: isNumber65, isObject: isObject20, isString: isString21, merge: merge93, pick: pick102, pushUnique: pushUnique36, splat: splat21, stableSort: stableSort8 } = Utilities_default;
Series_default.keepProps.push("simulation", "hadOutsideDataLabels");
var axisMax = 100;
var treemapAxisDefaultValues = false;
function onSeriesAfterBindAxes() {
  const series = this, xAxis2 = series.xAxis, yAxis2 = series.yAxis;
  let treeAxis;
  if (xAxis2 && yAxis2) {
    if (series.is("treemap")) {
      treeAxis = {
        endOnTick: false,
        gridLineWidth: 0,
        lineWidth: 0,
        min: 0,
        minPadding: 0,
        max: axisMax,
        maxPadding: 0,
        startOnTick: false,
        title: void 0,
        tickPositions: []
      };
      extend81(yAxis2.options, treeAxis);
      extend81(xAxis2.options, treeAxis);
      treemapAxisDefaultValues = true;
    } else if (treemapAxisDefaultValues) {
      yAxis2.setOptions(yAxis2.userOptions);
      xAxis2.setOptions(xAxis2.userOptions);
      treemapAxisDefaultValues = false;
    }
  }
}
var TreemapSeries = class extends ScatterSeries5 {
  constructor() {
    super(...arguments);
    this.simulation = 0;
  }
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(SeriesClass) {
    if (pushUnique36(composed33, "TreemapSeries")) {
      addEvent85(SeriesClass, "afterBindAxes", onSeriesAfterBindAxes);
    }
  }
  /* *
   *
   *  Function
   *
   * */
  /* eslint-disable valid-jsdoc */
  algorithmCalcPoints(directionChange, last, group, childrenArea) {
    const plot = group.plot, end = group.elArr.length - 1;
    let pX, pY, pW, pH, gW = group.lW, gH = group.lH, keep, i = 0;
    if (last) {
      gW = group.nW;
      gH = group.nH;
    } else {
      keep = group.elArr[end];
    }
    for (const p of group.elArr) {
      if (last || i < end) {
        if (group.direction === 0) {
          pX = plot.x;
          pY = plot.y;
          pW = gW;
          pH = p / pW;
        } else {
          pX = plot.x;
          pY = plot.y;
          pH = gH;
          pW = p / pH;
        }
        childrenArea.push({
          x: pX,
          y: pY,
          width: pW,
          height: correctFloat16(pH)
        });
        if (group.direction === 0) {
          plot.y = plot.y + pH;
        } else {
          plot.x = plot.x + pW;
        }
      }
      i = i + 1;
    }
    group.reset();
    if (group.direction === 0) {
      group.width = group.width - gW;
    } else {
      group.height = group.height - gH;
    }
    plot.y = plot.parent.y + (plot.parent.height - group.height);
    plot.x = plot.parent.x + (plot.parent.width - group.width);
    if (directionChange) {
      group.direction = 1 - group.direction;
    }
    if (!last) {
      group.addElement(keep);
    }
  }
  algorithmFill(directionChange, parent, children) {
    const childrenArea = [];
    let pTot, direction = parent.direction, x = parent.x, y = parent.y, width = parent.width, height = parent.height, pX, pY, pW, pH;
    for (const child of children) {
      pTot = parent.width * parent.height * (child.val / parent.val);
      pX = x;
      pY = y;
      if (direction === 0) {
        pH = height;
        pW = pTot / pH;
        width = width - pW;
        x = x + pW;
      } else {
        pW = width;
        pH = pTot / pW;
        height = height - pH;
        y = y + pH;
      }
      childrenArea.push({
        x: pX,
        y: pY,
        width: pW,
        height: pH,
        direction: 0,
        val: 0
      });
      if (directionChange) {
        direction = 1 - direction;
      }
    }
    return childrenArea;
  }
  algorithmLowAspectRatio(directionChange, parent, children) {
    const series = this, childrenArea = [], plot = {
      x: parent.x,
      y: parent.y,
      parent
    }, direction = parent.direction, end = children.length - 1, group = new TreemapAlgorithmGroup_default(parent.height, parent.width, direction, plot);
    let pTot, i = 0;
    for (const child of children) {
      pTot = parent.width * parent.height * (child.val / parent.val);
      group.addElement(pTot);
      if (group.lP.nR > group.lP.lR) {
        series.algorithmCalcPoints(
          directionChange,
          false,
          group,
          childrenArea,
          plot
          // @todo no supported
        );
      }
      if (i === end) {
        series.algorithmCalcPoints(
          directionChange,
          true,
          group,
          childrenArea,
          plot
          // @todo not supported
        );
      }
      ++i;
    }
    return childrenArea;
  }
  /**
   * Over the alignment method by setting z index.
   * @private
   */
  alignDataLabel(point, dataLabel, labelOptions) {
    ColumnSeries12.prototype.alignDataLabel.apply(this, arguments);
    if (point.dataLabel) {
      point.dataLabel.attr({ zIndex: (point.node.zIndex || 0) + 1 });
    }
  }
  applyTreeGrouping() {
    const series = this, parentList = series.parentList || {}, { cluster } = series.options, minimumClusterSize = cluster?.minimumClusterSize || 5;
    if (cluster?.enabled) {
      const parentGroups = {};
      const checkIfHide = (node) => {
        if (node?.point?.shapeArgs) {
          const { width = 0, height = 0 } = node.point.shapeArgs, area = width * height;
          const { pixelWidth = 0, pixelHeight = 0 } = cluster, compareHeight = defined70(pixelHeight), thresholdArea = pixelHeight ? pixelWidth * pixelHeight : pixelWidth * pixelWidth;
          if (width < pixelWidth || height < (compareHeight ? pixelHeight : pixelWidth) || area < thresholdArea) {
            if (!node.isGroup && defined70(node.parent)) {
              if (!parentGroups[node.parent]) {
                parentGroups[node.parent] = [];
              }
              parentGroups[node.parent].push(node);
            }
          }
        }
        node?.children.forEach((child) => {
          checkIfHide(child);
        });
      };
      checkIfHide(series.tree);
      for (const parent in parentGroups) {
        if (parentGroups[parent]) {
          if (parentGroups[parent].length > minimumClusterSize) {
            parentGroups[parent].forEach((node) => {
              const index = parentList[parent].indexOf(node.i);
              if (index !== -1) {
                parentList[parent].splice(index, 1);
                const id = `highcharts-grouped-treemap-points-${node.parent || "root"}`;
                let groupPoint = series.points.find((p) => p.id === id);
                if (!groupPoint) {
                  const PointClass = series.pointClass, pointIndex = series.points.length;
                  groupPoint = new PointClass(series, {
                    className: cluster.className,
                    color: cluster.color,
                    id,
                    index: pointIndex,
                    isGroup: true,
                    value: 0
                  });
                  extend81(groupPoint, {
                    formatPrefix: "cluster"
                  });
                  series.points.push(groupPoint);
                  parentList[parent].push(pointIndex);
                  parentList[id] = [];
                }
                const amount = groupPoint.groupedPointsAmount + 1, val = series.points[groupPoint.index].options.value || 0, name = cluster.name || `+ ${amount}`;
                series.points[groupPoint.index].groupedPointsAmount = amount;
                series.points[groupPoint.index].options.value = val + (node.point.value || 0);
                series.points[groupPoint.index].name = name;
                parentList[id].push(node.point.index);
              }
            });
          }
        }
      }
      series.nodeMap = {};
      series.nodeList = [];
      series.parentList = parentList;
      const tree = series.buildTree("", -1, 0, series.parentList);
      series.translate(tree);
    }
  }
  /**
   * Recursive function which calculates the area for all children of a
   * node.
   *
   * @private
   * @function Highcharts.Series#calculateChildrenAreas
   *
   * @param {Object} parent
   * The node which is parent to the children.
   *
   * @param {Object} area
   * The rectangular area of the parent.
   */
  calculateChildrenAreas(parent, area) {
    const series = this, options2 = series.options, mapOptionsToLevel = series.mapOptionsToLevel, level = mapOptionsToLevel[parent.level + 1], algorithm = pick102(level?.layoutAlgorithm && series[level?.layoutAlgorithm] && level.layoutAlgorithm, options2.layoutAlgorithm), alternate = options2.alternateStartingDirection, children = parent.children.filter((n) => parent.isGroup || !n.ignore), groupPadding = level?.groupPadding ?? options2.groupPadding ?? 0, rootNode = series.nodeMap[series.rootNode];
    if (!algorithm) {
      return;
    }
    let childrenValues = [], axisWidth = rootNode.pointValues?.width || 0, axisHeight = rootNode.pointValues?.height || 0;
    if (level?.layoutStartingDirection) {
      area.direction = level.layoutStartingDirection === "vertical" ? 0 : 1;
    }
    childrenValues = series[algorithm](area, children);
    let i = -1;
    for (const child of children) {
      const values = childrenValues[++i];
      if (child === rootNode) {
        axisWidth = axisWidth || values.width;
        axisHeight = values.height;
      }
      const groupPaddingXValues = groupPadding / (series.xAxis.len / axisHeight), groupPaddingYValues = groupPadding / (series.yAxis.len / axisHeight);
      child.values = merge93(values, {
        val: child.childrenTotal,
        direction: alternate ? 1 - area.direction : area.direction
      });
      if (child.children.length && child.point.dataLabels?.length) {
        const dlHeight = arrayMax11(child.point.dataLabels.map((dl) => dl.options?.headers && dl.height || 0)) / (series.yAxis.len / axisHeight);
        if (dlHeight < child.values.height / 2) {
          child.values.y += dlHeight;
          child.values.height -= dlHeight;
        }
      }
      if (groupPadding) {
        const xPad = Math.min(groupPaddingXValues, child.values.width / 4), yPad = Math.min(groupPaddingYValues, child.values.height / 4);
        child.values.x += xPad;
        child.values.width -= 2 * xPad;
        child.values.y += yPad;
        child.values.height -= 2 * yPad;
      }
      child.pointValues = merge93(values, {
        x: values.x / series.axisRatio,
        // Flip y-values to avoid visual regression with csvCoord in
        // Axis.translate at setPointValues. #12488
        y: axisMax - values.y - values.height,
        width: values.width / series.axisRatio
      });
      if (child.children.length) {
        series.calculateChildrenAreas(child, child.values);
      }
    }
    const getChildrenRecursive = (node, result = [], getLeaves = true) => {
      node.children.forEach((child) => {
        if (getLeaves && child.isLeaf) {
          result.push(child.point);
        } else if (!getLeaves && !child.isLeaf) {
          result.push(child.point);
        }
        if (child.children.length) {
          getChildrenRecursive(child, result, getLeaves);
        }
      });
      return result;
    };
    if (options2.nodeSizeBy === "leaf" && parent === rootNode && this.hasOutsideDataLabels && // Sizing by leaf value is not possible if any of the groups have
    // explicit values
    !getChildrenRecursive(rootNode, void 0, false).some((point) => isNumber65(point.options.value)) && !isNumber65(rootNode.point?.options.value)) {
      const leaves = getChildrenRecursive(rootNode), values = leaves.map((point) => point.options.value || 0), areas = leaves.map(({ node: { pointValues } }) => pointValues ? pointValues.width * pointValues.height : 0), valueSum = values.reduce((sum2, value) => sum2 + value, 0), areaSum = areas.reduce((sum2, value) => sum2 + value, 0), expectedAreaPerValue = areaSum / valueSum;
      let minMiss = 0, maxMiss = 0;
      leaves.forEach((point, i2) => {
        const areaPerValue = values[i2] ? areas[i2] / values[i2] : 1, fit = clamp21(areaPerValue / expectedAreaPerValue, 0.8, 1.4);
        let miss = 1 - fit;
        if (point.value) {
          if (areas[i2] < 20) {
            miss *= areas[i2] / 20;
          }
          if (miss > maxMiss) {
            maxMiss = miss;
          }
          if (miss < minMiss) {
            minMiss = miss;
          }
          point.simulatedValue = (point.simulatedValue || point.value) / fit;
        }
      });
      if (
        // An area error less than 5% is acceptable, the human ability
        // to assess area size is not that accurate
        (minMiss < -0.05 || maxMiss > 0.05) && // In case an eternal loop is brewing, pull the emergency brake
        this.simulation < 10
      ) {
        this.simulation++;
        this.setTreeValues(parent);
        area.val = parent.val;
        this.calculateChildrenAreas(parent, area);
      } else {
        leaves.forEach((point) => {
          delete point.simulatedValue;
        });
        this.setTreeValues(parent);
        this.simulation = 0;
      }
    }
  }
  /**
   * Create level list.
   * @private
   */
  createList(e) {
    const chart = this.chart, breadcrumbs = chart.breadcrumbs, list = [];
    if (breadcrumbs) {
      let currentLevelNumber = 0;
      list.push({
        level: currentLevelNumber,
        levelOptions: chart.series[0]
      });
      let node = e.target.nodeMap[e.newRootId];
      const extraNodes = [];
      while (node.parent || node.parent === "") {
        extraNodes.push(node);
        node = e.target.nodeMap[node.parent];
      }
      for (const node2 of extraNodes.reverse()) {
        list.push({
          level: ++currentLevelNumber,
          levelOptions: node2
        });
      }
      if (list.length <= 1) {
        list.length = 0;
      }
    }
    return list;
  }
  /**
   * Extend drawDataLabels with logic to handle custom options related to
   * the treemap series:
   *
   * - Points which is not a leaf node, has dataLabels disabled by
   *   default.
   *
   * - Options set on series.levels is merged in.
   *
   * - Width of the dataLabel is set to match the width of the point
   *   shape.
   *
   * @private
   */
  drawDataLabels() {
    const series = this, mapOptionsToLevel = series.mapOptionsToLevel, points = series.points.filter(function(n) {
      return n.node.visible || defined70(n.dataLabel);
    }), padding = splat21(series.options.dataLabels || {})[0]?.padding, positionsAreSet = points.some((p) => isNumber65(p.plotY));
    for (const point of points) {
      const style = {}, options2 = { style }, level = mapOptionsToLevel[point.node.level];
      if (!point.node.isLeaf && !point.node.isGroup || point.node.isGroup && point.node.level <= series.nodeMap[series.rootNode].level) {
        options2.enabled = false;
      }
      if (level?.dataLabels) {
        merge93(true, options2, splat21(level.dataLabels)[0]);
        series.hasDataLabels = () => true;
      }
      if (point.node.isLeaf) {
        options2.inside = true;
      } else if (options2.headers) {
        options2.verticalAlign = "top";
      }
      if (point.shapeArgs && positionsAreSet) {
        const { height = 0, width = 0 } = point.shapeArgs;
        if (width > 32 && height > 16 && point.shouldDraw()) {
          const dataLabelWidth = width - 2 * (options2.padding || padding || 0);
          style.width = `${dataLabelWidth}px`;
          style.lineClamp ?? (style.lineClamp = Math.floor(height / 16));
          style.visibility = "inherit";
          if (options2.headers) {
            point.dataLabel?.attr({
              width: dataLabelWidth
            });
          }
        } else {
          style.width = `${width}px`;
          style.visibility = "hidden";
        }
      }
      point.dlOptions = merge93(options2, point.options.dataLabels);
    }
    super.drawDataLabels(points);
  }
  /**
   * Override drawPoints
   * @private
   */
  drawPoints(points = this.points) {
    const series = this, chart = series.chart, renderer = chart.renderer, styledMode = chart.styledMode, options2 = series.options, shadow = styledMode ? {} : options2.shadow, borderRadius = options2.borderRadius, withinAnimationLimit = chart.pointCount < options2.animationLimit, allowTraversingTree = options2.allowTraversingTree;
    for (const point of points) {
      const levelDynamic = point.node.levelDynamic, animatableAttribs = {}, attribs = {}, css19 = {}, groupKey = "level-group-" + point.node.level, hasGraphic = !!point.graphic, shouldAnimate = withinAnimationLimit && hasGraphic, shapeArgs = point.shapeArgs;
      if (point.shouldDraw()) {
        point.isInside = true;
        if (borderRadius) {
          attribs.r = borderRadius;
        }
        merge93(
          true,
          // Extend object
          // Which object to extend
          shouldAnimate ? animatableAttribs : attribs,
          // Add shapeArgs to animate/attr if graphic exists
          hasGraphic ? shapeArgs : {},
          // Add style attribs if !styleMode
          styledMode ? {} : series.pointAttribs(point, point.selected ? "select" : void 0)
        );
        if (series.colorAttribs && styledMode) {
          extend81(css19, series.colorAttribs(point));
        }
        if (!series[groupKey]) {
          series[groupKey] = renderer.g(groupKey).attr({
            // @todo Set the zIndex based upon the number of
            // levels, instead of using 1000
            zIndex: 1e3 - (levelDynamic || 0)
          }).add(series.group);
          series[groupKey].survive = true;
        }
      }
      point.draw({
        animatableAttribs,
        attribs,
        css: css19,
        group: series[groupKey],
        imageUrl: point.imageUrl,
        renderer,
        shadow,
        shapeArgs,
        shapeType: point.shapeType
      });
      if (allowTraversingTree && point.graphic) {
        point.drillId = options2.interactByLeaf ? series.drillToByLeaf(point) : series.drillToByGroup(point);
      }
    }
  }
  /**
   * Finds the drill id for a parent node. Returns false if point should
   * not have a click event.
   * @private
   */
  drillToByGroup(point) {
    return !point.node.isLeaf || point.node.isGroup ? point.id : false;
  }
  /**
   * Finds the drill id for a leaf node. Returns false if point should not
   * have a click event
   * @private
   */
  drillToByLeaf(point) {
    const { traverseToLeaf } = point.series.options;
    let drillId = false, nodeParent;
    if (point.node.parent !== this.rootNode && point.node.isLeaf) {
      if (traverseToLeaf) {
        drillId = point.id;
      } else {
        nodeParent = point.node;
        while (!drillId) {
          if (typeof nodeParent.parent !== "undefined") {
            nodeParent = this.nodeMap[nodeParent.parent];
          }
          if (nodeParent.parent === this.rootNode) {
            drillId = nodeParent.id;
          }
        }
      }
    }
    return drillId;
  }
  /**
   * @todo remove this function at a suitable version.
   * @private
   */
  drillToNode(id, redraw) {
    error10(32, false, void 0, { "treemap.drillToNode": "use treemap.setRootNode" });
    this.setRootNode(id, redraw);
  }
  drillUp() {
    const series = this, node = series.nodeMap[series.rootNode];
    if (node && isString21(node.parent)) {
      series.setRootNode(node.parent, true, { trigger: "traverseUpButton" });
    }
  }
  getExtremes() {
    const { dataMin, dataMax } = super.getExtremes(this.colorValueData);
    this.valueMin = dataMin;
    this.valueMax = dataMax;
    return super.getExtremes();
  }
  /**
   * Creates an object map from parent id to childrens index.
   *
   * @private
   * @function Highcharts.Series#getListOfParents
   *
   * @param {Highcharts.SeriesTreemapDataOptions} [data]
   *        List of points set in options.
   *
   * @param {Array<string>} [existingIds]
   *        List of all point ids.
   *
   * @return {Object}
   *         Map from parent id to children index in data.
   */
  getListOfParents(data, existingIds) {
    const arr = isArray25(data) ? data : [], ids = isArray25(existingIds) ? existingIds : [], listOfParents = arr.reduce(function(prev, curr, i) {
      const parent = pick102(curr.parent, "");
      if (typeof prev[parent] === "undefined") {
        prev[parent] = [];
      }
      prev[parent].push(i);
      return prev;
    }, {
      "": []
      // Root of tree
    });
    for (const parent of Object.keys(listOfParents)) {
      const children = listOfParents[parent];
      if (parent !== "" && ids.indexOf(parent) === -1) {
        for (const child of children) {
          listOfParents[""].push(child);
        }
        delete listOfParents[parent];
      }
    }
    return listOfParents;
  }
  /**
   * Creates a tree structured object from the series points.
   * @private
   */
  getTree() {
    const series = this, allIds = this.data.map(function(d) {
      return d.id;
    });
    series.parentList = series.getListOfParents(this.data, allIds);
    series.nodeMap = {};
    series.nodeList = [];
    return series.buildTree("", -1, 0, series.parentList || {});
  }
  buildTree(id, index, level, list, parent) {
    const series = this, children = [], point = series.points[index];
    let height = 0, child;
    for (const i of list[id] || []) {
      child = series.buildTree(series.points[i].id, i, level + 1, list, id);
      height = Math.max(child.height + 1, height);
      children.push(child);
    }
    const node = new series.NodeClass().init(id, index, children, height, level, series, parent);
    for (const child2 of children) {
      child2.parentNode = node;
    }
    series.nodeMap[node.id] = node;
    series.nodeList.push(node);
    if (point) {
      point.node = node;
      node.point = point;
    }
    return node;
  }
  /**
   * Define hasData function for non-cartesian series. Returns true if the
   * series has points at all.
   * @private
   */
  hasData() {
    return !!this.dataTable.rowCount;
  }
  init(chart, options2) {
    const series = this, breadcrumbsOptions = merge93(options2.drillUpButton, options2.breadcrumbs), setOptionsEvent = addEvent85(series, "setOptions", (event) => {
      const options3 = event.userOptions;
      if (defined70(options3.allowDrillToNode) && !defined70(options3.allowTraversingTree)) {
        options3.allowTraversingTree = options3.allowDrillToNode;
        delete options3.allowDrillToNode;
      }
      if (defined70(options3.drillUpButton) && !defined70(options3.traverseUpButton)) {
        options3.traverseUpButton = options3.drillUpButton;
        delete options3.drillUpButton;
      }
      const dataLabels = splat21(options3.dataLabels || {});
      options3.levels?.forEach((level) => {
        dataLabels.push.apply(dataLabels, splat21(level.dataLabels || {}));
      });
      this.hasOutsideDataLabels = dataLabels.some((dl) => dl.headers);
    });
    super.init(chart, options2);
    delete series.opacity;
    series.eventsToUnbind.push(setOptionsEvent);
    if (series.options.allowTraversingTree) {
      series.eventsToUnbind.push(addEvent85(series, "click", series.onClickDrillToNode));
      series.eventsToUnbind.push(addEvent85(series, "setRootNode", function(e) {
        const chart2 = series.chart;
        if (chart2.breadcrumbs) {
          chart2.breadcrumbs.updateProperties(series.createList(e));
        }
      }));
      series.eventsToUnbind.push(addEvent85(
        series,
        "update",
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function(e, redraw) {
          const breadcrumbs = this.chart.breadcrumbs;
          if (breadcrumbs && e.options.breadcrumbs) {
            breadcrumbs.update(e.options.breadcrumbs);
          }
          this.hadOutsideDataLabels = this.hasOutsideDataLabels;
        }
      ));
      series.eventsToUnbind.push(addEvent85(series, "destroy", function destroyEvents(e) {
        const chart2 = this.chart;
        if (chart2.breadcrumbs && !e.keepEventsForUpdate) {
          chart2.breadcrumbs.destroy();
          chart2.breadcrumbs = void 0;
        }
      }));
    }
    if (!chart.breadcrumbs) {
      chart.breadcrumbs = new Breadcrumbs_default(chart, breadcrumbsOptions);
    }
    series.eventsToUnbind.push(addEvent85(chart.breadcrumbs, "up", function(e) {
      const drillUpsNumber = this.level - e.newLevel;
      for (let i = 0; i < drillUpsNumber; i++) {
        series.drillUp();
      }
    }));
  }
  /**
   * Add drilling on the suitable points.
   * @private
   */
  onClickDrillToNode(event) {
    const series = this, point = event.point, drillId = point?.drillId;
    if (isString21(drillId)) {
      point.setState("");
      series.setRootNode(drillId, true, { trigger: "click" });
    }
  }
  /**
   * Get presentational attributes
   * @private
   */
  pointAttribs(point, state) {
    const series = this, mapOptionsToLevel = isObject20(series.mapOptionsToLevel) ? series.mapOptionsToLevel : {}, level = point && mapOptionsToLevel[point.node.level] || {}, options2 = this.options, stateOptions = state && options2.states && options2.states[state] || {}, className = point?.getClassName() || "", attr18 = {
      "stroke": point && point.borderColor || level.borderColor || stateOptions.borderColor || options2.borderColor,
      "stroke-width": pick102(point && point.borderWidth, level.borderWidth, stateOptions.borderWidth, options2.borderWidth),
      "dashstyle": point?.borderDashStyle || level.borderDashStyle || stateOptions.borderDashStyle || options2.borderDashStyle,
      "fill": point?.color || this.color
    };
    if (className.indexOf("highcharts-above-level") !== -1) {
      attr18.fill = "none";
      attr18["stroke-width"] = 0;
    } else if (className.indexOf("highcharts-internal-node-interactive") !== -1) {
      attr18["fill-opacity"] = stateOptions.opacity ?? options2.opacity ?? 1;
      attr18.cursor = "pointer";
    } else if (className.indexOf("highcharts-internal-node") !== -1) {
      attr18.fill = "none";
    } else if (state && stateOptions.brightness) {
      attr18.fill = color11(attr18.fill).brighten(stateOptions.brightness).get();
    }
    return attr18;
  }
  /**
   * Set the node's color recursively, from the parent down.
   * @private
   */
  setColorRecursive(node, parentColor, colorIndex, index, siblings) {
    const series = this, chart = series?.chart, colors = chart?.options?.colors;
    if (node) {
      const colorInfo = getColor2(node, {
        colors,
        index,
        mapOptionsToLevel: series.mapOptionsToLevel,
        parentColor,
        parentColorIndex: colorIndex,
        series,
        siblings
      }), point = series.points[node.i];
      if (point) {
        point.color = colorInfo.color;
        point.colorIndex = colorInfo.colorIndex;
      }
      let i = -1;
      for (const child of node.children || []) {
        series.setColorRecursive(child, colorInfo.color, colorInfo.colorIndex, ++i, node.children.length);
      }
    }
  }
  setPointValues() {
    const series = this;
    const { points, xAxis: xAxis2, yAxis: yAxis2 } = series;
    const styledMode = series.chart.styledMode;
    const getStrokeWidth = (point) => styledMode ? 0 : series.pointAttribs(point)["stroke-width"] || 0;
    for (const point of points) {
      const { pointValues: values, visible } = point.node;
      if (values && visible) {
        const { height, width, x, y } = values, strokeWidth = getStrokeWidth(point), xValue = xAxis2.toPixels(x, true), x2Value = xAxis2.toPixels(x + width, true), yValue = yAxis2.toPixels(y, true), y2Value = yAxis2.toPixels(y + height, true), x1 = xValue === 0 ? strokeWidth / 2 : crisp14(xAxis2.toPixels(x, true), strokeWidth, true), x2 = x2Value === xAxis2.len ? xAxis2.len - strokeWidth / 2 : crisp14(xAxis2.toPixels(x + width, true), strokeWidth, true), y1 = yValue === yAxis2.len ? yAxis2.len - strokeWidth / 2 : crisp14(yAxis2.toPixels(y, true), strokeWidth, true), y2 = y2Value === 0 ? strokeWidth / 2 : crisp14(yAxis2.toPixels(y + height, true), strokeWidth, true);
        const shapeArgs = {
          x: Math.min(x1, x2),
          y: Math.min(y1, y2),
          width: Math.abs(x2 - x1),
          height: Math.abs(y2 - y1)
        };
        point.plotX = shapeArgs.x + shapeArgs.width / 2;
        point.plotY = shapeArgs.y + shapeArgs.height / 2;
        point.shapeArgs = shapeArgs;
      } else {
        delete point.plotX;
        delete point.plotY;
      }
    }
  }
  /**
   * Sets a new root node for the series.
   *
   * @private
   * @function Highcharts.Series#setRootNode
   *
   * @param {string} id
   * The id of the new root node.
   *
   * @param {boolean} [redraw=true]
   * Whether to redraw the chart or not.
   *
   * @param {Object} [eventArguments]
   * Arguments to be accessed in event handler.
   *
   * @param {string} [eventArguments.newRootId]
   * Id of the new root.
   *
   * @param {string} [eventArguments.previousRootId]
   * Id of the previous root.
   *
   * @param {boolean} [eventArguments.redraw]
   * Whether to redraw the chart after.
   *
   * @param {Object} [eventArguments.series]
   * The series to update the root of.
   *
   * @param {string} [eventArguments.trigger]
   * The action which triggered the event. Undefined if the setRootNode is
   * called directly.
   *
   * @emits Highcharts.Series#event:setRootNode
   */
  setRootNode(id, redraw, eventArguments) {
    const series = this, eventArgs = extend81({
      newRootId: id,
      previousRootId: series.rootNode,
      redraw: pick102(redraw, true),
      series
    }, eventArguments);
    const defaultFn = function(args) {
      const series2 = args.series;
      series2.idPreviousRoot = args.previousRootId;
      series2.rootNode = args.newRootId;
      series2.isDirty = true;
      if (args.redraw) {
        series2.chart.redraw();
      }
    };
    fireEvent49(series, "setRootNode", eventArgs, defaultFn);
  }
  /**
   * Workaround for `inactive` state. Since `series.opacity` option is
   * already reserved, don't use that state at all by disabling
   * `inactiveOtherPoints` and not inheriting states by points.
   * @private
   */
  setState(state) {
    this.options.inactiveOtherPoints = true;
    super.setState(state, false);
    this.options.inactiveOtherPoints = false;
  }
  setTreeValues(tree) {
    const series = this, options2 = series.options, idRoot = series.rootNode, mapIdToNode = series.nodeMap, nodeRoot = mapIdToNode[idRoot], levelIsConstant = typeof options2.levelIsConstant === "boolean" ? options2.levelIsConstant : true, children = [], point = series.points[tree.i];
    let childrenTotal = 0;
    for (let child of tree.children) {
      child = series.setTreeValues(child);
      children.push(child);
      if (!child.ignore) {
        childrenTotal += child.val;
      }
    }
    stableSort8(children, (a, b) => (a.sortIndex || 0) - (b.sortIndex || 0));
    let val = pick102(point?.simulatedValue, point?.options.value, childrenTotal);
    if (point) {
      point.value = val;
    }
    if (point?.isGroup && options2.cluster?.reductionFactor) {
      val /= options2.cluster.reductionFactor;
    }
    if (tree.parentNode?.point?.isGroup && series.rootNode !== tree.parent) {
      tree.visible = false;
    }
    extend81(tree, {
      children,
      childrenTotal,
      // Ignore this node if point is not visible
      ignore: !(pick102(point?.visible, true) && val > 0),
      isLeaf: tree.visible && !childrenTotal,
      isGroup: point?.isGroup,
      levelDynamic: tree.level - (levelIsConstant ? 0 : nodeRoot.level),
      name: pick102(point?.name, ""),
      sortIndex: pick102(point?.sortIndex, -val),
      val
    });
    return tree;
  }
  sliceAndDice(parent, children) {
    return this.algorithmFill(true, parent, children);
  }
  squarified(parent, children) {
    return this.algorithmLowAspectRatio(true, parent, children);
  }
  strip(parent, children) {
    return this.algorithmLowAspectRatio(false, parent, children);
  }
  stripes(parent, children) {
    return this.algorithmFill(false, parent, children);
  }
  translate(tree) {
    const series = this, options2 = series.options, applyGrouping3 = !tree;
    let rootId = updateRootId2(series), rootNode, pointValues, seriesArea, val;
    if (!tree && !rootId.startsWith("highcharts-grouped-treemap-points-")) {
      (this.points || []).forEach((point) => {
        if (point.isGroup) {
          point.destroy();
        }
      });
      super.translate();
      tree = series.getTree();
    }
    series.tree = tree = tree || series.tree;
    rootNode = series.nodeMap[rootId];
    if (rootId !== "" && !rootNode) {
      series.setRootNode("", false);
      rootId = series.rootNode;
      rootNode = series.nodeMap[rootId];
    }
    if (!rootNode.point?.isGroup) {
      series.mapOptionsToLevel = getLevelOptions2({
        from: rootNode.level + 1,
        levels: options2.levels,
        to: tree.height,
        defaults: {
          levelIsConstant: series.options.levelIsConstant,
          colorByPoint: options2.colorByPoint
        }
      });
    }
    TreemapUtilities_default.recursive(series.nodeMap[series.rootNode], (node) => {
      const p = node.parent;
      let next = false;
      node.visible = true;
      if (p || p === "") {
        next = series.nodeMap[p];
      }
      return next;
    });
    TreemapUtilities_default.recursive(series.nodeMap[series.rootNode].children, (children) => {
      let next = false;
      for (const child of children) {
        child.visible = true;
        if (child.children.length) {
          next = (next || []).concat(child.children);
        }
      }
      return next;
    });
    series.setTreeValues(tree);
    series.axisRatio = series.xAxis.len / series.yAxis.len;
    series.nodeMap[""].pointValues = pointValues = {
      x: 0,
      y: 0,
      width: axisMax,
      height: axisMax
    };
    series.nodeMap[""].values = seriesArea = merge93(pointValues, {
      width: pointValues.width * series.axisRatio,
      direction: options2.layoutStartingDirection === "vertical" ? 0 : 1,
      val: tree.val
    });
    if (this.hasOutsideDataLabels || this.hadOutsideDataLabels) {
      this.drawDataLabels();
    }
    series.calculateChildrenAreas(tree, seriesArea);
    if (!series.colorAxis && !options2.colorByPoint) {
      series.setColorRecursive(series.tree);
    }
    if (options2.allowTraversingTree && rootNode.pointValues) {
      val = rootNode.pointValues;
      series.xAxis.setExtremes(val.x, val.x + val.width, false);
      series.yAxis.setExtremes(val.y, val.y + val.height, false);
      series.xAxis.setScale();
      series.yAxis.setScale();
    }
    series.setPointValues();
    if (applyGrouping3) {
      series.applyTreeGrouping();
    }
  }
};
TreemapSeries.defaultOptions = merge93(ScatterSeries5.defaultOptions, TreemapSeriesDefaults_default);
extend81(TreemapSeries.prototype, {
  buildKDTree: noop19,
  colorAttribs: ColorMapComposition_default.seriesMembers.colorAttribs,
  colorKey: "colorValue",
  // Point color option key
  directTouch: true,
  getExtremesFromAll: true,
  getSymbol: noop19,
  optionalAxis: "colorAxis",
  parallelArrays: ["x", "y", "value", "colorValue"],
  pointArrayMap: ["value", "colorValue"],
  pointClass: TreemapPoint_default,
  NodeClass: TreemapNode_default,
  trackerGroups: ["group", "dataLabelsGroup"],
  utils: TreemapUtilities_default
});
ColorMapComposition_default.compose(TreemapSeries);
SeriesRegistry_default.registerSeriesType("treemap", TreemapSeries);
var TreemapSeries_default = TreemapSeries;

// node_modules/highcharts/es-modules/masters/modules/treemap.src.js
var G15 = Globals_default;
G15.Breadcrumbs = G15.Breadcrumbs || Breadcrumbs_default;
G15.Breadcrumbs.compose(G15.Chart, G15.defaultOptions);
TreemapSeries_default.compose(G15.Series);

// node_modules/highcharts/es-modules/Extensions/NoDataToDisplay/NoDataDefaults.js
var lang5 = {
  /**
   * The text to display when the chart contains no data.
   *
   * @see [noData](#noData)
   *
   * @sample highcharts/no-data-to-display/no-data-line
   *         No-data text
   *
   * @since    3.0.8
   * @product  highcharts highstock
   * @requires modules/no-data-to-display
   */
  noData: "No data to display"
};
var noData = {
  /**
   * An object of additional SVG attributes for the no-data label.
   *
   * @type      {Highcharts.SVGAttributes}
   * @since     3.0.8
   * @product   highcharts highstock gantt
   * @apioption noData.attr
   */
  attr: {
    zIndex: 1
  },
  /**
   * Whether to insert the label as HTML, or as pseudo-HTML rendered with
   * SVG.
   *
   * @type      {boolean}
   * @default   false
   * @since     4.1.10
   * @product   highcharts highstock gantt
   * @apioption noData.useHTML
   */
  /**
   * The position of the no-data label, relative to the plot area.
   *
   * @type  {Highcharts.AlignObject}
   * @since 3.0.8
   */
  position: {
    /**
     * Horizontal offset of the label, in pixels.
     */
    x: 0,
    /**
     * Vertical offset of the label, in pixels.
     */
    y: 0,
    /**
     * Horizontal alignment of the label.
     *
     * @type {Highcharts.AlignValue}
     */
    align: "center",
    /**
     * Vertical alignment of the label.
     *
     * @type {Highcharts.VerticalAlignValue}
     */
    verticalAlign: "middle"
  },
  /**
   * CSS styles for the no-data label.
   *
   * @sample highcharts/no-data-to-display/no-data-line
   *         Styled no-data text
   *
   * @type {Highcharts.CSSObject}
   */
  style: {
    /** @ignore */
    fontWeight: "bold",
    /** @ignore */
    fontSize: "0.8em",
    /** @ignore */
    color: "#666666"
    /* Palette.neutralColor60 */
  }
};
var NoDataDefaults = {
  lang: lang5,
  noData
};
var NoDataDefaults_default = NoDataDefaults;

// node_modules/highcharts/es-modules/Extensions/NoDataToDisplay/NoDataToDisplay.js
var { addEvent: addEvent86, extend: extend82, merge: merge94 } = Utilities_default;
function chartHasData() {
  const chart = this, series = chart.series || [];
  let i = series.length;
  while (i--) {
    if (series[i].hasData() && !series[i].options.isInternal) {
      return true;
    }
  }
  return chart.loadingShown;
}
function chartHideNoData() {
  const chart = this;
  if (chart.noDataLabel) {
    chart.noDataLabel = chart.noDataLabel.destroy();
  }
}
function chartShowNoData(str) {
  const chart = this, options2 = chart.options, text = str || options2 && options2.lang.noData || "", noDataOptions = options2 && (options2.noData || {});
  if (chart.renderer) {
    if (!chart.noDataLabel) {
      chart.noDataLabel = chart.renderer.label(text, 0, 0, void 0, void 0, void 0, noDataOptions.useHTML, void 0, "no-data").add();
    }
    if (!chart.styledMode) {
      chart.noDataLabel.attr(AST_default.filterUserAttributes(noDataOptions.attr || {})).css(noDataOptions.style || {});
    }
    chart.noDataLabel.align(extend82(chart.noDataLabel.getBBox(), noDataOptions.position || {}), false, "plotBox");
  }
}
function compose20(ChartClass, highchartsDefaultOptions) {
  const chartProto = ChartClass.prototype;
  if (!chartProto.showNoData) {
    chartProto.hasData = chartHasData;
    chartProto.hideNoData = chartHideNoData;
    chartProto.showNoData = chartShowNoData;
    addEvent86(ChartClass, "render", onChartRender5);
    merge94(true, highchartsDefaultOptions, NoDataDefaults_default);
  }
}
function onChartRender5() {
  const chart = this;
  if (chart.hasData()) {
    chart.hideNoData();
  } else {
    chart.showNoData();
  }
}
var NoDataToDisplay = {
  compose: compose20
};
var NoDataToDisplay_default = NoDataToDisplay;

// node_modules/highcharts/es-modules/masters/modules/no-data-to-display.src.js
var G16 = Globals_default;
NoDataToDisplay_default.compose(G16.Chart, G16.defaultOptions);

// node_modules/highcharts/es-modules/Series/NodesComposition.js
var { series: { prototype: seriesProto6, prototype: { pointClass: { prototype: pointProto } } } } = SeriesRegistry_default;
var { defined: defined71, extend: extend83, find: find16, merge: merge95, pick: pick103 } = Utilities_default;
var NodesComposition;
(function(NodesComposition2) {
  function compose27(PointClass, SeriesClass) {
    const pointProto2 = PointClass.prototype, seriesProto7 = SeriesClass.prototype;
    pointProto2.setNodeState = setNodeState;
    pointProto2.setState = setNodeState;
    pointProto2.update = updateNode;
    seriesProto7.destroy = destroy;
    seriesProto7.setData = setData;
    return SeriesClass;
  }
  NodesComposition2.compose = compose27;
  function createNode(id) {
    const PointClass = this.pointClass, findById = (nodes, id2) => find16(nodes, (node2) => node2.id === id2);
    let node = findById(this.nodes, id), options2;
    if (!node) {
      options2 = this.options.nodes && findById(this.options.nodes, id);
      const newNode = new PointClass(this, extend83({
        className: "highcharts-node",
        isNode: true,
        id,
        y: 1
        // Pass isNull test
      }, options2));
      newNode.linksTo = [];
      newNode.linksFrom = [];
      newNode.getSum = function() {
        let sumTo = 0, sumFrom = 0;
        newNode.linksTo.forEach((link) => {
          sumTo += link.weight || 0;
        });
        newNode.linksFrom.forEach((link) => {
          sumFrom += link.weight || 0;
        });
        return Math.max(sumTo, sumFrom);
      };
      newNode.offset = function(point, coll) {
        let offset3 = 0;
        for (let i = 0; i < newNode[coll].length; i++) {
          if (newNode[coll][i] === point) {
            return offset3;
          }
          offset3 += newNode[coll][i].weight;
        }
      };
      newNode.hasShape = function() {
        let outgoing = 0;
        newNode.linksTo.forEach((link) => {
          if (link.outgoing) {
            outgoing++;
          }
        });
        return !newNode.linksTo.length || outgoing !== newNode.linksTo.length;
      };
      newNode.index = this.nodes.push(newNode) - 1;
      node = newNode;
    }
    node.formatPrefix = "node";
    node.name = node.name || node.options.id || "";
    node.mass = pick103(
      // Node:
      node.options.mass,
      node.options.marker && node.options.marker.radius,
      // Series:
      this.options.marker && this.options.marker.radius,
      // Default:
      4
    );
    return node;
  }
  NodesComposition2.createNode = createNode;
  function destroy() {
    this.data = [].concat(this.points || [], this.nodes);
    return seriesProto6.destroy.apply(this, arguments);
  }
  NodesComposition2.destroy = destroy;
  function generatePoints2() {
    const chart = this.chart, nodeLookup = {};
    seriesProto6.generatePoints.call(this);
    if (!this.nodes) {
      this.nodes = [];
    }
    this.colorCounter = 0;
    this.nodes.forEach((node) => {
      node.linksFrom.length = 0;
      node.linksTo.length = 0;
      node.level = node.options.level;
    });
    this.points.forEach((point) => {
      if (defined71(point.from)) {
        if (!nodeLookup[point.from]) {
          nodeLookup[point.from] = this.createNode(point.from);
        }
        nodeLookup[point.from].linksFrom.push(point);
        point.fromNode = nodeLookup[point.from];
        if (chart.styledMode) {
          point.colorIndex = pick103(point.options.colorIndex, nodeLookup[point.from].colorIndex);
        } else {
          point.color = point.options.color || nodeLookup[point.from].color;
        }
      }
      if (defined71(point.to)) {
        if (!nodeLookup[point.to]) {
          nodeLookup[point.to] = this.createNode(point.to);
        }
        nodeLookup[point.to].linksTo.push(point);
        point.toNode = nodeLookup[point.to];
      }
      point.name = point.name || point.id;
    }, this);
    this.nodeLookup = nodeLookup;
  }
  NodesComposition2.generatePoints = generatePoints2;
  function setData() {
    if (this.nodes) {
      this.nodes.forEach((node) => {
        node.destroy();
      });
      this.nodes.length = 0;
    }
    seriesProto6.setData.apply(this, arguments);
  }
  function setNodeState(state) {
    const args = arguments, others = this.isNode ? this.linksTo.concat(this.linksFrom) : [this.fromNode, this.toNode];
    if (state !== "select") {
      others.forEach((linkOrNode) => {
        if (linkOrNode && linkOrNode.series) {
          pointProto.setState.apply(linkOrNode, args);
          if (!linkOrNode.isNode) {
            if (linkOrNode.fromNode.graphic) {
              pointProto.setState.apply(linkOrNode.fromNode, args);
            }
            if (linkOrNode.toNode && linkOrNode.toNode.graphic) {
              pointProto.setState.apply(linkOrNode.toNode, args);
            }
          }
        }
      });
    }
    pointProto.setState.apply(this, args);
  }
  NodesComposition2.setNodeState = setNodeState;
  function updateNode(options2, redraw, animation, runEvent) {
    const nodes = this.series.options.nodes, data = this.series.options.data, dataLength = data?.length || 0, linkConfig = data?.[this.index];
    pointProto.update.call(
      this,
      options2,
      this.isNode ? false : redraw,
      // Hold the redraw for nodes
      animation,
      runEvent
    );
    if (this.isNode) {
      const nodeIndex = (nodes || []).reduce(
        // Array.findIndex needs a polyfill
        (prevIndex, n, index) => this.id === n.id ? index : prevIndex,
        -1
      ), nodeConfig = merge95(nodes && nodes[nodeIndex] || {}, data?.[this.index] || {});
      if (data) {
        if (linkConfig) {
          data[this.index] = linkConfig;
        } else {
          data.length = dataLength;
        }
      }
      if (nodes) {
        if (nodeIndex >= 0) {
          nodes[nodeIndex] = nodeConfig;
        } else {
          nodes.push(nodeConfig);
        }
      } else {
        this.series.options.nodes = [nodeConfig];
      }
      if (pick103(redraw, true)) {
        this.series.chart.redraw(animation);
      }
    }
  }
  NodesComposition2.updateNode = updateNode;
})(NodesComposition || (NodesComposition = {}));
var NodesComposition_default = NodesComposition;

// node_modules/highcharts/es-modules/Series/Sankey/SankeyPoint.js
var { column: ColumnSeries13 } = SeriesRegistry_default.seriesTypes;
var { defined: defined72 } = Utilities_default;
var SankeyPoint = class extends ColumnSeries13.prototype.pointClass {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  applyOptions(options2, x) {
    Point_default.prototype.applyOptions.call(this, options2, x);
    if (defined72(this.options.level)) {
      this.options.column = this.column = this.options.level;
    }
    return this;
  }
  /**
   * @private
   */
  getClassName() {
    return (this.isNode ? "highcharts-node " : "highcharts-link ") + Point_default.prototype.getClassName.call(this);
  }
  /**
   * If there are incoming links, place it to the right of the
   * highest order column that links to this one.
   *
   * @private
   */
  getFromNode() {
    const node = this;
    let fromColumn = -1, fromNode;
    for (let i = 0; i < node.linksTo.length; i++) {
      const point = node.linksTo[i];
      if (point.fromNode.column > fromColumn && point.fromNode !== node) {
        fromNode = point.fromNode;
        fromColumn = fromNode.column;
      }
    }
    return { fromNode, fromColumn };
  }
  /**
   * Calculate node.column if it's not set by user
   * @private
   */
  setNodeColumn() {
    const node = this;
    if (!defined72(node.options.column)) {
      if (node.linksTo.length === 0) {
        node.column = 0;
      } else {
        node.column = node.getFromNode().fromColumn + 1;
      }
    }
  }
  /**
   * @private
   */
  isValid() {
    return this.isNode || typeof this.weight === "number";
  }
};
var SankeyPoint_default = SankeyPoint;

// node_modules/highcharts/es-modules/Series/Sankey/SankeySeriesDefaults.js
var SankeySeriesDefaults = {
  borderWidth: 0,
  colorByPoint: true,
  /**
   * Higher numbers makes the links in a sankey diagram or dependency
   * wheelrender more curved. A `curveFactor` of 0 makes the lines
   * straight.
   *
   * @private
   */
  curveFactor: 0.33,
  /**
   * Options for the data labels appearing on top of the nodes and links.
   * For sankey charts, data labels are visible for the nodes by default,
   * but hidden for links. This is controlled by modifying the
   * `nodeFormat`, and the `format` that applies to links and is an empty
   * string by default.
   *
   * @declare Highcharts.SeriesSankeyDataLabelsOptionsObject
   *
   * @private
   */
  dataLabels: {
    enabled: true,
    backgroundColor: "none",
    // Enable padding
    crop: false,
    /**
     * The
     * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
     * specifying what to show for _nodes_ in the sankey diagram. By
     * default the `nodeFormatter` returns `{point.name}`.
     *
     * @sample highcharts/plotoptions/sankey-link-datalabels/
     *         Node and link data labels
     *
     * @type {string}
     */
    nodeFormat: void 0,
    /**
     * Callback to format data labels for _nodes_ in the sankey diagram.
     * The `nodeFormat` option takes precedence over the
     * `nodeFormatter`.
     *
     * @type  {Highcharts.SeriesSankeyDataLabelsFormatterCallbackFunction}
     * @since 6.0.2
     */
    nodeFormatter: function() {
      return this.point.name;
    },
    format: void 0,
    /**
     * @type {Highcharts.SeriesSankeyDataLabelsFormatterCallbackFunction}
     */
    formatter: function() {
      return;
    },
    inside: true
  },
  /**
   * @default   true
   * @extends   plotOptions.series.inactiveOtherPoints
   * @private
   */
  inactiveOtherPoints: true,
  /**
   * Set options on specific levels. Takes precedence over series options,
   * but not node and link options.
   *
   * @sample highcharts/demo/sunburst
   *         Sunburst chart
   *
   * @type      {Array<*>}
   * @since     7.1.0
   * @apioption plotOptions.sankey.levels
   */
  /**
   * Can set `borderColor` on all nodes which lay on the same level.
   *
   * @type      {Highcharts.ColorString}
   * @apioption plotOptions.sankey.levels.borderColor
   */
  /**
   * Can set `borderWidth` on all nodes which lay on the same level.
   *
   * @type      {number}
   * @apioption plotOptions.sankey.levels.borderWidth
   */
  /**
   * Can set `color` on all nodes which lay on the same level.
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @apioption plotOptions.sankey.levels.color
   */
  /**
   * Can set `colorByPoint` on all nodes which lay on the same level.
   *
   * @type      {boolean}
   * @default   true
   * @apioption plotOptions.sankey.levels.colorByPoint
   */
  /**
   * Can set `dataLabels` on all points which lay on the same level.
   *
   * @extends   plotOptions.sankey.dataLabels
   * @apioption plotOptions.sankey.levels.dataLabels
   */
  /**
   * Decides which level takes effect from the options set in the levels
   * object.
   *
   * @type      {number}
   * @apioption plotOptions.sankey.levels.level
   */
  /**
   * Can set `linkOpacity` on all points which lay on the same level.
   *
   * @type      {number}
   * @default   0.5
   * @apioption plotOptions.sankey.levels.linkOpacity
   */
  /**
   * Can set `states` on all nodes and points which lay on the same level.
   *
   * @extends   plotOptions.sankey.states
   * @apioption plotOptions.sankey.levels.states
   */
  /**
   * Determines color mode for sankey links. Available options:
   *
   * - `from` color of the sankey link will be the same as the 'from node'
   *
   * - `gradient` color of the sankey link will be set to gradient between
   * colors of 'from node' and 'to node'
   *
   * - `to` color of the sankey link will be same as the 'to node'.
   *
   * @sample highcharts/demo/vertical-sankey
   *         Vertical sankey diagram with gradients
   * @sample highcharts/series-sankey/link-color-mode
   *         Sankey diagram with gradients and explanation
   *
   * @type      {('from'|'gradient'|'to')}
   * @since     11.2.0
   */
  linkColorMode: "from",
  /**
   * Opacity for the links between nodes in the sankey diagram.
   *
   * @private
   */
  linkOpacity: 0.5,
  /**
   * Opacity for the nodes in the sankey diagram.
   *
   * @private
   */
  opacity: 1,
  /**
   * The minimal width for a line of a sankey. By default,
   * 0 values are not shown.
   *
   * @sample highcharts/plotoptions/sankey-minlinkwidth
   *         Sankey diagram with minimal link height
   *
   * @type      {number}
   * @since     7.1.3
   * @default   0
   * @apioption plotOptions.sankey.minLinkWidth
   *
   * @private
   */
  minLinkWidth: 0,
  /**
   * Determines which side of the chart the nodes are to be aligned to. When
   * the chart is inverted, `top` aligns to the left and `bottom` to the
   * right.
   *
   * @sample highcharts/plotoptions/sankey-nodealignment
   *         Node alignment demonstrated
   *
   * @type      {'top'|'center'|'bottom'}
   * @apioption plotOptions.sankey.nodeAlignment
   */
  nodeAlignment: "center",
  /**
   * The pixel width of each node in a sankey diagram or dependency wheel, or
   * the height in case the chart is inverted.
   *
   * Can be a number or a percentage string.
   *
   * Sankey series also support setting it to `auto`. With this setting, the
   * nodes are sized to fill up the plot area in the longitudinal direction,
   * regardless of the number of levels.
   *
   * @see    [sankey.nodeDistance](#nodeDistance)
   * @sample highcharts/series-sankey/node-distance
   *         Sankey with auto node width combined with node distance
   * @sample highcharts/series-organization/node-distance
   *         Organization chart with node distance of 50%
   *
   * @type {number|string}
   */
  nodeWidth: 20,
  /**
   * The padding between nodes in a sankey diagram or dependency wheel, in
   * pixels. For sankey charts, this applies to the nodes of the same column,
   * so vertical distance by default, or horizontal distance in an inverted
   * (vertical) sankey.
   *
   * If the number of nodes is so great that it is impossible to lay them out
   * within the plot area with the given `nodePadding`, they will be rendered
   * with a smaller padding as a strategy to avoid overflow.
   */
  nodePadding: 10,
  /**
   * The distance between nodes in a sankey diagram in the longitudinal
   * direction. The longitudinal direction means the direction that the chart
   * flows - in a horizontal chart the distance is horizontal, in an inverted
   * chart (vertical), the distance is vertical.
   *
   * If a number is given, it denotes pixels. If a percentage string is given,
   * the distance is a percentage of the rendered node width. A `nodeDistance`
   * of `100%` will render equal widths for the nodes and the gaps between
   * them.
   *
   * This option applies only when the `nodeWidth` option is `auto`, making
   * the node width respond to the number of columns.
   *
   * @since 11.4.0
   * @sample highcharts/series-sankey/node-distance
   *         Sankey with dnode distance of 100% means equal to node width
   * @sample highcharts/series-organization/node-distance
   *         Organization chart with node distance of 50%
   * @type   {number|string}
   */
  nodeDistance: 30,
  showInLegend: false,
  states: {
    hover: {
      /**
       * Opacity for the links between nodes in the sankey diagram in
       * hover mode.
       */
      linkOpacity: 1,
      /**
       * Opacity for the nodes in the sankey diagram in hover mode.
       */
      opacity: 1
    },
    /**
     * The opposite state of a hover for a single point node/link.
     *
     * @declare Highcharts.SeriesStatesInactiveOptionsObject
     */
    inactive: {
      /**
       * Opacity for the links between nodes in the sankey diagram in
       * inactive mode.
       */
      linkOpacity: 0.1,
      /**
       * Opacity of the nodes in the sankey diagram in inactive mode.
       */
      opacity: 0.1,
      /**
       * Animation when not hovering over the marker.
       *
       * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
       * @apioption plotOptions.series.states.inactive.animation
       */
      animation: {
        /** @internal */
        duration: 50
      }
    }
  },
  tooltip: {
    /**
     * A callback for defining the format for _nodes_ in the chart's
     * tooltip, as opposed to links.
     *
     * @type      {Highcharts.FormatterCallbackFunction<Highcharts.SankeyNodeObject>}
     * @since     6.0.2
     * @apioption plotOptions.sankey.tooltip.nodeFormatter
     */
    /**
     * Whether the tooltip should follow the pointer or stay fixed on
     * the item.
     */
    followPointer: true,
    headerFormat: '<span style="font-size: 0.8em">{series.name}</span><br/>',
    pointFormat: "{point.fromNode.name}  {point.toNode.name}: <b>{point.weight}</b><br/>",
    /**
     * The
     * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
     * specifying what to show for _nodes_ in tooltip of a diagram
     * series, as opposed to links.
     */
    nodeFormat: "{point.name}: <b>{point.sum}</b><br/>"
  }
};
var SankeySeriesDefaults_default = SankeySeriesDefaults;

// node_modules/highcharts/es-modules/Series/Sankey/SankeyColumnComposition.js
var { defined: defined73, getAlignFactor: getAlignFactor12, relativeLength: relativeLength16 } = Utilities_default;
var SankeyColumnComposition;
(function(SankeyColumnComposition2) {
  function compose27(points, series) {
    const sankeyColumnArray = points;
    sankeyColumnArray.sankeyColumn = new SankeyColumnAdditions(sankeyColumnArray, series);
    return sankeyColumnArray;
  }
  SankeyColumnComposition2.compose = compose27;
  class SankeyColumnAdditions {
    /* *
     *
     *  Constructor
     *
     * */
    constructor(points, series) {
      this.points = points;
      this.series = series;
    }
    /* *
     *
     *  Functions
     *
     * */
    /**
     * Calculate translation factor used in column and nodes distribution
     * @private
     * @function Highcharts.SankeyColumn#getTranslationFactor
     *
     * @param {SankeySeries} series
     * The Series
     * @return {number} TranslationFactor
     * Translation Factor
     */
    getTranslationFactor(series) {
      const column2 = this.points, nodes = column2.slice(), chart = series.chart, minLinkWidth = series.options.minLinkWidth || 0;
      let skipPoint, factor = 0, i, remainingHeight = (chart.plotSizeY || 0) - (series.options.borderWidth || 0) - (column2.length - 1) * series.nodePadding;
      while (column2.length) {
        factor = remainingHeight / column2.sankeyColumn.sum();
        skipPoint = false;
        i = column2.length;
        while (i--) {
          if (column2[i].getSum() * factor < minLinkWidth) {
            column2.splice(i, 1);
            remainingHeight = Math.max(0, remainingHeight - minLinkWidth);
            skipPoint = true;
          }
        }
        if (!skipPoint) {
          break;
        }
      }
      column2.length = 0;
      for (const node of nodes) {
        column2.push(node);
      }
      return factor;
    }
    /**
     * Get the top position of the column in pixels
     * @private
     * @function Highcharts.SankeyColumn#top
     *
     * @param {number} factor
     * The Translation Factor
     * @return {number} top
     * The top position of the column
     */
    top(factor) {
      const series = this.series, nodePadding = series.nodePadding, height = this.points.reduce((height2, node) => {
        if (height2 > 0) {
          height2 += nodePadding;
        }
        const nodeHeight = Math.max(node.getSum() * factor, series.options.minLinkWidth || 0);
        height2 += nodeHeight;
        return height2;
      }, 0);
      return getAlignFactor12(series.options.nodeAlignment || "center") * ((series.chart.plotSizeY || 0) - height);
    }
    /**
     * Get the left position of the column in pixels
     * @private
     * @function Highcharts.SankeyColumn#top
     *
     * @param {number} factor
     * The Translation Factor
     * @return {number} left
     * The left position of the column
     */
    left(factor) {
      const series = this.series, chart = series.chart, equalNodes = series.options.equalNodes, maxNodesLength = chart.inverted ? chart.plotHeight : chart.plotWidth, nodePadding = series.nodePadding, width = this.points.reduce((width2, node) => {
        if (width2 > 0) {
          width2 += nodePadding;
        }
        const nodeWidth = equalNodes ? maxNodesLength / node.series.nodes.length - nodePadding : Math.max(node.getSum() * factor, series.options.minLinkWidth || 0);
        width2 += nodeWidth;
        return width2;
      }, 0);
      return ((chart.plotSizeX || 0) - Math.round(width)) / 2;
    }
    /**
     * Calculate sum of all nodes inside specific column
     * @private
     * @function Highcharts.SankeyColumn#sum
     *
     * @param {ArrayComposition} this
     * Sankey Column Array
     *
     * @return {number} sum
     * Sum of all nodes inside column
     */
    sum() {
      return this.points.reduce((sum2, node) => sum2 + node.getSum(), 0);
    }
    /**
     * Get the offset in pixels of a node inside the column
     * @private
     * @function Highcharts.SankeyColumn#offset
     *
     * @param {SankeyPoint} node
     * Sankey node
     * @param {number} factor
     * Translation Factor
     * @return {number} offset
     * Offset of a node inside column
     */
    offset(node, factor) {
      const column2 = this.points, series = this.series, nodePadding = series.nodePadding;
      let offset3 = 0, totalNodeOffset;
      if (series.is("organization") && node.hangsFrom) {
        return {
          absoluteTop: node.hangsFrom.nodeY
        };
      }
      for (let i = 0; i < column2.length; i++) {
        const sum2 = column2[i].getSum();
        const height = Math.max(sum2 * factor, series.options.minLinkWidth || 0);
        const directionOffset = node.options[series.chart.inverted ? "offsetHorizontal" : "offsetVertical"], optionOffset = node.options.offset || 0;
        if (sum2) {
          totalNodeOffset = height + nodePadding;
        } else {
          totalNodeOffset = 0;
        }
        if (column2[i] === node) {
          return {
            relativeTop: offset3 + (defined73(directionOffset) ? (
              // `directionOffset` is a percent of the node
              // height
              relativeLength16(directionOffset, height)
            ) : relativeLength16(optionOffset, totalNodeOffset))
          };
        }
        offset3 += totalNodeOffset;
      }
    }
  }
  SankeyColumnComposition2.SankeyColumnAdditions = SankeyColumnAdditions;
})(SankeyColumnComposition || (SankeyColumnComposition = {}));
var SankeyColumnComposition_default = SankeyColumnComposition;

// node_modules/highcharts/es-modules/Series/Sankey/SankeySeries.js
var { column: ColumnSeries14, line: LineSeries7 } = SeriesRegistry_default.seriesTypes;
var { parse: color12 } = Color_default;
var { getLevelOptions: getLevelOptions3, getNodeWidth: getNodeWidth2 } = TreeUtilities_default;
var { clamp: clamp22, crisp: crisp15, extend: extend84, isObject: isObject21, merge: merge96, pick: pick104, relativeLength: relativeLength17, stableSort: stableSort9 } = Utilities_default;
TextPath_default.compose(SVGElement_default);
var SankeySeries = class _SankeySeries extends ColumnSeries14 {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * @private
   */
  static getDLOptions(params) {
    const optionsPoint = isObject21(params.optionsPoint) ? params.optionsPoint.dataLabels : {}, optionsLevel = isObject21(params.level) ? params.level.dataLabels : {}, options2 = merge96({
      style: {}
    }, optionsLevel, optionsPoint);
    return options2;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Create node columns by analyzing the nodes and the relations between
   * incoming and outgoing links.
   * @private
   */
  createNodeColumns() {
    const columns = [];
    for (const node of this.nodes) {
      node.setNodeColumn();
      if (!columns[node.column]) {
        columns[node.column] = SankeyColumnComposition_default.compose([], this);
      }
      columns[node.column].push(node);
    }
    for (let i = 0; i < columns.length; i++) {
      if (typeof columns[i] === "undefined") {
        columns[i] = SankeyColumnComposition_default.compose([], this);
      }
    }
    return columns;
  }
  /**
   * Order the nodes, starting with the root node(s). (#9818)
   * @private
   */
  order(node, level) {
    const series = this;
    if (typeof node.level === "undefined") {
      node.level = level;
      for (const link of node.linksFrom) {
        if (link.toNode) {
          series.order(link.toNode, level + 1);
        }
      }
    }
  }
  /**
   * Extend generatePoints by adding the nodes, which are Point objects
   * but pushed to the this.nodes array.
   * @private
   */
  generatePoints() {
    NodesComposition_default.generatePoints.apply(this, arguments);
    if (this.orderNodes) {
      for (const node of this.nodes) {
        if (node.linksTo.length === 0) {
          this.order(node, 0);
        }
      }
      stableSort9(this.nodes, (a, b) => a.level - b.level);
    }
  }
  /**
   * Overridable function to get node padding, overridden in dependency
   * wheel series type.
   * @private
   */
  getNodePadding() {
    let nodePadding = this.options.nodePadding || 0;
    if (this.nodeColumns) {
      const maxLength = this.nodeColumns.reduce((acc, col) => Math.max(acc, col.length), 0);
      if (maxLength * nodePadding > this.chart.plotSizeY) {
        nodePadding = this.chart.plotSizeY / maxLength;
      }
    }
    return nodePadding;
  }
  /**
   * Define hasData function for non-cartesian series.
   * @private
   * @return {boolean}
   *         Returns true if the series has points at all.
   */
  hasData() {
    return !!this.dataTable.rowCount;
  }
  /**
   * Return the presentational attributes.
   * @private
   */
  pointAttribs(point, state) {
    if (!point) {
      return {};
    }
    const series = this, level = point.isNode ? point.level : point.fromNode.level, levelOptions = series.mapOptionsToLevel[level || 0] || {}, options2 = point.options, stateOptions = levelOptions.states && levelOptions.states[state || ""] || {}, values = [
      "colorByPoint",
      "borderColor",
      "borderWidth",
      "linkOpacity",
      "opacity"
    ].reduce((obj, key) => {
      obj[key] = pick104(stateOptions[key], options2[key], levelOptions[key], series.options[key]);
      return obj;
    }, {}), color14 = pick104(stateOptions.color, options2.color, values.colorByPoint ? point.color : levelOptions.color);
    if (point.isNode) {
      return {
        fill: color14,
        stroke: values.borderColor,
        "stroke-width": values.borderWidth,
        opacity: values.opacity
      };
    }
    return {
      fill: color14,
      "fill-opacity": values.linkOpacity
    };
  }
  drawTracker() {
    ColumnSeries14.prototype.drawTracker.call(this, this.points);
    ColumnSeries14.prototype.drawTracker.call(this, this.nodes);
  }
  drawPoints() {
    ColumnSeries14.prototype.drawPoints.call(this, this.points);
    ColumnSeries14.prototype.drawPoints.call(this, this.nodes);
  }
  drawDataLabels() {
    ColumnSeries14.prototype.drawDataLabels.call(this, this.points);
    ColumnSeries14.prototype.drawDataLabels.call(this, this.nodes);
  }
  /**
   * Run pre-translation by generating the nodeColumns.
   * @private
   */
  translate() {
    this.generatePoints();
    this.nodeColumns = this.createNodeColumns();
    const series = this, chart = this.chart, options2 = this.options, nodeColumns = this.nodeColumns, columnCount = nodeColumns.length;
    this.nodeWidth = getNodeWidth2(this, columnCount);
    this.nodePadding = this.getNodePadding();
    this.translationFactor = nodeColumns.reduce((translationFactor, column2) => Math.min(translationFactor, column2.sankeyColumn.getTranslationFactor(series)), Infinity);
    this.colDistance = (chart.plotSizeX - this.nodeWidth - options2.borderWidth) / Math.max(1, nodeColumns.length - 1);
    series.mapOptionsToLevel = getLevelOptions3({
      // NOTE: if support for allowTraversingTree is added, then from
      // should be the level of the root node.
      from: 1,
      levels: options2.levels,
      to: nodeColumns.length - 1,
      // Height of the tree
      defaults: {
        borderColor: options2.borderColor,
        borderRadius: options2.borderRadius,
        // Organization series
        borderWidth: options2.borderWidth,
        color: series.color,
        colorByPoint: options2.colorByPoint,
        // NOTE: if support for allowTraversingTree is added, then
        // levelIsConstant should be optional.
        levelIsConstant: true,
        linkColor: options2.linkColor,
        // Organization series
        linkLineWidth: options2.linkLineWidth,
        // Organization series
        linkOpacity: options2.linkOpacity,
        states: options2.states
      }
    });
    for (const column2 of nodeColumns) {
      for (const node of column2) {
        series.translateNode(node, column2);
      }
    }
    for (const node of this.nodes) {
      for (const linkPoint of node.linksFrom) {
        if ((linkPoint.weight || linkPoint.isNull) && linkPoint.to) {
          series.translateLink(linkPoint);
          linkPoint.allowShadow = false;
        }
      }
    }
  }
  /**
   * Run translation operations for one link.
   * @private
   */
  translateLink(point) {
    const getY = (node, fromOrTo) => {
      const linkTop = node.offset(point, fromOrTo) * translationFactor;
      const y = Math.min(
        node.nodeY + linkTop,
        // Prevent links from spilling below the node (#12014)
        node.nodeY + (node.shapeArgs && node.shapeArgs.height || 0) - linkHeight
      );
      return y;
    };
    const fromNode = point.fromNode, toNode = point.toNode, chart = this.chart, { inverted } = chart, translationFactor = this.translationFactor, options2 = this.options, linkColorMode = pick104(point.linkColorMode, options2.linkColorMode), curvy = (chart.inverted ? -this.colDistance : this.colDistance) * options2.curveFactor, nodeLeft = fromNode.nodeX, right = toNode.nodeX, outgoing = point.outgoing;
    let linkHeight = Math.max(point.weight * translationFactor, this.options.minLinkWidth), fromY = getY(fromNode, "linksFrom"), toY = getY(toNode, "linksTo"), nodeW = this.nodeWidth, straight2 = right > nodeLeft + nodeW;
    if (chart.inverted) {
      fromY = chart.plotSizeY - fromY;
      toY = (chart.plotSizeY || 0) - toY;
      nodeW = -nodeW;
      linkHeight = -linkHeight;
      straight2 = nodeLeft > right;
    }
    point.shapeType = "path";
    point.linkBase = [
      fromY,
      fromY + linkHeight,
      toY,
      toY + linkHeight
    ];
    if (straight2 && typeof toY === "number") {
      point.shapeArgs = {
        d: [
          ["M", nodeLeft + nodeW, fromY],
          [
            "C",
            nodeLeft + nodeW + curvy,
            fromY,
            right - curvy,
            toY,
            right,
            toY
          ],
          ["L", right + (outgoing ? nodeW : 0), toY + linkHeight / 2],
          ["L", right, toY + linkHeight],
          [
            "C",
            right - curvy,
            toY + linkHeight,
            nodeLeft + nodeW + curvy,
            fromY + linkHeight,
            nodeLeft + nodeW,
            fromY + linkHeight
          ],
          ["Z"]
        ]
      };
    } else if (typeof toY === "number") {
      const bend = 20, vDist = chart.plotHeight - fromY - linkHeight, x1 = right - bend - linkHeight, x2 = right - bend, x3 = right, x4 = nodeLeft + nodeW, x5 = x4 + bend, x6 = x5 + linkHeight, fy1 = fromY, fy2 = fromY + linkHeight, fy3 = fy2 + bend, y4 = fy3 + vDist, y5 = y4 + bend, y6 = y5 + linkHeight, ty1 = toY, ty2 = ty1 + linkHeight, ty3 = ty2 + bend, cfy1 = fy2 - linkHeight * 0.7, cy2 = y5 + linkHeight * 0.7, cty1 = ty2 - linkHeight * 0.7, cx1 = x3 - linkHeight * 0.7, cx2 = x4 + linkHeight * 0.7;
      point.shapeArgs = {
        d: [
          ["M", x4, fy1],
          ["C", cx2, fy1, x6, cfy1, x6, fy3],
          ["L", x6, y4],
          ["C", x6, cy2, cx2, y6, x4, y6],
          ["L", x3, y6],
          ["C", cx1, y6, x1, cy2, x1, y4],
          ["L", x1, ty3],
          ["C", x1, cty1, cx1, ty1, x3, ty1],
          ["L", x3, ty2],
          ["C", x2, ty2, x2, ty2, x2, ty3],
          ["L", x2, y4],
          ["C", x2, y5, x2, y5, x3, y5],
          ["L", x4, y5],
          ["C", x5, y5, x5, y5, x5, y4],
          ["L", x5, fy3],
          ["C", x5, fy2, x5, fy2, x4, fy2],
          ["Z"]
        ]
      };
    }
    point.dlBox = {
      x: nodeLeft + (right - nodeLeft + nodeW) / 2,
      y: fromY + (toY - fromY) / 2,
      height: linkHeight,
      width: 0
    };
    point.tooltipPos = chart.inverted ? [
      chart.plotSizeY - point.dlBox.y - linkHeight / 2,
      chart.plotSizeX - point.dlBox.x
    ] : [
      point.dlBox.x,
      point.dlBox.y + linkHeight / 2
    ];
    point.y = point.plotY = 1;
    point.x = point.plotX = 1;
    if (!point.options.color) {
      if (linkColorMode === "from") {
        point.color = fromNode.color;
      } else if (linkColorMode === "to") {
        point.color = toNode.color;
      } else if (linkColorMode === "gradient") {
        const fromColor = color12(fromNode.color).get(), toColor = color12(toNode.color).get();
        point.color = {
          linearGradient: {
            x1: 1,
            x2: 0,
            y1: 0,
            y2: 0
          },
          stops: [
            [0, inverted ? fromColor : toColor],
            [1, inverted ? toColor : fromColor]
          ]
        };
      }
    }
  }
  /**
   * Run translation operations for one node.
   * @private
   */
  translateNode(node, column2) {
    const translationFactor = this.translationFactor, chart = this.chart, options2 = this.options, { borderRadius, borderWidth = 0 } = options2, sum2 = node.getSum(), nodeHeight = Math.max(Math.round(sum2 * translationFactor), this.options.minLinkWidth), nodeWidth = Math.round(this.nodeWidth), nodeOffset = column2.sankeyColumn.offset(node, translationFactor), fromNodeTop = crisp15(pick104(nodeOffset.absoluteTop, column2.sankeyColumn.top(translationFactor) + nodeOffset.relativeTop), borderWidth), left = crisp15(this.colDistance * node.column + borderWidth / 2, borderWidth) + relativeLength17(node.options[chart.inverted ? "offsetVertical" : "offsetHorizontal"] || 0, nodeWidth), nodeLeft = chart.inverted ? chart.plotSizeX - left : left;
    node.sum = sum2;
    if (sum2) {
      node.shapeType = "roundedRect";
      node.nodeX = nodeLeft;
      node.nodeY = fromNodeTop;
      let x = nodeLeft, y = fromNodeTop, width = node.options.width || options2.width || nodeWidth, height = node.options.height || options2.height || nodeHeight;
      const r = clamp22(relativeLength17(typeof borderRadius === "object" ? borderRadius.radius : borderRadius || 0, width), 0, nodeHeight / 2);
      if (chart.inverted) {
        x = nodeLeft - nodeWidth;
        y = chart.plotSizeY - fromNodeTop - nodeHeight;
        width = node.options.height || options2.height || nodeWidth;
        height = node.options.width || options2.width || nodeHeight;
      }
      node.dlOptions = _SankeySeries.getDLOptions({
        level: this.mapOptionsToLevel[node.level],
        optionsPoint: node.options
      });
      node.plotX = 1;
      node.plotY = 1;
      node.tooltipPos = chart.inverted ? [
        chart.plotSizeY - y - height / 2,
        chart.plotSizeX - x - width / 2
      ] : [
        x + width / 2,
        y + height / 2
      ];
      node.shapeArgs = {
        x,
        y,
        width,
        height,
        r,
        display: node.hasShape() ? "" : "none"
      };
    } else {
      node.dlOptions = {
        enabled: false
      };
    }
  }
};
SankeySeries.defaultOptions = merge96(ColumnSeries14.defaultOptions, SankeySeriesDefaults_default);
NodesComposition_default.compose(SankeyPoint_default, SankeySeries);
extend84(SankeySeries.prototype, {
  animate: LineSeries7.prototype.animate,
  // Create a single node that holds information on incoming and outgoing
  // links.
  createNode: NodesComposition_default.createNode,
  forceDL: true,
  invertible: true,
  isCartesian: false,
  orderNodes: true,
  noSharedTooltip: true,
  pointArrayMap: ["from", "to", "weight"],
  pointClass: SankeyPoint_default,
  searchPoint: Globals_default.noop
});
SeriesRegistry_default.registerSeriesType("sankey", SankeySeries);

// node_modules/highcharts/es-modules/Series/Timeline/TimelinePoint.js
var { line: { prototype: { pointClass: LinePoint } }, pie: { prototype: { pointClass: PiePoint4 } } } = SeriesRegistry_default.seriesTypes;
var { defined: defined74, isNumber: isNumber66, merge: merge97, objectEach: objectEach35, pick: pick105 } = Utilities_default;
var TimelinePoint = class extends LinePoint {
  /* *
   *
   *  Functions
   *
   * */
  alignConnector() {
    const point = this, series = point.series, dataLabel = point.dataLabel, connector = dataLabel.connector, dlOptions = dataLabel.options || {}, connectorWidth = dlOptions.connectorWidth || 0, chart = point.series.chart, bBox = connector.getBBox(), plotPos = {
      x: bBox.x + (dataLabel.translateX || 0),
      y: bBox.y + (dataLabel.translateY || 0)
    };
    if (chart.inverted) {
      plotPos.y -= connectorWidth / 2;
    } else {
      plotPos.x += connectorWidth / 2;
    }
    const isVisible = chart.isInsidePlot(plotPos.x, plotPos.y);
    connector[isVisible ? "animate" : "attr"]({
      d: point.getConnectorPath()
    });
    connector.addClass("highcharts-color-" + point.colorIndex);
    if (!series.chart.styledMode) {
      connector.attr({
        stroke: dlOptions.connectorColor || point.color,
        "stroke-width": dlOptions.connectorWidth,
        opacity: dataLabel[defined74(dataLabel.newOpacity) ? "newOpacity" : "opacity"]
      });
    }
  }
  drawConnector() {
    const point = this, { dataLabel, series } = point;
    if (dataLabel) {
      if (!dataLabel.connector) {
        dataLabel.connector = series.chart.renderer.path(point.getConnectorPath()).attr({
          zIndex: -1
        }).add(dataLabel);
      }
      if (point.series.chart.isInsidePlot(
        // #10507
        dataLabel.x || 0,
        dataLabel.y || 0
      )) {
        point.alignConnector();
      }
    }
  }
  getConnectorPath() {
    const { plotX = 0, plotY = 0, series, dataLabel } = this, chart = series.chart, xAxisLen = series.xAxis.len, inverted = chart.inverted, direction = inverted ? "x2" : "y2";
    if (dataLabel) {
      const targetDLPos = dataLabel.targetPosition, negativeDistance = (dataLabel.alignAttr || dataLabel)[direction[0]] < series.yAxis.len / 2;
      let coords = {
        x1: plotX,
        y1: plotY,
        x2: plotX,
        y2: isNumber66(targetDLPos.y) ? targetDLPos.y : dataLabel.y
      };
      if (inverted) {
        coords = {
          x1: plotY,
          y1: xAxisLen - plotX,
          x2: targetDLPos.x || dataLabel.x,
          y2: xAxisLen - plotX
        };
      }
      if (negativeDistance) {
        coords[direction] += dataLabel[inverted ? "width" : "height"] || 0;
      }
      objectEach35(coords, (_coord, i) => {
        coords[i] -= (dataLabel.alignAttr || dataLabel)[i[0]];
      });
      return chart.renderer.crispLine([
        ["M", coords.x1, coords.y1],
        ["L", coords.x2, coords.y2]
      ], dataLabel.options?.connectorWidth || 0);
    }
    return [];
  }
  constructor(series, options2) {
    super(series, options2);
    this.name ?? (this.name = // If options is null, we are dealing with a null point
    (options2 && options2.y !== null || !series.options.nullInteraction) && "Event" || "Null");
    this.y = 1;
  }
  isValid() {
    return this.options.y !== null || this.series.options.nullInteraction || true;
  }
  setState() {
    const proceed = super.setState;
    if (!this.isNull || this.series.options.nullInteraction) {
      proceed.apply(this, arguments);
    }
  }
  setVisible(visible, redraw) {
    const point = this, series = point.series;
    redraw = pick105(redraw, series.options.ignoreHiddenPoint);
    PiePoint4.prototype.setVisible.call(point, visible, false);
    series.processData();
    if (redraw) {
      series.chart.redraw();
    }
  }
  applyOptions(options2, x) {
    const isNull = this.isNull || options2 === null || options2.y === null, series = this.series;
    if (!x && !options2?.x) {
      if (isNumber66(this.x)) {
        x = this.x;
      } else if (isNumber66(series?.xIncrement) || NaN) {
        x = series.xIncrement || 0;
        series.autoIncrement();
      }
    }
    options2 = Point_default.prototype.optionsToObject.call(this, options2 ?? (series.options.nullInteraction && { y: 0 } || null));
    const p = super.applyOptions(options2, x);
    this.userDLOptions = merge97(this.userDLOptions, options2.dataLabels);
    p.isNull = isNull;
    return p;
  }
};
var TimelinePoint_default = TimelinePoint;

// node_modules/highcharts/es-modules/Series/Timeline/TimelineSeriesDefaults.js
var TimelineSeriesDefaults = {
  colorByPoint: true,
  stickyTracking: false,
  ignoreHiddenPoint: true,
  /**
   * @ignore
   */
  legendType: "point",
  /**
   * Pixel width of the graph line.
   */
  lineWidth: 4,
  tooltip: {
    headerFormat: '<span style="color:{point.color}"></span> <span style="font-size: 0.8em"> {point.key}</span><br/>',
    pointFormat: "{point.description}"
  },
  states: {
    hover: {
      lineWidthPlus: 0
    }
  },
  /**
   * @declare Highcharts.TimelineDataLabelsOptionsObject
   */
  dataLabels: {
    enabled: true,
    allowOverlap: true,
    /**
     * Whether to position data labels alternately. For example, if
     * [distance](#plotOptions.timeline.dataLabels.distance)
     * is set equal to `100`, then data labels will be positioned
     * alternately (on both sides of the point) at a distance of 100px.
     *
     * @sample {highcharts} highcharts/series-timeline/alternate-disabled
     *         Alternate disabled
     */
    alternate: true,
    backgroundColor: "#ffffff",
    borderWidth: 1,
    borderColor: "#999999",
    borderRadius: 3,
    color: "#333333",
    /**
     * The color of the line connecting the data label to the point.
     * The default color is the same as the point's color.
     *
     * In styled mode, the connector stroke is given in the
     * `.highcharts-data-label-connector` class.
     *
     * @sample {highcharts} highcharts/series-timeline/connector-styles
     *         Custom connector width and color
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @apioption plotOptions.timeline.dataLabels.connectorColor
     */
    /**
     * The width of the line connecting the data label to the point.
     *
     * In styled mode, the connector stroke width is given in the
     * `.highcharts-data-label-connector` class.
     *
     * @sample {highcharts} highcharts/series-timeline/connector-styles
     *         Custom connector width and color
     */
    connectorWidth: 1,
    /**
     * A pixel value defining the distance between the data label and
     * the point. Negative numbers puts the label on top of the point in a
     * non-inverted chart. Defaults to 100 for horizontal and 20 for
     * vertical timeline (`chart.inverted: true`).
     */
    distance: void 0,
    // eslint-disable-next-line jsdoc/require-description
    /**
     * @default function () {
     *   let format;
     *
     *   if (!this.series.chart.styledMode) {
     *       format = '<span style="color:' + this.point.color +
     *           '"> </span>';
     *   } else {
     *       format = '<span class="highcharts-color-' +
     *          this.point.colorIndex + '"> </span>';
     *   }
     *   format += '<span>' + (this.key || '') + '</span><br/>' +
     *       (this.point.label || '');
     *   return format;
     * }
     */
    formatter: function() {
      let format18;
      if (!this.series.chart.styledMode) {
        format18 = '<span style="color:' + this.point.color + '"> </span>';
      } else {
        format18 = '<span class="highcharts-color-' + this.point.colorIndex + '"> </span>';
      }
      format18 += '<span class="highcharts-strong">' + (this.key || "") + "</span><br/>" + (this.label || "");
      return format18;
    },
    style: {
      /** @internal */
      textOutline: "none",
      /** @internal */
      fontWeight: "normal",
      /** @internal */
      fontSize: "0.8em",
      /** @internal */
      textAlign: "left"
    },
    /**
     * Shadow options for the data label.
     *
     * @type {boolean|Highcharts.CSSObject}
     */
    shadow: false,
    /**
     * @type      {number}
     * @apioption plotOptions.timeline.dataLabels.width
     */
    verticalAlign: "middle"
  },
  marker: {
    enabledThreshold: 0,
    symbol: "square",
    radius: 6,
    lineWidth: 2,
    height: 15
  },
  showInLegend: false,
  colorKey: "x",
  legendSymbol: "rectangle"
};
var TimelineSeriesDefaults_default = TimelineSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Timeline/TimelineSeries.js
var { column: ColumnSeries15, line: LineSeries8 } = SeriesRegistry_default.seriesTypes;
var { addEvent: addEvent87, arrayMax: arrayMax12, arrayMin: arrayMin10, defined: defined75, extend: extend85, merge: merge98, pick: pick106 } = Utilities_default;
var TimelineSeries = class extends LineSeries8 {
  /* *
   *
   *  Functions
   *
   * */
  alignDataLabel(point, dataLabel, _options, _alignTo) {
    const series = this, isInverted = series.chart.inverted, visiblePoints = series.visibilityMap.filter((point2) => !!point2), visiblePointsCount = series.visiblePointsCount || 0, pointIndex = visiblePoints.indexOf(point), isFirstOrLast = !pointIndex || pointIndex === visiblePointsCount - 1, dataLabelsOptions = series.options.dataLabels, userDLOptions = point.userDLOptions || {}, multiplier = dataLabelsOptions.alternate ? isFirstOrLast ? 1.5 : 2 : 1, availableSpace = Math.floor(series.xAxis.len / visiblePointsCount), pad3 = dataLabel.padding;
    let distance, targetDLWidth, styles;
    if (point.visible) {
      distance = Math.abs(userDLOptions.x || point.options.dataLabels.x);
      if (isInverted) {
        targetDLWidth = (distance - pad3) * 2 - (point.itemHeight || 0) / 2;
        styles = {
          width: pick106(dataLabelsOptions.style?.width, `${series.yAxis.len * 0.4}px`),
          // Apply ellipsis when data label height is exceeded.
          textOverflow: (dataLabel.width || 0) / targetDLWidth * (dataLabel.height || 0) / 2 > availableSpace * multiplier ? "ellipsis" : "none"
        };
      } else {
        styles = {
          width: (userDLOptions.width || dataLabelsOptions.width || availableSpace * multiplier - pad3 * 2) + "px"
        };
      }
      dataLabel.css(styles);
      if (!series.chart.styledMode) {
        dataLabel.shadow(dataLabelsOptions.shadow);
      }
    }
    super.alignDataLabel.apply(series, arguments);
  }
  bindAxes() {
    const series = this;
    super.bindAxes();
    if (!series.xAxis.userOptions.type) {
      series.xAxis.categories = series.xAxis.hasNames = true;
    }
  }
  distributeDL() {
    const series = this, dataLabelsOptions = series.options.dataLabels, inverted = series.chart.inverted;
    let visibilityIndex = 1;
    if (dataLabelsOptions) {
      const distance = pick106(dataLabelsOptions.distance, inverted ? 20 : 100);
      for (const point of series.points) {
        const defaults = {
          [inverted ? "x" : "y"]: dataLabelsOptions.alternate && visibilityIndex % 2 ? -distance : distance
        };
        if (inverted) {
          defaults.align = dataLabelsOptions.alternate && visibilityIndex % 2 ? "right" : "left";
        }
        point.options.dataLabels = merge98(defaults, point.userDLOptions);
        visibilityIndex++;
      }
    }
  }
  generatePoints() {
    super.generatePoints();
    const series = this, points = series.points, pointsLen = points.length, xData = series.getColumn("x");
    for (let i = 0, iEnd = pointsLen; i < iEnd; ++i) {
      const x = xData[i];
      points[i].applyOptions({ x }, x);
    }
  }
  getVisibilityMap() {
    const series = this, nullInteraction = series.options.nullInteraction, map = ((series.data.length ? series.data : series.options.data) || []).map((point) => point && point.visible !== false && (!point.isNull || nullInteraction) ? point : false);
    return map;
  }
  getXExtremes(xData) {
    const series = this, filteredData = xData.filter((_x, i) => series.points[i].isValid() && series.points[i].visible);
    return {
      min: arrayMin10(filteredData),
      max: arrayMax12(filteredData)
    };
  }
  init() {
    const series = this;
    super.init.apply(series, arguments);
    series.eventsToUnbind.push(addEvent87(series, "afterTranslate", function() {
      let lastPlotX, closestPointRangePx = Number.MAX_VALUE;
      for (const point of series.points) {
        point.isInside = point.isInside && point.visible;
        if (point.visible && (!point.isNull || series.options.nullInteraction)) {
          if (defined75(lastPlotX)) {
            closestPointRangePx = Math.min(closestPointRangePx, Math.abs(point.plotX - lastPlotX));
          }
          lastPlotX = point.plotX;
        }
      }
      series.closestPointRangePx = closestPointRangePx;
    }));
    series.eventsToUnbind.push(addEvent87(series, "drawDataLabels", function() {
      series.distributeDL();
    }));
    series.eventsToUnbind.push(addEvent87(series, "afterDrawDataLabels", function() {
      let dataLabel;
      for (const point of series.points) {
        dataLabel = point.dataLabel;
        if (dataLabel) {
          dataLabel.animate = function(params) {
            if (this.targetPosition) {
              this.targetPosition = params;
            }
            return this.renderer.Element.prototype.animate.apply(this, arguments);
          };
          if (!dataLabel.targetPosition) {
            dataLabel.targetPosition = {};
          }
          point.drawConnector();
        }
      }
    }));
    series.eventsToUnbind.push(addEvent87(series.chart, "afterHideOverlappingLabel", function() {
      for (const p of series.points) {
        if (p.dataLabel && p.dataLabel.connector && p.dataLabel.oldOpacity !== p.dataLabel.newOpacity) {
          p.alignConnector();
        }
      }
    }));
  }
  markerAttribs(point, state) {
    const series = this, seriesMarkerOptions = series.options.marker, pointMarkerOptions = point.marker || {}, symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol, width = pick106(pointMarkerOptions.width, seriesMarkerOptions.width, series.closestPointRangePx), height = pick106(pointMarkerOptions.height, seriesMarkerOptions.height);
    let seriesStateOptions, pointStateOptions, radius = 0;
    if (series.xAxis.dateTime) {
      return super.markerAttribs(point, state);
    }
    if (state) {
      seriesStateOptions = seriesMarkerOptions.states[state] || {};
      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
      radius = pick106(pointStateOptions.radius, seriesStateOptions.radius, radius + (seriesStateOptions.radiusPlus || 0));
    }
    point.hasImage = symbol && symbol.indexOf("url") === 0;
    const attribs = {
      x: Math.floor(point.plotX) - width / 2 - radius / 2,
      y: point.plotY - height / 2 - radius / 2,
      width: width + radius,
      height: height + radius
    };
    return series.chart.inverted ? {
      y: attribs.x && attribs.width && series.xAxis.len - attribs.x - attribs.width,
      x: attribs.y && attribs.y,
      width: attribs.height,
      height: attribs.width
    } : attribs;
  }
};
TimelineSeries.defaultOptions = merge98(LineSeries8.defaultOptions, TimelineSeriesDefaults_default);
addEvent87(TimelineSeries, "afterProcessData", function() {
  const series = this, xData = series.getColumn("x");
  let visiblePoints = 0;
  series.visibilityMap = series.getVisibilityMap();
  for (const point of series.visibilityMap) {
    if (point) {
      visiblePoints++;
    }
  }
  series.visiblePointsCount = visiblePoints;
  this.dataTable.setColumn("y", new Array(xData.length).fill(1));
});
extend85(TimelineSeries.prototype, {
  // Use a group of trackers from TrackerMixin
  drawTracker: ColumnSeries15.prototype.drawTracker,
  pointClass: TimelinePoint_default,
  trackerGroups: ["markerGroup", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("timeline", TimelineSeries);

// node_modules/highcharts/es-modules/Series/Organization/OrganizationPoint.js
var { sankey: { prototype: { pointClass: SankeyPointClass } } } = SeriesRegistry_default.seriesTypes;
var { defined: defined76, find: find17, pick: pick107 } = Utilities_default;
function getOffset(node) {
  let offset3 = node.linksFrom.length;
  node.linksFrom.forEach((link) => {
    if (link.id === link.toNode.linksTo[0].id) {
      offset3 += getOffset(link.toNode);
    } else {
      offset3--;
    }
  });
  return offset3;
}
var OrganizationPoint = class extends SankeyPointClass {
  /* *
   *
   *  Functions
   *
   * */
  constructor(series, options2, x) {
    super(series, options2, x);
    if (!this.isNode) {
      this.dataLabelOnNull = true;
      this.formatPrefix = "link";
    }
  }
  /**
   * All nodes in an org chart are equal width.
   * @private
   */
  getSum() {
    return 1;
  }
  /**
   * Set node.column for hanging layout
   * @private
   */
  setNodeColumn() {
    super.setNodeColumn();
    const node = this, fromNode = node.getFromNode().fromNode;
    if (
      // Not defined by user
      !defined76(node.options.column) && // Has links to
      node.linksTo.length !== 0 && // And parent uses hanging layout
      fromNode && fromNode.options.layout === "hanging"
    ) {
      let i = -1, link;
      node.options.layout = pick107(node.options.layout, "hanging");
      node.hangsFrom = fromNode;
      find17(fromNode.linksFrom, (link2, index) => {
        const found = link2.toNode === node;
        if (found) {
          i = index;
        }
        return found;
      });
      for (let j = 0; j < fromNode.linksFrom.length; ++j) {
        link = fromNode.linksFrom[j];
        if (link.toNode.id === node.id) {
          j = fromNode.linksFrom.length;
        } else {
          i += getOffset(link.toNode);
        }
      }
      node.column = (node.column || 0) + i;
    }
  }
};
var OrganizationPoint_default = OrganizationPoint;

// node_modules/highcharts/es-modules/Series/Organization/OrganizationSeriesDefaults.js
var OrganizationSeriesDefaults = {
  /**
   * The border color of the node cards.
   *
   * @type {Highcharts.ColorString}
   */
  borderColor: "#666666",
  /**
   * The border radius of the node cards.
   *
   * @private
   */
  borderRadius: 3,
  /**
   * Radius for the rounded corners of the links between nodes. This
   * option is now deprecated, and moved to
   * [link.radius](#plotOptions.organization.link.radius).
   *
   * @sample   highcharts/series-organization/link-options
   *           Square links
   *
   * @deprecated
   * @apioption series.organization.linkRadius
   */
  /**
   * Link Styling options
   * @since 10.3.0
   * @product highcharts
   */
  link: {
    /**
     * Modifier of the shape of the curved link. Works best for values
     * between 0 and 1, where 0 is a straight line, and 1 is a shape
     * close to the default one.
     *
     * @default 0.5
     * @type {number}
     * @since 10.3.0
     * @product highcharts
     * @apioption series.organization.link.offset
     */
    /**
     * The color of the links between nodes.
     *
     * @type {Highcharts.ColorString}
     */
    color: "#666666",
    /**
     * The line width of the links connecting nodes, in pixels.
     *
     * @sample   highcharts/series-organization/link-options
     *           Square links
     */
    lineWidth: 1,
    /**
     * Radius for the rounded corners of the links between nodes.
     * Works for `default` link type.
     *
     * @sample   highcharts/series-organization/link-options
     *           Square links
     */
    radius: 10,
    /**
     * Type of the link shape.
     *
     * @sample   highcharts/series-organization/different-link-types
     *           Different link types
     *
     * @declare Highcharts.OrganizationLinkTypeValue
     * @type {'default' | 'curved' | 'straight'}
     * @default 'default'
     * @product highcharts
     */
    type: "default"
  },
  borderWidth: 1,
  /**
   * @declare Highcharts.SeriesOrganizationDataLabelsOptionsObject
   *
   * @private
   */
  dataLabels: {
    /* eslint-disable valid-jsdoc */
    /**
     * A callback for defining the format for _nodes_ in the
     * organization chart. The `nodeFormat` option takes precedence
     * over `nodeFormatter`.
     *
     * In an organization chart, the `nodeFormatter` is a quite complex
     * function of the available options, striving for a good default
     * layout of cards with or without images. In organization chart,
     * the data labels come with `useHTML` set to true, meaning they
     * will be rendered as true HTML above the SVG.
     *
     * @sample highcharts/series-organization/datalabels-nodeformatter
     *         Modify the default label format output
     *
     * @type  {Highcharts.SeriesSankeyDataLabelsFormatterCallbackFunction}
     * @since 6.0.2
     */
    nodeFormatter: function() {
      const outerStyle = {
        width: "100%",
        height: "100%",
        display: "flex",
        "flex-direction": "row",
        "align-items": "center",
        "justify-content": "center"
      }, imageStyle = {
        "max-height": "100%",
        "border-radius": "50%"
      }, innerStyle = {
        width: "100%",
        padding: 0,
        "text-align": "center",
        "white-space": "normal"
      }, nameStyle = {
        margin: 0
      }, titleStyle = {
        margin: 0
      }, descriptionStyle = {
        opacity: 0.75,
        margin: "5px"
      };
      function styleAttr(style) {
        return Object.keys(style).reduce(function(str, key) {
          return str + key + ":" + style[key] + ";";
        }, 'style="') + '"';
      }
      const { description, image, title } = this.point;
      if (image) {
        imageStyle["max-width"] = "30%";
        innerStyle.width = "70%";
      }
      if (this.series.chart.renderer.forExport) {
        outerStyle.display = "block";
        innerStyle.position = "absolute";
        innerStyle.left = image ? "30%" : 0;
        innerStyle.top = 0;
      }
      let html2 = "<div " + styleAttr(outerStyle) + ">";
      if (image) {
        html2 += '<img src="' + image + '" ' + styleAttr(imageStyle) + ">";
      }
      html2 += "<div " + styleAttr(innerStyle) + ">";
      if (this.point.name) {
        html2 += "<h4 " + styleAttr(nameStyle) + ">" + this.point.name + "</h4>";
      }
      if (title) {
        html2 += "<p " + styleAttr(titleStyle) + ">" + (title || "") + "</p>";
      }
      if (description) {
        html2 += "<p " + styleAttr(descriptionStyle) + ">" + description + "</p>";
      }
      html2 += "</div></div>";
      return html2;
    },
    /* eslint-enable valid-jsdoc */
    style: {
      /** @internal */
      fontWeight: "normal",
      /** @internal */
      fontSize: "0.9em",
      /** @internal */
      textAlign: "left"
    },
    useHTML: true,
    linkTextPath: {
      attributes: {
        startOffset: "95%",
        textAnchor: "end"
      }
    }
  },
  /**
   * The indentation in pixels of hanging nodes, nodes which parent has
   * [layout](#series.organization.nodes.layout) set to `hanging`.
   *
   * @private
   */
  hangingIndent: 20,
  /**
   * Defines the indentation of a `hanging` layout parent's children.
   * Possible options:
   *
   * - `inherit` (default): Only the first child adds the indentation,
   * children of a child with indentation inherit the indentation.
   * - `cumulative`: All children of a child with indentation add its
   * own indent. The option may cause overlapping of nodes.
   * Then use `shrink` option:
   * - `shrink`: Nodes shrink by the
   * [hangingIndent](#plotOptions.organization.hangingIndent)
   * value until they reach the
   * [minNodeLength](#plotOptions.organization.minNodeLength).
   *
   * @sample highcharts/series-organization/hanging-cumulative
   *         Every indent increases the indentation
   *
   * @sample highcharts/series-organization/hanging-shrink
   *         Every indent decreases the nodes' width
   *
   * @type {Highcharts.OrganizationHangingIndentTranslationValue}
   * @since 10.0.0
   * @default inherit
   *
   * @private
   */
  hangingIndentTranslation: "inherit",
  /**
   * Whether links connecting hanging nodes should be drawn on the left
   * or right side. Useful for RTL layouts.
   * **Note:** Only effects inverted charts (vertical layout).
   *
   * @sample highcharts/series-organization/hanging-side
   *         Nodes hanging from right side.
   *
   * @type {'left'|'right'}
   * @since 11.3.0
   * @default 'left'
   */
  hangingSide: "left",
  /**
   *
   * The color of the links between nodes. This option is moved to
   * [link.color](#plotOptions.organization.link.color).
   *
   * @type {Highcharts.ColorString}
   * @deprecated
   * @apioption series.organization.linkColor
   * @private
   */
  /**
   * The line width of the links connecting nodes, in pixels. This option
   * is now deprecated and moved to the
   * [link.radius](#plotOptions.organization.link.lineWidth).
   *
   * @sample   highcharts/series-organization/link-options
   *           Square links
   *
   * @deprecated
   * @apioption series.organization.linkLineWidth
   * @private
   */
  /**
   * In a horizontal chart, the minimum width of the **hanging** nodes
   * only, in pixels. In a vertical chart, the minimum height of the
   * **haning** nodes only, in pixels too.
   *
   * Note: Used only when
   * [hangingIndentTranslation](#plotOptions.organization.hangingIndentTranslation)
   * is set to `shrink`.
   *
   * @see [nodeWidth](#plotOptions.organization.nodeWidth)
   *
   * @private
   */
  minNodeLength: 10,
  /**
   * In a horizontal chart, the width of the nodes in pixels. Note that
   * most organization charts are inverted (vertical), so the name of this
   * option is counterintuitive.
   *
   * @see [minNodeLength](#plotOptions.organization.minNodeLength)
   *
   * @private
   */
  nodeWidth: 50,
  tooltip: {
    nodeFormat: "{point.name}<br>{point.title}<br>{point.description}"
  }
};
var OrganizationSeriesDefaults_default = OrganizationSeriesDefaults;

// node_modules/highcharts/es-modules/Series/PathUtilities.js
var getLinkPath = {
  "default": getDefaultPath,
  straight: getStraightPath,
  curved: getCurvedPath
};
function getDefaultPath(pathParams) {
  const { x1, y1, x2, y2, width = 0, inverted = false, radius, parentVisible } = pathParams;
  const path = [
    ["M", x1, y1],
    ["L", x1, y1],
    ["C", x1, y1, x1, y2, x1, y2],
    ["L", x1, y2],
    ["C", x1, y1, x1, y2, x1, y2],
    ["L", x1, y2]
  ];
  return parentVisible ? applyRadius([
    ["M", x1, y1],
    ["L", x1 + width * (inverted ? -0.5 : 0.5), y1],
    ["L", x1 + width * (inverted ? -0.5 : 0.5), y2],
    ["L", x2, y2]
  ], radius) : path;
}
function getStraightPath(pathParams) {
  const { x1, y1, x2, y2, width = 0, inverted = false, parentVisible } = pathParams;
  return parentVisible ? [
    ["M", x1, y1],
    ["L", x1 + width * (inverted ? -1 : 1), y2],
    ["L", x2, y2]
  ] : [
    ["M", x1, y1],
    ["L", x1, y2],
    ["L", x1, y2]
  ];
}
function getCurvedPath(pathParams) {
  const { x1, y1, x2, y2, offset: offset3 = 0, width = 0, inverted = false, parentVisible } = pathParams;
  return parentVisible ? [
    ["M", x1, y1],
    [
      "C",
      x1 + offset3,
      y1,
      x1 - offset3 + width * (inverted ? -1 : 1),
      y2,
      x1 + width * (inverted ? -1 : 1),
      y2
    ],
    ["L", x2, y2]
  ] : [
    ["M", x1, y1],
    ["C", x1, y1, x1, y2, x1, y2],
    ["L", x2, y2]
  ];
}
function applyRadius(path, r) {
  const d = [];
  for (let i = 0; i < path.length; i++) {
    const x = path[i][1];
    const y = path[i][2];
    if (typeof x === "number" && typeof y === "number") {
      if (i === 0) {
        d.push(["M", x, y]);
      } else if (i === path.length - 1) {
        d.push(["L", x, y]);
      } else if (r) {
        const prevSeg = path[i - 1];
        const nextSeg = path[i + 1];
        if (prevSeg && nextSeg) {
          const x1 = prevSeg[1], y1 = prevSeg[2], x2 = nextSeg[1], y2 = nextSeg[2];
          if (typeof x1 === "number" && typeof x2 === "number" && typeof y1 === "number" && typeof y2 === "number" && x1 !== x2 && y1 !== y2) {
            const directionX = x1 < x2 ? 1 : -1, directionY = y1 < y2 ? 1 : -1;
            d.push([
              "L",
              x - directionX * Math.min(Math.abs(x - x1), r),
              y - directionY * Math.min(Math.abs(y - y1), r)
            ], [
              "C",
              x,
              y,
              x,
              y,
              x + directionX * Math.min(Math.abs(x - x2), r),
              y + directionY * Math.min(Math.abs(y - y2), r)
            ]);
          }
        }
      } else {
        d.push(["L", x, y]);
      }
    }
  }
  return d;
}
var PathUtilities = {
  applyRadius,
  getLinkPath
};
var PathUtilities_default = PathUtilities;

// node_modules/highcharts/es-modules/Series/Organization/OrganizationSeries.js
var { sankey: SankeySeries2 } = SeriesRegistry_default.seriesTypes;
var { css: css18, crisp: crisp16, extend: extend86, isNumber: isNumber67, merge: merge99, pick: pick108 } = Utilities_default;
TextPath_default.compose(SVGElement_default);
var OrganizationSeries = class extends SankeySeries2 {
  /* *
   *
   *  Functions
   *
   * */
  alignDataLabel(point, dataLabel, options2) {
    const shapeArgs = point.shapeArgs, text = dataLabel.text;
    if (options2.useHTML && shapeArgs) {
      const padjust = this.options.borderWidth + 2 * this.options.dataLabels.padding;
      let width = shapeArgs.width || 0, height = shapeArgs.height || 0;
      if (this.chart.inverted) {
        width = height;
        height = shapeArgs.width || 0;
      }
      height -= padjust;
      width -= padjust;
      text.foreignObject?.attr({
        x: 0,
        y: 0,
        width,
        height
      });
      css18(text.element.parentNode, {
        width: width + "px",
        height: height + "px"
      });
      css18(text.element, {
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        overflow: "hidden"
      });
      dataLabel.getBBox = () => ({ width, height, x: 0, y: 0 });
      dataLabel.width = width;
      dataLabel.height = height;
    }
    super.alignDataLabel.apply(this, arguments);
  }
  createNode(id) {
    const node = super.createNode.call(this, id);
    node.getSum = () => 1;
    return node;
  }
  pointAttribs(point, state) {
    const series = this, attribs = SankeySeries2.prototype.pointAttribs.call(series, point, state), level = point.isNode ? point.level : point.fromNode.level, levelOptions = series.mapOptionsToLevel[level || 0] || {}, options2 = point.options, stateOptions = levelOptions.states && levelOptions.states[state] || {}, borderRadius = pick108(stateOptions.borderRadius, options2.borderRadius, levelOptions.borderRadius, series.options.borderRadius), linkColor = pick108(stateOptions.linkColor, options2.linkColor, levelOptions.linkColor, series.options.linkColor, stateOptions.link && stateOptions.link.color, options2.link && options2.link.color, levelOptions.link && levelOptions.link.color, series.options.link && series.options.link.color), linkLineWidth = pick108(stateOptions.linkLineWidth, options2.linkLineWidth, levelOptions.linkLineWidth, series.options.linkLineWidth, stateOptions.link && stateOptions.link.lineWidth, options2.link && options2.link.lineWidth, levelOptions.link && levelOptions.link.lineWidth, series.options.link && series.options.link.lineWidth), linkOpacity = pick108(stateOptions.linkOpacity, options2.linkOpacity, levelOptions.linkOpacity, series.options.linkOpacity, stateOptions.link && stateOptions.link.linkOpacity, options2.link && options2.link.linkOpacity, levelOptions.link && levelOptions.link.linkOpacity, series.options.link && series.options.link.linkOpacity);
    if (!point.isNode) {
      attribs.stroke = linkColor;
      attribs["stroke-width"] = linkLineWidth;
      attribs.opacity = linkOpacity;
      delete attribs.fill;
    } else {
      if (isNumber67(borderRadius)) {
        attribs.r = borderRadius;
      }
    }
    return attribs;
  }
  translateLink(point) {
    const chart = this.chart, options2 = this.options, fromNode = point.fromNode, toNode = point.toNode, linkWidth = pick108(options2.linkLineWidth, options2.link.lineWidth, 0), factor = pick108(options2.link.offset, 0.5), type = pick108(point.options.link && point.options.link.type, options2.link.type);
    if (fromNode.shapeArgs && toNode.shapeArgs) {
      const hangingIndent = options2.hangingIndent, hangingRight = options2.hangingSide === "right", toOffset = toNode.options.offset, percentOffset = /%$/.test(toOffset) && parseInt(toOffset, 10), inverted = chart.inverted;
      let x1 = crisp16((fromNode.shapeArgs.x || 0) + (fromNode.shapeArgs.width || 0), linkWidth), y1 = crisp16((fromNode.shapeArgs.y || 0) + (fromNode.shapeArgs.height || 0) / 2, linkWidth), x2 = crisp16(toNode.shapeArgs.x || 0, linkWidth), y2 = crisp16((toNode.shapeArgs.y || 0) + (toNode.shapeArgs.height || 0) / 2, linkWidth), xMiddle;
      if (inverted) {
        x1 -= fromNode.shapeArgs.width || 0;
        x2 += toNode.shapeArgs.width || 0;
      }
      xMiddle = this.colDistance ? crisp16(x2 + (inverted ? 1 : -1) * (this.colDistance - this.nodeWidth) / 2, linkWidth) : crisp16((x2 + x1) / 2, linkWidth);
      if (percentOffset && (percentOffset >= 50 || percentOffset <= -50)) {
        xMiddle = x2 = crisp16(x2 + (inverted ? -0.5 : 0.5) * (toNode.shapeArgs.width || 0), linkWidth);
        y2 = toNode.shapeArgs.y || 0;
        if (percentOffset > 0) {
          y2 += toNode.shapeArgs.height || 0;
        }
      }
      if (toNode.hangsFrom === fromNode) {
        if (chart.inverted) {
          y1 = !hangingRight ? crisp16((fromNode.shapeArgs.y || 0) + (fromNode.shapeArgs.height || 0) - hangingIndent / 2, linkWidth) : crisp16((fromNode.shapeArgs.y || 0) + hangingIndent / 2, linkWidth);
          y2 = !hangingRight ? (toNode.shapeArgs.y || 0) + (toNode.shapeArgs.height || 0) : (toNode.shapeArgs.y || 0) + hangingIndent / 2;
        } else {
          y1 = crisp16((fromNode.shapeArgs.y || 0) + hangingIndent / 2, linkWidth);
        }
        xMiddle = x2 = crisp16((toNode.shapeArgs.x || 0) + (toNode.shapeArgs.width || 0) / 2, linkWidth);
      }
      point.plotX = xMiddle;
      point.plotY = (y1 + y2) / 2;
      point.shapeType = "path";
      if (type === "straight") {
        point.shapeArgs = {
          d: [
            ["M", x1, y1],
            ["L", x2, y2]
          ]
        };
      } else if (type === "curved") {
        const offset3 = Math.abs(x2 - x1) * factor * (inverted ? -1 : 1);
        point.shapeArgs = {
          d: [
            ["M", x1, y1],
            ["C", x1 + offset3, y1, x2 - offset3, y2, x2, y2]
          ]
        };
      } else {
        point.shapeArgs = {
          d: PathUtilities_default.applyRadius([
            ["M", x1, y1],
            ["L", xMiddle, y1],
            ["L", xMiddle, y2],
            ["L", x2, y2]
          ], pick108(options2.linkRadius, options2.link.radius))
        };
      }
      point.dlBox = {
        x: (x1 + x2) / 2,
        y: (y1 + y2) / 2,
        height: linkWidth,
        width: 0
      };
    }
  }
  translateNode(node, column2) {
    super.translateNode(node, column2);
    const chart = this.chart, options2 = this.options, sum2 = node.getSum(), translationFactor = this.translationFactor, nodeHeight = Math.max(Math.round(sum2 * translationFactor), options2.minLinkWidth || 0), hangingRight = options2.hangingSide === "right", indent = options2.hangingIndent || 0, indentLogic = options2.hangingIndentTranslation, minLength = options2.minNodeLength || 10, nodeWidth = Math.round(this.nodeWidth), shapeArgs = node.shapeArgs, sign = chart.inverted ? -1 : 1;
    let parentNode = node.hangsFrom;
    if (parentNode) {
      if (indentLogic === "cumulative") {
        shapeArgs.height -= indent;
        if (chart.inverted && !hangingRight) {
          shapeArgs.y -= sign * indent;
        }
        while (parentNode) {
          shapeArgs.y += (hangingRight ? 1 : sign) * indent;
          parentNode = parentNode.hangsFrom;
        }
      } else if (indentLogic === "shrink") {
        while (parentNode && shapeArgs.height > indent + minLength) {
          shapeArgs.height -= indent;
          if (!chart.inverted || hangingRight) {
            shapeArgs.y += indent;
          }
          parentNode = parentNode.hangsFrom;
        }
      } else {
        shapeArgs.height -= indent;
        if (!chart.inverted || hangingRight) {
          shapeArgs.y += indent;
        }
      }
    }
    node.nodeHeight = chart.inverted ? shapeArgs.width : shapeArgs.height;
    if (node.shapeArgs && !node.hangsFrom) {
      node.shapeArgs = merge99(node.shapeArgs, {
        x: (node.shapeArgs.x || 0) + nodeWidth / 2 - (node.shapeArgs.width || 0) / 2,
        y: (node.shapeArgs.y || 0) + nodeHeight / 2 - (node.shapeArgs.height || 0) / 2
      });
    }
  }
  drawDataLabels() {
    const dlOptions = this.options.dataLabels;
    if (dlOptions.linkTextPath && dlOptions.linkTextPath.enabled) {
      for (const link of this.points) {
        link.options.dataLabels = merge99(link.options.dataLabels, { useHTML: false });
      }
    }
    super.drawDataLabels();
  }
};
OrganizationSeries.defaultOptions = merge99(SankeySeries2.defaultOptions, OrganizationSeriesDefaults_default);
extend86(OrganizationSeries.prototype, {
  pointClass: OrganizationPoint_default
});
SeriesRegistry_default.registerSeriesType("organization", OrganizationSeries);

// node_modules/highcharts/es-modules/Series/XRange/XRangeSeriesDefaults.js
var { correctFloat: correctFloat17, isNumber: isNumber68, isObject: isObject22 } = Utilities_default;
var XRangeSeriesDefaults = {
  /**
   * A partial fill for each point, typically used to visualize how much
   * of a task is performed. The partial fill object can be set either on
   * series or point level.
   *
   * @sample {highcharts} highcharts/demo/x-range
   *         X-range with partial fill
   *
   * @product   highcharts highstock gantt
   * @apioption plotOptions.xrange.partialFill
   */
  /**
   * The fill color to be used for partial fills. Defaults to a darker
   * shade of the point color.
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product   highcharts highstock gantt
   * @apioption plotOptions.xrange.partialFill.fill
   */
  /**
   * A partial fill for each point, typically used to visualize how much
   * of a task is performed. See [completed](series.gantt.data.completed).
   *
   * @sample gantt/demo/progress-indicator
   *         Gantt with progress indicator
   *
   * @product   gantt
   * @apioption plotOptions.gantt.partialFill
   */
  /**
   * In an X-range series, this option makes all points of the same Y-axis
   * category the same color.
   */
  colorByPoint: true,
  dataLabels: {
    formatter: function() {
      let amount = this.partialFill;
      if (isObject22(amount)) {
        amount = amount.amount;
      }
      if (isNumber68(amount) && amount > 0) {
        return correctFloat17(amount * 100) + "%";
      }
    },
    inside: true,
    verticalAlign: "middle",
    style: {
      whiteSpace: "nowrap"
    }
  },
  tooltip: {
    headerFormat: '<span style="font-size: 0.8em">{ucfirst point.x} - {point.x2}</span><br/>',
    pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.yCategory}</b><br/>'
  },
  borderRadius: 3,
  pointRange: 0
};
var XRangeSeriesDefaults_default = XRangeSeriesDefaults;

// node_modules/highcharts/es-modules/Series/XRange/XRangePoint.js
var { column: { prototype: { pointClass: ColumnPoint3 } } } = SeriesRegistry_default.seriesTypes;
var { extend: extend87 } = Utilities_default;
var XRangePoint = class _XRangePoint extends ColumnPoint3 {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * Return color of a point based on its category.
   *
   * @private
   * @function getColorByCategory
   *
   * @param {object} series
   *        The series which the point belongs to.
   *
   * @param {object} point
   *        The point to calculate its color for.
   *
   * @return {object}
   *         Returns an object containing the properties color and colorIndex.
   */
  static getColorByCategory(series, point) {
    const colors = series.options.colors || series.chart.options.colors, colorCount = colors ? colors.length : series.chart.options.chart.colorCount, colorIndex = point.y % colorCount, color14 = colors?.[colorIndex];
    return {
      colorIndex,
      color: color14
    };
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  resolveColor() {
    const series = this.series;
    if (series.options.colorByPoint && !this.options.color) {
      const colorByPoint = _XRangePoint.getColorByCategory(series, this);
      if (!series.chart.styledMode) {
        this.color = colorByPoint.color;
      }
      if (!this.options.colorIndex) {
        this.colorIndex = colorByPoint.colorIndex;
      }
    } else {
      this.color = this.options.color || series.color;
    }
  }
  /**
   * Extend init to have y default to 0.
   *
   * @private
   */
  constructor(series, options2) {
    super(series, options2);
    if (!this.y) {
      this.y = 0;
    }
  }
  /**
   * Extend applyOptions to handle time strings for x2
   *
   * @private
   */
  applyOptions(options2, x) {
    super.applyOptions(options2, x);
    this.x2 = this.series.chart.time.parse(this.x2);
    this.isNull = !this.isValid?.();
    return this;
  }
  /**
   * @private
   */
  setState() {
    super.setState.apply(this, arguments);
    this.series.drawPoint(this, this.series.getAnimationVerb());
  }
  /**
   * @private
   */
  isValid() {
    return typeof this.x === "number" && typeof this.x2 === "number";
  }
};
extend87(XRangePoint.prototype, {
  ttBelow: false,
  tooltipDateKeys: ["x", "x2"]
});
var XRangePoint_default = XRangePoint;

// node_modules/highcharts/es-modules/Series/XRange/XRangeSeries.js
var { composed: composed34, noop: noop20 } = Globals_default;
var { parse: color13 } = Color_default;
var { column: ColumnSeries16 } = SeriesRegistry_default.seriesTypes;
var { addEvent: addEvent88, clamp: clamp23, crisp: crisp17, defined: defined77, extend: extend88, find: find18, isNumber: isNumber69, isObject: isObject23, merge: merge100, pick: pick109, pushUnique: pushUnique37, relativeLength: relativeLength18 } = Utilities_default;
function onAxisAfterGetSeriesExtremes() {
  let dataMax, modMax;
  if (this.isXAxis) {
    dataMax = pick109(this.dataMax, -Number.MAX_VALUE);
    for (const series of this.series) {
      const column2 = series.dataTable.getColumn("x2", true) || series.dataTable.getColumn("end", true);
      if (column2) {
        for (const val of column2) {
          if (isNumber69(val) && val > dataMax) {
            dataMax = val;
            modMax = true;
          }
        }
      }
    }
    if (modMax) {
      this.dataMax = dataMax;
    }
  }
}
var XRangeSeries = class extends ColumnSeries16 {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(AxisClass) {
    if (pushUnique37(composed34, "Series.XRange")) {
      addEvent88(AxisClass, "afterGetSeriesExtremes", onAxisAfterGetSeriesExtremes);
    }
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * @private
   */
  init() {
    super.init.apply(this, arguments);
    this.options.stacking = void 0;
  }
  /**
   * Borrow the column series metrics, but with swapped axes. This gives
   * free access to features like groupPadding, grouping, pointWidth etc.
   * @private
   */
  getColumnMetrics() {
    const swapAxes = () => {
      for (const series of this.chart.series) {
        const xAxis2 = series.xAxis;
        series.xAxis = series.yAxis;
        series.yAxis = xAxis2;
      }
    };
    swapAxes();
    const metrics = super.getColumnMetrics();
    swapAxes();
    return metrics;
  }
  /**
   * Override cropData to show a point where x or x2 is outside visible range,
   * but one of them is inside.
   * @private
   */
  cropData(table, min4, max4) {
    const xData = table.getColumn("x") || [], x2Data = table.getColumn("x2");
    table.setColumn("x", x2Data, void 0, { silent: true });
    const croppedData = super.cropData(table, min4, max4);
    table.setColumn("x", xData.slice(croppedData.start, croppedData.end), void 0, { silent: true });
    return croppedData;
  }
  /**
   * Finds the index of an existing point that matches the given point
   * options.
   *
   * @private
   *
   * @param {Highcharts.XRangePointOptions} options
   *        The options of the point.
   *
   * @return {number|undefined}
   *         Returns index of a matching point, or undefined if no match is
   *         found.
   */
  findPointIndex(options2) {
    const { cropStart, points } = this;
    const { id } = options2;
    let pointIndex;
    if (id) {
      const point = find18(points, (point2) => point2.id === id);
      pointIndex = point ? point.index : void 0;
    }
    if (typeof pointIndex === "undefined") {
      const point = find18(points, (point2) => point2.x === options2.x && point2.x2 === options2.x2 && !point2.touched);
      pointIndex = point ? point.index : void 0;
    }
    if (this.cropped && isNumber69(pointIndex) && isNumber69(cropStart) && pointIndex >= cropStart) {
      pointIndex -= cropStart;
    }
    return pointIndex;
  }
  alignDataLabel(point) {
    const oldPlotX = point.plotX;
    point.plotX = pick109(point.dlBox?.centerX, point.plotX);
    if (point.dataLabel && point.shapeArgs?.width) {
      point.dataLabel.css({
        width: `${point.shapeArgs.width}px`
      });
    }
    super.alignDataLabel.apply(this, arguments);
    point.plotX = oldPlotX;
  }
  /**
   * @private
   */
  translatePoint(point) {
    const xAxis2 = this.xAxis, yAxis2 = this.yAxis, metrics = this.columnMetrics, options2 = this.options, minPointLength = options2.minPointLength || 0, oldColWidth = (point.shapeArgs?.width || 0) / 2, seriesXOffset = this.pointXOffset = metrics.offset, posX = pick109(point.x2, point.x + (point.len || 0)), borderRadius = options2.borderRadius, plotTop = this.chart.plotTop, plotLeft = this.chart.plotLeft;
    let plotX = point.plotX, plotX2 = xAxis2.translate(posX, 0, 0, 0, 1);
    const length = Math.abs(plotX2 - plotX), inverted = this.chart.inverted, borderWidth = pick109(options2.borderWidth, 1);
    let widthDifference, partialFill, yOffset = metrics.offset, pointHeight = Math.round(metrics.width), dlLeft, dlRight, dlWidth, clipRectWidth;
    if (minPointLength) {
      widthDifference = minPointLength - length;
      if (widthDifference < 0) {
        widthDifference = 0;
      }
      plotX -= widthDifference / 2;
      plotX2 += widthDifference / 2;
    }
    plotX = Math.max(plotX, -10);
    plotX2 = clamp23(plotX2, -10, xAxis2.len + 10);
    if (defined77(point.options.pointWidth)) {
      yOffset -= (Math.ceil(point.options.pointWidth) - pointHeight) / 2;
      pointHeight = Math.ceil(point.options.pointWidth);
    }
    if (options2.pointPlacement && isNumber69(point.plotY) && yAxis2.categories) {
      point.plotY = yAxis2.translate(point.y, 0, 1, 0, 1, options2.pointPlacement);
    }
    const x = crisp17(Math.min(plotX, plotX2), borderWidth), x2 = crisp17(Math.max(plotX, plotX2), borderWidth), width = x2 - x;
    const r = Math.min(relativeLength18(typeof borderRadius === "object" ? borderRadius.radius : borderRadius || 0, pointHeight), Math.min(width, pointHeight) / 2);
    const shapeArgs = {
      x,
      y: crisp17((point.plotY || 0) + yOffset, borderWidth),
      width,
      height: pointHeight,
      r
    };
    point.shapeArgs = shapeArgs;
    if (!inverted) {
      point.tooltipPos[0] -= oldColWidth + seriesXOffset - shapeArgs.width / 2;
    } else {
      point.tooltipPos[1] += seriesXOffset + oldColWidth;
    }
    dlLeft = shapeArgs.x;
    dlRight = dlLeft + shapeArgs.width;
    if (dlLeft < 0 || dlRight > xAxis2.len) {
      dlLeft = clamp23(dlLeft, 0, xAxis2.len);
      dlRight = clamp23(dlRight, 0, xAxis2.len);
      dlWidth = dlRight - dlLeft;
      point.dlBox = merge100(shapeArgs, {
        x: dlLeft,
        width: dlRight - dlLeft,
        centerX: dlWidth ? dlWidth / 2 : null
      });
    } else {
      point.dlBox = null;
    }
    const tooltipPos = point.tooltipPos;
    const xIndex = !inverted ? 0 : 1;
    const yIndex = !inverted ? 1 : 0;
    const tooltipYOffset = this.columnMetrics ? this.columnMetrics.offset : -metrics.width / 2;
    if (inverted) {
      tooltipPos[xIndex] += shapeArgs.width / 2;
    } else {
      tooltipPos[xIndex] = clamp23(tooltipPos[xIndex] + (xAxis2.reversed ? -1 : 0) * shapeArgs.width, xAxis2.left - plotLeft, xAxis2.left + xAxis2.len - plotLeft - 1);
    }
    tooltipPos[yIndex] = clamp23(tooltipPos[yIndex] + (inverted ? -1 : 1) * tooltipYOffset, yAxis2.top - plotTop, yAxis2.top + yAxis2.len - plotTop - 1);
    partialFill = point.partialFill;
    if (partialFill) {
      if (isObject23(partialFill)) {
        partialFill = partialFill.amount;
      }
      if (!isNumber69(partialFill)) {
        partialFill = 0;
      }
      point.partShapeArgs = merge100(shapeArgs);
      clipRectWidth = Math.max(Math.round(length * partialFill + point.plotX - plotX), 0);
      point.clipRectArgs = {
        x: xAxis2.reversed ? (
          // #10717
          shapeArgs.x + length - clipRectWidth
        ) : shapeArgs.x,
        y: shapeArgs.y,
        width: clipRectWidth,
        height: shapeArgs.height
      };
    }
    point.key = point.category || point.name;
    point.yCategory = yAxis2.categories?.[point.y ?? -1];
  }
  /**
   * @private
   */
  translate() {
    super.translate.apply(this, arguments);
    for (const point of this.points) {
      this.translatePoint(point);
    }
  }
  /**
   * Draws a single point in the series. Needed for partial fill.
   *
   * This override turns point.graphic into a group containing the
   * original graphic and an overlay displaying the partial fill.
   *
   * @private
   *
   * @param {Highcharts.Point} point
   *        An instance of Point in the series.
   *
   * @param {"animate"|"attr"} verb
   *        'animate' (animates changes) or 'attr' (sets options)
   */
  drawPoint(point, verb) {
    const seriesOpts = this.options, renderer = this.chart.renderer, type = point.shapeType, shapeArgs = point.shapeArgs, partShapeArgs = point.partShapeArgs, clipRectArgs = point.clipRectArgs, pointState = point.state, stateOpts = seriesOpts.states[pointState || "normal"] || {}, pointStateVerb = typeof pointState === "undefined" ? "attr" : verb, pointAttr = this.pointAttribs(point, pointState), animation = pick109(this.chart.options.chart.animation, stateOpts.animation);
    let graphic = point.graphic, pfOptions = point.partialFill;
    if (!point.isNull && point.visible !== false) {
      if (graphic) {
        graphic.rect[verb](shapeArgs);
      } else {
        point.graphic = graphic = renderer.g("point").addClass(point.getClassName()).add(point.group || this.group);
        graphic.rect = renderer[type](merge100(shapeArgs)).addClass(point.getClassName()).addClass("highcharts-partfill-original").add(graphic);
      }
      if (partShapeArgs) {
        if (graphic.partRect) {
          graphic.partRect[verb](merge100(partShapeArgs));
          graphic.partialClipRect[verb](merge100(clipRectArgs));
        } else {
          graphic.partialClipRect = renderer.clipRect(clipRectArgs.x, clipRectArgs.y, clipRectArgs.width, clipRectArgs.height);
          graphic.partRect = renderer[type](partShapeArgs).addClass("highcharts-partfill-overlay").add(graphic).clip(graphic.partialClipRect);
        }
      }
      if (!this.chart.styledMode) {
        graphic.rect[verb](pointAttr, animation).shadow(seriesOpts.shadow);
        if (partShapeArgs) {
          if (!isObject23(pfOptions)) {
            pfOptions = {};
          }
          if (isObject23(seriesOpts.partialFill)) {
            pfOptions = merge100(seriesOpts.partialFill, pfOptions);
          }
          const fill = pfOptions.fill || color13(pointAttr.fill).brighten(-0.3).get() || color13(point.color || this.color).brighten(-0.3).get();
          pointAttr.fill = fill;
          graphic.partRect[pointStateVerb](pointAttr, animation).shadow(seriesOpts.shadow);
        }
      }
    } else if (graphic) {
      point.graphic = graphic.destroy();
    }
  }
  /**
   * @private
   */
  drawPoints() {
    const verb = this.getAnimationVerb();
    for (const point of this.points) {
      this.drawPoint(point, verb);
    }
  }
  /**
   * Returns "animate", or "attr" if the number of points is above the
   * animation limit.
   *
   * @private
   */
  getAnimationVerb() {
    return this.chart.pointCount < (this.options.animationLimit || 250) ? "animate" : "attr";
  }
  /**
   * @private
   */
  isPointInside(point) {
    const shapeArgs = point.shapeArgs, plotX = point.plotX, plotY = point.plotY;
    if (!shapeArgs) {
      return super.isPointInside.apply(this, arguments);
    }
    const isInside = typeof plotX !== "undefined" && typeof plotY !== "undefined" && plotY >= 0 && plotY <= this.yAxis.len && (shapeArgs.x || 0) + (shapeArgs.width || 0) >= 0 && plotX <= this.xAxis.len;
    return isInside;
  }
};
XRangeSeries.defaultOptions = merge100(ColumnSeries16.defaultOptions, XRangeSeriesDefaults_default);
extend88(XRangeSeries.prototype, {
  pointClass: XRangePoint_default,
  pointArrayMap: ["x2", "y"],
  getExtremesFromAll: true,
  keysAffectYAxis: ["y"],
  parallelArrays: ["x", "x2", "y"],
  requireSorting: false,
  type: "xrange",
  animate: SeriesRegistry_default.series.prototype.animate,
  autoIncrement: noop20,
  buildKDTree: noop20
});
SeriesRegistry_default.registerSeriesType("xrange", XRangeSeries);
var XRangeSeries_default = XRangeSeries;

// node_modules/highcharts/es-modules/masters/modules/xrange.src.js
var G17 = Globals_default;
XRangeSeries_default.compose(G17.Axis);

// node_modules/highcharts/es-modules/Series/Bullet/BulletPoint.js
var BulletPoint = class extends ColumnSeries_default.prototype.pointClass {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Destroys target graphic.
   * @private
   */
  destroy() {
    const series = this;
    if (series.targetGraphic) {
      series.targetGraphic = series.targetGraphic.destroy();
    }
    super.destroy.apply(series, arguments);
    return;
  }
};
var BulletPoint_default = BulletPoint;

// node_modules/highcharts/es-modules/Series/Bullet/BulletSeriesDefaults.js
var BulletSeriesDefaults = {
  /**
   * All options related with look and positioning of targets.
   *
   * @since 6.0.0
   */
  targetOptions: {
    /**
     * The width of the rectangle representing the target. Could be set
     * as a pixel value or as a percentage of a column width.
     *
     * @type  {number|string}
     * @since 6.0.0
     */
    width: "140%",
    /**
     * The height of the rectangle representing the target.
     *
     * @since 6.0.0
     */
    height: 3,
    /**
     * The border color of the rectangle representing the target. When
     * not set, the point's border color is used.
     *
     * In styled mode, use class `highcharts-bullet-target` instead.
     *
     * @type      {Highcharts.ColorString}
     * @since     6.0.0
     * @product   highcharts
     * @apioption plotOptions.bullet.targetOptions.borderColor
     */
    /**
     * The color of the rectangle representing the target. When not set,
     * point's color (if set in point's options -
     * [`color`](#series.bullet.data.color)) or zone of the target value
     * (if [`zones`](#plotOptions.bullet.zones) or
     * [`negativeColor`](#plotOptions.bullet.negativeColor) are set)
     * or the same color as the point has is used.
     *
     * In styled mode, use class `highcharts-bullet-target` instead.
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @since     6.0.0
     * @product   highcharts
     * @apioption plotOptions.bullet.targetOptions.color
     */
    /**
     * The border width of the rectangle representing the target.
     *
     * In styled mode, use class `highcharts-bullet-target` instead.
     *
     * @since   6.0.0
     */
    borderWidth: 0,
    /**
     * The border radius of the rectangle representing the target.
     */
    borderRadius: 0
  },
  tooltip: {
    pointFormat: '<span style="color:{series.color}"></span> {series.name}: <b>{point.y}</b>. Target: <b>{point.target}</b><br/>'
  }
};
var BulletSeriesDefaults_default = BulletSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Bullet/BulletSeries.js
var { extend: extend89, isNumber: isNumber70, merge: merge101, pick: pick110, relativeLength: relativeLength19 } = Utilities_default;
var BulletSeries = class extends ColumnSeries_default {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Draws the targets. For inverted chart, the `series.group` is rotated,
   * so the same coordinates apply. This method is based on column series
   * drawPoints function.
   *
   * @ignore
   * @function Highcharts.Series#drawPoints
   */
  drawPoints() {
    const series = this, chart = series.chart, options2 = series.options, animationLimit = options2.animationLimit || 250;
    super.drawPoints.apply(this, arguments);
    for (const point of series.points) {
      const pointOptions = point.options, targetVal = point.target, pointVal = point.y;
      let targetShapeArgs, targetGraphic = point.targetGraphic, width, height, targetOptions, y;
      if (isNumber70(targetVal) && targetVal !== null) {
        targetOptions = merge101(options2.targetOptions, pointOptions.targetOptions);
        height = targetOptions.height;
        let shapeArgs = point.shapeArgs;
        if (point.dlBox && shapeArgs && !isNumber70(shapeArgs.width)) {
          shapeArgs = point.dlBox;
        }
        width = relativeLength19(targetOptions.width, shapeArgs.width);
        y = series.yAxis.translate(targetVal, false, true, false, true) - targetOptions.height / 2 - 0.5;
        targetShapeArgs = series.crispCol.apply({
          // Use fake series object to set borderWidth of target
          chart,
          borderWidth: targetOptions.borderWidth,
          options: {
            crisp: options2.crisp
          }
        }, [
          shapeArgs.x + shapeArgs.width / 2 - width / 2,
          y,
          width,
          height
        ]);
        if (targetGraphic) {
          targetGraphic[chart.pointCount < animationLimit ? "animate" : "attr"](targetShapeArgs);
          if (isNumber70(pointVal) && pointVal !== null) {
            targetGraphic.element.point = point;
          } else {
            targetGraphic.element.point = void 0;
          }
        } else {
          point.targetGraphic = targetGraphic = chart.renderer.rect().attr(targetShapeArgs).add(series.group);
        }
        if (!chart.styledMode) {
          targetGraphic.attr({
            fill: pick110(targetOptions.color, pointOptions.color, series.zones.length && (point.getZone.call({
              series,
              x: point.x,
              y: targetVal,
              options: {}
            }).color || series.color) || void 0, point.color, series.color),
            stroke: pick110(targetOptions.borderColor, point.borderColor, series.options.borderColor),
            "stroke-width": targetOptions.borderWidth,
            r: targetOptions.borderRadius
          });
        }
        if (isNumber70(pointVal) && pointVal !== null) {
          targetGraphic.element.point = point;
        }
        targetGraphic.addClass(point.getClassName() + " highcharts-bullet-target", true);
      } else if (targetGraphic) {
        point.targetGraphic = targetGraphic.destroy();
      }
    }
  }
  /**
   * Includes target values to extend extremes from y values.
   *
   * @ignore
   * @function Highcharts.Series#getExtremes
   */
  getExtremes(yData) {
    const dataExtremes = super.getExtremes.call(this, yData), targetData = this.targetData;
    if (targetData && targetData.length) {
      const targetExtremes = super.getExtremes.call(this, targetData);
      if (isNumber70(targetExtremes.dataMin)) {
        dataExtremes.dataMin = Math.min(pick110(dataExtremes.dataMin, Infinity), targetExtremes.dataMin);
      }
      if (isNumber70(targetExtremes.dataMax)) {
        dataExtremes.dataMax = Math.max(pick110(dataExtremes.dataMax, -Infinity), targetExtremes.dataMax);
      }
    }
    return dataExtremes;
  }
};
BulletSeries.defaultOptions = merge101(ColumnSeries_default.defaultOptions, BulletSeriesDefaults_default);
extend89(BulletSeries.prototype, {
  parallelArrays: ["x", "y", "target"],
  pointArrayMap: ["y", "target"]
});
BulletSeries.prototype.pointClass = BulletPoint_default;
SeriesRegistry_default.registerSeriesType("bullet", BulletSeries);

// node_modules/highcharts/es-modules/Extensions/ArrowSymbols.js
function arrow(x, y, w, h) {
  return [
    ["M", x, y + h / 2],
    ["L", x + w, y],
    ["L", x, y + h / 2],
    ["L", x + w, y + h]
  ];
}
function arrowHalf(x, y, w, h) {
  return arrow(x, y, w / 2, h);
}
function compose21(SVGRendererClass) {
  const symbols3 = SVGRendererClass.prototype.symbols;
  symbols3.arrow = arrow;
  symbols3["arrow-filled"] = triangleLeft;
  symbols3["arrow-filled-half"] = triangleLeftHalf;
  symbols3["arrow-half"] = arrowHalf;
  symbols3["triangle-left"] = triangleLeft;
  symbols3["triangle-left-half"] = triangleLeftHalf;
}
function triangleLeft(x, y, w, h) {
  return [
    ["M", x + w, y],
    ["L", x, y + h / 2],
    ["L", x + w, y + h],
    ["Z"]
  ];
}
function triangleLeftHalf(x, y, w, h) {
  return triangleLeft(x, y, w / 2, h);
}
var ArrowSymbols = {
  compose: compose21
};
var ArrowSymbols_default = ArrowSymbols;

// node_modules/highcharts/es-modules/Gantt/Connection.js
var { defined: defined78, error: error11, merge: merge102, objectEach: objectEach36 } = Utilities_default;
var deg2rad11 = Globals_default.deg2rad;
var max = Math.max;
var min = Math.min;
var Connection = class {
  constructor(from, to, options2) {
    this.init(from, to, options2);
  }
  /**
   * Initialize the Connection object. Used as constructor only.
   *
   * @function Highcharts.Connection#init
   *
   * @param {Highcharts.Point} from
   *        Connection runs from this Point.
   *
   * @param {Highcharts.Point} to
   *        Connection runs to this Point.
   *
   * @param {Highcharts.ConnectorsOptions} [options]
   *        Connection options.
   */
  init(from, to, options2) {
    this.fromPoint = from;
    this.toPoint = to;
    this.options = options2;
    this.chart = from.series.chart;
    this.pathfinder = this.chart.pathfinder;
  }
  /**
   * Add (or update) this connection's path on chart. Stores reference to the
   * created element on this.graphics.path.
   *
   * @function Highcharts.Connection#renderPath
   *
   * @param {Highcharts.SVGPathArray} path
   *        Path to render, in array format. E.g. ['M', 0, 0, 'L', 10, 10]
   *
   * @param {Highcharts.SVGAttributes} [attribs]
   *        SVG attributes for the path.
   *
   * @param {Partial<Highcharts.AnimationOptionsObject>} [animation]
   *        Animation options for the rendering.
   */
  renderPath(path, attribs) {
    const connection = this, chart = this.chart, styledMode = chart.styledMode, pathfinder = this.pathfinder, anim = {};
    let pathGraphic = connection.graphics && connection.graphics.path;
    if (!pathfinder.group) {
      pathfinder.group = chart.renderer.g().addClass("highcharts-pathfinder-group").attr({ zIndex: -1 }).add(chart.seriesGroup);
    }
    pathfinder.group.translate(chart.plotLeft, chart.plotTop);
    if (!(pathGraphic && pathGraphic.renderer)) {
      pathGraphic = chart.renderer.path().add(pathfinder.group);
      if (!styledMode) {
        pathGraphic.attr({
          opacity: 0
        });
      }
    }
    pathGraphic.attr(attribs);
    anim.d = path;
    if (!styledMode) {
      anim.opacity = 1;
    }
    pathGraphic.animate(anim);
    this.graphics = this.graphics || {};
    this.graphics.path = pathGraphic;
  }
  /**
   * Calculate and add marker graphics for connection to the chart. The
   * created/updated elements are stored on this.graphics.start and
   * this.graphics.end.
   *
   * @function Highcharts.Connection#addMarker
   *
   * @param {string} type
   *        Marker type, either 'start' or 'end'.
   *
   * @param {Highcharts.ConnectorsMarkerOptions} options
   *        All options for this marker. Not calculated or merged with other
   *        options.
   *
   * @param {Highcharts.SVGPathArray} path
   *        Connection path in array format. This is used to calculate the
   *        rotation angle of the markers.
   */
  addMarker(type, options2, path) {
    const connection = this, chart = connection.fromPoint.series.chart, pathfinder = chart.pathfinder, renderer = chart.renderer, point = type === "start" ? connection.fromPoint : connection.toPoint, anchor = point.getPathfinderAnchorPoint(options2);
    let markerVector, radians, rotation, box, width, height, pathVector, segment;
    if (!options2.enabled) {
      return;
    }
    if (type === "start") {
      segment = path[1];
    } else {
      segment = path[path.length - 2];
    }
    if (segment && segment[0] === "M" || segment[0] === "L") {
      pathVector = {
        x: segment[1],
        y: segment[2]
      };
      radians = point.getRadiansToVector(pathVector, anchor);
      markerVector = point.getMarkerVector(radians, options2.radius, anchor);
      rotation = -radians / deg2rad11;
      if (options2.width && options2.height) {
        width = options2.width;
        height = options2.height;
      } else {
        width = height = options2.radius * 2;
      }
      connection.graphics = connection.graphics || {};
      box = {
        x: markerVector.x - width / 2,
        y: markerVector.y - height / 2,
        width,
        height,
        rotation,
        rotationOriginX: markerVector.x,
        rotationOriginY: markerVector.y
      };
      if (!connection.graphics[type]) {
        connection.graphics[type] = renderer.symbol(options2.symbol).addClass("highcharts-point-connecting-path-" + type + "-marker highcharts-color-" + this.fromPoint.colorIndex).attr(box).add(pathfinder.group);
        if (!renderer.styledMode) {
          connection.graphics[type].attr({
            fill: options2.color || connection.fromPoint.color,
            stroke: options2.lineColor,
            "stroke-width": options2.lineWidth,
            opacity: 0
          }).animate({
            opacity: 1
          }, point.series.options.animation);
        }
      } else {
        connection.graphics[type].animate(box);
      }
    }
  }
  /**
   * Calculate and return connection path.
   * Note: Recalculates chart obstacles on demand if they aren't calculated.
   *
   * @function Highcharts.Connection#getPath
   *
   * @param {Highcharts.ConnectorsOptions} options
   *        Connector options. Not calculated or merged with other options.
   *
   * @return {object|undefined}
   *         Calculated SVG path data in array format.
   */
  getPath(options2) {
    const pathfinder = this.pathfinder, chart = this.chart, algorithm = pathfinder.algorithms[options2.type];
    let chartObstacles = pathfinder.chartObstacles;
    if (typeof algorithm !== "function") {
      error11('"' + options2.type + '" is not a Pathfinder algorithm.');
      return {
        path: [],
        obstacles: []
      };
    }
    if (algorithm.requiresObstacles && !chartObstacles) {
      chartObstacles = pathfinder.chartObstacles = pathfinder.getChartObstacles(options2);
      chart.options.connectors.algorithmMargin = options2.algorithmMargin;
      pathfinder.chartObstacleMetrics = pathfinder.getObstacleMetrics(chartObstacles);
    }
    return algorithm(
      // From
      this.fromPoint.getPathfinderAnchorPoint(options2.startMarker),
      // To
      this.toPoint.getPathfinderAnchorPoint(options2.endMarker),
      merge102({
        chartObstacles,
        lineObstacles: pathfinder.lineObstacles || [],
        obstacleMetrics: pathfinder.chartObstacleMetrics,
        hardBounds: {
          xMin: 0,
          xMax: chart.plotWidth,
          yMin: 0,
          yMax: chart.plotHeight
        },
        obstacleOptions: {
          margin: options2.algorithmMargin
        },
        startDirectionX: pathfinder.getAlgorithmStartDirection(options2.startMarker)
      }, options2)
    );
  }
  /**
   * (re)Calculate and (re)draw the connection.
   *
   * @function Highcharts.Connection#render
   */
  render() {
    const connection = this, fromPoint = connection.fromPoint, series = fromPoint.series, chart = series.chart, pathfinder = chart.pathfinder, attribs = {};
    let options2 = merge102(chart.options.connectors, series.options.connectors, fromPoint.options.connectors, connection.options);
    if (!chart.styledMode) {
      attribs.stroke = options2.lineColor || fromPoint.color;
      attribs["stroke-width"] = options2.lineWidth;
      if (options2.dashStyle) {
        attribs.dashstyle = options2.dashStyle;
      }
    }
    attribs["class"] = // eslint-disable-line dot-notation
    "highcharts-point-connecting-path highcharts-color-" + fromPoint.colorIndex;
    options2 = merge102(attribs, options2);
    if (!defined78(options2.marker.radius)) {
      options2.marker.radius = min(max(Math.ceil((options2.algorithmMargin || 8) / 2) - 1, 1), 5);
    }
    const pathResult = connection.getPath(options2), path = pathResult.path;
    if (pathResult.obstacles) {
      pathfinder.lineObstacles = pathfinder.lineObstacles || [];
      pathfinder.lineObstacles = pathfinder.lineObstacles.concat(pathResult.obstacles);
    }
    connection.renderPath(path, attribs);
    connection.addMarker("start", merge102(options2.marker, options2.startMarker), path);
    connection.addMarker("end", merge102(options2.marker, options2.endMarker), path);
  }
  /**
   * Destroy connection by destroying the added graphics elements.
   *
   * @function Highcharts.Connection#destroy
   */
  destroy() {
    if (this.graphics) {
      objectEach36(this.graphics, function(val) {
        val.destroy();
      });
      delete this.graphics;
    }
  }
};
var Connection_default = Connection;

// node_modules/highcharts/es-modules/Extensions/CurrentDateIndication.js
var { composed: composed35 } = Globals_default;
var { addEvent: addEvent89, merge: merge103, pushUnique: pushUnique38, wrap: wrap13 } = Utilities_default;
var defaultOptions22 = {
  color: "#ccd3ff",
  width: 2,
  /**
   * @declare Highcharts.AxisCurrentDateIndicatorLabelOptions
   */
  label: {
    /**
     * Format of the label. This options is passed as the first argument to
     * [dateFormat](/class-reference/Highcharts.Time#dateFormat) function.
     *
     * @type      {string|Intl.DateTimeFormatOptions}
     * @product   gantt
     * @apioption xAxis.currentDateIndicator.label.format
     */
    format: "%[abdYHM]",
    formatter: function(value, format18) {
      return this.axis.chart.time.dateFormat(format18 || "", value, true);
    },
    rotation: 0,
    /**
     * @type {Highcharts.CSSObject}
     */
    style: {
      /** @internal */
      fontSize: "0.7em"
    }
  }
};
function compose22(AxisClass, PlotLineOrBandClass) {
  if (pushUnique38(composed35, "CurrentDateIndication")) {
    addEvent89(AxisClass, "afterSetOptions", onAxisAfterSetOptions2);
    addEvent89(PlotLineOrBandClass, "render", onPlotLineOrBandRender);
    wrap13(PlotLineOrBandClass.prototype, "getLabelText", wrapPlotLineOrBandGetLabelText);
  }
}
function onAxisAfterSetOptions2() {
  const options2 = this.options, cdiOptions = options2.currentDateIndicator;
  if (cdiOptions) {
    const plotLineOptions = typeof cdiOptions === "object" ? merge103(defaultOptions22, cdiOptions) : merge103(defaultOptions22);
    plotLineOptions.value = Date.now();
    plotLineOptions.className = "highcharts-current-date-indicator";
    if (!options2.plotLines) {
      options2.plotLines = [];
    }
    options2.plotLines.push(plotLineOptions);
  }
}
function onPlotLineOrBandRender() {
  if (this.label) {
    this.label.attr({
      text: this.getLabelText(this.options.label)
    });
  }
}
function wrapPlotLineOrBandGetLabelText(defaultMethod, defaultLabelOptions) {
  const options2 = this.options;
  if (options2 && options2.className && options2.className.indexOf("highcharts-current-date-indicator") !== -1 && options2.label && typeof options2.label.formatter === "function") {
    options2.value = Date.now();
    return options2.label.formatter.call(this, options2.value, options2.label.format);
  }
  return defaultMethod.call(this, defaultLabelOptions);
}
var CurrentDateIndication = {
  compose: compose22
};
var CurrentDateIndication_default = CurrentDateIndication;

// node_modules/highcharts/es-modules/Core/Chart/GanttChart.js
var { defaultOptions: defaultOptions23 } = Defaults_default;
var { isArray: isArray26, merge: merge104, splat: splat22 } = Utilities_default;
var GanttChart = class extends Chart_default {
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Initializes the chart. The constructor's arguments are passed on
   * directly.
   *
   * @function Highcharts.GanttChart#init
   *
   * @param {Highcharts.Options} userOptions
   *        Custom options.
   *
   * @param {Function} [callback]
   *        Function to run when the chart has loaded and all external
   *        images are loaded.
   *
   *
   * @emits Highcharts.GanttChart#event:init
   * @emits Highcharts.GanttChart#event:afterInit
   */
  init(userOptions, callback) {
    const xAxisOptions = userOptions.xAxis, yAxisOptions = userOptions.yAxis;
    let defaultLinkedTo;
    userOptions.xAxis = userOptions.yAxis = void 0;
    const options2 = merge104(
      true,
      {
        chart: {
          type: "gantt"
        },
        title: {
          text: ""
        },
        legend: {
          enabled: false
        },
        navigator: {
          series: { type: "gantt" },
          // Bars were clipped, #14060.
          yAxis: {
            type: "category"
          }
        }
      },
      userOptions,
      // User's options
      // forced options
      {
        isGantt: true
      }
    );
    userOptions.xAxis = xAxisOptions;
    userOptions.yAxis = yAxisOptions;
    options2.xAxis = (!isArray26(userOptions.xAxis) ? [userOptions.xAxis || {}, {}] : userOptions.xAxis).map((xAxisOptions2, i) => {
      if (i === 1) {
        defaultLinkedTo = 0;
      }
      return merge104(
        // Defaults
        {
          grid: {
            borderColor: "#cccccc",
            enabled: true
          },
          opposite: defaultOptions23.xAxis?.opposite ?? xAxisOptions2.opposite ?? true,
          linkedTo: defaultLinkedTo
        },
        // User options
        xAxisOptions2,
        // Forced options
        {
          type: "datetime"
        }
      );
    });
    options2.yAxis = splat22(userOptions.yAxis || {}).map((yAxisOptions2) => merge104(
      // Defaults
      {
        grid: {
          borderColor: "#cccccc",
          enabled: true
        },
        staticScale: 50,
        reversed: true,
        // Set default type treegrid, but only if 'categories' is
        // undefined
        type: yAxisOptions2.categories ? yAxisOptions2.type : "treegrid"
      },
      // User options
      yAxisOptions2
    ));
    super.init(options2, callback);
  }
};
(function(GanttChart2) {
  function ganttChart(a, b, c) {
    return new GanttChart2(a, b, c);
  }
  GanttChart2.ganttChart = ganttChart;
})(GanttChart || (GanttChart = {}));
var GanttChart_default = GanttChart;

// node_modules/highcharts/es-modules/Gantt/PathfinderAlgorithms.js
var { pick: pick111 } = Utilities_default;
var { min: min2, max: max2, abs } = Math;
function findLastObstacleBefore(obstacles, xMin, startIx) {
  const min4 = xMin - 1e-7;
  let left = startIx || 0, right = obstacles.length - 1, cursor, cmp;
  while (left <= right) {
    cursor = right + left >> 1;
    cmp = min4 - obstacles[cursor].xMin;
    if (cmp > 0) {
      left = cursor + 1;
    } else if (cmp < 0) {
      right = cursor - 1;
    } else {
      return cursor;
    }
  }
  return left > 0 ? left - 1 : 0;
}
function pointWithinObstacle(obstacle, point) {
  return point.x <= obstacle.xMax && point.x >= obstacle.xMin && point.y <= obstacle.yMax && point.y >= obstacle.yMin;
}
function findObstacleFromPoint(obstacles, point) {
  let i = findLastObstacleBefore(obstacles, point.x + 1) + 1;
  while (i--) {
    if (obstacles[i].xMax >= point.x && // Optimization using lazy evaluation
    pointWithinObstacle(obstacles[i], point)) {
      return i;
    }
  }
  return -1;
}
function pathFromSegments(segments) {
  const path = [];
  if (segments.length) {
    path.push(["M", segments[0].start.x, segments[0].start.y]);
    for (let i = 0; i < segments.length; ++i) {
      path.push(["L", segments[i].end.x, segments[i].end.y]);
    }
  }
  return path;
}
function limitObstacleToBounds(obstacle, bounds) {
  obstacle.yMin = max2(obstacle.yMin, bounds.yMin);
  obstacle.yMax = min2(obstacle.yMax, bounds.yMax);
  obstacle.xMin = max2(obstacle.xMin, bounds.xMin);
  obstacle.xMax = min2(obstacle.xMax, bounds.xMax);
}
function straight(start, end) {
  return {
    path: [
      ["M", start.x, start.y],
      ["L", end.x, end.y]
    ],
    obstacles: [{ start, end }]
  };
}
var simpleConnect = function(start, end, options2) {
  const segments = [], chartObstacles = options2.chartObstacles, startObstacleIx = findObstacleFromPoint(chartObstacles, start), endObstacleIx = findObstacleFromPoint(chartObstacles, end);
  let endSegment, dir = pick111(options2.startDirectionX, abs(end.x - start.x) > abs(end.y - start.y)) ? "x" : "y", startObstacle, endObstacle, waypoint, useMax, endPoint;
  function copyFromPoint(from, fromKey, to, toKey, offset3) {
    const point = {
      x: from.x,
      y: from.y
    };
    point[fromKey] = to[toKey || fromKey] + (offset3 || 0);
    return point;
  }
  function getMeOut(obstacle, point, direction) {
    const useMax2 = abs(point[direction] - obstacle[direction + "Min"]) > abs(point[direction] - obstacle[direction + "Max"]);
    return copyFromPoint(point, direction, obstacle, direction + (useMax2 ? "Max" : "Min"), useMax2 ? 1 : -1);
  }
  if (endObstacleIx > -1) {
    endObstacle = chartObstacles[endObstacleIx];
    waypoint = getMeOut(endObstacle, end, dir);
    endSegment = {
      start: waypoint,
      end
    };
    endPoint = waypoint;
  } else {
    endPoint = end;
  }
  if (startObstacleIx > -1) {
    startObstacle = chartObstacles[startObstacleIx];
    waypoint = getMeOut(startObstacle, start, dir);
    segments.push({
      start,
      end: waypoint
    });
    if (
      // Going towards max from start:
      waypoint[dir] >= start[dir] === // Going towards min to end:
      waypoint[dir] >= endPoint[dir]
    ) {
      dir = dir === "y" ? "x" : "y";
      useMax = start[dir] < end[dir];
      segments.push({
        start: waypoint,
        end: copyFromPoint(waypoint, dir, startObstacle, dir + (useMax ? "Max" : "Min"), useMax ? 1 : -1)
      });
      dir = dir === "y" ? "x" : "y";
    }
  }
  const prevWaypoint = segments.length ? segments[segments.length - 1].end : start;
  waypoint = copyFromPoint(prevWaypoint, dir, endPoint);
  segments.push({
    start: prevWaypoint,
    end: waypoint
  });
  dir = dir === "y" ? "x" : "y";
  const waypoint2 = copyFromPoint(waypoint, dir, endPoint);
  segments.push({
    start: waypoint,
    end: waypoint2
  });
  segments.push(endSegment);
  const path = PathUtilities_default.applyRadius(pathFromSegments(segments), options2.radius);
  return {
    path,
    obstacles: segments
  };
};
simpleConnect.requiresObstacles = true;
function fastAvoid(start, end, options2) {
  const dirIsX = pick111(options2.startDirectionX, abs(end.x - start.x) > abs(end.y - start.y)), dir = dirIsX ? "x" : "y", endSegments = [], metrics = options2.obstacleMetrics, softMinX = min2(start.x, end.x) - metrics.maxWidth - 10, softMaxX = max2(start.x, end.x) + metrics.maxWidth + 10, softMinY = min2(start.y, end.y) - metrics.maxHeight - 10, softMaxY = max2(start.y, end.y) + metrics.maxHeight + 10;
  let segments, useMax, extractedEndPoint, forceObstacleBreak = false, chartObstacles = options2.chartObstacles, endObstacleIx = findLastObstacleBefore(chartObstacles, softMaxX);
  const startObstacleIx = findLastObstacleBefore(chartObstacles, softMinX);
  function pivotPoint(fromPoint, toPoint, directionIsX) {
    const searchDirection = fromPoint.x < toPoint.x ? 1 : -1;
    let firstPoint, lastPoint, highestPoint, lowestPoint;
    if (fromPoint.x < toPoint.x) {
      firstPoint = fromPoint;
      lastPoint = toPoint;
    } else {
      firstPoint = toPoint;
      lastPoint = fromPoint;
    }
    if (fromPoint.y < toPoint.y) {
      lowestPoint = fromPoint;
      highestPoint = toPoint;
    } else {
      lowestPoint = toPoint;
      highestPoint = fromPoint;
    }
    let i = searchDirection < 0 ? (
      // Searching backwards, start at last obstacle before last point
      min2(findLastObstacleBefore(chartObstacles, lastPoint.x), chartObstacles.length - 1)
    ) : (
      // Forwards. Since we're not sorted by xMax, we have to look
      // at all obstacles.
      0
    );
    while (chartObstacles[i] && (searchDirection > 0 && chartObstacles[i].xMin <= lastPoint.x || searchDirection < 0 && chartObstacles[i].xMax >= firstPoint.x)) {
      if (chartObstacles[i].xMin <= lastPoint.x && chartObstacles[i].xMax >= firstPoint.x && chartObstacles[i].yMin <= highestPoint.y && chartObstacles[i].yMax >= lowestPoint.y) {
        if (directionIsX) {
          return {
            y: fromPoint.y,
            x: fromPoint.x < toPoint.x ? chartObstacles[i].xMin - 1 : chartObstacles[i].xMax + 1,
            obstacle: chartObstacles[i]
          };
        }
        return {
          x: fromPoint.x,
          y: fromPoint.y < toPoint.y ? chartObstacles[i].yMin - 1 : chartObstacles[i].yMax + 1,
          obstacle: chartObstacles[i]
        };
      }
      i += searchDirection;
    }
    return toPoint;
  }
  function getDodgeDirection(obstacle, fromPoint, toPoint, dirIsX2, bounds) {
    const softBounds = bounds.soft, hardBounds = bounds.hard, dir2 = dirIsX2 ? "x" : "y", toPointMax = { x: fromPoint.x, y: fromPoint.y }, toPointMin = { x: fromPoint.x, y: fromPoint.y }, maxOutOfSoftBounds = obstacle[dir2 + "Max"] >= softBounds[dir2 + "Max"], minOutOfSoftBounds = obstacle[dir2 + "Min"] <= softBounds[dir2 + "Min"], maxOutOfHardBounds = obstacle[dir2 + "Max"] >= hardBounds[dir2 + "Max"], minOutOfHardBounds = obstacle[dir2 + "Min"] <= hardBounds[dir2 + "Min"], minDistance = abs(obstacle[dir2 + "Min"] - fromPoint[dir2]), maxDistance = abs(obstacle[dir2 + "Max"] - fromPoint[dir2]);
    let useMax2 = abs(minDistance - maxDistance) < 10 ? fromPoint[dir2] < toPoint[dir2] : maxDistance < minDistance;
    toPointMin[dir2] = obstacle[dir2 + "Min"];
    toPointMax[dir2] = obstacle[dir2 + "Max"];
    const minPivot = pivotPoint(fromPoint, toPointMin, dirIsX2)[dir2] !== toPointMin[dir2], maxPivot = pivotPoint(fromPoint, toPointMax, dirIsX2)[dir2] !== toPointMax[dir2];
    useMax2 = minPivot ? maxPivot ? useMax2 : true : maxPivot ? false : useMax2;
    useMax2 = minOutOfSoftBounds ? maxOutOfSoftBounds ? useMax2 : true : (
      // Out on min
      maxOutOfSoftBounds ? false : useMax2
    );
    useMax2 = minOutOfHardBounds ? maxOutOfHardBounds ? useMax2 : true : (
      // Out on min
      maxOutOfHardBounds ? false : useMax2
    );
    return useMax2;
  }
  function clearPathTo(fromPoint, toPoint, dirIsX2) {
    if (fromPoint.x === toPoint.x && fromPoint.y === toPoint.y) {
      return [];
    }
    const dir2 = dirIsX2 ? "x" : "y", obstacleMargin = options2.obstacleOptions.margin, bounds = {
      soft: {
        xMin: softMinX,
        xMax: softMaxX,
        yMin: softMinY,
        yMax: softMaxY
      },
      hard: options2.hardBounds
    };
    let pivot, segments2, waypoint, waypointUseMax, envelopingObstacle, secondEnvelopingObstacle, envelopWaypoint;
    envelopingObstacle = findObstacleFromPoint(chartObstacles, fromPoint);
    if (envelopingObstacle > -1) {
      envelopingObstacle = chartObstacles[envelopingObstacle];
      waypointUseMax = getDodgeDirection(envelopingObstacle, fromPoint, toPoint, dirIsX2, bounds);
      limitObstacleToBounds(envelopingObstacle, options2.hardBounds);
      envelopWaypoint = dirIsX2 ? {
        y: fromPoint.y,
        x: envelopingObstacle[waypointUseMax ? "xMax" : "xMin"] + (waypointUseMax ? 1 : -1)
      } : {
        x: fromPoint.x,
        y: envelopingObstacle[waypointUseMax ? "yMax" : "yMin"] + (waypointUseMax ? 1 : -1)
      };
      secondEnvelopingObstacle = findObstacleFromPoint(chartObstacles, envelopWaypoint);
      if (secondEnvelopingObstacle > -1) {
        secondEnvelopingObstacle = chartObstacles[secondEnvelopingObstacle];
        limitObstacleToBounds(secondEnvelopingObstacle, options2.hardBounds);
        envelopWaypoint[dir2] = waypointUseMax ? max2(envelopingObstacle[dir2 + "Max"] - obstacleMargin + 1, (secondEnvelopingObstacle[dir2 + "Min"] + envelopingObstacle[dir2 + "Max"]) / 2) : min2(envelopingObstacle[dir2 + "Min"] + obstacleMargin - 1, (secondEnvelopingObstacle[dir2 + "Max"] + envelopingObstacle[dir2 + "Min"]) / 2);
        if (fromPoint.x === envelopWaypoint.x && fromPoint.y === envelopWaypoint.y) {
          if (forceObstacleBreak) {
            envelopWaypoint[dir2] = waypointUseMax ? max2(envelopingObstacle[dir2 + "Max"], secondEnvelopingObstacle[dir2 + "Max"]) + 1 : min2(envelopingObstacle[dir2 + "Min"], secondEnvelopingObstacle[dir2 + "Min"]) - 1;
          }
          forceObstacleBreak = !forceObstacleBreak;
        } else {
          forceObstacleBreak = false;
        }
      }
      segments2 = [{
        start: fromPoint,
        end: envelopWaypoint
      }];
    } else {
      pivot = pivotPoint(fromPoint, {
        x: dirIsX2 ? toPoint.x : fromPoint.x,
        y: dirIsX2 ? fromPoint.y : toPoint.y
      }, dirIsX2);
      segments2 = [{
        start: fromPoint,
        end: {
          x: pivot.x,
          y: pivot.y
        }
      }];
      if (pivot[dirIsX2 ? "x" : "y"] !== toPoint[dirIsX2 ? "x" : "y"]) {
        waypointUseMax = getDodgeDirection(pivot.obstacle, pivot, toPoint, !dirIsX2, bounds);
        limitObstacleToBounds(pivot.obstacle, options2.hardBounds);
        waypoint = {
          x: dirIsX2 ? pivot.x : pivot.obstacle[waypointUseMax ? "xMax" : "xMin"] + (waypointUseMax ? 1 : -1),
          y: dirIsX2 ? pivot.obstacle[waypointUseMax ? "yMax" : "yMin"] + (waypointUseMax ? 1 : -1) : pivot.y
        };
        dirIsX2 = !dirIsX2;
        segments2 = segments2.concat(clearPathTo({
          x: pivot.x,
          y: pivot.y
        }, waypoint, dirIsX2));
      }
    }
    segments2 = segments2.concat(clearPathTo(segments2[segments2.length - 1].end, toPoint, !dirIsX2));
    return segments2;
  }
  function extractFromObstacle(obstacle, point, goalPoint) {
    const dirIsX2 = min2(obstacle.xMax - point.x, point.x - obstacle.xMin) < min2(obstacle.yMax - point.y, point.y - obstacle.yMin), bounds = {
      soft: options2.hardBounds,
      hard: options2.hardBounds
    }, useMax2 = getDodgeDirection(obstacle, point, goalPoint, dirIsX2, bounds);
    return dirIsX2 ? {
      y: point.y,
      x: obstacle[useMax2 ? "xMax" : "xMin"] + (useMax2 ? 1 : -1)
    } : {
      x: point.x,
      y: obstacle[useMax2 ? "yMax" : "yMin"] + (useMax2 ? 1 : -1)
    };
  }
  chartObstacles = chartObstacles.slice(startObstacleIx, endObstacleIx + 1);
  if ((endObstacleIx = findObstacleFromPoint(chartObstacles, end)) > -1) {
    extractedEndPoint = extractFromObstacle(chartObstacles[endObstacleIx], end, start);
    endSegments.push({
      end,
      start: extractedEndPoint
    });
    end = extractedEndPoint;
  }
  while ((endObstacleIx = findObstacleFromPoint(chartObstacles, end)) > -1) {
    useMax = end[dir] - start[dir] < 0;
    extractedEndPoint = {
      x: end.x,
      y: end.y
    };
    extractedEndPoint[dir] = chartObstacles[endObstacleIx][useMax ? dir + "Max" : dir + "Min"] + (useMax ? 1 : -1);
    endSegments.push({
      end,
      start: extractedEndPoint
    });
    end = extractedEndPoint;
  }
  segments = clearPathTo(start, end, dirIsX);
  segments = segments.concat(endSegments.reverse());
  return {
    path: pathFromSegments(segments),
    obstacles: segments
  };
}
fastAvoid.requiresObstacles = true;
var algorithms = {
  fastAvoid,
  straight,
  simpleConnect
};
var PathfinderAlgorithms_default = algorithms;

// node_modules/highcharts/es-modules/Gantt/ConnectorsDefaults.js
var connectorsDefaults = {
  /**
   * The Pathfinder module allows you to define connections between any two
   * points, represented as lines - optionally with markers for the start
   * and/or end points. Multiple algorithms are available for calculating how
   * the connecting lines are drawn.
   *
   * Connector functionality requires Highcharts Gantt to be loaded. In Gantt
   * charts, the connectors are used to draw dependencies between tasks.
   *
   * @see [dependency](series.gantt.data.dependency)
   *
   * @sample gantt/pathfinder/demo
   *         Pathfinder connections
   *
   * @declare      Highcharts.ConnectorsOptions
   * @product      gantt
   * @optionparent connectors
   */
  connectors: {
    /**
     * Enable connectors for this chart. Requires Highcharts Gantt.
     *
     * @type      {boolean}
     * @default   true
     * @since     6.2.0
     * @apioption connectors.enabled
     */
    /**
     * Set the default dash style for this chart's connecting lines.
     *
     * @type      {string}
     * @default   solid
     * @since     6.2.0
     * @apioption connectors.dashStyle
     */
    /**
     * Set the default color for this chart's Pathfinder connecting lines.
     * Defaults to the color of the point being connected.
     *
     * @type      {Highcharts.ColorString}
     * @since     6.2.0
     * @apioption connectors.lineColor
     */
    /**
     * Set the default pathfinder margin to use, in pixels. Some Pathfinder
     * algorithms attempt to avoid obstacles, such as other points in the
     * chart. These algorithms use this margin to determine how close lines
     * can be to an obstacle. The default is to compute this automatically
     * from the size of the obstacles in the chart.
     *
     * To draw connecting lines close to existing points, set this to a low
     * number. For more space around existing points, set this number
     * higher.
     *
     * @sample gantt/pathfinder/algorithm-margin
     *         Small algorithmMargin
     *
     * @type      {number}
     * @since     6.2.0
     * @apioption connectors.algorithmMargin
     */
    /**
     * Set the default pathfinder algorithm to use for this chart. It is
     * possible to define your own algorithms by adding them to the
     * Highcharts.Pathfinder.prototype.algorithms object before the chart
     * has been created.
     *
     * The default algorithms are as follows:
     *
     * `straight`:      Draws a straight line between the connecting
     *                  points. Does not avoid other points when drawing.
     *
     * `simpleConnect`: Finds a path between the points using right angles
     *                  only. Takes only starting/ending points into
     *                  account, and will not avoid other points.
     *
     * `fastAvoid`:     Finds a path between the points using right angles
     *                  only. Will attempt to avoid other points, but its
     *                  focus is performance over accuracy. Works well with
     *                  less dense datasets.
     *
     * Default value: `straight` is used as default for most series types,
     * while `simpleConnect` is used as default for Gantt series, to show
     * dependencies between points.
     *
     * @sample gantt/pathfinder/demo
     *         Different types used
     *
     * @type    {Highcharts.PathfinderTypeValue}
     * @default undefined
     * @since   6.2.0
     */
    type: "straight",
    /**
     * The corner radius for the connector line.
     *
     * @since 11.2.0
     */
    radius: 0,
    /**
     * Set the default pixel width for this chart's Pathfinder connecting
     * lines.
     *
     * @since 6.2.0
     */
    lineWidth: 1,
    /**
     * Marker options for this chart's Pathfinder connectors. Note that
     * this option is overridden by the `startMarker` and `endMarker`
     * options.
     *
     * @declare Highcharts.ConnectorsMarkerOptions
     * @since   6.2.0
     */
    marker: {
      /**
       * Set the radius of the connector markers. The default is
       * automatically computed based on the algorithmMargin setting.
       *
       * Setting marker.width and marker.height will override this
       * setting.
       *
       * @type      {number}
       * @since     6.2.0
       * @apioption connectors.marker.radius
       */
      /**
       * Set the width of the connector markers. If not supplied, this
       * is inferred from the marker radius.
       *
       * @type      {number}
       * @since     6.2.0
       * @apioption connectors.marker.width
       */
      /**
       * Set the height of the connector markers. If not supplied, this
       * is inferred from the marker radius.
       *
       * @type      {number}
       * @since     6.2.0
       * @apioption connectors.marker.height
       */
      /**
       * Set the color of the connector markers. By default this is the
       * same as the connector color.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since     6.2.0
       * @apioption connectors.marker.color
       */
      /**
       * Set the line/border color of the connector markers. By default
       * this is the same as the marker color.
       *
       * @type      {Highcharts.ColorString}
       * @since     6.2.0
       * @apioption connectors.marker.lineColor
       */
      /**
       * Enable markers for the connectors.
       */
      enabled: false,
      /**
       * Horizontal alignment of the markers relative to the points.
       *
       * @type {Highcharts.AlignValue}
       */
      align: "center",
      /**
       * Vertical alignment of the markers relative to the points.
       *
       * @type {Highcharts.VerticalAlignValue}
       */
      verticalAlign: "middle",
      /**
       * Whether or not to draw the markers inside the points.
       */
      inside: false,
      /**
       * Set the line/border width of the pathfinder markers.
       */
      lineWidth: 1
    },
    /**
     * Marker options specific to the start markers for this chart's
     * Pathfinder connectors. Overrides the generic marker options.
     *
     * @declare Highcharts.ConnectorsStartMarkerOptions
     * @extends connectors.marker
     * @since   6.2.0
     */
    startMarker: {
      /**
       * Set the symbol of the connector start markers.
       */
      symbol: "diamond"
    },
    /**
     * Marker options specific to the end markers for this chart's
     * Pathfinder connectors. Overrides the generic marker options.
     *
     * @declare Highcharts.ConnectorsEndMarkerOptions
     * @extends connectors.marker
     * @since   6.2.0
     */
    endMarker: {
      /**
       * Set the symbol of the connector end markers.
       */
      symbol: "arrow-filled"
    }
  }
};
var ConnectorsDefaults_default = connectorsDefaults;

// node_modules/highcharts/es-modules/Gantt/PathfinderComposition.js
var { setOptions: setOptions5 } = Defaults_default;
var { defined: defined79, error: error12, merge: merge105 } = Utilities_default;
function getPointBB(point) {
  const shapeArgs = point.shapeArgs;
  if (shapeArgs) {
    return {
      xMin: shapeArgs.x || 0,
      xMax: (shapeArgs.x || 0) + (shapeArgs.width || 0),
      yMin: shapeArgs.y || 0,
      yMax: (shapeArgs.y || 0) + (shapeArgs.height || 0)
    };
  }
  const bb = point.graphic && point.graphic.getBBox();
  return bb ? {
    xMin: point.plotX - bb.width / 2,
    xMax: point.plotX + bb.width / 2,
    yMin: point.plotY - bb.height / 2,
    yMax: point.plotY + bb.height / 2
  } : null;
}
function warnLegacy(chart) {
  if (chart.options.pathfinder || chart.series.reduce(function(acc, series) {
    if (series.options) {
      merge105(true, series.options.connectors = series.options.connectors || {}, series.options.pathfinder);
    }
    return acc || series.options && series.options.pathfinder;
  }, false)) {
    merge105(true, chart.options.connectors = chart.options.connectors || {}, chart.options.pathfinder);
    error12('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.');
  }
}
var ConnectionComposition;
(function(ConnectionComposition2) {
  function compose27(ChartClass, PathfinderClass, PointClass) {
    const pointProto2 = PointClass.prototype;
    if (!pointProto2.getPathfinderAnchorPoint) {
      ChartClass.prototype.callbacks.push(function(chart) {
        const options2 = chart.options;
        if (options2.connectors.enabled !== false) {
          warnLegacy(chart);
          this.pathfinder = new PathfinderClass(this);
          this.pathfinder.update(true);
        }
      });
      pointProto2.getMarkerVector = pointGetMarkerVector;
      pointProto2.getPathfinderAnchorPoint = pointGetPathfinderAnchorPoint;
      pointProto2.getRadiansToVector = pointGetRadiansToVector;
      setOptions5(ConnectorsDefaults_default);
    }
  }
  ConnectionComposition2.compose = compose27;
  function pointGetPathfinderAnchorPoint(markerOptions) {
    const bb = getPointBB(this);
    let x, y;
    switch (markerOptions.align) {
      // eslint-disable-line default-case
      case "right":
        x = "xMax";
        break;
      case "left":
        x = "xMin";
    }
    switch (markerOptions.verticalAlign) {
      // eslint-disable-line default-case
      case "top":
        y = "yMin";
        break;
      case "bottom":
        y = "yMax";
    }
    return {
      x: x ? bb[x] : (bb.xMin + bb.xMax) / 2,
      y: y ? bb[y] : (bb.yMin + bb.yMax) / 2
    };
  }
  function pointGetRadiansToVector(v1, v2) {
    let box;
    if (!defined79(v2)) {
      box = getPointBB(this);
      if (box) {
        v2 = {
          x: (box.xMin + box.xMax) / 2,
          y: (box.yMin + box.yMax) / 2
        };
      }
    }
    return Math.atan2(v2.y - v1.y, v1.x - v2.x);
  }
  function pointGetMarkerVector(radians, markerRadius, anchor) {
    const twoPI = Math.PI * 2, bb = getPointBB(this), rectWidth = bb.xMax - bb.xMin, rectHeight = bb.yMax - bb.yMin, rAtan = Math.atan2(rectHeight, rectWidth), rectHalfWidth = rectWidth / 2, rectHalfHeight = rectHeight / 2, rectHorizontalCenter = bb.xMin + rectHalfWidth, rectVerticalCenter = bb.yMin + rectHalfHeight, edgePoint = {
      x: rectHorizontalCenter,
      y: rectVerticalCenter
    };
    let theta = radians, tanTheta = 1, leftOrRightRegion = false, xFactor = 1, yFactor = 1;
    while (theta < -Math.PI) {
      theta += twoPI;
    }
    while (theta > Math.PI) {
      theta -= twoPI;
    }
    tanTheta = Math.tan(theta);
    if (theta > -rAtan && theta <= rAtan) {
      yFactor = -1;
      leftOrRightRegion = true;
    } else if (theta > rAtan && theta <= Math.PI - rAtan) {
      yFactor = -1;
    } else if (theta > Math.PI - rAtan || theta <= -(Math.PI - rAtan)) {
      xFactor = -1;
      leftOrRightRegion = true;
    } else {
      xFactor = -1;
    }
    if (leftOrRightRegion) {
      edgePoint.x += xFactor * rectHalfWidth;
      edgePoint.y += yFactor * rectHalfWidth * tanTheta;
    } else {
      edgePoint.x += xFactor * (rectHeight / (2 * tanTheta));
      edgePoint.y += yFactor * rectHalfHeight;
    }
    if (anchor.x !== rectHorizontalCenter) {
      edgePoint.x = anchor.x;
    }
    if (anchor.y !== rectVerticalCenter) {
      edgePoint.y = anchor.y;
    }
    return {
      x: edgePoint.x + markerRadius * Math.cos(theta),
      y: edgePoint.y - markerRadius * Math.sin(theta)
    };
  }
})(ConnectionComposition || (ConnectionComposition = {}));
var PathfinderComposition_default = ConnectionComposition;

// node_modules/highcharts/es-modules/Gantt/Pathfinder.js
var { addEvent: addEvent90, defined: defined80, pick: pick112, splat: splat23 } = Utilities_default;
var max3 = Math.max;
var min3 = Math.min;
function getPointBB2(point) {
  const shapeArgs = point.shapeArgs;
  if (shapeArgs) {
    return {
      xMin: shapeArgs.x || 0,
      xMax: (shapeArgs.x || 0) + (shapeArgs.width || 0),
      yMin: shapeArgs.y || 0,
      yMax: (shapeArgs.y || 0) + (shapeArgs.height || 0)
    };
  }
  const bb = point.graphic && point.graphic.getBBox();
  return bb ? {
    xMin: point.plotX - bb.width / 2,
    xMax: point.plotX + bb.width / 2,
    yMin: point.plotY - bb.height / 2,
    yMax: point.plotY + bb.height / 2
  } : null;
}
function calculateObstacleDistance(a, b, bbMargin) {
  const margin = pick112(bbMargin, 10), yOverlap = a.yMax + margin > b.yMin - margin && a.yMin - margin < b.yMax + margin, xOverlap = a.xMax + margin > b.xMin - margin && a.xMin - margin < b.xMax + margin, xDistance = yOverlap ? a.xMin > b.xMax ? a.xMin - b.xMax : b.xMin - a.xMax : Infinity, yDistance = xOverlap ? a.yMin > b.yMax ? a.yMin - b.yMax : b.yMin - a.yMax : Infinity;
  if (xOverlap && yOverlap) {
    return margin ? calculateObstacleDistance(a, b, Math.floor(margin / 2)) : Infinity;
  }
  return min3(xDistance, yDistance);
}
function calculateObstacleMargin(obstacles) {
  const len = obstacles.length, distances = [];
  let onstacleDistance;
  for (let i = 0; i < len; ++i) {
    for (let j = i + 1; j < len; ++j) {
      onstacleDistance = calculateObstacleDistance(obstacles[i], obstacles[j]);
      if (onstacleDistance < 80) {
        distances.push(onstacleDistance);
      }
    }
  }
  distances.push(80);
  return max3(
    Math.floor(
      distances.sort(function(a, b) {
        return a - b;
      })[
        // Discard first 10% of the relevant distances, and then grab
        // the smallest one.
        Math.floor(distances.length / 10)
      ] / 2 - 1
      // Divide the distance by 2 and subtract 1.
    ),
    1
    // 1 is the minimum margin
  );
}
var Pathfinder = class _Pathfinder {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(ChartClass, PointClass) {
    PathfinderComposition_default.compose(ChartClass, _Pathfinder, PointClass);
  }
  /* *
   *
   *  Constructor
   *
   * */
  constructor(chart) {
    this.init(chart);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Initialize the Pathfinder object.
   *
   * @function Highcharts.Pathfinder#init
   *
   * @param {Highcharts.Chart} chart
   *        The chart context.
   */
  init(chart) {
    this.chart = chart;
    this.connections = [];
    addEvent90(chart, "redraw", function() {
      this.pathfinder.update();
    });
  }
  /**
   * Update Pathfinder connections from scratch.
   *
   * @function Highcharts.Pathfinder#update
   *
   * @param {boolean} [deferRender]
   *        Whether or not to defer rendering of connections until
   *        series.afterAnimate event has fired. Used on first render.
   */
  update(deferRender) {
    const chart = this.chart, pathfinder = this, oldConnections = pathfinder.connections;
    pathfinder.connections = [];
    chart.series.forEach(function(series) {
      if (series.visible && !series.options.isInternal) {
        series.points.forEach(function(point) {
          const ganttPointOptions = point.options;
          if (ganttPointOptions && ganttPointOptions.dependency) {
            ganttPointOptions.connect = ganttPointOptions.dependency;
          }
          const connects = point.options?.connect ? splat23(point.options.connect) : [];
          let to;
          if (point.visible && point.isInside !== false) {
            connects.forEach((connect) => {
              const toId = typeof connect === "string" ? connect : connect.to;
              if (toId) {
                to = chart.get(toId);
              }
              if (to instanceof Point_default && to.series.visible && to.visible && to.isInside !== false) {
                pathfinder.connections.push(new Connection_default(
                  point,
                  // From
                  to,
                  typeof connect === "string" ? {} : connect
                ));
              }
            });
          }
        });
      }
    });
    for (let j = 0, k, found, lenOld = oldConnections.length, lenNew = pathfinder.connections.length; j < lenOld; ++j) {
      found = false;
      const oldCon = oldConnections[j];
      for (k = 0; k < lenNew; ++k) {
        const newCon = pathfinder.connections[k];
        if ((oldCon.options && oldCon.options.type) === (newCon.options && newCon.options.type) && oldCon.fromPoint === newCon.fromPoint && oldCon.toPoint === newCon.toPoint) {
          newCon.graphics = oldCon.graphics;
          found = true;
          break;
        }
      }
      if (!found) {
        oldCon.destroy();
      }
    }
    delete this.chartObstacles;
    delete this.lineObstacles;
    pathfinder.renderConnections(deferRender);
  }
  /**
   * Draw the chart's connecting paths.
   *
   * @function Highcharts.Pathfinder#renderConnections
   *
   * @param {boolean} [deferRender]
   *        Whether or not to defer render until series animation is finished.
   *        Used on first render.
   */
  renderConnections(deferRender) {
    if (deferRender) {
      this.chart.series.forEach(function(series) {
        const render = function() {
          const pathfinder = series.chart.pathfinder, conns = pathfinder && pathfinder.connections || [];
          conns.forEach(function(connection) {
            if (connection.fromPoint && connection.fromPoint.series === series) {
              connection.render();
            }
          });
          if (series.pathfinderRemoveRenderEvent) {
            series.pathfinderRemoveRenderEvent();
            delete series.pathfinderRemoveRenderEvent;
          }
        };
        if (series.options.animation === false) {
          render();
        } else {
          series.pathfinderRemoveRenderEvent = addEvent90(series, "afterAnimate", render);
        }
      });
    } else {
      this.connections.forEach(function(connection) {
        connection.render();
      });
    }
  }
  /**
       * Get obstacles for the points in the chart. Does not include connecting
       * lines from Pathfinder. Applies algorithmMargin to the obstacles.
       *
       * @function Highcharts.Pathfinder#getChartObstacles
       *
       * @param {Object} options
       *        Options for the calculation. Currently only
       *        `options.algorithmMargin`.
       *
       * @param {number} options.algorithmMargin
       *        The algorithm margin to use for the obstacles.
  
      * @return {Array<object>}
       *         An array of calculated obstacles. Each obstacle is defined as an
       *         object with xMin, xMax, yMin and yMax properties.
       */
  getChartObstacles(options2) {
    const series = this.chart.series, margin = pick112(options2.algorithmMargin, 0);
    let obstacles = [], calculatedMargin;
    for (let i = 0, sLen = series.length; i < sLen; ++i) {
      if (series[i].visible && !series[i].options.isInternal) {
        for (let j = 0, pLen = series[i].points.length, bb, point; j < pLen; ++j) {
          point = series[i].points[j];
          if (point.visible) {
            bb = getPointBB2(point);
            if (bb) {
              obstacles.push({
                xMin: bb.xMin - margin,
                xMax: bb.xMax + margin,
                yMin: bb.yMin - margin,
                yMax: bb.yMax + margin
              });
            }
          }
        }
      }
    }
    obstacles = obstacles.sort(function(a, b) {
      return a.xMin - b.xMin;
    });
    if (!defined80(options2.algorithmMargin)) {
      calculatedMargin = options2.algorithmMargin = calculateObstacleMargin(obstacles);
      obstacles.forEach(function(obstacle) {
        obstacle.xMin -= calculatedMargin;
        obstacle.xMax += calculatedMargin;
        obstacle.yMin -= calculatedMargin;
        obstacle.yMax += calculatedMargin;
      });
    }
    return obstacles;
  }
  /**
   * Utility function to get metrics for obstacles:
   * - Widest obstacle width
   * - Tallest obstacle height
   *
   * @function Highcharts.Pathfinder#getObstacleMetrics
   *
   * @param {Array<object>} obstacles
   *        An array of obstacles to inspect.
   *
   * @return {Object}
   *         The calculated metrics, as an object with maxHeight and maxWidth
   *         properties.
   */
  getObstacleMetrics(obstacles) {
    let maxWidth = 0, maxHeight = 0, width, height, i = obstacles.length;
    while (i--) {
      width = obstacles[i].xMax - obstacles[i].xMin;
      height = obstacles[i].yMax - obstacles[i].yMin;
      if (maxWidth < width) {
        maxWidth = width;
      }
      if (maxHeight < height) {
        maxHeight = height;
      }
    }
    return {
      maxHeight,
      maxWidth
    };
  }
  /**
   * Utility to get which direction to start the pathfinding algorithm
   * (X vs Y), calculated from a set of marker options.
   *
   * @function Highcharts.Pathfinder#getAlgorithmStartDirection
   *
   * @param {Highcharts.ConnectorsMarkerOptions} markerOptions
   *        Marker options to calculate from.
   *
   * @return {boolean}
   *         Returns true for X, false for Y, and undefined for autocalculate.
   */
  getAlgorithmStartDirection(markerOptions) {
    const xCenter = markerOptions.align !== "left" && markerOptions.align !== "right", yCenter = markerOptions.verticalAlign !== "top" && markerOptions.verticalAlign !== "bottom";
    return xCenter ? yCenter ? void 0 : false : (
      // When x is centered
      yCenter ? true : void 0
    );
  }
};
Pathfinder.prototype.algorithms = PathfinderAlgorithms_default;
var Pathfinder_default = Pathfinder;

// node_modules/highcharts/es-modules/masters/modules/pathfinder.src.js
var G18 = Globals_default;
G18.Pathfinder = G18.Pathfinder || Pathfinder_default;
ArrowSymbols_default.compose(G18.SVGRenderer);
G18.Pathfinder.compose(G18.Chart, G18.Point);

// node_modules/highcharts/es-modules/Extensions/StaticScale.js
var { addEvent: addEvent91, defined: defined81, isNumber: isNumber71, pick: pick113 } = Utilities_default;
function compose23(AxisClass, ChartClass) {
  const chartProto = ChartClass.prototype;
  if (!chartProto.adjustHeight) {
    addEvent91(AxisClass, "afterSetOptions", onAxisAfterSetOptions3);
    chartProto.adjustHeight = chartAdjustHeight;
    addEvent91(ChartClass, "render", chartProto.adjustHeight);
  }
}
function onAxisAfterSetOptions3() {
  const chartOptions = this.chart.options.chart;
  if (!this.horiz && isNumber71(this.options.staticScale) && (!chartOptions.height || chartOptions.scrollablePlotArea && chartOptions.scrollablePlotArea.minHeight)) {
    this.staticScale = this.options.staticScale;
  }
}
function chartAdjustHeight() {
  const chart = this;
  if (chart.redrawTrigger !== "adjustHeight") {
    for (const axis of chart.axes || []) {
      const chart2 = axis.chart, animate4 = !!chart2.initiatedScale && chart2.options.animation, staticScale = axis.options.staticScale;
      if (axis.staticScale && defined81(axis.min)) {
        let height = pick113(axis.brokenAxis && axis.brokenAxis.unitLength, axis.max + axis.tickInterval - axis.min) * staticScale;
        height = Math.max(height, staticScale);
        const diff = height - chart2.plotHeight;
        if (!chart2.scrollablePixelsY && Math.abs(diff) >= 1) {
          chart2.plotHeight = height;
          chart2.redrawTrigger = "adjustHeight";
          chart2.setSize(void 0, chart2.chartHeight + diff, animate4);
        }
        axis.series.forEach(function(series) {
          const clipRect = series.sharedClipKey && chart2.sharedClips[series.sharedClipKey];
          if (clipRect) {
            clipRect.attr(chart2.inverted ? {
              width: chart2.plotHeight
            } : {
              height: chart2.plotHeight
            });
          }
        });
      }
    }
    this.initiatedScale = true;
  }
  this.redrawTrigger = null;
}
var StaticScale = {
  compose: compose23
};
var StaticScale_default = StaticScale;

// node_modules/highcharts/es-modules/masters/modules/static-scale.src.js
var G19 = Globals_default;
StaticScale_default.compose(G19.Axis, G19.Chart);

// node_modules/highcharts/es-modules/Series/Gantt/GanttPoint.js
var { xrange: { prototype: { pointClass: XRangePoint2 } } } = SeriesRegistry_default.seriesTypes;
var GanttPoint = class _GanttPoint extends XRangePoint2 {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * @private
   */
  static setGanttPointAliases(options2, chart) {
    options2.x = options2.start = chart.time.parse(options2.start ?? options2.x);
    options2.x2 = options2.end = chart.time.parse(options2.end ?? options2.x2);
    options2.partialFill = options2.completed = options2.completed ?? options2.partialFill;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Applies the options containing the x and y data and possible some
   * extra properties. This is called on point init or from point.update.
   *
   * @private
   * @function Highcharts.Point#applyOptions
   *
   * @param {Object} options
   *        The point options
   *
   * @param {number} x
   *        The x value
   *
   * @return {Highcharts.Point}
   *         The Point instance
   */
  applyOptions(options2, x) {
    const ganttPoint = super.applyOptions(options2, x);
    _GanttPoint.setGanttPointAliases(ganttPoint, ganttPoint.series.chart);
    this.isNull = !this.isValid?.();
    return ganttPoint;
  }
  isValid() {
    return (typeof this.start === "number" || typeof this.x === "number") && (typeof this.end === "number" || typeof this.x2 === "number" || this.milestone);
  }
};
var GanttPoint_default = GanttPoint;

// node_modules/highcharts/es-modules/Series/Gantt/GanttSeriesDefaults.js
var { isNumber: isNumber72 } = Utilities_default;
var GanttSeriesDefaults = {
  // Options - default options merged with parent
  grouping: false,
  dataLabels: {
    enabled: true
  },
  tooltip: {
    headerFormat: '<span style="font-size: 0.8em">{series.name}</span><br/>',
    pointFormat: null,
    pointFormatter: function() {
      const point = this, series = point.series, xAxis2 = series.xAxis, formats = series.tooltipOptions.dateTimeLabelFormats, startOfWeek = xAxis2.options.startOfWeek, ttOptions = series.tooltipOptions, milestone = point.options.milestone;
      let format18 = ttOptions.xDateFormat, retVal = "<b>" + (point.name || point.yCategory) + "</b>";
      if (ttOptions.pointFormat) {
        return point.tooltipFormatter(ttOptions.pointFormat);
      }
      if (!format18 && isNumber72(point.start)) {
        format18 = series.chart.time.getDateFormat(xAxis2.closestPointRange, point.start, startOfWeek, formats || {});
      }
      const start = series.chart.time.dateFormat(format18, point.start), end = series.chart.time.dateFormat(format18, point.end);
      retVal += "<br/>";
      if (!milestone) {
        retVal += "Start: " + start + "<br/>";
        retVal += "End: " + end + "<br/>";
      } else {
        retVal += start + "<br/>";
      }
      return retVal;
    }
  },
  connectors: {
    type: "simpleConnect",
    /**
     * @declare Highcharts.ConnectorsAnimationOptionsObject
     */
    animation: {
      reversed: true
      // Dependencies go from child to parent
    },
    radius: 0,
    startMarker: {
      enabled: true,
      symbol: "arrow-filled",
      radius: 4,
      fill: "#fa0",
      align: "left"
    },
    endMarker: {
      enabled: false,
      // Only show arrow on the dependent task
      align: "right"
    }
  }
};
var GanttSeriesDefaults_default = GanttSeriesDefaults;

// node_modules/highcharts/es-modules/Core/Axis/GridAxis.js
var { dateFormats: dateFormats2 } = Globals_default;
var { addEvent: addEvent92, defined: defined82, erase: erase13, find: find19, isArray: isArray27, isNumber: isNumber73, merge: merge106, pick: pick114, timeUnits: timeUnits6, wrap: wrap14 } = Utilities_default;
var GridAxisSide;
(function(GridAxisSide2) {
  GridAxisSide2[GridAxisSide2["top"] = 0] = "top";
  GridAxisSide2[GridAxisSide2["right"] = 1] = "right";
  GridAxisSide2[GridAxisSide2["bottom"] = 2] = "bottom";
  GridAxisSide2[GridAxisSide2["left"] = 3] = "left";
})(GridAxisSide || (GridAxisSide = {}));
function argsToArray(args) {
  return Array.prototype.slice.call(args, 1);
}
function isObject24(x) {
  return Utilities_default.isObject(x, true);
}
function applyGridOptions(axis) {
  const options2 = axis.options;
  options2.labels.align = pick114(options2.labels.align, "center");
  if (!axis.categories) {
    options2.showLastLabel = false;
  }
  axis.labelRotation = 0;
  options2.labels.rotation = 0;
  options2.minTickInterval = 1;
}
function compose24(AxisClass, ChartClass, TickClass) {
  if (!AxisClass.keepProps.includes("grid")) {
    AxisClass.keepProps.push("grid");
    AxisClass.prototype.getMaxLabelDimensions = getMaxLabelDimensions;
    wrap14(AxisClass.prototype, "unsquish", wrapUnsquish);
    wrap14(AxisClass.prototype, "getOffset", wrapGetOffset);
    addEvent92(AxisClass, "init", onInit);
    addEvent92(AxisClass, "afterGetTitlePosition", onAfterGetTitlePosition);
    addEvent92(AxisClass, "afterInit", onAfterInit);
    addEvent92(AxisClass, "afterRender", onAfterRender);
    addEvent92(AxisClass, "afterSetAxisTranslation", onAfterSetAxisTranslation);
    addEvent92(AxisClass, "afterSetOptions", onAfterSetOptions2);
    addEvent92(AxisClass, "afterSetOptions", onAfterSetOptions22);
    addEvent92(AxisClass, "afterSetScale", onAfterSetScale2);
    addEvent92(AxisClass, "afterTickSize", onAfterTickSize);
    addEvent92(AxisClass, "trimTicks", onTrimTicks);
    addEvent92(AxisClass, "destroy", onDestroy);
    addEvent92(ChartClass, "afterSetChartSize", onChartAfterSetChartSize2);
    addEvent92(TickClass, "afterGetLabelPosition", onTickAfterGetLabelPosition2);
    addEvent92(TickClass, "labelFormat", onTickLabelFormat);
  }
  return AxisClass;
}
function getMaxLabelDimensions(ticks, tickPositions) {
  const dimensions = {
    width: 0,
    height: 0
  };
  tickPositions.forEach(function(pos) {
    const tick = ticks[pos];
    let labelHeight = 0, labelWidth = 0, label;
    if (isObject24(tick)) {
      label = isObject24(tick.label) ? tick.label : {};
      labelHeight = label.getBBox ? label.getBBox().height : 0;
      if (label.textStr && !isNumber73(label.textPxLength)) {
        label.textPxLength = label.getBBox().width;
      }
      labelWidth = isNumber73(label.textPxLength) ? (
        // Math.round ensures crisp lines
        Math.round(label.textPxLength)
      ) : 0;
      if (label.textStr) {
        labelWidth = Math.round(label.getBBox().width);
      }
      dimensions.height = Math.max(labelHeight, dimensions.height);
      dimensions.width = Math.max(labelWidth, dimensions.width);
    }
  });
  if (this.type === "treegrid" && this.treeGrid && this.treeGrid.mapOfPosToGridNode) {
    const treeDepth = this.treeGrid.mapOfPosToGridNode[-1].height || 0;
    dimensions.width += this.options.labels.indentation * (treeDepth - 1);
  }
  return dimensions;
}
function wrapGetOffset(proceed) {
  const { grid } = this, columnsFirst = this.side === 3;
  if (!columnsFirst) {
    proceed.apply(this);
  }
  if (!grid?.isColumn) {
    let columns = grid?.columns || [];
    if (columnsFirst) {
      columns = columns.slice().reverse();
    }
    columns.forEach((column2) => {
      column2.getOffset();
    });
  }
  if (columnsFirst) {
    proceed.apply(this);
  }
}
function onAfterGetTitlePosition(e) {
  const axis = this;
  const options2 = axis.options;
  const gridOptions = options2.grid || {};
  if (gridOptions.enabled === true) {
    const { axisTitle, height: axisHeight, horiz, left: axisLeft, offset: offset3, opposite, options: options3, top: axisTop, width: axisWidth } = axis;
    const tickSize = axis.tickSize();
    const titleWidth = axisTitle?.getBBox().width;
    const xOption = options3.title.x;
    const yOption = options3.title.y;
    const titleMargin = pick114(options3.title.margin, horiz ? 5 : 10);
    const titleFontSize = axisTitle ? axis.chart.renderer.fontMetrics(axisTitle).f : 0;
    const crispCorr = tickSize ? tickSize[0] / 2 : 0;
    const offAxis = (horiz ? axisTop + axisHeight : axisLeft) + (horiz ? 1 : -1) * // Horizontal axis reverses the margin
    (opposite ? -1 : 1) * // So does opposite axes
    crispCorr + (axis.side === GridAxisSide.bottom ? titleFontSize : 0);
    e.titlePosition.x = horiz ? axisLeft - (titleWidth || 0) / 2 - titleMargin + xOption : offAxis + (opposite ? axisWidth : 0) + offset3 + xOption;
    e.titlePosition.y = horiz ? offAxis - (opposite ? axisHeight : 0) + (opposite ? titleFontSize : -titleFontSize) / 2 + offset3 + yOption : axisTop - titleMargin + yOption;
  }
}
function onAfterInit() {
  const axis = this;
  const { chart, options: { grid: gridOptions = {} }, userOptions } = axis;
  if (gridOptions.enabled) {
    applyGridOptions(axis);
  }
  if (gridOptions.columns) {
    const columns = axis.grid.columns = [];
    let columnIndex = axis.grid.columnIndex = 0;
    while (++columnIndex < gridOptions.columns.length) {
      const columnOptions = merge106(
        userOptions,
        gridOptions.columns[columnIndex],
        {
          isInternal: true,
          linkedTo: 0,
          // Disable by default the scrollbar on the grid axis
          scrollbar: {
            enabled: false
          }
        },
        // Avoid recursion
        {
          grid: {
            columns: void 0
          }
        }
      );
      const column2 = new Axis_default(axis.chart, columnOptions, "yAxis");
      column2.grid.isColumn = true;
      column2.grid.columnIndex = columnIndex;
      erase13(chart.axes, column2);
      erase13(chart[axis.coll] || [], column2);
      columns.push(column2);
    }
  }
}
function onAfterRender() {
  const axis = this, { axisTitle, grid, options: options2 } = axis, gridOptions = options2.grid || {};
  if (gridOptions.enabled === true) {
    const min4 = axis.min || 0, max4 = axis.max || 0, firstTick = axis.ticks[axis.tickPositions[0]];
    if (axisTitle && !axis.chart.styledMode && firstTick?.slotWidth && !axis.options.title.style.width) {
      axisTitle.css({ width: `${firstTick.slotWidth}px` });
    }
    axis.maxLabelDimensions = axis.getMaxLabelDimensions(axis.ticks, axis.tickPositions);
    if (axis.rightWall) {
      axis.rightWall.destroy();
    }
    if (axis.grid?.isOuterAxis() && axis.axisLine) {
      const lineWidth = options2.lineWidth;
      if (lineWidth) {
        const linePath = axis.getLinePath(lineWidth), startPoint = linePath[0], endPoint = linePath[1], tickLength = (axis.tickSize("tick") || [1])[0], distance = tickLength * (axis.side === GridAxisSide.top || axis.side === GridAxisSide.left ? -1 : 1);
        if (startPoint[0] === "M" && endPoint[0] === "L") {
          if (axis.horiz) {
            startPoint[2] += distance;
            endPoint[2] += distance;
          } else {
            startPoint[1] += distance;
            endPoint[1] += distance;
          }
        }
        if (!axis.horiz && axis.chart.marginRight) {
          const upperBorderStartPoint = startPoint, upperBorderEndPoint = [
            "L",
            axis.left,
            startPoint[2] || 0
          ], upperBorderPath = [
            upperBorderStartPoint,
            upperBorderEndPoint
          ], lowerBorderEndPoint = [
            "L",
            axis.chart.chartWidth - axis.chart.marginRight,
            axis.toPixels(max4 + axis.tickmarkOffset)
          ], lowerBorderStartPoint = [
            "M",
            endPoint[1] || 0,
            axis.toPixels(max4 + axis.tickmarkOffset)
          ], lowerBorderPath = [
            lowerBorderStartPoint,
            lowerBorderEndPoint
          ];
          if (!axis.grid.upperBorder && min4 % 1 !== 0) {
            axis.grid.upperBorder = axis.grid.renderBorder(upperBorderPath);
          }
          if (axis.grid.upperBorder) {
            axis.grid.upperBorder.attr({
              stroke: options2.lineColor,
              "stroke-width": options2.lineWidth
            });
            axis.grid.upperBorder.animate({
              d: upperBorderPath
            });
          }
          if (!axis.grid.lowerBorder && max4 % 1 !== 0) {
            axis.grid.lowerBorder = axis.grid.renderBorder(lowerBorderPath);
          }
          if (axis.grid.lowerBorder) {
            axis.grid.lowerBorder.attr({
              stroke: options2.lineColor,
              "stroke-width": options2.lineWidth
            });
            axis.grid.lowerBorder.animate({
              d: lowerBorderPath
            });
          }
        }
        if (!axis.grid.axisLineExtra) {
          axis.grid.axisLineExtra = axis.grid.renderBorder(linePath);
        } else {
          axis.grid.axisLineExtra.attr({
            stroke: options2.lineColor,
            "stroke-width": options2.lineWidth
          });
          axis.grid.axisLineExtra.animate({
            d: linePath
          });
        }
        axis.axisLine[axis.showAxis ? "show" : "hide"]();
      }
    }
    (grid?.columns || []).forEach((column2) => column2.render());
    if (!axis.horiz && axis.chart.hasRendered && (axis.scrollbar || axis.linkedParent?.scrollbar) && axis.tickPositions.length) {
      const tickmarkOffset = axis.tickmarkOffset, lastTick = axis.tickPositions[axis.tickPositions.length - 1], firstTick2 = axis.tickPositions[0];
      let label, tickMark;
      while ((label = axis.hiddenLabels.pop()) && label.element) {
        label.show();
      }
      while ((tickMark = axis.hiddenMarks.pop()) && tickMark.element) {
        tickMark.show();
      }
      label = axis.ticks[firstTick2].label;
      if (label) {
        if (min4 - firstTick2 > tickmarkOffset) {
          axis.hiddenLabels.push(label.hide());
        } else {
          label.show();
        }
      }
      label = axis.ticks[lastTick].label;
      if (label) {
        if (lastTick - max4 > tickmarkOffset) {
          axis.hiddenLabels.push(label.hide());
        } else {
          label.show();
        }
      }
      const mark = axis.ticks[lastTick].mark;
      if (mark && lastTick - max4 < tickmarkOffset && lastTick - max4 > 0 && axis.ticks[lastTick].isLast) {
        axis.hiddenMarks.push(mark.hide());
      }
    }
  }
}
function onAfterSetAxisTranslation() {
  const axis = this;
  const tickInfo = axis.tickPositions?.info;
  const options2 = axis.options;
  const gridOptions = options2.grid || {};
  const userLabels = axis.userOptions.labels || {};
  if (gridOptions.enabled) {
    if (axis.horiz) {
      axis.series.forEach((series) => {
        series.options.pointRange = 0;
      });
      if (tickInfo && options2.dateTimeLabelFormats && options2.labels && !defined82(userLabels.align) && (options2.dateTimeLabelFormats[tickInfo.unitName].range === false || tickInfo.count > 1)) {
        options2.labels.align = "left";
        if (!defined82(userLabels.x)) {
          options2.labels.x = 3;
        }
      }
    } else {
      if (this.type !== "treegrid" && axis.grid && axis.grid.columns) {
        this.minPointOffset = this.tickInterval;
      }
    }
  }
}
function onAfterSetOptions2(e) {
  const options2 = this.options, userOptions = e.userOptions, gridOptions = options2 && isObject24(options2.grid) ? options2.grid : {};
  let gridAxisOptions;
  if (gridOptions.enabled === true) {
    gridAxisOptions = merge106(true, {
      className: "highcharts-grid-axis " + (userOptions.className || ""),
      dateTimeLabelFormats: {
        hour: {
          list: ["%[HM]", "%[H]"]
        },
        day: {
          list: ["%[AeB]", "%[aeb]", "%[E]"]
        },
        week: {
          list: ["Week %W", "W%W"]
        },
        month: {
          list: ["%[B]", "%[b]", "%o"]
        }
      },
      grid: {
        borderWidth: 1
      },
      labels: {
        padding: 2,
        style: {
          fontSize: "0.9em"
        }
      },
      margin: 0,
      title: {
        text: null,
        reserveSpace: false,
        rotation: 0,
        style: {
          textOverflow: "ellipsis"
        }
      },
      // In a grid axis, only allow one unit of certain types,
      // for example we shouldn't have one grid cell spanning
      // two days.
      units: [[
        "millisecond",
        // Unit name
        [1, 10, 100]
      ], [
        "second",
        [1, 10]
      ], [
        "minute",
        [1, 5, 15]
      ], [
        "hour",
        [1, 6]
      ], [
        "day",
        [1]
      ], [
        "week",
        [1]
      ], [
        "month",
        [1]
      ], [
        "year",
        null
      ]]
    }, userOptions);
    if (this.coll === "xAxis") {
      if (defined82(userOptions.linkedTo) && !defined82(userOptions.tickPixelInterval)) {
        gridAxisOptions.tickPixelInterval = 350;
      }
      if (
        // Check for tick pixel interval in options
        !defined82(userOptions.tickPixelInterval) && // Only for linked axes
        defined82(userOptions.linkedTo) && !defined82(userOptions.tickPositioner) && !defined82(userOptions.tickInterval) && !defined82(userOptions.units)
      ) {
        gridAxisOptions.tickPositioner = function(min4, max4) {
          const parentInfo = this.linkedParent?.tickPositions?.info;
          if (parentInfo) {
            const units2 = gridAxisOptions.units || [];
            let unitIdx, count = 1, unitName = "year";
            for (let i = 0; i < units2.length; i++) {
              const unit2 = units2[i];
              if (unit2 && unit2[0] === parentInfo.unitName) {
                unitIdx = i;
                break;
              }
            }
            const unit = isNumber73(unitIdx) && units2[unitIdx + 1];
            if (unit) {
              unitName = unit[0] || "year";
              const counts = unit[1];
              count = counts?.[0] || 1;
            } else if (parentInfo.unitName === "year") {
              count = parentInfo.count * 10;
            }
            const unitRange = timeUnits6[unitName];
            this.tickInterval = unitRange * count;
            return this.chart.time.getTimeTicks({ unitRange, count, unitName }, min4, max4, this.options.startOfWeek);
          }
        };
      }
    }
    merge106(true, this.options, gridAxisOptions);
    if (this.horiz) {
      options2.minPadding = pick114(userOptions.minPadding, 0);
      options2.maxPadding = pick114(userOptions.maxPadding, 0);
    }
    if (isNumber73(options2.grid.borderWidth)) {
      options2.tickWidth = options2.lineWidth = gridOptions.borderWidth;
    }
  }
}
function onAfterSetOptions22(e) {
  const axis = this;
  const userOptions = e.userOptions;
  const gridOptions = userOptions?.grid || {};
  const columns = gridOptions.columns;
  if (gridOptions.enabled && columns) {
    merge106(true, axis.options, columns[0]);
  }
}
function onAfterSetScale2() {
  const axis = this;
  (axis.grid.columns || []).forEach((column2) => column2.setScale());
}
function onAfterTickSize(e) {
  const { horiz, maxLabelDimensions, options: { grid: gridOptions = {} } } = this;
  if (gridOptions.enabled && maxLabelDimensions) {
    const labelPadding = this.options.labels.distance * 2;
    const distance = horiz ? gridOptions.cellHeight || labelPadding + maxLabelDimensions.height : labelPadding + maxLabelDimensions.width;
    if (isArray27(e.tickSize)) {
      e.tickSize[0] = distance;
    } else {
      e.tickSize = [distance, 0];
    }
  }
}
function onChartAfterSetChartSize2() {
  this.axes.forEach((axis) => {
    (axis.grid?.columns || []).forEach((column2) => {
      column2.setAxisSize();
      column2.setAxisTranslation();
    });
  });
}
function onDestroy(e) {
  const { grid } = this;
  (grid.columns || []).forEach((column2) => column2.destroy(e.keepEvents));
  grid.columns = void 0;
}
function onInit(e) {
  const axis = this;
  const userOptions = e.userOptions || {};
  const gridOptions = userOptions.grid || {};
  if (gridOptions.enabled && defined82(gridOptions.borderColor)) {
    userOptions.tickColor = userOptions.lineColor = gridOptions.borderColor;
  }
  if (!axis.grid) {
    axis.grid = new GridAxisAdditions(axis);
  }
  axis.hiddenLabels = [];
  axis.hiddenMarks = [];
}
function onTickAfterGetLabelPosition2(e) {
  const tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed, chart = axis.chart, options2 = axis.options, gridOptions = options2.grid || {}, labelOpts = axis.options.labels, align = labelOpts.align, verticalAlign = "middle", side = GridAxisSide[axis.side], tickmarkOffset = e.tickmarkOffset, tickPositions = axis.tickPositions, tickPos = tick.pos - tickmarkOffset, nextTickPos = isNumber73(tickPositions[e.index + 1]) ? tickPositions[e.index + 1] - tickmarkOffset : (axis.max || 0) + tickmarkOffset, tickSize = axis.tickSize("tick"), tickWidth = tickSize ? tickSize[0] : 0, crispCorr = tickSize ? tickSize[1] / 2 : 0;
  if (gridOptions.enabled === true) {
    let bottom, top, left, right;
    if (side === "top") {
      bottom = axis.top + axis.offset;
      top = bottom - tickWidth;
    } else if (side === "bottom") {
      top = chart.chartHeight - axis.bottom + axis.offset;
      bottom = top + tickWidth;
    } else {
      bottom = axis.top + axis.len - (axis.translate(reversed ? nextTickPos : tickPos) || 0);
      top = axis.top + axis.len - (axis.translate(reversed ? tickPos : nextTickPos) || 0);
    }
    if (side === "right") {
      left = chart.chartWidth - axis.right + axis.offset;
      right = left + tickWidth;
    } else if (side === "left") {
      right = axis.left + axis.offset;
      left = right - tickWidth;
    } else {
      left = Math.round(axis.left + (axis.translate(reversed ? nextTickPos : tickPos) || 0)) - crispCorr;
      right = Math.min(
        // #15742
        Math.round(axis.left + (axis.translate(reversed ? tickPos : nextTickPos) || 0)) - crispCorr,
        axis.left + axis.len
      );
    }
    tick.slotWidth = right - left;
    e.pos.x = align === "left" ? left : align === "right" ? right : left + (right - left) / 2;
    e.pos.y = verticalAlign === "top" ? top : verticalAlign === "bottom" ? bottom : top + (bottom - top) / 2;
    if (label) {
      const lblMetrics = chart.renderer.fontMetrics(label), labelHeight = label.getBBox().height;
      if (!labelOpts.useHTML) {
        const lines = Math.round(labelHeight / lblMetrics.h);
        e.pos.y += // Center the label
        // TODO: why does this actually center the label?
        (lblMetrics.b - (lblMetrics.h - lblMetrics.f)) / 2 + // Adjust for height of additional lines.
        -((lines - 1) * lblMetrics.h / 2);
      } else {
        e.pos.y += // Readjust yCorr in htmlUpdateTransform
        lblMetrics.b + // Adjust for height of html label
        -(labelHeight / 2);
      }
    }
    e.pos.x += axis.horiz && labelOpts.x || 0;
  }
}
function onTickLabelFormat(ctx) {
  const { axis, value } = ctx;
  if (axis.options.grid?.enabled) {
    const tickPos = axis.tickPositions;
    const series = (axis.linkedParent || axis).series[0];
    const isFirst = value === tickPos[0];
    const isLast = value === tickPos[tickPos.length - 1];
    const point = series && find19(series.options.data, function(p) {
      return p[axis.isXAxis ? "x" : "y"] === value;
    });
    let pointCopy;
    if (point && series.is("gantt")) {
      pointCopy = merge106(point);
      Globals_default.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(pointCopy, axis.chart);
    }
    ctx.isFirst = isFirst;
    ctx.isLast = isLast;
    ctx.point = pointCopy;
  }
}
function onTrimTicks() {
  const axis = this, options2 = axis.options, gridOptions = options2.grid || {}, categoryAxis = axis.categories, tickPositions = axis.tickPositions, firstPos = tickPositions[0], secondPos = tickPositions[1], lastPos = tickPositions[tickPositions.length - 1], beforeLastPos = tickPositions[tickPositions.length - 2], linkedMin = axis.linkedParent?.min, linkedMax = axis.linkedParent?.max, min4 = linkedMin || axis.min, max4 = linkedMax || axis.max, tickInterval = axis.tickInterval, startLessThanMin = (
    // #19845
    isNumber73(min4) && min4 >= firstPos + tickInterval && min4 < secondPos
  ), endMoreThanMin = isNumber73(min4) && firstPos < min4 && firstPos + tickInterval > min4, startLessThanMax = isNumber73(max4) && lastPos > max4 && lastPos - tickInterval < max4, endMoreThanMax = isNumber73(max4) && max4 <= lastPos - tickInterval && max4 > beforeLastPos;
  if (gridOptions.enabled === true && !categoryAxis && (axis.isXAxis || axis.isLinked)) {
    if ((endMoreThanMin || startLessThanMin) && !options2.startOnTick) {
      tickPositions[0] = min4;
    }
    if ((startLessThanMax || endMoreThanMax) && !options2.endOnTick) {
      tickPositions[tickPositions.length - 1] = max4;
    }
  }
}
function wrapUnsquish(proceed) {
  const axis = this;
  const { options: { grid: gridOptions = {} } } = axis;
  if (gridOptions.enabled === true && axis.categories) {
    return axis.tickInterval;
  }
  return proceed.apply(axis, argsToArray(arguments));
}
var GridAxisAdditions = class {
  /* *
  *
  *  Constructors
  *
  * */
  constructor(axis) {
    this.axis = axis;
  }
  /* *
  *
  *  Functions
  *
  * */
  /**
   * Checks if an axis is the outer axis in its dimension. Since
   * axes are placed outwards in order, the axis with the highest
   * index is the outermost axis.
   *
   * Example: If there are multiple x-axes at the top of the chart,
   * this function returns true if the axis supplied is the last
   * of the x-axes.
   *
   * @private
   *
   * @return {boolean}
   * True if the axis is the outermost axis in its dimension; false if
   * not.
   */
  isOuterAxis() {
    const axis = this.axis;
    const chart = axis.chart;
    const columnIndex = axis.grid.columnIndex;
    const columns = axis.linkedParent?.grid.columns || axis.grid.columns || [];
    const parentAxis = columnIndex ? axis.linkedParent : axis;
    let thisIndex = -1, lastIndex = 0;
    if (axis.side === 3 && !chart.inverted && columns.length) {
      return !axis.linkedParent;
    }
    (chart[axis.coll] || []).forEach((otherAxis, index) => {
      if (otherAxis.side === axis.side && !otherAxis.options.isInternal) {
        lastIndex = index;
        if (otherAxis === parentAxis) {
          thisIndex = index;
        }
      }
    });
    return lastIndex === thisIndex && (isNumber73(columnIndex) ? columns.length === columnIndex : true);
  }
  /**
   * Add extra border based on the provided path.
   * @private
   * @param {SVGPath} path
   * The path of the border.
   * @return {Highcharts.SVGElement}
   * Border
   */
  renderBorder(path) {
    const axis = this.axis, renderer = axis.chart.renderer, options2 = axis.options, extraBorderLine = renderer.path(path).addClass("highcharts-axis-line").add(axis.axisGroup);
    if (!renderer.styledMode) {
      extraBorderLine.attr({
        stroke: options2.lineColor,
        "stroke-width": options2.lineWidth,
        zIndex: 7
      });
    }
    return extraBorderLine;
  }
};
dateFormats2.E = function(timestamp) {
  return this.dateFormat("%a", timestamp, true).charAt(0);
};
dateFormats2.W = function(timestamp) {
  const d = this.toParts(timestamp), firstDay = (d[7] + 6) % 7, thursday = d.slice(0);
  thursday[2] = d[2] - firstDay + 3;
  const firstThursday = this.toParts(this.makeTime(thursday[0], 0, 1));
  if (firstThursday[7] !== 4) {
    d[1] = 0;
    d[2] = 1 + (11 - firstThursday[7]) % 7;
  }
  const thursdayTS = this.makeTime(thursday[0], thursday[1], thursday[2]), firstThursdayTS = this.makeTime(firstThursday[0], firstThursday[1], firstThursday[2]);
  return (1 + Math.floor((thursdayTS - firstThursdayTS) / 6048e5)).toString();
};
var GridAxis = {
  compose: compose24
};
var GridAxis_default = GridAxis;

// node_modules/highcharts/es-modules/Gantt/Tree.js
var { extend: extend90, isNumber: isNumber74, pick: pick115 } = Utilities_default;
function getListOfParents(data) {
  const root = "", ids = [], listOfParents = data.reduce((prev, curr) => {
    const { parent = "", id } = curr;
    if (typeof prev[parent] === "undefined") {
      prev[parent] = [];
    }
    prev[parent].push(curr);
    if (id) {
      ids.push(id);
    }
    return prev;
  }, {});
  Object.keys(listOfParents).forEach((node) => {
    if (node !== root && ids.indexOf(node) === -1) {
      const adoptedByRoot = listOfParents[node].map(function(orphan) {
        const { ...parentExcluded } = orphan;
        return parentExcluded;
      });
      listOfParents[root].push(...adoptedByRoot);
      delete listOfParents[node];
    }
  });
  return listOfParents;
}
function getNode(id, parent, level, data, mapOfIdToChildren, options2) {
  const after = options2 && options2.after, before = options2 && options2.before, node = {
    data,
    depth: level - 1,
    id,
    level,
    parent: parent || ""
  };
  let descendants = 0, height = 0, start, end;
  if (typeof before === "function") {
    before(node, options2);
  }
  const children = (mapOfIdToChildren[id] || []).map((child) => {
    const node2 = getNode(child.id, id, level + 1, child, mapOfIdToChildren, options2), childStart = child.start || NaN, childEnd = child.milestone === true ? childStart : child.end || NaN;
    start = !isNumber74(start) || childStart < start ? childStart : start;
    end = !isNumber74(end) || childEnd > end ? childEnd : end;
    descendants = descendants + 1 + node2.descendants;
    height = Math.max(node2.height + 1, height);
    return node2;
  });
  if (data) {
    data.start = pick115(data.start, start);
    data.end = pick115(data.end, end);
  }
  extend90(node, {
    children,
    descendants,
    height
  });
  if (typeof after === "function") {
    after(node, options2);
  }
  return node;
}
function getTree(data, options2) {
  return getNode("", null, 1, null, getListOfParents(data), options2);
}
var Tree = {
  getNode,
  getTree
};
var Tree_default = Tree;

// node_modules/highcharts/es-modules/Core/Axis/TreeGrid/TreeGridTick.js
var { addEvent: addEvent93, removeEvent: removeEvent13, isObject: isObject25, isNumber: isNumber75, pick: pick116, wrap: wrap15 } = Utilities_default;
function onTickInit() {
  const tick = this;
  if (!tick.treeGrid) {
    tick.treeGrid = new TreeGridTickAdditions(tick);
  }
}
function onTickHover(label) {
  label.addClass("highcharts-treegrid-node-active");
  if (!label.renderer.styledMode) {
    label.css({
      textDecoration: "underline"
    });
  }
}
function onTickHoverExit(label, options2) {
  const css19 = isObject25(options2.style) ? options2.style : {};
  label.removeClass("highcharts-treegrid-node-active");
  if (!label.renderer.styledMode) {
    label.css({ textDecoration: css19.textDecoration || "none" });
  }
}
function renderLabelIcon(tick, params) {
  const treeGrid = tick.treeGrid, isNew = !treeGrid.labelIcon, renderer = params.renderer, labelBox = params.xy, options2 = params.options, width = options2.width || 0, height = options2.height || 0, padding = options2.padding ?? tick.axis.linkedParent ? 0 : 5, iconCenter = {
    x: labelBox.x - width / 2 - padding,
    y: labelBox.y - height / 2
  }, rotation = params.collapsed ? 90 : 180, shouldRender = params.show && isNumber75(iconCenter.y);
  let icon = treeGrid.labelIcon;
  if (!icon) {
    treeGrid.labelIcon = icon = renderer.path(renderer.symbols[options2.type](options2.x || 0, options2.y || 0, width, height)).addClass("highcharts-label-icon").add(params.group);
  }
  icon[shouldRender ? "show" : "hide"]();
  if (!renderer.styledMode) {
    icon.attr({
      cursor: "pointer",
      "fill": pick116(
        params.color,
        "#666666"
        /* Palette.neutralColor60 */
      ),
      "stroke-width": 1,
      stroke: options2.lineColor,
      strokeWidth: options2.lineWidth || 0
    });
  }
  icon[isNew ? "attr" : "animate"]({
    translateX: iconCenter.x,
    translateY: iconCenter.y,
    rotation
  });
}
function wrapGetLabelPosition(proceed, x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
  const tick = this, lbOptions = pick116(tick.options?.labels, labelOptions), pos = tick.pos, axis = tick.axis, isTreeGrid = axis.type === "treegrid", result = proceed.apply(tick, [x, y, label, horiz, lbOptions, tickmarkOffset, index, step]);
  let mapOfPosToGridNode, node, level;
  if (isTreeGrid) {
    const { width = 0, padding = axis.linkedParent ? 0 : 5 } = lbOptions && isObject25(lbOptions.symbol, true) ? lbOptions.symbol : {}, indentation = lbOptions && isNumber75(lbOptions.indentation) ? lbOptions.indentation : 0;
    mapOfPosToGridNode = axis.treeGrid.mapOfPosToGridNode;
    node = mapOfPosToGridNode?.[pos];
    level = node?.depth || 1;
    result.x += // Add space for symbols
    width + padding * 2 + // Apply indentation
    (level - 1) * indentation;
  }
  return result;
}
function wrapRenderLabel(proceed) {
  const tick = this, { pos, axis, label, treeGrid: tickGrid, options: tickOptions } = tick, icon = tickGrid?.labelIcon, labelElement = label?.element, { treeGrid: axisGrid, options: axisOptions, chart, tickPositions } = axis, mapOfPosToGridNode = axisGrid.mapOfPosToGridNode, labelOptions = pick116(tickOptions?.labels, axisOptions?.labels), symbolOptions = labelOptions && isObject25(labelOptions.symbol, true) ? labelOptions.symbol : {}, node = mapOfPosToGridNode?.[pos], { descendants, depth } = node || {}, hasDescendants = node && descendants && descendants > 0, level = depth, isTreeGridElement = axis.type === "treegrid" && labelElement, shouldRender = tickPositions.indexOf(pos) > -1, prefixClassName = "highcharts-treegrid-node-", prefixLevelClass = prefixClassName + "level-", styledMode = chart.styledMode;
  let collapsed, addClassName, removeClassName;
  if (isTreeGridElement && node) {
    label.removeClass(new RegExp(prefixLevelClass + ".*")).addClass(prefixLevelClass + level);
  }
  proceed.apply(tick, Array.prototype.slice.call(arguments, 1));
  if (isTreeGridElement && hasDescendants) {
    collapsed = axisGrid.isCollapsed(node);
    renderLabelIcon(tick, {
      color: !styledMode && label.styles.color || "",
      collapsed,
      group: label.parentGroup,
      options: symbolOptions,
      renderer: label.renderer,
      show: shouldRender,
      xy: label.xy
    });
    addClassName = prefixClassName + (collapsed ? "collapsed" : "expanded");
    removeClassName = prefixClassName + (collapsed ? "expanded" : "collapsed");
    label.addClass(addClassName).removeClass(removeClassName);
    if (!styledMode) {
      label.css({
        cursor: "pointer"
      });
    }
    [label, icon].forEach((object) => {
      if (object && !object.attachedTreeGridEvents) {
        addEvent93(object.element, "mouseover", function() {
          onTickHover(label);
        });
        addEvent93(object.element, "mouseout", function() {
          onTickHoverExit(label, labelOptions);
        });
        addEvent93(object.element, "click", function() {
          tickGrid.toggleCollapse();
        });
        object.attachedTreeGridEvents = true;
      }
    });
  } else if (icon) {
    removeEvent13(labelElement);
    label?.css({ cursor: "default" });
    icon.destroy();
  }
}
var TreeGridTickAdditions = class {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * @private
   */
  static compose(TickClass) {
    const tickProto = TickClass.prototype;
    if (!tickProto.toggleCollapse) {
      addEvent93(TickClass, "init", onTickInit);
      wrap15(tickProto, "getLabelPosition", wrapGetLabelPosition);
      wrap15(tickProto, "renderLabel", wrapRenderLabel);
      tickProto.collapse = function(redraw) {
        this.treeGrid.collapse(redraw);
      };
      tickProto.expand = function(redraw) {
        this.treeGrid.expand(redraw);
      };
      tickProto.toggleCollapse = function(redraw) {
        this.treeGrid.toggleCollapse(redraw);
      };
    }
  }
  /* *
   *
   *  Constructors
   *
   * */
  /**
   * @private
   */
  constructor(tick) {
    this.tick = tick;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Collapse the grid cell. Used when axis is of type treegrid.
   *
   * @see gantt/treegrid-axis/collapsed-dynamically/demo.js
   *
   * @private
   * @function Highcharts.Tick#collapse
   *
   * @param {boolean} [redraw=true]
   * Whether to redraw the chart or wait for an explicit call to
   * {@link Highcharts.Chart#redraw}
   */
  collapse(redraw) {
    const tick = this.tick, axis = tick.axis, brokenAxis = axis.brokenAxis;
    if (brokenAxis && axis.treeGrid.mapOfPosToGridNode) {
      const pos = tick.pos, node = axis.treeGrid.mapOfPosToGridNode[pos], breaks = axis.treeGrid.collapse(node);
      brokenAxis.setBreaks(breaks, pick116(redraw, true));
    }
  }
  /**
   * Destroy remaining labelIcon if exist.
   *
   * @private
   * @function Highcharts.Tick#destroy
   */
  destroy() {
    if (this.labelIcon) {
      this.labelIcon.destroy();
    }
  }
  /**
   * Expand the grid cell. Used when axis is of type treegrid.
   *
   * @see gantt/treegrid-axis/collapsed-dynamically/demo.js
   *
   * @private
   * @function Highcharts.Tick#expand
   *
   * @param {boolean} [redraw=true]
   * Whether to redraw the chart or wait for an explicit call to
   * {@link Highcharts.Chart#redraw}
   */
  expand(redraw) {
    const { pos, axis } = this.tick, { treeGrid, brokenAxis } = axis, posMappedNodes = treeGrid.mapOfPosToGridNode;
    if (brokenAxis && posMappedNodes) {
      const node = posMappedNodes[pos], breaks = treeGrid.expand(node);
      brokenAxis.setBreaks(breaks, pick116(redraw, true));
    }
  }
  /**
   * Toggle the collapse/expand state of the grid cell. Used when axis is
   * of type treegrid.
   *
   * @see gantt/treegrid-axis/collapsed-dynamically/demo.js
   *
   * @private
   * @function Highcharts.Tick#toggleCollapse
   *
   * @param {boolean} [redraw=true]
   * Whether to redraw the chart or wait for an explicit call to
   * {@link Highcharts.Chart#redraw}
   */
  toggleCollapse(redraw) {
    const tick = this.tick, axis = tick.axis, brokenAxis = axis.brokenAxis;
    if (brokenAxis && axis.treeGrid.mapOfPosToGridNode) {
      const pos = tick.pos, node = axis.treeGrid.mapOfPosToGridNode[pos], breaks = axis.treeGrid.toggleCollapse(node);
      brokenAxis.setBreaks(breaks, pick116(redraw, true));
    }
  }
};
var TreeGridTick_default = TreeGridTickAdditions;

// node_modules/highcharts/es-modules/Core/Axis/TreeGrid/TreeGridAxis.js
var { getLevelOptions: getLevelOptions4 } = TreeUtilities_default;
var { addEvent: addEvent94, isArray: isArray28, splat: splat24, find: find20, fireEvent: fireEvent50, isObject: isObject26, isString: isString22, merge: merge107, pick: pick117, removeEvent: removeEvent14, wrap: wrap16 } = Utilities_default;
var TickConstructor;
function getBreakFromNode(node, max4) {
  const to = node.collapseEnd || 0;
  let from = node.collapseStart || 0;
  if (to >= max4) {
    from -= 0.5;
  }
  return {
    from,
    to,
    showPoints: false
  };
}
function getTreeGridFromData(data, uniqueNames, numberOfSeries) {
  const categories = [], collapsedNodes = [], mapOfIdToNode = {}, uniqueNamesEnabled = uniqueNames || false;
  let mapOfPosToGridNode = {}, posIterator = -1;
  const treeParams = {
    // After the children has been created.
    after: function(node) {
      const gridNode = mapOfPosToGridNode[node.pos];
      let height = 0, descendants = 0;
      gridNode.children.forEach(function(child) {
        descendants += (child.descendants || 0) + 1;
        height = Math.max((child.height || 0) + 1, height);
      });
      gridNode.descendants = descendants;
      gridNode.height = height;
      if (gridNode.collapsed) {
        collapsedNodes.push(gridNode);
      }
    },
    // Before the children has been created.
    before: function(node) {
      const data2 = isObject26(node.data, true) ? node.data : {}, name = isString22(data2.name) ? data2.name : "", parentNode = mapOfIdToNode[node.parent], parentGridNode = isObject26(parentNode, true) ? mapOfPosToGridNode[parentNode.pos] : null, hasSameName = function(x) {
        return x.name === name;
      };
      let gridNode, pos;
      if (uniqueNamesEnabled && isObject26(parentGridNode, true) && !!(gridNode = find20(parentGridNode.children, hasSameName))) {
        pos = gridNode.pos;
        gridNode.nodes.push(node);
      } else {
        pos = posIterator++;
      }
      if (!mapOfPosToGridNode[pos]) {
        mapOfPosToGridNode[pos] = gridNode = {
          depth: parentGridNode ? parentGridNode.depth + 1 : 0,
          name,
          id: data2.id,
          nodes: [node],
          children: [],
          pos
        };
        if (pos !== -1) {
          categories.push(name);
        }
        if (isObject26(parentGridNode, true)) {
          parentGridNode.children.push(gridNode);
        }
      }
      if (isString22(node.id)) {
        mapOfIdToNode[node.id] = node;
      }
      if (gridNode && data2.collapsed === true) {
        gridNode.collapsed = true;
      }
      node.pos = pos;
    }
  };
  const updateYValuesAndTickPos = function(map, numberOfSeries2) {
    const setValues = function(gridNode, start, result) {
      const nodes = gridNode.nodes, padding = 0.5;
      let end = start + (start === -1 ? 0 : numberOfSeries2 - 1);
      const diff = (end - start) / 2, pos = start + diff;
      nodes.forEach(function(node) {
        const data2 = node.data;
        if (isObject26(data2, true)) {
          data2.y = start + (data2.seriesIndex || 0);
          delete data2.seriesIndex;
        }
        node.pos = pos;
      });
      result[pos] = gridNode;
      gridNode.pos = pos;
      gridNode.tickmarkOffset = diff + padding;
      gridNode.collapseStart = end + padding;
      gridNode.children.forEach(function(child) {
        setValues(child, end + 1, result);
        end = (child.collapseEnd || 0) - padding;
      });
      gridNode.collapseEnd = end + padding;
      return result;
    };
    return setValues(map["-1"], -1, {});
  };
  const tree = Tree_default.getTree(data, treeParams);
  mapOfPosToGridNode = updateYValuesAndTickPos(mapOfPosToGridNode, numberOfSeries);
  return {
    categories,
    mapOfIdToNode,
    mapOfPosToGridNode,
    collapsedNodes,
    tree
  };
}
function onBeforeRender(e) {
  const chart = e.target, axes = chart.axes;
  axes.filter((axis) => axis.type === "treegrid").forEach(function(axis) {
    const options2 = axis.options || {}, labelOptions = options2.labels, uniqueNames = axis.uniqueNames, max4 = chart.time.parse(options2.max), isDirty = !axis.treeGrid.mapOfPosToGridNode || axis.series.some(function(series) {
      return !series.hasRendered || series.isDirtyData || series.isDirty;
    });
    let numberOfSeries = 0, data, treeGrid;
    if (isDirty) {
      const seriesHasPrimitivePoints = [];
      data = axis.series.reduce(function(arr, s) {
        const seriesData = s.options.data || [], firstPoint = seriesData[0], foundPrimitivePoint = Array.isArray(firstPoint) && !firstPoint.find((value) => typeof value === "object");
        seriesHasPrimitivePoints.push(foundPrimitivePoint);
        if (s.visible) {
          seriesData.forEach(function(pointOptions) {
            if (foundPrimitivePoint || s.options.keys?.length) {
              pointOptions = s.pointClass.prototype.optionsToObject.call({ series: s }, pointOptions);
              s.pointClass.setGanttPointAliases(pointOptions, chart);
            }
            if (isObject26(pointOptions, true)) {
              pointOptions.seriesIndex = numberOfSeries;
              arr.push(pointOptions);
            }
          });
          if (uniqueNames === true) {
            numberOfSeries++;
          }
        }
        return arr;
      }, []);
      if (max4 && data.length < max4) {
        for (let i = data.length; i <= max4; i++) {
          data.push({
            // Use the zero-width character
            // to avoid conflict with uniqueNames
            name: i + ""
          });
        }
      }
      treeGrid = getTreeGridFromData(data, uniqueNames || false, uniqueNames === true ? numberOfSeries : 1);
      axis.categories = treeGrid.categories;
      axis.treeGrid.mapOfPosToGridNode = treeGrid.mapOfPosToGridNode;
      axis.hasNames = true;
      axis.treeGrid.tree = treeGrid.tree;
      axis.series.forEach(function(series, index) {
        const axisData = (series.options.data || []).map(function(d) {
          if (seriesHasPrimitivePoints[index] || isArray28(d) && series.options.keys && series.options.keys.length) {
            data.forEach(function(point) {
              const toArray = splat24(d);
              if (toArray.indexOf(point.x || 0) >= 0 && toArray.indexOf(point.x2 || 0) >= 0) {
                d = point;
              }
            });
          }
          return isObject26(d, true) ? merge107(d) : d;
        });
        if (series.visible) {
          series.setData(axisData, false);
        }
      });
      axis.treeGrid.mapOptionsToLevel = getLevelOptions4({
        defaults: labelOptions,
        from: 1,
        levels: labelOptions?.levels,
        to: axis.treeGrid.tree?.height
      });
      if (e.type === "beforeRender") {
        axis.treeGrid.collapsedNodes = treeGrid.collapsedNodes;
      }
    }
  });
}
function wrapGenerateTick(proceed, pos) {
  const axis = this, mapOptionsToLevel = axis.treeGrid.mapOptionsToLevel || {}, isTreeGrid = axis.type === "treegrid", ticks = axis.ticks;
  let tick = ticks[pos], levelOptions, options2, gridNode;
  if (isTreeGrid && axis.treeGrid.mapOfPosToGridNode) {
    gridNode = axis.treeGrid.mapOfPosToGridNode[pos];
    levelOptions = mapOptionsToLevel[gridNode.depth];
    if (levelOptions) {
      options2 = {
        labels: levelOptions
      };
    }
    if (!tick && TickConstructor) {
      ticks[pos] = tick = new TickConstructor(axis, pos, void 0, void 0, {
        category: gridNode.name,
        tickmarkOffset: gridNode.tickmarkOffset,
        options: options2
      });
    } else {
      tick.parameters.category = gridNode.name;
      tick.options = options2;
      tick.addLabel();
    }
  } else {
    proceed.apply(axis, Array.prototype.slice.call(arguments, 1));
  }
}
function wrapInit(proceed, chart, userOptions, coll) {
  const axis = this, isTreeGrid = userOptions.type === "treegrid";
  if (!axis.treeGrid) {
    axis.treeGrid = new TreeGridAxisAdditions(axis);
  }
  if (isTreeGrid) {
    addEvent94(chart, "beforeRender", onBeforeRender);
    addEvent94(chart, "beforeRedraw", onBeforeRender);
    addEvent94(chart, "addSeries", function(e) {
      if (e.options.data) {
        const treeGrid = getTreeGridFromData(e.options.data, userOptions.uniqueNames || false, 1);
        axis.treeGrid.collapsedNodes = (axis.treeGrid.collapsedNodes || []).concat(treeGrid.collapsedNodes);
      }
    });
    addEvent94(axis, "foundExtremes", function() {
      if (axis.treeGrid.collapsedNodes) {
        axis.treeGrid.collapsedNodes.forEach(function(node) {
          const breaks = axis.treeGrid.collapse(node);
          if (axis.brokenAxis) {
            axis.brokenAxis.setBreaks(breaks, false);
            if (axis.treeGrid.collapsedNodes) {
              axis.treeGrid.collapsedNodes = axis.treeGrid.collapsedNodes.filter((n) => node.collapseStart !== n.collapseStart || node.collapseEnd !== n.collapseEnd);
            }
          }
        });
      }
    });
    addEvent94(axis, "afterBreaks", function() {
      if (axis.coll === "yAxis" && !axis.staticScale && axis.chart.options.chart.height) {
        axis.isDirty = true;
      }
    });
    userOptions = merge107({
      // Default options
      grid: {
        enabled: true
      },
      // TODO: add support for align in treegrid.
      labels: {
        align: "left",
        /**
        * Set options on specific levels in a tree grid axis. Takes
        * precedence over labels options.
        *
        * @sample {gantt} gantt/treegrid-axis/labels-levels
        *         Levels on TreeGrid Labels
        *
        * @type      {Array<*>}
        * @product   gantt
        * @apioption yAxis.labels.levels
        *
        * @private
        */
        levels: [{
          /**
          * Specify the level which the options within this object
          * applies to.
          *
          * @type      {number}
          * @product   gantt
          * @apioption yAxis.labels.levels.level
          *
          * @private
          */
          level: void 0
        }, {
          level: 1,
          /**
           * @type      {Highcharts.CSSObject}
           * @product   gantt
           * @apioption yAxis.labels.levels.style
           *
           * @private
           */
          style: {
            /** @ignore-option */
            fontWeight: "bold"
          }
        }],
        /**
         * The symbol for the collapse and expand icon in a
         * treegrid.
         *
         * @product      gantt
         * @optionparent yAxis.labels.symbol
         *
         * @private
         */
        symbol: {
          /**
           * The symbol type. Points to a definition function in
           * the `Highcharts.Renderer.symbols` collection.
           *
           * @type {Highcharts.SymbolKeyValue}
           *
           * @private
           */
          type: "triangle",
          x: -5,
          y: -5,
          height: 10,
          width: 10
        }
      },
      uniqueNames: false
    }, userOptions, {
      // Forced options
      reversed: true
    });
  }
  proceed.apply(axis, [chart, userOptions, coll]);
  if (isTreeGrid) {
    axis.hasNames = true;
    axis.options.showLastLabel = true;
  }
}
function wrapSetTickInterval(proceed) {
  const axis = this, options2 = axis.options, time = axis.chart.time, linkedParent = typeof options2.linkedTo === "number" ? this.chart[axis.coll]?.[options2.linkedTo] : void 0, isTreeGrid = axis.type === "treegrid";
  if (isTreeGrid) {
    axis.min = axis.userMin ?? time.parse(options2.min) ?? axis.dataMin;
    axis.max = axis.userMax ?? time.parse(options2.max) ?? axis.dataMax;
    fireEvent50(axis, "foundExtremes");
    axis.setAxisTranslation();
    axis.tickInterval = 1;
    axis.tickmarkOffset = 0.5;
    axis.tickPositions = axis.treeGrid.mapOfPosToGridNode ? axis.treeGrid.getTickPositions() : [];
    if (linkedParent) {
      const linkedParentExtremes = linkedParent.getExtremes();
      axis.min = pick117(linkedParentExtremes.min, linkedParentExtremes.dataMin);
      axis.max = pick117(linkedParentExtremes.max, linkedParentExtremes.dataMax);
      axis.tickPositions = linkedParent.tickPositions;
    }
    axis.linkedParent = linkedParent;
  } else {
    proceed.apply(axis, Array.prototype.slice.call(arguments, 1));
  }
}
function wrapRedraw(proceed) {
  const axis = this, isTreeGrid = this.type === "treegrid";
  if (isTreeGrid && axis.visible) {
    axis.tickPositions.forEach(function(pos) {
      const tick = axis.ticks[pos];
      if (tick.label?.attachedTreeGridEvents) {
        removeEvent14(tick.label.element);
        tick.label.attachedTreeGridEvents = false;
      }
    });
  }
  proceed.apply(axis, Array.prototype.slice.call(arguments, 1));
}
var TreeGridAxisAdditions = class {
  /* *
   *
   *  Static Functions
   *
   * */
  /**
   * @private
   */
  static compose(AxisClass, ChartClass, SeriesClass, TickClass) {
    if (!AxisClass.keepProps.includes("treeGrid")) {
      const axisProps = AxisClass.prototype;
      AxisClass.keepProps.push("treeGrid");
      wrap16(axisProps, "generateTick", wrapGenerateTick);
      wrap16(axisProps, "init", wrapInit);
      wrap16(axisProps, "setTickInterval", wrapSetTickInterval);
      wrap16(axisProps, "redraw", wrapRedraw);
      axisProps.utils = {
        getNode: Tree_default.getNode
      };
      if (!TickConstructor) {
        TickConstructor = TickClass;
      }
    }
    GridAxis_default.compose(AxisClass, ChartClass, TickClass);
    BrokenAxis_default.compose(AxisClass, SeriesClass);
    TreeGridTick_default.compose(TickClass);
    return AxisClass;
  }
  /* *
   *
   *  Constructors
   *
   * */
  /**
   * @private
   */
  constructor(axis) {
    this.axis = axis;
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Set the collapse status.
   *
   * @private
   *
   * @param {Highcharts.Axis} axis
   * The axis to check against.
   *
   * @param {Highcharts.GridNode} node
   * The node to collapse.
   */
  setCollapsedStatus(node) {
    const axis = this.axis, chart = axis.chart;
    axis.series.forEach(function(series) {
      const data = series.options.data;
      if (node.id && data) {
        const point = chart.get(node.id), dataPoint = data[series.data.indexOf(point)];
        if (point && dataPoint) {
          point.collapsed = node.collapsed;
          dataPoint.collapsed = node.collapsed;
        }
      }
    });
  }
  /**
   * Calculates the new axis breaks to collapse a node.
   *
   * @private
   *
   * @param {Highcharts.Axis} axis
   * The axis to check against.
   *
   * @param {Highcharts.GridNode} node
   * The node to collapse.
   *
   * @param {number} pos
   * The tick position to collapse.
   *
   * @return {Array<object>}
   * Returns an array of the new breaks for the axis.
   */
  collapse(node) {
    const axis = this.axis, breaks = axis.options.breaks || [], obj = getBreakFromNode(node, axis.max);
    breaks.push(obj);
    node.collapsed = true;
    axis.treeGrid.setCollapsedStatus(node);
    return breaks;
  }
  /**
   * Calculates the new axis breaks to expand a node.
   *
   * @private
   *
   * @param {Highcharts.Axis} axis
   * The axis to check against.
   *
   * @param {Highcharts.GridNode} node
   * The node to expand.
   *
   * @param {number} pos
   * The tick position to expand.
   *
   * @return {Array<object>}
   * Returns an array of the new breaks for the axis.
   */
  expand(node) {
    const axis = this.axis, breaks = axis.options.breaks || [], obj = getBreakFromNode(node, axis.max);
    node.collapsed = false;
    axis.treeGrid.setCollapsedStatus(node);
    return breaks.reduce(function(arr, b) {
      if (b.to !== obj.to || b.from !== obj.from) {
        arr.push(b);
      }
      return arr;
    }, []);
  }
  /**
   * Creates a list of positions for the ticks on the axis. Filters out
   * positions that are outside min and max, or is inside an axis break.
   *
   * @private
   *
   * @return {Array<number>}
   * List of positions.
   */
  getTickPositions() {
    const axis = this.axis, roundedMin = Math.floor(axis.min / axis.tickInterval) * axis.tickInterval, roundedMax = Math.ceil(axis.max / axis.tickInterval) * axis.tickInterval;
    return Object.keys(axis.treeGrid.mapOfPosToGridNode || {}).reduce(function(arr, key) {
      const pos = +key;
      if (pos >= roundedMin && pos <= roundedMax && !axis.brokenAxis?.isInAnyBreak(pos)) {
        arr.push(pos);
      }
      return arr;
    }, []);
  }
  /**
   * Check if a node is collapsed.
   *
   * @private
   *
   * @param {Highcharts.Axis} axis
   * The axis to check against.
   *
   * @param {Object} node
   * The node to check if is collapsed.
   *
   * @param {number} pos
   * The tick position to collapse.
   *
   * @return {boolean}
   * Returns true if collapsed, false if expanded.
   */
  isCollapsed(node) {
    const axis = this.axis, breaks = axis.options.breaks || [], obj = getBreakFromNode(node, axis.max);
    return breaks.some(function(b) {
      return b.from === obj.from && b.to === obj.to;
    });
  }
  /**
   * Calculates the new axis breaks after toggling the collapse/expand
   * state of a node. If it is collapsed it will be expanded, and if it is
   * expanded it will be collapsed.
   *
   * @private
   *
   * @param {Highcharts.Axis} axis
   * The axis to check against.
   *
   * @param {Highcharts.GridNode} node
   * The node to toggle.
   *
   * @return {Array<object>}
   * Returns an array of the new breaks for the axis.
   */
  toggleCollapse(node) {
    return this.isCollapsed(node) ? this.expand(node) : this.collapse(node);
  }
};
var TreeGridAxis_default = TreeGridAxisAdditions;

// node_modules/highcharts/es-modules/Series/Gantt/GanttSeries.js
var { series: Series10, seriesTypes: { xrange: XRangeSeries2 } } = SeriesRegistry_default;
var { extend: extend91, isNumber: isNumber76, merge: merge108 } = Utilities_default;
var GanttSeries = class extends XRangeSeries2 {
  /* *
   *
   *  Static Functions
   *
   * */
  static compose(AxisClass, ChartClass, SeriesClass, TickClass) {
    XRangeSeries2.compose(AxisClass);
    if (!ChartClass) {
      return;
    }
    StaticScale_default.compose(AxisClass, ChartClass);
    if (!SeriesClass) {
      return;
    }
    Pathfinder_default.compose(ChartClass, SeriesClass.prototype.pointClass);
    if (!TickClass) {
      return;
    }
    TreeGridAxis_default.compose(AxisClass, ChartClass, SeriesClass, TickClass);
  }
  /* *
   *
   *  Functions
   *
   * */
  /**
   * Draws a single point in the series.
   *
   * This override draws the point as a diamond if point.options.milestone
   * is true, and uses the original drawPoint() if it is false or not set.
   *
   * @requires highcharts-gantt
   *
   * @private
   * @function Highcharts.seriesTypes.gantt#drawPoint
   *
   * @param {Highcharts.Point} point
   *        An instance of Point in the series
   *
   * @param {"animate"|"attr"} verb
   *        'animate' (animates changes) or 'attr' (sets options)
   */
  drawPoint(point, verb) {
    const series = this, seriesOpts = series.options, renderer = series.chart.renderer, shapeArgs = point.shapeArgs, plotY = point.plotY, state = point.selected && "select", cutOff = seriesOpts.stacking && !seriesOpts.borderRadius;
    let graphic = point.graphic, diamondShape;
    if (point.options.milestone) {
      if (isNumber76(plotY) && point.y !== null && point.visible !== false) {
        diamondShape = renderer.symbols.diamond(shapeArgs.x || 0, shapeArgs.y || 0, shapeArgs.width || 0, shapeArgs.height || 0);
        if (graphic) {
          graphic[verb]({
            d: diamondShape
          });
        } else {
          point.graphic = graphic = renderer.path(diamondShape).addClass(point.getClassName(), true).add(point.group || series.group);
        }
        if (!series.chart.styledMode) {
          point.graphic.attr(series.pointAttribs(point, state)).shadow(seriesOpts.shadow, null, cutOff);
        }
      } else if (graphic) {
        point.graphic = graphic.destroy();
      }
    } else {
      super.drawPoint(point, verb);
    }
  }
  /**
   * Handle milestones, as they have no x2.
   * @private
   */
  translatePoint(point) {
    let shapeArgs, size;
    super.translatePoint(point);
    if (point.options.milestone) {
      shapeArgs = point.shapeArgs;
      size = shapeArgs.height || 0;
      point.shapeArgs = {
        x: (shapeArgs.x || 0) - size / 2,
        y: shapeArgs.y,
        width: size,
        height: size
      };
    }
  }
};
GanttSeries.defaultOptions = merge108(XRangeSeries2.defaultOptions, GanttSeriesDefaults_default);
extend91(GanttSeries.prototype, {
  pointArrayMap: ["start", "end", "y"],
  pointClass: GanttPoint_default,
  setData: Series10.prototype.setData
});
SeriesRegistry_default.registerSeriesType("gantt", GanttSeries);
var GanttSeries_default = GanttSeries;

// node_modules/highcharts/es-modules/masters/modules/gantt.src.js
var G20 = Globals_default;
G20.Connection = G20.Connection || Connection_default;
G20.GanttChart = G20.GanttChart || GanttChart_default;
G20.Navigator = G20.Navigator || Navigator_default;
G20.RangeSelector = G20.RangeSelector || RangeSelector_default;
G20.Scrollbar = G20.Scrollbar || Scrollbar_default;
G20.ganttChart = G20.GanttChart.ganttChart;
ArrowSymbols_default.compose(G20.SVGRenderer);
CurrentDateIndication_default.compose(G20.Axis, G20.PlotLineOrBand);
GanttSeries_default.compose(G20.Axis, G20.Chart, G20.Series, G20.Tick);
G20.Navigator.compose(G20.Chart, G20.Axis, G20.Series);
G20.RangeSelector.compose(G20.Axis, G20.Chart);
G20.Scrollbar.compose(G20.Axis);

// node_modules/highcharts/es-modules/Extensions/DraggablePoints/DragDropUtilities.js
var { addEvent: addEvent95 } = Utilities_default;
function addEvents(el, types, fn, options2) {
  const removeFuncs = types.map((type) => addEvent95(el, type, fn, options2));
  return function() {
    for (const fn2 of removeFuncs) {
      fn2();
    }
  };
}
function countProps(obj) {
  return Object.keys(obj).length;
}
function getFirstProp(obj) {
  for (const p in obj) {
    if (Object.hasOwnProperty.call(obj, p)) {
      return obj[p];
    }
  }
}
function getNormalizedEvent(e, chart) {
  return typeof e.chartX === "undefined" || typeof e.chartY === "undefined" ? chart.pointer?.normalize(e) || e : e;
}
var DragDropUtilities = {
  addEvents,
  countProps,
  getFirstProp,
  getNormalizedEvent
};
var DragDropUtilities_default = DragDropUtilities;

// node_modules/highcharts/es-modules/Extensions/DraggablePoints/DragDropDefaults.js
var DragDropDefaults = {
  /**
   * Set the minimum X value the points can be moved to.
   *
   * @sample {gantt} gantt/dragdrop/drag-gantt
   *         Limit dragging
   * @sample {highcharts} highcharts/dragdrop/drag-xrange
   *         Limit dragging
   *
   * @type      {number|string}
   * @since     6.2.0
   * @apioption plotOptions.series.dragDrop.dragMinX
   */
  /**
   * Set the maximum X value the points can be moved to.
   *
   * @sample {gantt} gantt/dragdrop/drag-gantt
   *         Limit dragging
   * @sample {highcharts} highcharts/dragdrop/drag-xrange
   *         Limit dragging
   *
   * @type      {number|string}
   * @since     6.2.0
   * @apioption plotOptions.series.dragDrop.dragMaxX
   */
  /**
   * Set the minimum Y value the points can be moved to.
   *
   * @sample {gantt} gantt/dragdrop/drag-gantt
   *         Limit dragging
   * @sample {highcharts} highcharts/dragdrop/drag-xrange
   *         Limit dragging
   *
   * @type      {number}
   * @since     6.2.0
   * @apioption plotOptions.series.dragDrop.dragMinY
   */
  /**
   * Set the maximum Y value the points can be moved to.
   *
   * @sample {gantt} gantt/dragdrop/drag-gantt
   *         Limit dragging
   * @sample {highcharts} highcharts/dragdrop/drag-xrange
   *         Limit dragging
   *
   * @type      {number}
   * @since     6.2.0
   * @apioption plotOptions.series.dragDrop.dragMaxY
   */
  /**
   * The X precision value to drag to for this series. Set to 0 to disable. By
   * default this is disabled, except for category axes, where the default is
   * `1`.
   *
   * @type      {number}
   * @default   0
   * @since     6.2.0
   * @apioption plotOptions.series.dragDrop.dragPrecisionX
   */
  /**
   * The Y precision value to drag to for this series. Set to 0 to disable. By
   * default this is disabled, except for category axes, where the default is
   * `1`.
   *
   * @type      {number}
   * @default   0
   * @since     6.2.0
   * @apioption plotOptions.series.dragDrop.dragPrecisionY
   */
  /**
   * Enable dragging in the X dimension.
   *
   * @type      {boolean}
   * @since     6.2.0
   * @apioption plotOptions.series.dragDrop.draggableX
   */
  /**
   * Enable dragging in the Y dimension. Note that this is not supported for
   * TreeGrid axes (the default axis type in Gantt charts).
   *
   * @type      {boolean}
   * @since     6.2.0
   * @apioption plotOptions.series.dragDrop.draggableY
   */
  /**
   * Group the points by a property. Points with the same property value will
   * be grouped together when moving.
   *
   * @sample {gantt} gantt/dragdrop/drag-gantt
   *         Drag grouped points
   * @sample {highcharts} highcharts/dragdrop/drag-xrange
   *         Drag grouped points
   *
   * @type      {string}
   * @since     6.2.0
   * @apioption plotOptions.series.dragDrop.groupBy
   */
  /**
   * Update points as they are dragged. If false, a guide box is drawn to
   * illustrate the new point size.
   *
   * @sample {gantt} gantt/dragdrop/drag-gantt
   *         liveRedraw disabled
   * @sample {highcharts} highcharts/dragdrop/drag-xrange
   *         liveRedraw disabled
   *
   * @type      {boolean}
   * @default   true
   * @since     6.2.0
   * @apioption plotOptions.series.dragDrop.liveRedraw
   */
  /**
   * Set a key to hold when dragging to zoom the chart. This is useful to
   * avoid zooming while moving points. Should be set different than
   * [chart.panKey](#chart.panKey).
   *
   * @type       {string}
   * @since      6.2.0
   * @validvalue ["alt", "ctrl", "meta", "shift"]
   * @deprecated
   * @requires  modules/draggable-points
   * @apioption  chart.zoomKey
   */
  /**
   * Callback that fires when starting to drag a point. The mouse event object
   * is passed in as an argument. If a drag handle is used, `e.updateProp` is
   * set to the data property being dragged. The `this` context is the point.
   * See [drag and drop options](plotOptions.series.dragDrop).
   *
   * @sample {highcharts} highcharts/dragdrop/drag-xrange
   *         Drag events
   *
   * @type      {Highcharts.PointDragStartCallbackFunction}
   * @since     6.2.0
   * @requires  modules/draggable-points
   * @apioption plotOptions.series.point.events.dragStart
   */
  /**
   * Callback that fires while dragging a point. The mouse event is passed in
   * as parameter. The original data can be accessed from `e.origin`, and the
   * new point values can be accessed from `e.newPoints`. If there is only a
   * single point being updated, it can be accessed from `e.newPoint` for
   * simplicity, and its ID can be accessed from `e.newPointId`. The `this`
   * context is the point being dragged. To stop the default drag action,
   * return false. See [drag and drop options](plotOptions.series.dragDrop).
   *
   * @sample {highcharts} highcharts/dragdrop/drag-xrange
   *         Drag events
   * @sample {highcharts|highstock} highcharts/dragdrop/undraggable-points
   *         Dragging disabled for specific points
   *
   * @type      {Highcharts.PointDragCallbackFunction}
   * @since     6.2.0
   * @requires  modules/draggable-points
   * @apioption plotOptions.series.point.events.drag
   */
  /**
   * Callback that fires when the point is dropped. The parameters passed are
   * the same as for [drag](#plotOptions.series.point.events.drag). To stop
   * the default drop action, return false. See
   * [drag and drop options](plotOptions.series.dragDrop).
   *
   * @sample {highcharts} highcharts/dragdrop/drag-xrange
   *         Drag events
   * @sample {highcharts|highstock} highcharts/dragdrop/undraggable-points
   *         Dragging disabled for specific points
   *
   * @type      {Highcharts.PointDropCallbackFunction}
   * @since     6.2.0
   * @requires  modules/draggable-points
   * @apioption plotOptions.series.point.events.drop
   */
  /**
   * Point specific options for the draggable-points module. Overrides options
   * on `series.dragDrop`.
   *
   * @declare   Highcharts.SeriesLineDataDragDropOptions
   * @extends   plotOptions.series.dragDrop
   * @since     6.2.0
   * @requires  modules/draggable-points
   * @apioption series.line.data.dragDrop
   */
  /**
   * The amount of pixels to drag the pointer before it counts as a drag
   * operation. This prevents drag/drop to fire when just clicking or
   * selecting points.
   *
   * @type      {number}
   * @default   2
   * @since     6.2.0
   */
  dragSensitivity: 2,
  /**
   * Options for the drag handles available in column series.
   *
   * @declare      Highcharts.DragDropHandleOptionsObject
   * @since        6.2.0
   * @optionparent plotOptions.column.dragDrop.dragHandle
   */
  dragHandle: {
    /**
     * Function to define the SVG path to use for the drag handles. Takes
     * the point as argument. Should return an SVG path in array format. The
     * SVG path is automatically positioned on the point.
     *
     * @type      {Function}
     * @since     6.2.0
     * @apioption plotOptions.column.dragDrop.dragHandle.pathFormatter
     */
    // pathFormatter: null,
    /**
     * The mouse cursor to use for the drag handles. By default this is
     * intelligently switching between `ew-resize` and `ns-resize` depending on
     * the direction the point is being dragged.
     *
     * @type      {string}
     * @since     6.2.0
     * @apioption plotOptions.column.dragDrop.dragHandle.cursor
     */
    // cursor: null,
    /**
     * The class name of the drag handles. Defaults to `highcharts-drag-handle`.
     *
     * @since 6.2.0
     */
    className: "highcharts-drag-handle",
    /**
     * The fill color of the drag handles.
     *
     * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @since 6.2.0
     */
    color: "#fff",
    /**
     * The line color of the drag handles.
     *
     * @type  {Highcharts.ColorString}
     * @since 6.2.0
     */
    lineColor: "rgba(0, 0, 0, 0.6)",
    /**
     * The line width for the drag handles.
     *
     * @since 6.2.0
     */
    lineWidth: 1,
    /**
     * The z index for the drag handles.
     *
     * @since 6.2.0
     */
    zIndex: 901
  },
  /**
   * Style options for the guide box. The guide box has one state by default,
   * the `default` state.
   *
   * @declare Highcharts.PlotOptionsSeriesDragDropGuideBoxOptions
   * @since 6.2.0
   * @type  {Highcharts.Dictionary<Highcharts.DragDropGuideBoxOptionsObject>}
   */
  guideBox: {
    /**
     * Style options for the guide box default state.
     *
     * @declare Highcharts.DragDropGuideBoxOptionsObject
     * @since   6.2.0
     */
    "default": {
      /**
       * CSS class name of the guide box in this state. Defaults to
       * `highcharts-drag-box-default`.
       *
       * @since 6.2.0
       */
      className: "highcharts-drag-box-default",
      /**
       * Width of the line around the guide box.
       *
       * @since 6.2.0
       */
      lineWidth: 1,
      /**
       * Color of the border around the guide box.
       *
       * @type  {Highcharts.ColorString}
       * @since 6.2.0
       */
      lineColor: "#888",
      /**
       * Guide box fill color.
       *
       * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since 6.2.0
       */
      color: "rgba(0, 0, 0, 0.1)",
      /**
       * Guide box cursor.
       *
       * @since 6.2.0
       */
      cursor: "move",
      /**
       * Guide box zIndex.
       *
       * @since 6.2.0
       */
      zIndex: 900
    }
  }
};
var DragDropDefaults_default = DragDropDefaults;

// node_modules/highcharts/es-modules/Extensions/DraggablePoints/DraggableChart.js
var { animObject: animObject17 } = AnimationUtilities_default;
var { addEvents: addEvents2, countProps: countProps2, getFirstProp: getFirstProp2, getNormalizedEvent: getNormalizedEvent2 } = DragDropUtilities_default;
var { doc: doc29 } = Globals_default;
var { addEvent: addEvent96, isArray: isArray29, merge: merge109, pick: pick118 } = Utilities_default;
function addDragDropEvents(chart) {
  const container = chart.container;
  if (isChartDraggable(chart)) {
    addEvents2(container, ["mousedown", "touchstart"], (e) => {
      mouseDown(getNormalizedEvent2(e, chart), chart);
    });
    addEvents2(container, ["mousemove", "touchmove"], (e) => {
      mouseMove(getNormalizedEvent2(e, chart), chart);
    }, {
      passive: false
    });
    addEvent96(container, "mouseleave", (e) => {
      mouseUp(getNormalizedEvent2(e, chart), chart);
    });
    chart.unbindDragDropMouseUp = addEvents2(doc29, ["mouseup", "touchend"], (e) => {
      mouseUp(getNormalizedEvent2(e, chart), chart);
    }, {
      passive: false
    });
    chart.hasAddedDragDropEvents = true;
    addEvent96(chart, "destroy", () => {
      if (chart.unbindDragDropMouseUp) {
        chart.unbindDragDropMouseUp();
      }
    });
  }
}
function chartHideDragHandles() {
  const chart = this, dragHandles = chart.dragHandles || {};
  if (dragHandles) {
    for (const key of Object.keys(dragHandles)) {
      if (dragHandles[key].destroy) {
        dragHandles[key].destroy();
      }
    }
    delete chart.dragHandles;
  }
}
function chartSetGuideBoxState(state, options2) {
  const guideBox = this.dragGuideBox, guideBoxOptions = merge109(DragDropDefaults_default.guideBox, options2), stateOptions = merge109(
    guideBoxOptions["default"],
    // eslint-disable-line dot-notation
    guideBoxOptions[state]
  );
  return guideBox.attr({
    "class": stateOptions.className,
    stroke: stateOptions.lineColor,
    strokeWidth: stateOptions.lineWidth,
    fill: stateOptions.color,
    cursor: stateOptions.cursor,
    zIndex: stateOptions.zIndex
  }).css({ pointerEvents: "none" });
}
function chartZoomOrPanKeyPressed(e) {
  const chart = this, chartOptions = chart.options.chart || {}, panKey = chartOptions.panKey && chartOptions.panKey + "Key", zoomKey = chart.zooming.key && chart.zooming.key + "Key";
  return e[zoomKey] || e[panKey];
}
function compose25(ChartClass) {
  const chartProto = ChartClass.prototype;
  if (!chartProto.hideDragHandles) {
    chartProto.hideDragHandles = chartHideDragHandles;
    chartProto.setGuideBoxState = chartSetGuideBoxState;
    chartProto.zoomOrPanKeyPressed = chartZoomOrPanKeyPressed;
    addEvent96(ChartClass, "render", onChartRender6);
  }
}
function dragMove(e, point) {
  const series = point.series, chart = series.chart, data = chart.dragDropData, options2 = merge109(series.options.dragDrop, point.options.dragDrop), draggableX = options2.draggableX, draggableY = options2.draggableY, origin = data.origin, updateProp = data.updateProp;
  let dX = e.chartX - origin.chartX, dY = e.chartY - origin.chartY;
  const oldDx = dX;
  if (chart.inverted) {
    dX = -dY;
    dY = -oldDx;
  }
  if (pick118(options2.liveRedraw, true)) {
    updatePoints(chart, false);
    point.showDragHandles();
  } else {
    if (updateProp) {
      resizeGuideBox(point, dX, dY);
    } else {
      chart.dragGuideBox.translate(draggableX ? dX : 0, draggableY ? dY : 0);
    }
  }
  origin.prevdX = dX;
  origin.prevdY = dY;
}
function flipResizeSide(side) {
  return {
    left: "right",
    right: "left",
    top: "bottom",
    bottom: "top"
  }[side];
}
function getGroupedPoints(point) {
  const series = point.series, data = series.options.data || [], groupKey = series.options.dragDrop.groupBy;
  let points = [];
  if (series.boosted && isArray29(data)) {
    for (let i = 0, iEnd = data.length; i < iEnd; ++i) {
      points.push(new series.pointClass(
        // eslint-disable-line new-cap
        series,
        data[i]
      ));
      points[points.length - 1].index = i;
    }
  } else {
    points = series.points;
  }
  return point.options[groupKey] ? (
    // If we have a grouping option, filter the points by that
    points.filter((comparePoint) => comparePoint.options[groupKey] === point.options[groupKey])
  ) : (
    // Otherwise return the point by itself only
    [point]
  );
}
function getNewPoints(dragDropData, newPos) {
  const point = dragDropData.point, series = point.series, chart = series.chart, options2 = merge109(series.options.dragDrop, point.options.dragDrop), updateProps = {}, resizeProp = dragDropData.updateProp, hashmap = {}, dragDropProps = point.series.dragDropProps;
  for (const key in dragDropProps) {
    const val = dragDropProps[key];
    if (resizeProp && (resizeProp !== key || !val.resize || val.optionName && options2[val.optionName] === false)) {
      continue;
    }
    if (resizeProp || val.move && (val.axis === "x" && options2.draggableX || val.axis === "y" && options2.draggableY)) {
      if (chart.mapView) {
        updateProps[key === "x" ? "lon" : "lat"] = val;
      } else {
        updateProps[key] = val;
      }
    }
  }
  for (
    const p of
    // If resizing).forEach(only update the point we are resizing
    resizeProp ? [point] : dragDropData.groupedPoints
  ) {
    hashmap[p.id] = {
      point: p,
      newValues: p.getDropValues(dragDropData.origin, newPos, updateProps)
    };
  }
  return hashmap;
}
function getPositionSnapshot(e, points, guideBox) {
  const res = {
    chartX: e.chartX,
    chartY: e.chartY,
    guideBox: guideBox && {
      x: guideBox.attr("x"),
      y: guideBox.attr("y"),
      width: guideBox.attr("width"),
      height: guideBox.attr("height")
    },
    points: {}
  };
  for (const point of points) {
    const dragDropProps = point.series.dragDropProps || {}, pointProps = {};
    for (const key of Object.keys(dragDropProps)) {
      const val = dragDropProps[key], axis = point.series[val.axis + "Axis"];
      pointProps[key] = point[key];
      if (point.series.chart.mapView && point.plotX && point.plotY) {
        pointProps[key + "Offset"] = key === "x" ? point.plotX : point.plotY;
      } else {
        pointProps[key + "Offset"] = // E.g. yAxis.toPixels(point.high), xAxis.toPixels
        // (point.end)
        axis.toPixels(point[key]) - (axis.horiz ? e.chartX : e.chartY);
      }
    }
    pointProps.point = point;
    res.points[point.id] = pointProps;
  }
  return res;
}
function hasDraggedPastSensitivity(e, chart, sensitivity) {
  const orig = chart.dragDropData.origin, oldX = orig.chartX, oldY = orig.chartY, newX = e.chartX, newY = e.chartY, distance = Math.sqrt((newX - oldX) * (newX - oldX) + (newY - oldY) * (newY - oldY));
  return distance > sensitivity;
}
function initDragDrop(e, point) {
  const groupedPoints = getGroupedPoints(point), series = point.series, chart = series.chart;
  let guideBox;
  if (!pick118(series.options.dragDrop && series.options.dragDrop.liveRedraw, true)) {
    chart.dragGuideBox = guideBox = series.getGuideBox(groupedPoints);
    chart.setGuideBoxState("default", series.options.dragDrop.guideBox).add(series.group);
  }
  chart.dragDropData = {
    origin: getPositionSnapshot(e, groupedPoints, guideBox),
    point,
    groupedPoints,
    isDragging: true
  };
}
function isChartDraggable(chart) {
  let i = chart.series ? chart.series.length : 0;
  if (chart.hasCartesianSeries && !chart.polar || chart.mapView) {
    while (i--) {
      if (chart.series[i].options.dragDrop && isSeriesDraggable(chart.series[i])) {
        return true;
      }
    }
  }
  return false;
}
function isPointMovable(point) {
  const series = point.series, chart = series.chart, seriesDragDropOptions = series.options.dragDrop || {}, pointDragDropOptions = point.options && point.options.dragDrop, updateProps = series.dragDropProps;
  let p, hasMovableX, hasMovableY;
  for (const key in updateProps) {
    p = updateProps[key];
    if (p.axis === "x" && p.move) {
      hasMovableX = true;
    } else if (p.axis === "y" && p.move) {
      hasMovableY = true;
    }
  }
  return (seriesDragDropOptions.draggableX && hasMovableX || seriesDragDropOptions.draggableY && hasMovableY) && !(pointDragDropOptions && pointDragDropOptions.draggableX === false && pointDragDropOptions.draggableY === false) && (!!(series.yAxis && series.xAxis) || chart.mapView);
}
function isSeriesDraggable(series) {
  const props = ["draggableX", "draggableY"], dragDropProps = series.dragDropProps || {};
  let val;
  for (const key of Object.keys(dragDropProps)) {
    val = dragDropProps[key];
    if (val.optionName) {
      props.push(val.optionName);
    }
  }
  let i = props.length;
  while (i--) {
    if (series.options.dragDrop[props[i]]) {
      return true;
    }
  }
}
function mouseDown(e, chart) {
  const dragPoint = chart.hoverPoint, dragDropOptions = merge109(dragPoint && dragPoint.series.options.dragDrop, dragPoint && dragPoint.options.dragDrop), draggableX = dragDropOptions.draggableX || false, draggableY = dragDropOptions.draggableY || false;
  chart.cancelClick = false;
  if (
    // Option is disabled for the point
    !(draggableX || draggableY) || // Zoom/pan key is pressed
    chart.zoomOrPanKeyPressed(e) || // Dragging an annotation
    chart.hasDraggedAnnotation
  ) {
    return;
  }
  if (chart.dragDropData && chart.dragDropData.isDragging) {
    mouseUp(e, chart);
    return;
  }
  if (dragPoint && isPointMovable(dragPoint)) {
    chart.mouseIsDown = false;
    initDragDrop(e, dragPoint);
    dragPoint.firePointEvent("dragStart", e);
  }
}
function mouseMove(e, chart) {
  if (chart.zoomOrPanKeyPressed(e)) {
    return;
  }
  const dragDropData = chart.dragDropData;
  let point, seriesDragDropOpts, newPoints, numNewPoints = 0, newPoint;
  if (dragDropData && dragDropData.isDragging && dragDropData.point.series) {
    point = dragDropData.point;
    seriesDragDropOpts = point.series.options.dragDrop;
    e.preventDefault();
    if (!dragDropData.draggedPastSensitivity) {
      dragDropData.draggedPastSensitivity = hasDraggedPastSensitivity(e, chart, pick118(point.options.dragDrop && point.options.dragDrop.dragSensitivity, seriesDragDropOpts && seriesDragDropOpts.dragSensitivity, DragDropDefaults_default.dragSensitivity));
    }
    if (dragDropData.draggedPastSensitivity) {
      dragDropData.newPoints = getNewPoints(dragDropData, e);
      newPoints = dragDropData.newPoints;
      numNewPoints = countProps2(newPoints);
      newPoint = numNewPoints === 1 ? getFirstProp2(newPoints) : null;
      point.firePointEvent("drag", {
        origin: dragDropData.origin,
        newPoints: dragDropData.newPoints,
        newPoint: newPoint && newPoint.newValues,
        newPointId: newPoint && newPoint.point.id,
        numNewPoints,
        chartX: e.chartX,
        chartY: e.chartY
      }, function() {
        dragMove(e, point);
      });
    }
  }
}
function mouseUp(e, chart) {
  const dragDropData = chart.dragDropData;
  if (dragDropData && dragDropData.isDragging && dragDropData.draggedPastSensitivity && dragDropData.point.series) {
    const point = dragDropData.point, newPoints = dragDropData.newPoints, numNewPoints = countProps2(newPoints), newPoint = numNewPoints === 1 ? getFirstProp2(newPoints) : null;
    if (chart.dragHandles) {
      chart.hideDragHandles();
    }
    e.preventDefault();
    chart.cancelClick = true;
    point.firePointEvent("drop", {
      origin: dragDropData.origin,
      chartX: e.chartX,
      chartY: e.chartY,
      newPoints,
      numNewPoints,
      newPoint: newPoint && newPoint.newValues,
      newPointId: newPoint && newPoint.point.id
    }, function() {
      updatePoints(chart);
    });
  }
  delete chart.dragDropData;
  if (chart.dragGuideBox) {
    chart.dragGuideBox.destroy();
    delete chart.dragGuideBox;
  }
}
function onChartRender6() {
  if (!this.hasAddedDragDropEvents) {
    addDragDropEvents(this);
  }
}
function resizeGuideBox(point, dX, dY) {
  const series = point.series, chart = series.chart, dragDropData = chart.dragDropData, resizeProp = series.dragDropProps[dragDropData.updateProp], newPoint = dragDropData.newPoints[point.id].newValues, resizeSide = typeof resizeProp.resizeSide === "function" ? resizeProp.resizeSide(newPoint, point) : resizeProp.resizeSide;
  if (resizeProp.beforeResize) {
    resizeProp.beforeResize(chart.dragGuideBox, newPoint, point);
  }
  resizeRect(chart.dragGuideBox, resizeProp.axis === "x" && series.xAxis.reversed || resizeProp.axis === "y" && series.yAxis.reversed ? flipResizeSide(resizeSide) : resizeSide, {
    x: resizeProp.axis === "x" ? dX - (dragDropData.origin.prevdX || 0) : 0,
    y: resizeProp.axis === "y" ? dY - (dragDropData.origin.prevdY || 0) : 0
  });
}
function resizeRect(rect2, updateSide, update) {
  let resizeAttrs;
  switch (updateSide) {
    case "left":
      resizeAttrs = {
        x: rect2.attr("x") + update.x,
        width: Math.max(1, rect2.attr("width") - update.x)
      };
      break;
    case "right":
      resizeAttrs = {
        width: Math.max(1, rect2.attr("width") + update.x)
      };
      break;
    case "top":
      resizeAttrs = {
        y: rect2.attr("y") + update.y,
        height: Math.max(1, rect2.attr("height") - update.y)
      };
      break;
    case "bottom":
      resizeAttrs = {
        height: Math.max(1, rect2.attr("height") + update.y)
      };
      break;
    default:
  }
  rect2.attr(resizeAttrs);
}
function updatePoints(chart, animation) {
  const newPoints = chart.dragDropData.newPoints, animOptions = animObject17(animation);
  chart.isDragDropAnimating = true;
  let newPoint;
  for (const key of Object.keys(newPoints)) {
    newPoint = newPoints[key];
    newPoint.point.update(newPoint.newValues, false);
  }
  chart.redraw(animOptions);
  setTimeout(() => {
    delete chart.isDragDropAnimating;
    if (chart.hoverPoint && !chart.dragHandles) {
      chart.hoverPoint.showDragHandles();
    }
  }, animOptions.duration);
}
var DraggableChart = {
  compose: compose25,
  flipResizeSide,
  initDragDrop
};
var DraggableChart_default = DraggableChart;

// node_modules/highcharts/es-modules/Extensions/DraggablePoints/DragDropProps.js
var { flipResizeSide: flipResizeSide2 } = DraggableChart_default;
var { isNumber: isNumber77, merge: merge110, pick: pick119 } = Utilities_default;
var line = {
  x: {
    axis: "x",
    move: true
  },
  y: {
    axis: "y",
    move: true
  }
};
var flags = line;
var column = {
  x: {
    axis: "x",
    move: true
  },
  y: {
    axis: "y",
    move: false,
    resize: true,
    // Force guideBox start coordinates
    beforeResize: (guideBox, pointVals, point) => {
      const plotThreshold = pick119(
        point.yBottom,
        // Added support for stacked series. (#18741)
        point.series.translatedThreshold
      ), plotY = guideBox.attr("y"), threshold = isNumber77(point.stackY) ? point.stackY - (point.y || 0) : point.series.options.threshold || 0, y = threshold + pointVals.y;
      let height, diff;
      if (point.series.yAxis.reversed ? y < threshold : y >= threshold) {
        height = guideBox.attr("height");
        diff = plotThreshold ? plotThreshold - plotY - height : 0;
        guideBox.attr({
          height: Math.max(0, Math.round(height + diff))
        });
      } else {
        guideBox.attr({
          y: Math.round(plotY + (plotThreshold ? plotThreshold - plotY : 0))
        });
      }
    },
    // Flip the side of the resize handle if column is below threshold.
    // Make sure we remove the handle on the other side.
    resizeSide: (pointVals, point) => {
      const chart = point.series.chart, dragHandles = chart.dragHandles, side = pointVals.y >= (point.series.options.threshold || 0) ? "top" : "bottom", flipSide = flipResizeSide2(side);
      if (dragHandles && dragHandles[flipSide]) {
        dragHandles[flipSide].destroy();
        delete dragHandles[flipSide];
      }
      return side;
    },
    // Position handle at bottom if column is below threshold
    handlePositioner: (point) => {
      const bBox = point.shapeArgs || point.graphic && point.graphic.getBBox() || {}, reversed = point.series.yAxis.reversed, threshold = point.series.options.threshold || 0, y = point.y || 0, bottom = !reversed && y >= threshold || reversed && y < threshold;
      return {
        x: bBox.x || 0,
        y: bottom ? bBox.y || 0 : (bBox.y || 0) + (bBox.height || 0)
      };
    },
    // Horizontal handle
    handleFormatter: (point) => {
      const shapeArgs = point.shapeArgs || {}, radius = shapeArgs.r || 0, width = shapeArgs.width || 0, centerX = width / 2;
      return [
        // Left wick
        ["M", radius, 0],
        ["L", centerX - 5, 0],
        // Circle
        ["A", 1, 1, 0, 0, 0, centerX + 5, 0],
        ["A", 1, 1, 0, 0, 0, centerX - 5, 0],
        // Right wick
        ["M", centerX + 5, 0],
        ["L", width - radius, 0]
      ];
    }
  }
};
var boxplot = {
  x: column.x,
  /**
   * Allow low value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.boxplot.dragDrop.draggableLow
   */
  low: {
    optionName: "draggableLow",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: "bottom",
    handlePositioner: (point) => ({
      x: point.shapeArgs.x || 0,
      y: point.lowPlot
    }),
    handleFormatter: column.y.handleFormatter,
    propValidate: (val, point) => val <= point.q1
  },
  /**
   * Allow Q1 value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.boxplot.dragDrop.draggableQ1
   */
  q1: {
    optionName: "draggableQ1",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: "bottom",
    handlePositioner: (point) => ({
      x: point.shapeArgs.x || 0,
      y: point.q1Plot
    }),
    handleFormatter: column.y.handleFormatter,
    propValidate: (val, point) => val <= point.median && val >= point.low
  },
  median: {
    // Median cannot be dragged individually, just move the whole
    // point for this.
    axis: "y",
    move: true
  },
  /**
   * Allow Q3 value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.boxplot.dragDrop.draggableQ3
   */
  q3: {
    optionName: "draggableQ3",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: "top",
    handlePositioner: (point) => ({
      x: point.shapeArgs.x || 0,
      y: point.q3Plot
    }),
    handleFormatter: column.y.handleFormatter,
    propValidate: (val, point) => val <= point.high && val >= point.median
  },
  /**
   * Allow high value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.boxplot.dragDrop.draggableHigh
   */
  high: {
    optionName: "draggableHigh",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: "top",
    handlePositioner: (point) => ({
      x: point.shapeArgs.x || 0,
      y: point.highPlot
    }),
    handleFormatter: column.y.handleFormatter,
    propValidate: (val, point) => val >= point.q3
  }
};
var errorbar = {
  x: column.x,
  low: {
    ...boxplot.low,
    propValidate: (val, point) => val <= point.high
  },
  high: {
    ...boxplot.high,
    propValidate: (val, point) => val >= point.low
  }
};
var bullet = {
  x: column.x,
  y: column.y,
  /**
   * Allow target value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.bullet.dragDrop.draggableTarget
   */
  target: {
    optionName: "draggableTarget",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: "top",
    handlePositioner: (point) => {
      const bBox = point.targetGraphic.getBBox();
      return {
        x: point.barX,
        y: bBox.y + bBox.height / 2
      };
    },
    handleFormatter: column.y.handleFormatter
  }
};
var ohlc2 = {
  x: column.x,
  /**
   * Allow low value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.ohlc.dragDrop.draggableLow
   */
  low: {
    optionName: "draggableLow",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: "bottom",
    handlePositioner: (point) => ({
      x: point.shapeArgs.x,
      y: point.plotLow
    }),
    handleFormatter: column.y.handleFormatter,
    propValidate: (val, point) => val <= point.open && val <= point.close
  },
  /**
   * Allow high value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.ohlc.dragDrop.draggableHigh
   */
  high: {
    optionName: "draggableHigh",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: "top",
    handlePositioner: (point) => ({
      x: point.shapeArgs.x,
      y: point.plotHigh
    }),
    handleFormatter: column.y.handleFormatter,
    propValidate: (val, point) => val >= point.open && val >= point.close
  },
  /**
   * Allow open value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.ohlc.dragDrop.draggableOpen
   */
  open: {
    optionName: "draggableOpen",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: (point) => point.open >= point.close ? "top" : "bottom",
    handlePositioner: (point) => ({
      x: point.shapeArgs.x,
      y: point.plotOpen
    }),
    handleFormatter: column.y.handleFormatter,
    propValidate: (val, point) => val <= point.high && val >= point.low
  },
  /**
   * Allow close value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.ohlc.dragDrop.draggableClose
   */
  close: {
    optionName: "draggableClose",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: (point) => point.open >= point.close ? "bottom" : "top",
    handlePositioner: (point) => ({
      x: point.shapeArgs.x,
      y: point.plotClose
    }),
    handleFormatter: column.y.handleFormatter,
    propValidate: (val, point) => val <= point.high && val >= point.low
  }
};
var waterfall = {
  x: column.x,
  y: merge110(column.y, {
    handleFormatter: (point) => point.isSum || point.isIntermediateSum ? null : column?.y?.handleFormatter?.(point) || null
  })
};
var columnrange = {
  x: {
    axis: "x",
    move: true
  },
  /**
   * Allow low value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.columnrange.dragDrop.draggableLow
   */
  low: {
    optionName: "draggableLow",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: "bottom",
    handlePositioner: (point) => {
      const bBox = point.shapeArgs || point.graphic.getBBox();
      return {
        x: bBox.x || 0,
        y: (bBox.y || 0) + (bBox.height || 0)
      };
    },
    handleFormatter: column.y.handleFormatter,
    propValidate: (val, point) => val <= point.high
  },
  /**
   * Allow high value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.columnrange.dragDrop.draggableHigh
   */
  high: {
    optionName: "draggableHigh",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: "top",
    handlePositioner: (point) => {
      const bBox = point.shapeArgs || point.graphic.getBBox();
      return {
        x: bBox.x || 0,
        y: bBox.y || 0
      };
    },
    handleFormatter: column.y.handleFormatter,
    propValidate: (val, point) => val >= point.low
  }
};
var arearange = {
  x: columnrange.x,
  /**
   * Allow low value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.arearange.dragDrop.draggableLow
   */
  low: {
    optionName: "draggableLow",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: "bottom",
    handlePositioner: (point) => {
      const bBox = point.graphics && point.graphics[0] && point.graphics[0].getBBox();
      return bBox ? {
        x: bBox.x + bBox.width / 2,
        y: bBox.y + bBox.height / 2
      } : { x: -999, y: -999 };
    },
    handleFormatter: arearangeHandleFormatter,
    propValidate: columnrange.low.propValidate
  },
  /**
   * Allow high value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.arearange.dragDrop.draggableHigh
   */
  high: {
    optionName: "draggableHigh",
    axis: "y",
    move: true,
    resize: true,
    resizeSide: "top",
    handlePositioner: (point) => {
      const bBox = point.graphics && point.graphics[1] && point.graphics[1].getBBox();
      return bBox ? {
        x: bBox.x + bBox.width / 2,
        y: bBox.y + bBox.height / 2
      } : { x: -999, y: -999 };
    },
    handleFormatter: arearangeHandleFormatter,
    propValidate: columnrange.high.propValidate
  }
};
var xrange = {
  y: {
    axis: "y",
    move: true
  },
  /**
   * Allow x value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.xrange.dragDrop.draggableX1
   */
  x: {
    optionName: "draggableX1",
    axis: "x",
    move: true,
    resize: true,
    resizeSide: "left",
    handlePositioner: (point) => xrangeHandlePositioner(point, "x"),
    handleFormatter: horizHandleFormatter,
    propValidate: (val, point) => val <= point.x2
  },
  /**
   * Allow x2 value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.xrange.dragDrop.draggableX2
   */
  x2: {
    optionName: "draggableX2",
    axis: "x",
    move: true,
    resize: true,
    resizeSide: "right",
    handlePositioner: (point) => xrangeHandlePositioner(point, "x2"),
    handleFormatter: horizHandleFormatter,
    propValidate: (val, point) => val >= point.x
  }
};
var gantt = {
  y: xrange.y,
  /**
   * Allow start value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.gantt.dragDrop.draggableStart
   */
  start: merge110(xrange.x, {
    optionName: "draggableStart",
    // Do not allow individual drag handles for milestones
    validateIndividualDrag: (point) => !point.milestone
  }),
  /**
   * Allow end value to be dragged individually.
   *
   * @type      {boolean}
   * @default   true
   * @requires  modules/draggable-points
   * @apioption plotOptions.gantt.dragDrop.draggableEnd
   */
  end: merge110(xrange.x2, {
    optionName: "draggableEnd",
    // Do not allow individual drag handles for milestones
    validateIndividualDrag: (point) => !point.milestone
  })
};
function arearangeHandleFormatter(point) {
  const radius = point.graphic ? point.graphic.getBBox().width / 2 + 1 : 4;
  return [
    ["M", 0 - radius, 0],
    ["a", radius, radius, 0, 1, 0, radius * 2, 0],
    ["a", radius, radius, 0, 1, 0, radius * -2, 0]
  ];
}
function horizHandleFormatter(point) {
  const shapeArgs = point.shapeArgs || point.graphic.getBBox(), top = shapeArgs.r || 0, bottom = shapeArgs.height - top, centerY = shapeArgs.height / 2;
  return [
    // Top wick
    ["M", 0, top],
    ["L", 0, centerY - 5],
    // Circle
    ["A", 1, 1, 0, 0, 0, 0, centerY + 5],
    ["A", 1, 1, 0, 0, 0, 0, centerY - 5],
    // Bottom wick
    ["M", 0, centerY + 5],
    ["L", 0, bottom]
  ];
}
function xrangeHandlePositioner(point, xProp) {
  const series = point.series, xAxis2 = series.xAxis, yAxis2 = series.yAxis, inverted = series.chart.inverted, offsetY = series.columnMetrics ? series.columnMetrics.offset : -point.shapeArgs.height / 2;
  let newX = xAxis2.toPixels(point[xProp], true), newY = yAxis2.toPixels(point.y, true);
  if (inverted) {
    newX = xAxis2.len - newX;
    newY = yAxis2.len - newY;
  }
  newY += offsetY;
  return {
    x: Math.round(newX),
    y: Math.round(newY)
  };
}
var DragDropProps = {
  arearange,
  boxplot,
  bullet,
  column,
  columnrange,
  errorbar,
  flags,
  gantt,
  line,
  ohlc: ohlc2,
  waterfall,
  xrange
};
var DragDropProps_default = DragDropProps;

// node_modules/highcharts/es-modules/Extensions/DraggablePoints/DraggablePoints.js
var { addEvents: addEvents3, getNormalizedEvent: getNormalizedEvent3 } = DragDropUtilities_default;
var { initDragDrop: initDragDrop2 } = DraggableChart_default;
var { addEvent: addEvent97, clamp: clamp24, isNumber: isNumber78, merge: merge111 } = Utilities_default;
function compose26(ChartClass, SeriesClass) {
  DraggableChart_default.compose(ChartClass);
  const seriesProto7 = SeriesClass.prototype;
  if (!seriesProto7.dragDropProps) {
    const PointClass = SeriesClass.prototype.pointClass, seriesTypes7 = SeriesClass.types, pointProto2 = PointClass.prototype;
    pointProto2.getDropValues = pointGetDropValues;
    pointProto2.showDragHandles = pointShowDragHandles;
    addEvent97(PointClass, "mouseOut", onPointMouseOut);
    addEvent97(PointClass, "mouseOver", onPointMouseOver);
    addEvent97(PointClass, "remove", onPointRemove);
    seriesProto7.dragDropProps = DragDropProps_default.line;
    seriesProto7.getGuideBox = seriesGetGuideBox;
    const seriesWithDragDropProps = [
      "arearange",
      "boxplot",
      "bullet",
      "column",
      "columnrange",
      "errorbar",
      "flags",
      "gantt",
      "ohlc",
      "waterfall",
      "xrange"
    ];
    for (const seriesType of seriesWithDragDropProps) {
      if (seriesTypes7[seriesType]) {
        seriesTypes7[seriesType].prototype.dragDropProps = DragDropProps_default[seriesType];
      }
    }
    const seriesWithoutDragDropProps = [
      "bellcurve",
      "gauge",
      "histogram",
      "map",
      "mapline",
      "pareto",
      "pie",
      "sankey",
      "sma",
      "sunburst",
      "treemap",
      "vector",
      "windbarb",
      "wordcloud"
    ];
    for (const seriesType of seriesWithoutDragDropProps) {
      if (seriesTypes7[seriesType]) {
        seriesTypes7[seriesType].prototype.dragDropProps = null;
      }
    }
  }
}
function mouseOut(point) {
  const chart = point.series && point.series.chart, dragDropData = chart && chart.dragDropData;
  if (chart && chart.dragHandles && !(dragDropData && (dragDropData.isDragging && dragDropData.draggedPastSensitivity || dragDropData.isHoveringHandle === point.id))) {
    chart.hideDragHandles();
  }
}
function mouseOver(point) {
  const series = point.series, chart = series && series.chart, dragDropData = chart && chart.dragDropData, is3d = chart && chart.is3d && chart.is3d();
  if (chart && !(dragDropData && dragDropData.isDragging && // Ignore if dragging a point
  dragDropData.draggedPastSensitivity) && !chart.isDragDropAnimating && // Ignore if animating
  series.options.dragDrop && // No need to compute handles without this
  !is3d) {
    if (chart.dragHandles) {
      chart.hideDragHandles();
    }
    point.showDragHandles();
  }
}
function onPointMouseOut() {
  const point = this;
  setTimeout(() => {
    if (point.series) {
      mouseOut(point);
    }
  }, 10);
}
function onPointMouseOver() {
  const point = this;
  setTimeout(() => mouseOver(point), 12);
}
function onPointRemove() {
  const chart = this.series.chart, dragHandles = chart.dragHandles;
  if (dragHandles && dragHandles.point === this.id) {
    chart.hideDragHandles();
  }
}
function onResizeHandleMouseOut(point) {
  const chart = point.series.chart;
  if (chart.dragDropData && point.id === chart.dragDropData.isHoveringHandle) {
    delete chart.dragDropData.isHoveringHandle;
  }
  if (!chart.hoverPoint) {
    mouseOut(point);
  }
}
function onResizeHandleMouseDown(e, point, updateProp) {
  const chart = point.series.chart;
  if (chart.zoomOrPanKeyPressed(e)) {
    return;
  }
  chart.mouseIsDown = false;
  initDragDrop2(e, point);
  chart.dragDropData.updateProp = e.updateProp = updateProp;
  point.firePointEvent("dragStart", e);
  e.stopPropagation();
  e.preventDefault();
}
function pointGetDropValues(origin, newPos, updateProps) {
  const point = this, series = point.series, chart = series.chart, mapView = chart.mapView, options2 = merge111(series.options.dragDrop, point.options.dragDrop), result = {}, pointOrigin = origin.points[point.id], updateSingleProp = Object.keys(updateProps).length === 1;
  const limitToRange = (val, dir) => {
    const direction = dir.toUpperCase(), time = series.chart.time, defaultPrecision = series[`${dir}Axis`].categories ? 1 : 0, precision = options2[`dragPrecision${direction}`] ?? defaultPrecision, min4 = time.parse(options2[`dragMin${direction}`]) ?? -Infinity, max4 = time.parse(options2[`dragMax${direction}`]) ?? Infinity;
    let res = val;
    if (precision) {
      res = Math.round(res / precision) * precision;
    }
    return clamp24(res, min4, max4);
  };
  const limitToMapRange = (newPos2, dir, key) => {
    if (mapView) {
      const direction = dir.toUpperCase(), precision = options2[`dragPrecision${direction}`] ?? 0, lonLatMin = mapView.pixelsToLonLat({
        x: 0,
        y: 0
      }), lonLatMax = mapView.pixelsToLonLat({
        x: chart.plotBox.width,
        y: chart.plotBox.height
      });
      let min4 = options2[`dragMin${direction}`] ?? lonLatMin?.[key] ?? -Infinity, max4 = options2[`dragMax${direction}`] ?? lonLatMax?.[key] ?? Infinity, res = newPos2[key];
      if (mapView.projection.options.name === "Orthographic") {
        return res;
      }
      if (key === "lat") {
        if (isNaN(min4) || min4 > mapView.projection.maxLatitude) {
          min4 = mapView.projection.maxLatitude;
        }
        if (isNaN(max4) || max4 < -1 * mapView.projection.maxLatitude) {
          max4 = -1 * mapView.projection.maxLatitude;
        }
        const temp = max4;
        max4 = min4;
        min4 = temp;
      }
      if (!mapView.projection.hasCoordinates) {
        const lonLatRes = mapView.pixelsToLonLat({
          x: newPos2.chartX - chart.plotLeft,
          y: chart.plotHeight - newPos2.chartY + chart.plotTop
        });
        if (lonLatRes) {
          res = lonLatRes[key];
        }
      }
      if (precision) {
        res = Math.round(res / precision) * precision;
      }
      return clamp24(res, min4, max4);
    }
  };
  for (const key of Object.keys(updateProps)) {
    const val = updateProps[key], oldVal = pointOrigin.point[key], axis = series[val.axis + "Axis"], newVal = mapView ? limitToMapRange(newPos, val.axis, key) : limitToRange(axis.toValue((axis.horiz ? newPos.chartX : newPos.chartY) + pointOrigin[key + "Offset"]), val.axis);
    if (isNumber78(newVal) && !(updateSingleProp && val.propValidate && !val.propValidate(newVal, point)) && typeof oldVal !== "undefined") {
      result[key] = newVal;
    }
  }
  return result;
}
function pointShowDragHandles() {
  const point = this, series = point.series, chart = series.chart, { inverted, renderer } = chart, options2 = merge111(series.options.dragDrop, point.options.dragDrop), dragDropProps = series.dragDropProps || {};
  let dragHandles = chart.dragHandles;
  for (const key of Object.keys(dragDropProps)) {
    const val = dragDropProps[key], handleOptions = merge111(DragDropDefaults_default.dragHandle, val.handleOptions, options2.dragHandle), handleAttrs = {
      "class": handleOptions.className,
      "stroke-width": handleOptions.lineWidth,
      fill: handleOptions.color,
      stroke: handleOptions.lineColor
    }, pathFormatter = handleOptions.pathFormatter || val.handleFormatter, handlePositioner = val.handlePositioner, validate = val.validateIndividualDrag ? val.validateIndividualDrag(point) : true;
    let pos, handle, path;
    if (val.resize && validate && val.resizeSide && pathFormatter && (options2["draggable" + val.axis.toUpperCase()] || options2[val.optionName]) && options2[val.optionName] !== false) {
      if (!dragHandles) {
        dragHandles = chart.dragHandles = {
          group: renderer.g("drag-drop-handles").add(series.markerGroup || series.group),
          point: point.id
        };
      } else {
        dragHandles.point = point.id;
      }
      pos = handlePositioner(point);
      handleAttrs.d = path = pathFormatter(point);
      const minEdge = point.series.xAxis.categories ? -0.5 : 0;
      if (!path || pos.x < minEdge || pos.y < 0) {
        return;
      }
      handleAttrs.cursor = handleOptions.cursor || (val.axis === "x" !== !!inverted ? "ew-resize" : "ns-resize");
      handle = dragHandles[val.optionName];
      if (!handle) {
        handle = dragHandles[val.optionName] = renderer.path().add(dragHandles.group);
      }
      handleAttrs.translateX = inverted ? series.yAxis.len - pos.y : pos.x;
      handleAttrs.translateY = inverted ? series.xAxis.len - pos.x : pos.y;
      if (inverted) {
        handleAttrs.rotation = -90;
      }
      handle.attr(handleAttrs);
      addEvents3(handle.element, ["touchstart", "mousedown"], (e) => {
        onResizeHandleMouseDown(getNormalizedEvent3(e, chart), point, key);
      }, {
        passive: false
      });
      addEvent97(dragHandles.group.element, "mouseover", () => {
        chart.dragDropData = chart.dragDropData || {};
        chart.dragDropData.isHoveringHandle = point.id;
      });
      addEvents3(dragHandles.group.element, ["touchend", "mouseout"], () => {
        onResizeHandleMouseOut(point);
      });
    }
  }
}
function seriesGetGuideBox(points) {
  const chart = this.chart;
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, changed;
  for (const point of points) {
    const bBox = point.graphic && point.graphic.getBBox() || point.shapeArgs;
    if (bBox) {
      let plotX2;
      const x2 = point.x2;
      if (isNumber78(x2)) {
        plotX2 = point.series.xAxis.translate(x2, false, false, false, true);
      }
      const skipBBox = !(bBox.width || bBox.height || bBox.x || bBox.y);
      changed = true;
      minX = Math.min(point.plotX || 0, plotX2 || 0, skipBBox ? Infinity : bBox.x || 0, minX);
      maxX = Math.max(point.plotX || 0, plotX2 || 0, (bBox.x || 0) + (bBox.width || 0), maxX);
      minY = Math.min(point.plotY || 0, skipBBox ? Infinity : bBox.y || 0, minY);
      maxY = Math.max((bBox.y || 0) + (bBox.height || 0), maxY);
    }
  }
  return changed ? chart.renderer.rect(minX, minY, maxX - minX, maxY - minY) : chart.renderer.g();
}
var DraggablePoints = {
  compose: compose26
};
var DraggablePoints_default = DraggablePoints;

// node_modules/highcharts/es-modules/masters/modules/draggable-points.src.js
var G21 = Globals_default;
DraggablePoints_default.compose(G21.Chart, G21.Series);

// node_modules/@vaadin/charts/src/vaadin-chart-mixin.js
["exportChart", "exportChartLocal", "getSVG"].forEach((methodName) => {
  highstock_src_default.wrap(highstock_src_default.Chart.prototype, methodName, function(proceed, ...args) {
    highstock_src_default.fireEvent(this, "beforeExport");
    const result = proceed.apply(this, args);
    highstock_src_default.fireEvent(this, "afterExport");
    return result;
  });
});
Pointer_default.prototype.onDocumentMouseMove = function(e) {
  const chart = this.chart;
  const chartPosition = this.chartPosition;
  const pEvt = this.normalize(e, chartPosition);
  const tooltip = chart.tooltip;
  if (chartPosition && (!tooltip || !tooltip.isSticky) && !chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
    visiblePlotOnly: true
  }) && // Use the first element from the composed path instead of the actual target
  !this.inClass(pEvt.composedPath()[0], "highcharts-tracker")) {
    this.reset();
  }
};
var { simulatedEventTarget: simulatedEventTarget3 } = HTMLUtilities_default;
KeyboardNavigation_default.prototype.onMouseUp = function(e) {
  delete this.isClickingChart;
  if (!this.keyboardReset && e.relatedTarget !== simulatedEventTarget3) {
    const chart = this.chart;
    const target = e.composedPath()[0];
    if (!target || !chart.container.contains(target)) {
      const curMod = this.modules && this.modules[this.currentModuleIx || 0];
      if (curMod && curMod.terminate) {
        curMod.terminate();
      }
      this.currentModuleIx = 0;
    }
    if (chart.focusElement) {
      chart.focusElement.removeFocusBorder();
      delete chart.focusElement;
    }
    this.keyboardReset = true;
  }
};
highstock_src_default.setOptions({ lang: { noData: "" } });
var ChartMixin = (superClass) => class extends ResizeMixin(superClass) {
  static get properties() {
    return {
      /**
       * Configuration object that exposes the JS Api to configure the chart.
       *
       * Most important methods are:
       * - `addSeries (Object options, [Boolean redraw], [Mixed animation])`
       * - `addAxis (Object options, [Boolean isX], [Boolean redraw], [Mixed animation])`
       * - `setTitle (Object title, object subtitle, Boolean redraw)`
       *
       * Most important properties are:
       * - `configuration.series`: An array of the chart's series. Detailed API for Series object is
       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Series)
       * - `configuration.xAxis`: An array of the chart's x axes. Detailed API for Axis object is
       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)
       * - `configuration.yAxis`: An array of the chart's y axes. Detailed API for Axis object is
       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)
       * - `configuration.title`: The chart title.
       *
       * For detailed documentation of available API check the [API site](http://api.highcharts.com/class-reference/classes.list)
       * @type {!Highcharts.Chart | undefined}
       */
      configuration: {
        type: Object,
        sync: true
      },
      /**
       * If categories are present names are used instead of numbers for the category axis.
       * The format of categories can be an `Array` with a list of categories, such as `['2010', '2011', '2012']`
       * or a mapping `Object`, like `{0:'1',9:'Target (10)', 15: 'Max'}`.
       * @type {ChartCategories | undefined}
       */
      categories: {
        type: Object,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Category-axis maximum value. Defaults to `undefined`.
       * @attr {number} category-max
       */
      categoryMax: {
        type: Number,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Category-axis minimum value. Defaults to `undefined`.
       * @attr {number} category-min
       */
      categoryMin: {
        type: Number,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * The position of the category axis. Acceptable values are `left`, `right`, `top` and `bottom`
       * except for bar charts which only accept `left` and `right`.
       * With the default value, charts appear as though they have `category-position="bottom"`
       * except for bar charts that appear as though they have `category-position="left"`.
       *
       * Defaults to `undefined`
       *
       * @attr {left|right|top|bottom} category-position
       * @type {ChartCategoryPosition | undefined}
       */
      categoryPosition: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Specifies whether to hide legend or show.
       * Legend configuration can be set up via additionalOptions property
       * @attr {boolean} no-legend
       */
      noLegend: {
        type: Boolean,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Specifies how series are stacked on top of each other.
       * Possible values are null, "normal" or "percent".
       * If "stack" property is not defined on the vaadin-chart-series elements, then series will be put into
       * the default stack.
       * @attr {normal|percent} stacking
       * @type {ChartStacking | undefined}
       */
      stacking: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Specifies whether the chart is a normal chart or a timeline chart.
       * Value of this property is ignored for Gantt charts (type="gantt").
       */
      timeline: {
        type: Boolean,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Represents the title of the chart.
       * @type {string}
       */
      title: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Whether or not to show tooltip when hovering data points.
       */
      tooltip: {
        type: Boolean,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Sets the default series type of the chart.
       * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type.
       */
      type: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Represents the subtitle of the chart.
       * @type {string | undefined}
       */
      subtitle: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Specifies whether to show chart in 3 or in 2 dimensions.
       * Some display angles are added by default to the "chart.options3d" (`{alpha: 15, beta: 15, depth: 50}`).
       * 3D display options can be modified via `additionalOptions`.
       * The thickness of a Pie chart can be set on `additionalOptions` through `plotOptions.pie.depth`.
       * 3D is supported by Bar, Column, Pie and Scatter3D charts.
       * More info available at [Highcharts](https://www.highcharts.com/docs/chart-concepts/3d-charts).
       */
      chart3d: {
        type: Boolean,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Specifies the message displayed on a chart without displayable data.
       * @attr {string} empty-text
       * @type {string}
       */
      emptyText: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Represents additional JSON configuration.
       * @type {Options | undefined}
       */
      additionalOptions: {
        type: Object,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * When present, cartesian charts like line, spline, area and column are transformed
       * into the polar coordinate system.
       */
      polar: {
        type: Boolean,
        reflectToAttribute: true,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "__chart3dObserver(chart3d, configuration)",
      "__emptyTextObserver(emptyText, configuration)",
      "__hideLegend(noLegend, configuration)",
      "__polarObserver(polar, configuration)",
      "__stackingObserver(stacking, configuration)",
      "__tooltipObserver(tooltip, configuration)",
      "__updateCategories(categories, configuration)",
      "__updateCategoryMax(categoryMax, configuration)",
      "__updateCategoryMin(categoryMin, configuration)",
      "__updateCategoryPosition(categoryPosition, configuration)",
      "__updateSubtitle(subtitle, configuration)",
      "__updateTitle(title, configuration)",
      "__updateType(type, configuration)",
      "__updateAdditionalOptions(additionalOptions)"
    ];
  }
  /** @private */
  static __callHighchartsFunction(functionName, redrawCharts, ...args) {
    const functionToCall = highstock_src_default[functionName];
    if (functionToCall && typeof functionToCall === "function") {
      args.forEach((arg) => inflateFunctions(arg));
      functionToCall.apply(this.configuration, args);
      if (redrawCharts) {
        const lang6 = highstock_src_default.defaultOptions.lang;
        highstock_src_default.charts.forEach((c) => {
          if (c !== void 0) {
            c.time.lang = lang6;
            c.redraw();
          }
        });
      }
    }
  }
  constructor() {
    super();
    this._baseConfig = {
      annotations: [],
      chart: {
        styledMode: true
      },
      credits: {
        enabled: false
      },
      exporting: {
        enabled: false
      },
      title: {
        text: null
      },
      series: [],
      xAxis: {},
      yAxis: {
        axisGenerated: true
      }
    };
    this._baseChart3d = {
      enabled: true,
      alpha: 15,
      beta: 15,
      depth: 50
    };
  }
  /**
   * @return {!Options}
   */
  get options() {
    const options2 = { ...this._baseConfig };
    deepMerge(options2, this.additionalOptions);
    if (this.type) {
      options2.chart.type = this.type;
    }
    if (this.polar) {
      options2.chart.polar = true;
    }
    if (this.title) {
      options2.title = {
        text: this.title
      };
    }
    if (!options2.tooltip) {
      options2.tooltip = {};
      if (!this.tooltip) {
        options2.tooltip.enabled = false;
      }
    }
    if (this.subtitle) {
      options2.subtitle = {
        text: this.subtitle
      };
    }
    if (this.categories) {
      if (Array.isArray(options2.xAxis)) {
        options2.xAxis[0].categories = this.categories;
      } else {
        options2.xAxis.categories = this.categories;
      }
    }
    if (isFinite(this.categoryMin)) {
      if (Array.isArray(options2.xAxis)) {
        options2.xAxis[0].min = this.categoryMin;
      } else {
        options2.xAxis.min = this.categoryMin;
      }
    }
    if (isFinite(this.categoryMax)) {
      if (Array.isArray(options2.xAxis)) {
        options2.xAxis[0].max = this.categoryMax;
      } else {
        options2.xAxis.max = this.categoryMax;
      }
    }
    if (this.noLegend) {
      options2.legend = {
        enabled: false
      };
    }
    if (this.emptyText) {
      if (!options2.lang) {
        options2.lang = {};
      }
      options2.lang.noData = this.emptyText;
    }
    if (this.categoryPosition) {
      options2.chart.inverted = this.__shouldInvert();
      if (Array.isArray(options2.xAxis)) {
        options2.xAxis.forEach((e) => {
          e.opposite = this.__shouldFlipOpposite();
        });
      } else if (options2.xAxis) {
        options2.xAxis.opposite = this.__shouldFlipOpposite();
      }
    }
    if (this.stacking) {
      if (!options2.plotOptions) {
        options2.plotOptions = {};
      }
      if (!options2.plotOptions.series) {
        options2.plotOptions.series = {};
      }
      options2.plotOptions.series.stacking = this.stacking;
    }
    if (this.chart3d) {
      options2.chart.options3d = { ...this._baseChart3d, ...options2.chart.options3d };
    }
    return options2;
  }
  /*
   * Name of the chart events to add to the configuration and its corresponding event for the chart element
   * @private
   */
  get __chartEventNames() {
    return {
      /**
       * Fired when a new series is added.
       * @event chart-add-series
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      addSeries: "chart-add-series",
      /**
       * Fired after a chart is exported.
       * @event chart-after-export
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      afterExport: "chart-after-export",
      /**
       * Fired after a chart is printed.
       * @event chart-after-print
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      afterPrint: "chart-after-print",
      /**
       * Fired before a chart is exported.
       * @event chart-before-export
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      beforeExport: "chart-before-export",
      /**
       * Fired before a chart is printed.
       * @event chart-before-print
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      beforePrint: "chart-before-print",
      /**
       * Fired when clicking on the plot background.
       * @event chart-click
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      click: "chart-click",
      /**
       * Fired when drilldown point is clicked.
       * @event chart-drilldown
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      drilldown: "chart-drilldown",
      /**
       * Fired when drilling up from a drilldown series.
       * @event chart-drillup
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      drillup: "chart-drillup",
      /**
       * Fired after all the series has been drilled up if chart has multiple drilldown series.
       * @event chart-drillupall
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      drillupall: "chart-drillupall",
      /**
       * Fired when the chart is finished loading.
       * @event chart-load
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      load: "chart-load",
      /**
       * Fired when the chart is redraw. Can be called after a `Chart.configuration.redraw()`
       * or after an axis, series or point is modified with the `redraw` option set to `true`.
       * @event chart-redraw
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      redraw: "chart-redraw",
      /**
       * Fired when an area of the chart has been selected.
       * @event chart-selection
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      selection: "chart-selection",
      /**
       * Fired when the chart finishes resizing.
       * @event chart-end-resize
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      endResize: "chart-end-resize"
    };
  }
  /**
   * Name of the series events to add to the configuration and its corresponding event for the chart element
   * @private
   */
  get __seriesEventNames() {
    return {
      /**
       * Fired when the series has finished its initial animation.
       * @event series-after-animate
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      afterAnimate: "series-after-animate",
      /**
       * Fired when the checkbox next to the series' name in the legend is clicked.
       * @event series-checkbox-click
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      checkboxClick: "series-checkbox-click",
      /**
       * Fired when the series is clicked.
       * @event series-click
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      click: "series-click",
      /**
       * Fired when the series is hidden after chart generation time.
       * @event series-hide
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      hide: "series-hide",
      /**
       * Fired when the legend item belonging to the series is clicked.
       * @event series-legend-item-click
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      /**
       * Fired when the mouses leave the graph.
       * @event series-mouse-out
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      mouseOut: "series-mouse-out",
      /**
       * Fired when the mouse enters the graph.
       * @event series-mouse-over
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      mouseOver: "series-mouse-over",
      /**
       * Fired when the series is show after chart generation time.
       * @event series-show
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      show: "series-show"
    };
  }
  /**
   * Name of the point events to add to the configuration and its corresponding event for the chart element
   * @private
   */
  get __pointEventNames() {
    return {
      /**
       * Fired when the point is clicked.
       * @event point-click
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      click: "point-click",
      /**
       * Fired when the legend item belonging to the point is clicked.
       * @event point-legend-item-click
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      /**
       * Fired when the mouse leaves the area close to the point.
       * @event point-mouse-out
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      mouseOut: "point-mouse-out",
      /**
       * Fired when the mouse enters the area close to the point.
       * @event point-mouse-over
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      mouseOver: "point-mouse-over",
      /**
       * Fired when the point is removed from the series.
       * @event point-remove
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      remove: "point-remove",
      /**
       * Fired when the point is selected either programmatically or by clicking on the point.
       * @event point-select
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      select: "point-select",
      /**
       * Fired when the point is unselected either programmatically or by clicking on the point
       * @event point-unselect
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      unselect: "point-unselect",
      /**
       * Fired when the point is updated programmatically through `.updateConfiguration()` method.
       * @event point-update
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      update: "point-update",
      /**
       * Fired when starting to drag a point.
       * @event point-drag-start
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      dragStart: "point-drag-start",
      /**
       * Fired when the point is dropped.
       * @event point-drop
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      drop: "point-drop",
      /**
       * Fired while dragging a point.
       * @event point-drag
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      drag: "point-drag"
    };
  }
  /** @private */
  get __xAxesEventNames() {
    return {
      /**
       * Fired when the minimum and maximum is set for the x axis.
       * @event xaxes-extremes-set
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} axis Point object where the event was sent from
       */
      afterSetExtremes: "xaxes-extremes-set"
    };
  }
  /** @private */
  get __yAxesEventNames() {
    return {
      /**
       * Fired when the minimum and maximum is set for the y axis.
       * @event yaxes-extremes-set
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} axis Point object where the event was sent from
       */
      afterSetExtremes: "yaxes-extremes-set"
    };
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__updateStyles();
    queueMicrotask(() => {
      if (this.configuration) {
        return;
      }
      this.__resetChart();
      this.__addChildObserver();
      this.__checkTurboMode();
    });
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("chart-redraw", this.__onRedraw.bind(this));
  }
  /**
   * Implements resize callback from `ResizeMixin`
   * to reflow when the chart element is resized.
   * @protected
   * @override
   */
  _onResize(contentRect) {
    if (!this.configuration) {
      return;
    }
    const { height, width } = contentRect;
    const { chartHeight, chartWidth } = this.configuration;
    this.$.wrapper.style.minHeight = "";
    if (this.$.wrapper.offsetHeight <= 1) {
      this.$.wrapper.style.minHeight = `${chartHeight}px`;
    }
    this.$.wrapper.style.minWidth = "";
    if (this.$.wrapper.offsetWidth <= 1) {
      this.$.wrapper.style.minWidth = `${chartWidth}px`;
    }
    if (height !== chartHeight || width !== chartWidth) {
      this.__reflow();
    }
  }
  /** @private */
  __reflow() {
    if (!this.configuration) {
      return;
    }
    this.configuration.reflow();
  }
  /** @private */
  __addChildObserver() {
    this._childObserver = new SlotObserver(this.$.slot, (info) => {
      this.__addSeries(info.addedNodes.filter(this.__filterSeriesNodes));
      this.__removeSeries(info.removedNodes.filter(this.__filterSeriesNodes));
      this.__cleanupAfterSeriesRemoved(info.removedNodes.filter(this.__filterSeriesNodes));
    });
  }
  /** @private */
  __filterSeriesNodes(node) {
    const ChartSeries2 = customElements.get("vaadin-chart-series");
    return node.nodeType === Node.ELEMENT_NODE && node instanceof ChartSeries2;
  }
  /** @private */
  __addSeries(series) {
    if (this.__isSeriesEmpty(series)) {
      return;
    }
    const seriesNodes = Array.from(this.childNodes).filter(this.__filterSeriesNodes);
    const yAxes = this.configuration.yAxis.reduce((acc, axis, index) => {
      acc[axis.options.id || index] = axis;
      return acc;
    }, {});
    for (let i = 0, len = series.length; i < len; i++) {
      const seriesElement = series[i];
      const { yAxis: unit, yAxisValueMin: valueMin, yAxisValueMax: valueMax } = seriesElement.options;
      const idxOnChildList = seriesNodes.indexOf(seriesElement);
      if (!unit && !this.configuration.yAxis.some((e) => e.userOptions.id === void 0)) {
        yAxes[unit] = this.__addAxis({ axisGenerated: true });
      } else if (unit && !yAxes[unit]) {
        yAxes[unit] = this.__addAxis({ id: unit, title: { text: unit }, axisGenerated: true });
      }
      if (isFinite(valueMin)) {
        this.__setYAxisProps(yAxes, unit, { min: valueMin });
      }
      if (isFinite(valueMax)) {
        this.__setYAxisProps(yAxes, unit, { max: valueMax });
      }
      const seriesConfiguration = this.__updateOrAddSeriesInstance(seriesElement.options, idxOnChildList, false);
      seriesElement.setSeries(seriesConfiguration);
    }
    this.__removeAxisIfEmpty();
    this.configuration.redraw();
  }
  /** @private */
  __removeSeries(seriesNodes) {
    if (this.__isSeriesEmpty(seriesNodes)) {
      return;
    }
    const ChartSeries2 = customElements.get("vaadin-chart-series");
    seriesNodes.forEach((series) => {
      if (series instanceof ChartSeries2) {
        series._series.remove();
      }
    });
  }
  /** @private */
  __setYAxisProps(yAxes, yAxisId, props) {
    if (yAxisId) {
      yAxes[yAxisId].update(props);
    } else {
      this.configuration.yAxis[0].update(props);
    }
  }
  /** @private */
  __isSeriesEmpty(series) {
    return series === null || series.length === 0;
  }
  /** @private */
  __cleanupAfterSeriesRemoved(series) {
    if (this.__isSeriesEmpty(series)) {
      return;
    }
    this.__removeAxisIfEmpty();
    this.__updateNoDataElement(this.configuration);
  }
  /** @private */
  __initChart(options2) {
    this.__initEventsListeners(options2);
    this.__updateStyledMode(options2);
    if (options2.chart.type === "gantt") {
      this.configuration = highstock_src_default.ganttChart(this.$.chart, options2);
    } else if (this.timeline) {
      this.configuration = highstock_src_default.stockChart(this.$.chart, options2);
    } else {
      this.configuration = highstock_src_default.chart(this.$.chart, options2);
    }
    this.__forceResize();
  }
  /** @private */
  __updateStyledMode(options2) {
    const styledMode = options2.chart.styledMode;
    this.$.chart.toggleAttribute("styled-mode", !!styledMode);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.configuration) {
      this._jsonConfigurationBuffer = deepMerge({}, this.configuration.userOptions);
    }
    queueMicrotask(() => {
      if (this.isConnected) {
        return;
      }
      if (this.configuration) {
        this.configuration.destroy();
        this.configuration = void 0;
        const seriesNodes = Array.from(this.childNodes).filter(this.__filterSeriesNodes);
        seriesNodes.forEach((series) => {
          series.setSeries(null);
        });
      }
      if (this._childObserver) {
        this._childObserver.disconnect();
      }
    });
  }
  /** @private */
  __resetChart() {
    const initialOptions = { ...this.options, ...this._jsonConfigurationBuffer };
    this.__initChart(initialOptions);
    this._jsonConfigurationBuffer = null;
  }
  /**
   * Search for axis with given `id`.
   *
   * @param {string} id contains the id that will be searched
   * @param {boolean} isXAxis indicates if it will remove x or y axes. Defaults to `false`.
   * @return {Axis}
   * @protected
   */
  __getAxis(id, isXAxis) {
    id = Number.parseInt(id) || id;
    if (this.configuration) {
      return (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).find((axis) => axis.options.id === id);
    }
  }
  /**
   * Add an axis with given options
   *
   * @param {Object} options axis options
   * @param {boolean} isXAxis indicates if axis is X (`true`) or Y (`false`). Defaults to `false`.
   * @return {!Axis}
   * @protected
   */
  __addAxis(options2, isXAxis) {
    if (this.configuration) {
      this.__createEventListeners(
        isXAxis ? this.__xAxesEventNames : this.__yAxesEventNames,
        options2,
        "events",
        "axis"
      );
      return this.configuration.addAxis(options2, isXAxis);
    }
  }
  /**
   * Iterates over axes (y or x) and removes whenever it doesn't contain any series and was created for unit
   *
   * @param {boolean} isXAxis indicates if it will remove x or y axes. Defaults to `false`.
   * @protected
   */
  __removeAxisIfEmpty(isXAxis) {
    if (this.configuration) {
      (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).forEach((axis) => {
        if (axis.userOptions.axisGenerated && axis.series.length === 0) {
          axis.remove();
        }
      });
    }
  }
  /**
   * Update the chart configuration.
   * This JSON API provides a simple single-argument alternative to the configuration property.
   *
   * Styling properties specified in this configuration will be ignored. To learn about chart styling
   * please see the CSS Styling section above.
   *
   * @param {!Options} jsonConfiguration Object chart configuration. Most important properties are:
   *
   * - annotations `Object[]` custom labels or shapes that can be tied to points, axis coordinates or chart pixel coordinates.
   *    Detailed API for annotations object is available in [API Site](http://api.highcharts.com/highcharts/annotations)
   * - chart `Object` with options regarding the chart area and plot area as well as general chart options.
   *    Detailed API for chart object is available in [API Site](http://api.highcharts.com/highcharts/chart)
   * - credits `Object` with options regarding the chart area and plot area as well as general chart options.
   *    Detailed API for credits object is available in [API Site](http://api.highcharts.com/highcharts/credits)
   * - plotOptions `Object` wrapper for config objects for each series type.
   *    Detailed API for plotOptions object is available in [API Site](http://api.highcharts.com/highcharts/plotOptions)
   * - series `Object[]` the actual series to append to the chart.
   *    Detailed API for series object is available in [API Site](http://api.highcharts.com/highcharts/series)
   * - subtitle `Object` the chart's subtitle.
   *    Detailed API for subtitle object is available in [API Site](http://api.highcharts.com/highcharts/subtitle)
   * - title `Object` the chart's main title.
   *    Detailed API for title object is available in [API Site](http://api.highcharts.com/highcharts/title)
   * - tooltip `Object` Options for the tooltip that appears when the user hovers over a series or point.
   *    Detailed API for tooltip object is available in [API Site](http://api.highcharts.com/highcharts/tooltip)
   * - xAxis `Object[]` The X axis or category axis. Normally this is the horizontal axis.
   *    Detailed API for xAxis object is available in [API Site](http://api.highcharts.com/highcharts/xAxis)
   * - yAxis `Object[]` The Y axis or value axis. Normally this is the vertical axis.
   *    Detailed API for yAxis object is available in [API Site](http://api.highcharts.com/highcharts/yAxis)
   * - zAxis `Object[]` The Z axis or depth axis for 3D plots.
   *    Detailed API for zAxis object is available in [API Site](http://api.highcharts.com/highcharts/zAxis)
   *
   * @param {boolean=} resetConfiguration Optional boolean that should be set to true if no other chart configuration was set before or
   *    if existing configuration should be discarded.
   */
  updateConfiguration(jsonConfiguration, resetConfiguration) {
    if (resetConfiguration || !this._jsonConfigurationBuffer) {
      this._jsonConfigurationBuffer = {};
    }
    const configCopy = deepMerge({}, jsonConfiguration);
    inflateFunctions(configCopy);
    this._jsonConfigurationBuffer = this.__makeConfigurationBuffer(this._jsonConfigurationBuffer, configCopy);
    queueMicrotask(() => {
      if (!this.configuration || !this._jsonConfigurationBuffer) {
        return;
      }
      if (resetConfiguration) {
        this.__resetChart();
        return;
      }
      this.configuration.update(this._jsonConfigurationBuffer, false);
      if (this._jsonConfigurationBuffer.credits) {
        this.__updateOrAddCredits(this._jsonConfigurationBuffer.credits);
      }
      if (this._jsonConfigurationBuffer.xAxis) {
        this.__updateOrAddAxes(this._jsonConfigurationBuffer.xAxis, true, false);
      }
      if (this._jsonConfigurationBuffer.yAxis) {
        this.__updateOrAddAxes(this._jsonConfigurationBuffer.yAxis, false, false);
      }
      if (this._jsonConfigurationBuffer.series) {
        this.__updateOrAddSeries(this._jsonConfigurationBuffer.series, false);
      }
      this._jsonConfigurationBuffer = null;
      this.configuration.redraw();
    });
  }
  /** @private */
  __makeConfigurationBuffer(target, source) {
    const _source = highstock_src_default.merge(source);
    const _target = highstock_src_default.merge(target);
    this.__mergeConfigurationArray(_target, _source, "series");
    this.__mergeConfigurationArray(_target, _source, "xAxis");
    this.__mergeConfigurationArray(_target, _source, "yAxis");
    return highstock_src_default.merge(_target, _source);
  }
  /** @private */
  __mergeConfigurationArray(target, configuration, entry) {
    if (!configuration || !configuration[entry] || !Array.isArray(configuration[entry])) {
      return;
    }
    if (!target[entry]) {
      target[entry] = Array.from(configuration[entry]);
      return;
    }
    const maxLength = Math.max(target[entry].length, configuration[entry].length);
    for (let i = 0; i < maxLength; i++) {
      target[entry][i] = highstock_src_default.merge(target[entry][i], configuration[entry][i]);
    }
    delete configuration[entry];
  }
  /** @private */
  __initEventsListeners(configuration) {
    this.__initChartEventsListeners(configuration);
    this.__initSeriesEventsListeners(configuration);
    this.__initPointsEventsListeners(configuration);
    this.__initAxisEventsListeners(configuration, true);
    this.__initLegendItemClickEventListener(configuration);
    this.__initAxisEventsListeners(configuration, false);
  }
  /** @private */
  __initChartEventsListeners(configuration) {
    this.__createEventListeners(this.__chartEventNames, configuration, "chart.events", "chart");
  }
  /** @private */
  __initSeriesEventsListeners(configuration) {
    this.__createEventListeners(this.__seriesEventNames, configuration, "plotOptions.series.events", "series");
  }
  /** @private */
  __initPointsEventsListeners(configuration) {
    this.__createEventListeners(this.__pointEventNames, configuration, "plotOptions.series.point.events", "point");
  }
  /** @private */
  __initLegendItemClickEventListener(configuration) {
    const eventObject = this.__ensureObjectPath(configuration, "legend.events");
    eventObject.itemClick = (event) => {
      const customEvent = {
        bubbles: false,
        composed: true,
        detail: {
          originalEvent: event,
          legend: event.target
        }
      };
      const legendItemMatch = [
        { clazz: highstock_src_default.Series, type: "series" },
        { clazz: highstock_src_default.Point, type: "point" }
      ].find(({ clazz }) => event.legendItem instanceof clazz);
      if (legendItemMatch) {
        const { type: legendItemClickType } = legendItemMatch;
        customEvent.detail[legendItemClickType] = event.legendItem;
        this.dispatchEvent(new CustomEvent(`${legendItemClickType}-legend-item-click`, customEvent));
        if (this._visibilityTogglingDisabled) {
          return false;
        }
      }
    };
  }
  /** @private */
  __initAxisEventsListeners(configuration, isXAxis) {
    let eventNames, axes;
    if (isXAxis) {
      eventNames = this.__xAxesEventNames;
      axes = configuration.xAxis;
    } else {
      eventNames = this.__yAxesEventNames;
      axes = configuration.yAxis;
    }
    if (Array.isArray(axes)) {
      axes.forEach((axis) => this.__createEventListeners(eventNames, axis, "events", "axis"));
    } else {
      this.__createEventListeners(eventNames, axes, "events", "axis");
    }
  }
  /** @private */
  __createEventListeners(eventList, configuration, pathToAdd, eventType) {
    const eventObject = this.__ensureObjectPath(configuration, pathToAdd);
    const self = this;
    for (let keys = Object.keys(eventList), i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (!eventObject[key]) {
        eventObject[key] = function(event) {
          const customEvent = {
            bubbles: false,
            composed: true,
            detail: {
              originalEvent: event,
              [eventType]: event.target
            }
          };
          if (key === "dragStart") {
            customEvent.detail[eventType] = this;
          }
          if (event.type === "afterSetExtremes") {
            if (event.min == null || event.max == null) {
              return;
            }
          }
          if (event.type === "selection") {
            if (event.xAxis && event.xAxis[0]) {
              customEvent.detail.xAxisMin = event.xAxis[0].min;
              customEvent.detail.xAxisMax = event.xAxis[0].max;
            }
            if (event.yAxis && event.yAxis[0]) {
              customEvent.detail.yAxisMin = event.yAxis[0].min;
              customEvent.detail.yAxisMax = event.yAxis[0].max;
            }
          }
          if (event.type === "click") {
            if (event.xAxis && event.xAxis[0]) {
              customEvent.detail.xValue = event.xAxis[0].value;
            }
            if (event.yAxis && event.yAxis[0]) {
              customEvent.detail.yValue = event.yAxis[0].value;
            }
          }
          if (["beforePrint", "beforeExport"].indexOf(event.type) >= 0) {
            prepareExport(self);
          }
          if (["afterPrint", "afterExport"].indexOf(event.type) >= 0) {
            cleanupExport(self);
          }
          self.dispatchEvent(new CustomEvent(eventList[key], customEvent));
        };
      }
    }
  }
  /** @private */
  __ensureObjectPath(object, path) {
    if (typeof path !== "string") {
      return;
    }
    path = path.split(".");
    return path.reduce((obj, key) => {
      if (!obj[key]) {
        obj[key] = {};
      }
      return obj[key];
    }, object);
  }
  /** @private */
  __hasConfigurationBuffer(path, property) {
    if (property && path.startsWith(property) && this._jsonConfigurationBuffer && Array.isArray(this._jsonConfigurationBuffer[property])) {
      return get(path.split(".")[1], this._jsonConfigurationBuffer[property][0]);
    }
    return get(path, this._jsonConfigurationBuffer) !== void 0;
  }
  /** @private */
  __updateOrAddCredits(credits) {
    if (this.configuration.credits) {
      this.configuration.credits.update(credits);
    } else {
      this.configuration.addCredits(credits);
    }
  }
  /** @private */
  __updateOrAddAxes(axes, isX, redraw) {
    if (!Array.isArray(axes)) {
      axes = [axes];
    }
    const confAxes = isX ? this.configuration.xAxis : this.configuration.yAxis;
    for (let i = 0; i < axes.length; i++) {
      const axis = axes[i];
      if (confAxes[i]) {
        confAxes[i].update(axis, redraw);
      } else {
        this.configuration.addAxis(axis, isX, redraw);
      }
    }
  }
  /** @private */
  __updateOrAddSeries(series, redraw) {
    if (!Array.isArray(series)) {
      throw new Error("The type of jsonConfiguration.series should be Object[]");
    }
    for (let i = 0; i < series.length; i++) {
      const currentSeries = series[i];
      this.__updateOrAddSeriesInstance(currentSeries, i, redraw);
    }
  }
  /** @private */
  __updateOrAddSeriesInstance(seriesOptions, position, redraw) {
    if (this.configuration.series[position]) {
      this.configuration.series[position].update(seriesOptions, redraw);
    } else {
      this.configuration.addSeries(seriesOptions, redraw);
    }
    return this.configuration.series[position];
  }
  /** @private */
  __updateCategories(categories, config2) {
    if (categories === void 0 || !config2 || this.__hasConfigurationBuffer("xAxis.categories", "xAxis")) {
      return;
    }
    this.__updateOrAddAxes([{ categories }], true);
  }
  /** @private */
  __updateCategoryMax(max4, config2) {
    if (max4 === void 0 || !config2 || this.__hasConfigurationBuffer("xAxis.max", "xAxis")) {
      return;
    }
    if (!isFinite(max4)) {
      console.warn('<vaadin-chart> Acceptable value for "category-max" are Numbers or null');
      return;
    }
    this.__updateOrAddAxes([{ max: max4 }], true);
  }
  /** @private */
  __updateCategoryMin(min4, config2) {
    if (min4 === void 0 || !config2 || this.__hasConfigurationBuffer("xAxis.min", "xAxis")) {
      return;
    }
    if (!isFinite(min4)) {
      console.warn('<vaadin-chart> Acceptable value for "category-min" are Numbers or null');
      return;
    }
    this.__updateOrAddAxes([{ min: min4 }], true);
  }
  /** @private */
  __shouldInvert() {
    if (this.type === "bar" && ["top", "bottom"].indexOf(this.categoryPosition) >= 0) {
      console.warn(`<vaadin-chart> Acceptable "category-position" values for bar charts are
          "left" and "right". For "top" and "bottom" positions please consider using a column chart.`);
      return;
    }
    const inverted = ["left", "right"];
    return inverted.indexOf(this.categoryPosition) >= 0;
  }
  /** @private */
  __shouldFlipOpposite() {
    const opposite = ["top", "right"];
    const oppositeBar = ["right"];
    return (this.type === "bar" ? oppositeBar : opposite).indexOf(this.categoryPosition) >= 0;
  }
  /** @private */
  __updateCategoryPosition(categoryPosition, config2) {
    if (categoryPosition === void 0 || !config2 || this.__hasConfigurationBuffer("chart.inverted")) {
      return;
    }
    const validPositions = ["left", "right", "top", "bottom"];
    if (validPositions.indexOf(categoryPosition) < 0) {
      console.warn(`<vaadin-chart> Acceptable "category-position" values are ${validPositions}`);
      return;
    }
    config2.update({
      chart: {
        inverted: this.__shouldInvert()
      }
    });
    config2.xAxis.forEach(
      (e) => e.update({
        opposite: this.__shouldFlipOpposite()
      })
    );
  }
  /** @private */
  __hideLegend(noLegend, config2) {
    if (noLegend === void 0 || !config2 || this.__hasConfigurationBuffer("legend")) {
      return;
    }
    if (config2.legend) {
      config2.legend.update({ enabled: !noLegend });
    } else {
      config2.legend = { enabled: !noLegend };
    }
  }
  /** @private */
  __updateTitle(title, config2) {
    if (title === void 0 || !config2 || this.__hasConfigurationBuffer("title")) {
      return;
    }
    config2.title.update({ text: title });
  }
  /** @private */
  __tooltipObserver(tooltip, config2) {
    if (tooltip === void 0 || !config2 || this.__hasConfigurationBuffer("tooltip")) {
      return;
    }
    config2.tooltip.update({ enabled: tooltip });
  }
  /** @private */
  __updateType(type, config2) {
    if (type === void 0 || !config2 || this.__hasConfigurationBuffer("chart.type")) {
      return;
    }
    config2.update({
      chart: { type: type || "line" }
    });
  }
  /** @private */
  __updateSubtitle(subtitle, config2) {
    if (subtitle === void 0 || !config2 || this.__hasConfigurationBuffer("subtitle")) {
      return;
    }
    if (!config2.subtitle) {
      config2.setSubtitle({ text: subtitle });
    } else {
      config2.subtitle.update({ text: subtitle });
    }
  }
  /** @private */
  __updateAdditionalOptions(options2) {
    if (this.configuration && options2) {
      this.updateConfiguration(options2);
    }
  }
  /** @private */
  __isStackingValid() {
    if (["normal", "percent", null].indexOf(this.stacking) === -1) {
      this.__showWarn("stacking", '"normal", "percent" or null');
      return false;
    }
    return true;
  }
  /** @private */
  __stackingObserver(stacking, config2) {
    if (stacking === void 0 || !config2 || this.__hasConfigurationBuffer("plotOptions.series.stacking")) {
      return;
    }
    if (!this.__isStackingValid()) {
      this.stacking = null;
      return;
    }
    config2.update({
      plotOptions: {
        series: { stacking }
      }
    });
  }
  /** @private */
  __chart3dObserver(chart3d, config2) {
    if (chart3d === void 0 || !config2 || this.__hasConfigurationBuffer("chart.options3d")) {
      return;
    }
    if (chart3d) {
      config2.update({
        chart: {
          options3d: {
            ...this._baseChart3d,
            ...this.additionalOptions && this.additionalOptions.chart && this.additionalOptions.chart.options3d,
            enabled: true
          }
        }
      });
    } else {
      config2.update({
        chart: {
          options3d: {
            enabled: false
          }
        }
      });
    }
  }
  /** @private */
  __polarObserver(polar, config2) {
    if (polar === void 0 || !config2 || this.__hasConfigurationBuffer("chart.polar")) {
      return;
    }
    config2.update({
      chart: { polar }
    });
  }
  /** @private */
  __emptyTextObserver(emptyText, config2) {
    if (emptyText === void 0 || !config2 || this.__hasConfigurationBuffer("lang.noData")) {
      return;
    }
    config2.update({
      lang: {
        noData: emptyText
      }
    });
    this.__updateNoDataElement(config2);
  }
  /**
   * Force the no data text element to become visible if the chart has no data.
   * This is necessary in cases where Highcharts does not update the element
   * automatically, for example when setting the language config
   * @private
   */
  __updateNoDataElement(config2) {
    const isEmpty = config2.series.every((e) => e.data.length === 0);
    if (isEmpty) {
      config2.hideNoData();
      config2.showNoData(this.emptyText);
    }
  }
  /** @private */
  __callChartFunction(functionName, ...args) {
    if (this.configuration) {
      const functionToCall = this.configuration[functionName];
      if (functionToCall && typeof functionToCall === "function") {
        args.forEach((arg) => inflateFunctions(arg));
        functionToCall.apply(this.configuration, args);
      }
    }
  }
  /** @private */
  __callSeriesFunction(functionName, seriesIndex, ...args) {
    if (this.configuration && this.configuration.series[seriesIndex]) {
      const series = this.configuration.series[seriesIndex];
      const functionToCall = series[functionName];
      if (functionToCall && typeof functionToCall === "function") {
        args.forEach((arg) => inflateFunctions(arg));
        functionToCall.apply(series, args);
      }
    }
  }
  /** @private */
  __callAxisFunction(functionName, axisCategory, axisIndex, ...args) {
    if (this.configuration) {
      let axes;
      switch (axisCategory) {
        case 0:
          axes = this.configuration.xAxis;
          break;
        case 1:
          axes = this.configuration.yAxis;
          break;
        case 2:
          axes = this.configuration.zAxis;
          break;
        case 3:
          axes = this.configuration.colorAxis;
          break;
        default:
          break;
      }
      if (axes && axes[axisIndex]) {
        const axis = axes[axisIndex];
        const functionToCall = axis[functionName];
        if (functionToCall && typeof functionToCall === "function") {
          args.forEach((arg) => inflateFunctions(arg));
          functionToCall.apply(axis, args);
        }
      }
    }
  }
  /** @private */
  __callPointFunction(functionName, seriesIndex, pointIndex, ...args) {
    if (this.configuration && this.configuration.series[seriesIndex] && this.configuration.series[seriesIndex].data[pointIndex]) {
      const point = this.configuration.series[seriesIndex].data[pointIndex];
      const functionToCall = point[functionName];
      if (functionToCall && typeof functionToCall === "function") {
        functionToCall.apply(point, args);
      }
    }
  }
  /**
   * Updates chart container and current chart style property depending on flex status
   * @private
   */
  __updateStyles() {
    const isFlex = getComputedStyle(this).flex !== "0 1 auto";
    if (isFlex) {
      this.style.display = "flex";
      this.$.wrapper.style.display = "flex";
      this.$.chart.style.flex = 1;
    } else {
      this.style.display = "";
      this.$.wrapper.style.display = "";
      this.$.chart.style.flex = "";
    }
  }
  /** @private */
  __showWarn(propertyName, acceptedValues) {
    console.warn(`<vaadin-chart> Acceptable values for "${propertyName}" are ${acceptedValues}`);
  }
  /**
   * @private
   * Workaround for https://github.com/highcharts/highcharts/issues/23443
   * Forces a resize in the chart to make it calculate the labels positions
   * correctly in a chart with "organization" series
   *
   * TODO: Remove when the related ticket is fixed
   */
  __forceResize() {
    const chart = this.configuration;
    const { options: options2 } = chart;
    const hasOrganizationSeries = options2.chart.styledMode && (options2.chart.type === "organization" || options2.series.some((series) => series.type === "organization"));
    if (!hasOrganizationSeries) {
      return;
    }
    requestAnimationFrame(() => {
      chart.setSize(chart.chartWidth - 10, chart.chartHeight);
      chart.setSize(null, null);
    });
  }
  /** @private */
  __onRedraw() {
    this.__checkTurboMode();
  }
  /** @private */
  __checkTurboMode() {
    const isDevelopmentMode = !!window.Vaadin.developmentMode;
    if (!this.configuration || !isDevelopmentMode || this.__turboModeWarningAlreadyLogged) {
      return;
    }
    const exceedsTurboThreshold = this.configuration.series.some((series) => {
      const threshold = series.options && series.options.turboThreshold || 0;
      const dataLength = series.data.length;
      return threshold > 0 && dataLength > threshold;
    });
    if (exceedsTurboThreshold) {
      this.__turboModeWarningAlreadyLogged = true;
      console.warn(
        "<vaadin-chart> Turbo mode has been enabled for one or more series, because the number of data items exceeds the configured threshold. Turbo mode improves the performance of charts with lots of data, but is not compatible with every type of series. Please consult the documentation on compatibility, or how to disable turbo mode."
      );
    }
  }
};

// node_modules/@vaadin/charts/src/vaadin-chart.js
var Chart2 = class extends ChartMixin(ThemableMixin(ElementMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-chart";
  }
  static get cvdlName() {
    return "vaadin-chart";
  }
  static get styles() {
    return chartStyles;
  }
  static get lumoInjector() {
    return { ...super.lumoInjector, includeBaseStyles: true };
  }
  /** @protected */
  render() {
    return html`
      <div id="wrapper" style="height: 100%; width: 100%; position: relative;">
        <div id="chart" style="height: 100%; width: 100%; position: absolute;"></div>
      </div>
      <slot id="slot"></slot>
    `;
  }
};
defineCustomElement(Chart2);
export {
  Chart2 as Chart
};
//# sourceMappingURL=@vaadin_charts_src_vaadin-chart__js.js.map
