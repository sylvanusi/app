import {
  Scroller
} from "./chunk-TP5B4ZSZ.js";
import {
  OverflowController
} from "./chunk-NSMHBY24.js";
import {
  loaderStyles
} from "./chunk-TG7PZOH5.js";
import {
  DelegateStateMixin
} from "./chunk-SFISAMYO.js";
import {
  SlotController
} from "./chunk-X5EEA4XV.js";
import {
  generateUniqueId
} from "./chunk-Z5LHTDPJ.js";
import {
  SlotObserver
} from "./chunk-VNVGWFKZ.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/tabsheet/src/vaadin-tabsheet-scroller.js
var TabsheetScroller = class extends Scroller {
  static get is() {
    return "vaadin-tabsheet-scroller";
  }
};
defineCustomElement(TabsheetScroller);

// node_modules/@vaadin/tabsheet/src/styles/vaadin-tabsheet-base-styles.js
var tabSheetStyles = [
  loaderStyles,
  css`
    :host {
      display: flex;
      flex-direction: column;
      border: var(--vaadin-tabsheet-border-width, 1px) solid
        var(--vaadin-tabsheet-border-color, var(--vaadin-border-color-secondary));
      border-radius: var(--vaadin-tabsheet-border-radius, var(--vaadin-radius-l));
      overflow: hidden;
    }

    :host([hidden]) {
      display: none !important;
    }

    [part='tabs-container'] {
      position: relative;
      display: flex;
      align-items: center;
      gap: var(--vaadin-tabsheet-gap, var(--vaadin-gap-s));
      padding: var(--vaadin-tabsheet-padding, var(--vaadin-padding-m));
      box-sizing: border-box;
    }

    ::slotted([slot='tabs']) {
      flex: 1;
      align-self: stretch;
      min-width: 128px;
    }

    ::slotted([hidden]) {
      display: none !important;
    }

    [part='content'] {
      position: relative;
      flex: 1;
      box-sizing: border-box;
      --vaadin-scroller-padding-block: var(--vaadin-tabsheet-padding, var(--vaadin-padding-m));
      --vaadin-scroller-padding-inline: var(--vaadin-tabsheet-padding, var(--vaadin-padding-m));
      --vaadin-scroller-overflow-indicator-top-opacity: 1;
    }

    [part='content'][focus-ring] {
      border-bottom-left-radius: inherit;
      border-bottom-right-radius: inherit;
      outline-offset: calc(var(--vaadin-focus-ring-width) * -1);
    }

    :host([loading]) [part='content'] {
      align-content: center;
    }

    [part='loader'] {
      margin: auto;
    }

    :host([theme~='no-border']) {
      border: 0;
      border-radius: 0;
    }

    :host([theme~='no-padding']) [part='content'] {
      padding: 0 !important;
      --vaadin-scroller-padding-block: 0px !important;
      --vaadin-scroller-padding-inline: 0px !important;
    }
  `
];

// node_modules/@vaadin/tabsheet/src/vaadin-tabsheet-mixin.js
var TabsSlotController = class extends SlotController {
  constructor(host) {
    super(host, "tabs");
    this.__tabsItemsChangedListener = this.__tabsItemsChangedListener.bind(this);
    this.__tabsSelectedChangedListener = this.__tabsSelectedChangedListener.bind(this);
    this.__tabIdObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        const tab = mutation.target;
        host.__linkTabAndPanel(tab);
        if (tab.selected) {
          host.__togglePanels(tab);
        }
      });
    });
  }
  /** @private */
  __tabsItemsChangedListener() {
    this.__tabIdObserver.disconnect();
    const items = this.tabs.items || [];
    items.forEach((tab) => {
      this.__tabIdObserver.observe(tab, {
        attributeFilter: ["id"]
      });
    });
    this.host._setItems(items);
  }
  /** @private */
  __tabsSelectedChangedListener() {
    this.host.selected = this.tabs.selected;
  }
  initCustomNode(tabs) {
    if (!(tabs instanceof customElements.get("vaadin-tabs"))) {
      throw Error('The "tabs" slot of a <vaadin-tabsheet> must only contain a <vaadin-tabs> element!');
    }
    this.tabs = tabs;
    tabs.addEventListener("items-changed", this.__tabsItemsChangedListener);
    tabs.addEventListener("selected-changed", this.__tabsSelectedChangedListener);
    this.host.__tabs = tabs;
    this.host.stateTarget = tabs;
    this.__tabsItemsChangedListener();
  }
  teardownNode(tabs) {
    this.tabs = null;
    tabs.removeEventListener("items-changed", this.__tabsItemsChangedListener);
    tabs.removeEventListener("selected-changed", this.__tabsSelectedChangedListener);
    this.host.__tabs = null;
    this.host._setItems([]);
    this.host.stateTarget = void 0;
  }
};
var TabSheetMixin = (superClass) => class extends DelegateStateMixin(superClass) {
  static get properties() {
    return {
      /**
       * A read-only list of `<vaadin-tab>`s from which a selection can be made.
       * It is populated from the elements passed inside the slotted
       * `<vaadin-tabs>`, and updated dynamically when adding or removing items.
       * @type {!Array<!Tab> | undefined}
       */
      items: {
        type: Array,
        readOnly: true,
        notify: true
      },
      /**
       * The index of the selected tab.
       */
      selected: {
        value: 0,
        type: Number,
        notify: true
      },
      /**
       * The slotted <vaadin-tabs> element.
       */
      __tabs: {
        type: Object
      },
      /**
       * The panel elements.
       */
      __panels: {
        type: Array
      }
    };
  }
  static get observers() {
    return ["__itemsOrPanelsChanged(items, __panels)", "__selectedTabItemChanged(selected, items, __panels)"];
  }
  /** @override */
  static get delegateProps() {
    return ["selected", "_theme"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.__overflowController = new OverflowController(this, this.shadowRoot.querySelector('[part="content"]'));
    this.addController(this.__overflowController);
    this._tabsSlotController = new TabsSlotController(this);
    this.addController(this._tabsSlotController);
    const panelSlot = this.shadowRoot.querySelector("#panel-slot");
    this.__panelsObserver = new SlotObserver(panelSlot, ({ addedNodes, removedNodes }) => {
      if (addedNodes.length) {
        addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE && node.hidden) {
            node.__customHidden = true;
          }
        });
      }
      if (removedNodes.length) {
        removedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE && node.hidden) {
            if (node.__customHidden) {
              delete node.__customHidden;
            } else {
              node.hidden = false;
            }
          }
        });
      }
      this.__panels = Array.from(
        panelSlot.assignedNodes({
          flatten: true
        })
      ).filter((node) => node.nodeType === Node.ELEMENT_NODE);
    });
  }
  /**
   * Override method from `DelegateStateMixin` to set delegate `theme`
   * using attribute instead of property (needed for the Lit version).
   * @protected
   * @override
   */
  _delegateProperty(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "_theme") {
      this._delegateAttribute("theme", value);
      return;
    }
    super._delegateProperty(name, value);
  }
  /**
   * An observer which applies the necessary roles and ARIA attributes
   * to associate the tab elements with the panels.
   * @private
   */
  __itemsOrPanelsChanged(items, panels) {
    if (!items || !panels) {
      return;
    }
    items.forEach((tabItem) => {
      this.__linkTabAndPanel(tabItem, panels);
    });
  }
  /**
   * An observer which toggles the visibility of the panels based on the selected tab.
   * @private
   */
  __selectedTabItemChanged(selected, items, panels) {
    if (!items || !panels || selected === void 0) {
      return;
    }
    this.__togglePanels(items[selected], panels);
  }
  /** @private */
  __togglePanels(selectedTab, panels = this.__panels) {
    const selectedTabId = selectedTab ? selectedTab.id : "";
    const selectedPanel = panels.find((panel) => panel.getAttribute("tab") === selectedTabId);
    const content = this.shadowRoot.querySelector('[part="content"]');
    this.toggleAttribute("loading", !selectedPanel);
    const hasOneVisiblePanel = panels.filter((panel) => !panel.hidden).length === 1;
    if (selectedPanel) {
      content.style.minHeight = "";
    } else if (hasOneVisiblePanel) {
      content.style.minHeight = `${content.offsetHeight}px`;
    }
    panels.forEach((panel) => {
      panel.hidden = panel !== selectedPanel;
    });
  }
  /** @private */
  __linkTabAndPanel(tab, panels = this.__panels) {
    const panel = panels.find((panel2) => panel2.getAttribute("tab") === tab.id);
    if (panel) {
      panel.role = "tabpanel";
      if (!panel.id) {
        panel.id = `tabsheet-panel-${generateUniqueId()}`;
      }
      panel.setAttribute("aria-labelledby", tab.id);
      tab.setAttribute("aria-controls", panel.id);
    }
  }
};

// node_modules/@vaadin/tabsheet/src/vaadin-tabsheet.js
var TabSheet = class extends TabSheetMixin(ThemableMixin(ElementMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-tabsheet";
  }
  static get styles() {
    return tabSheetStyles;
  }
  /** @protected */
  render() {
    return html`
      <div part="tabs-container">
        <slot name="prefix"></slot>
        <slot name="tabs"></slot>
        <slot name="suffix"></slot>
      </div>

      <vaadin-tabsheet-scroller part="content">
        <div part="loader"></div>
        <slot id="panel-slot"></slot>
      </vaadin-tabsheet-scroller>
    `;
  }
};
defineCustomElement(TabSheet);

export {
  TabSheet
};
//# sourceMappingURL=chunk-3R5L4NZD.js.map
