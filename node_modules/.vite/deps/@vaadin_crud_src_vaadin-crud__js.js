import {
  Grid,
  gridStyles
} from "./chunk-HFI5WLB3.js";
import "./chunk-NSMHBY24.js";
import "./chunk-7JJPFFGU.js";
import "./chunk-NKWOPJ2S.js";
import "./chunk-IVWWZXZF.js";
import {
  DialogBaseMixin
} from "./chunk-6GII5WG7.js";
import "./chunk-6QV6LNZP.js";
import "./chunk-MNTMWC4G.js";
import {
  FormLayout
} from "./chunk-UVWSZKWE.js";
import "./chunk-ZZVQ6C3W.js";
import {
  dialogOverlayStyles
} from "./chunk-7QAQCWIA.js";
import {
  MediaQueryController
} from "./chunk-QMCKCKIE.js";
import {
  capitalize,
  createField,
  createFields,
  getProperty,
  isValidEditorPosition,
  setProperty
} from "./chunk-J7Z2A7BX.js";
import "./chunk-Y26XBQLX.js";
import "./chunk-K6BWFOYR.js";
import "./chunk-TZCAYWP4.js";
import "./chunk-6KHZPEKJ.js";
import "./chunk-DIP5G4YG.js";
import "./chunk-ETYEORRM.js";
import "./chunk-F6FMTQFS.js";
import "./chunk-SP7V2F3Y.js";
import {
  ifDefined
} from "./chunk-OSWHV746.js";
import {
  FocusRestorationController,
  OverlayMixin
} from "./chunk-PFI4EOEJ.js";
import "./chunk-4QGJQDIU.js";
import "./chunk-6KCLDTNY.js";
import "./chunk-C63QNJWN.js";
import "./chunk-2WIP7T36.js";
import "./chunk-ZZO67D7M.js";
import "./chunk-WJXDM45A.js";
import "./chunk-722MDOVI.js";
import "./chunk-ME7RDPE7.js";
import "./chunk-R7PLRAV7.js";
import "./chunk-SFISAMYO.js";
import "./chunk-44TEYO45.js";
import "./chunk-XFKQJ73Z.js";
import {
  SlotController
} from "./chunk-X5EEA4XV.js";
import "./chunk-Z5LHTDPJ.js";
import "./chunk-VNVGWFKZ.js";
import {
  I18nMixin
} from "./chunk-WSKWP5BQ.js";
import "./chunk-T3UXCKHJ.js";
import "./chunk-472KGBTN.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  Debouncer
} from "./chunk-OWHE56FA.js";
import "./chunk-YZIAODF7.js";
import "./chunk-GXEMU344.js";
import "./chunk-ZBUMLMW2.js";
import "./chunk-EIHDKHUQ.js";
import "./chunk-5W5MB6YY.js";
import "./chunk-M3HWWZVG.js";
import "./chunk-WT6HVPMS.js";
import "./chunk-ERLMGG3V.js";
import "./chunk-SVPOVVYN.js";
import "./chunk-5DESY7LS.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import "./chunk-ULNR4UH6.js";
import {
  ThemableMixin,
  ThemePropertyMixin
} from "./chunk-MKNWHZM7.js";
import "./chunk-TMRBPE5K.js";
import {
  DirMixin
} from "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html,
  nothing,
  render
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";
import {
  timeOut
} from "./chunk-MWWP2LZ3.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/crud/src/styles/vaadin-crud-dialog-overlay-base-styles.js
var crudDialogOverlay = css`
  [part='header'] {
    color: var(--vaadin-dialog-title-color, var(--vaadin-text-color));
    font-size: var(--vaadin-dialog-title-font-size, 1em);
    font-weight: var(--vaadin-dialog-title-font-weight, 600);
    line-height: var(--vaadin-dialog-title-line-height, inherit);
    padding: var(--vaadin-crud-header-padding, var(--vaadin-dialog-padding, var(--vaadin-padding-l)));
  }

  ::slotted([slot='header']) {
    color: inherit !important;
    display: contents;
    font: inherit !important;
    overflow-wrap: anywhere;
  }

  :host(:is(*, #id)) [part='content'] {
    overflow: auto;
    overscroll-behavior: contain;
    padding: var(--vaadin-crud-form-padding, var(--vaadin-padding-l));
    padding-top: 0;
  }

  ::slotted([slot='form']) {
    --vaadin-crud-form-padding: 0;
  }

  [part='footer'] {
    justify-content: normal;
    background: var(--vaadin-crud-footer-background, transparent);
    border-top: var(--vaadin-crud-border-width, 1px) solid
      var(--vaadin-crud-border-color, var(--vaadin-border-color-secondary));
  }
`;
var crudDialogOverlayStyles = [...dialogOverlayStyles, crudDialogOverlay];

// node_modules/@vaadin/crud/src/vaadin-crud-dialog.js
var CrudDialogOverlay = class extends OverlayMixin(DirMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-crud-dialog-overlay";
  }
  static get styles() {
    return crudDialogOverlayStyles;
  }
  /**
   * Override method from OverlayFocusMixin to use dialog as focus trap root
   * @protected
   * @override
   */
  get _focusTrapRoot() {
    return this.getRootNode().host;
  }
  /** @protected */
  render() {
    return html`
      <div part="backdrop" id="backdrop" ?hidden="${!this.withBackdrop}"></div>
      <div part="overlay" id="overlay">
        <section id="resizerContainer" class="resizer-container">
          <header part="header">
            <slot name="header"></slot>
          </header>
          <div part="content" id="content">
            <slot name="form"></slot>
          </div>
          <footer part="footer" role="toolbar">
            <slot name="save-button"></slot>
            <slot name="cancel-button"></slot>
            <slot name="delete-button"></slot>
          </footer>
        </section>
      </div>
    `;
  }
  /**
   * @protected
   * @override
   */
  ready() {
    super.ready();
    this.setAttribute("has-header", "");
    this.setAttribute("has-footer", "");
  }
};
defineCustomElement(CrudDialogOverlay);
var CrudDialog = class extends DialogBaseMixin(ThemePropertyMixin(PolylitMixin(LitElement))) {
  static get is() {
    return "vaadin-crud-dialog";
  }
  static get styles() {
    return css`
      :host([opened]),
      :host([opening]),
      :host([closing]) {
        display: block !important;
        position: absolute;
      }

      :host,
      :host([hidden]) {
        display: none !important;
      }

      :host(:focus-visible) ::part(overlay) {
        outline: var(--vaadin-focus-ring-width) solid var(--vaadin-focus-ring-color);
      }
    `;
  }
  static get properties() {
    return {
      fullscreen: {
        type: Boolean
      },
      crudElement: {
        type: Object
      }
    };
  }
  /** @protected */
  render() {
    return html`
      <vaadin-crud-dialog-overlay
        id="overlay"
        .owner="${this.crudElement}"
        .opened="${this.opened}"
        @opened-changed="${this._onOverlayOpened}"
        @mousedown="${this._bringOverlayToFront}"
        @touchstart="${this._bringOverlayToFront}"
        @vaadin-overlay-outside-click="${this.__cancel}"
        @vaadin-overlay-escape-press="${this.__cancel}"
        theme="${ifDefined(this._theme)}"
        .modeless="${this.modeless}"
        .withBackdrop="${!this.modeless}"
        ?fullscreen="${this.fullscreen}"
        focus-trap
        exportparts="backdrop, overlay, header, content, footer"
      >
        <slot name="header" slot="header"></slot>
        <slot name="form" slot="form"></slot>
        <slot name="save-button" slot="save-button"></slot>
        <slot name="cancel-button" slot="cancel-button"></slot>
        <slot name="delete-button" slot="delete-button"></slot>
      </vaadin-crud-dialog-overlay>
    `;
  }
  /** @private **/
  __cancel() {
    this.dispatchEvent(new CustomEvent("cancel"));
  }
};
defineCustomElement(CrudDialog);

// node_modules/@vaadin/grid/src/styles/vaadin-grid-filter-base-styles.js
var gridFilterStyles = css`
  :host {
    display: inline-flex;
    max-width: 100%;
  }

  ::slotted(*) {
    width: 100%;
    box-sizing: border-box;
  }
`;

// node_modules/@vaadin/grid/src/vaadin-grid-filter-element-mixin.js
var GridFilterElementMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      /**
       * JS Path of the property in the item used for filtering the data.
       */
      path: {
        type: String,
        sync: true
      },
      /**
       * Current filter value.
       */
      value: {
        type: String,
        notify: true,
        sync: true
      },
      /** @private */
      _textField: {
        type: Object,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_filterChanged(path, value, _textField)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this._filterController = new SlotController(this, "", "vaadin-text-field", {
      initializer: (field) => {
        field.addEventListener("input", (e) => {
          this.value = e.target.value;
        });
        this._textField = field;
      }
    });
    this.addController(this._filterController);
  }
  /** @private */
  _filterChanged(path, value, textField) {
    if (path === void 0 || value === void 0 || !textField) {
      return;
    }
    textField.value = value;
    this._debouncerFilterChanged = Debouncer.debounce(this._debouncerFilterChanged, timeOut.after(200), () => {
      this.dispatchEvent(new CustomEvent("filter-changed", { bubbles: true }));
    });
  }
  focus() {
    if (this._textField) {
      this._textField.focus();
    }
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-filter.js
var GridFilter = class extends GridFilterElementMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement)))) {
  static get is() {
    return "vaadin-grid-filter";
  }
  static get styles() {
    return gridFilterStyles;
  }
  /** @protected */
  render() {
    return html`<slot></slot>`;
  }
};
defineCustomElement(GridFilter);

// node_modules/@vaadin/crud/src/styles/vaadin-crud-grid-base-styles.js
var crudGrid = css`
  #scroller {
    border-radius: inherit;
  }
`;
var crudGridStyles = [gridStyles, crudGrid];

// node_modules/@vaadin/crud/src/vaadin-crud-include-mixin.js
var IncludedMixin = (superClass) => class IncludedMixin extends superClass {
  static get properties() {
    return {
      /**
       * A list of item fields that should not be mapped to form fields.
       *
       * When [`include`](#/elements/vaadin-crud-form#property-include) is defined, this property is ignored.
       *
       * Default is to exclude any private property.
       *
       * @type {string | RegExp}
       */
      exclude: {
        value: "^_",
        observer: "__onExcludeChange",
        sync: true
      },
      /**
       * A list of item properties that should be mapped to form fields.
       *
       * When it is defined [`exclude`](#/elements/vaadin-crud-form#property-exclude) is ignored.
       *
       * @type {string | !Array<string> | undefined}
       */
      include: {
        observer: "__onIncludeChange",
        sync: true
      }
    };
  }
  /** @private */
  __onExcludeChange(exclude) {
    if (typeof exclude === "string") {
      this.exclude = exclude ? RegExp(exclude.replace(/, */gu, "|"), "iu") : void 0;
    }
  }
  /** @private */
  __onIncludeChange(include) {
    if (typeof include === "string") {
      this.include = include ? include.split(/, */u) : void 0;
    } else if (!this._fields && Array.isArray(include)) {
      const item = {};
      this.include.forEach((path) => {
        setProperty(path, null, item);
      });
      this._configure(item);
    }
  }
};

// node_modules/@vaadin/crud/src/vaadin-crud-grid-mixin.js
var CrudGridMixin = (superClass) => class extends IncludedMixin(superClass) {
  static get properties() {
    return {
      /**
       * Disable filtering in the generated columns.
       * @attr {boolean} no-filter
       */
      noFilter: Boolean,
      /**
       * Disable sorting in the generated columns.
       * @attr {boolean} no-sort
       */
      noSort: Boolean,
      /**
       * Do not add headers to columns.
       * @attr {boolean} no-head
       */
      noHead: Boolean,
      /**
       * Determines whether the edit column should be hidden.
       * @attr {boolean} hide-edit-column
       */
      hideEditColumn: {
        type: Boolean,
        sync: true
      }
    };
  }
  static get observers() {
    return ["__onItemsChange(items)", "__onHideEditColumnChange(hideEditColumn)"];
  }
  /** @private */
  __onItemsChange(items) {
    if ((!this.dataProvider || this.dataProvider === this._arrayDataProvider) && !this.include && items && items[0]) {
      this._configure(items[0]);
    }
  }
  /** @private */
  __onHideEditColumnChange() {
    if (this.firstChild) {
      this.__toggleEditColumn();
    }
  }
  /** @private */
  __toggleEditColumn() {
    let editColumn = this.querySelector("vaadin-crud-edit-column");
    if (this.hideEditColumn) {
      if (editColumn) {
        this.removeChild(editColumn);
      }
    } else if (!editColumn) {
      editColumn = document.createElement("vaadin-crud-edit-column");
      editColumn.frozenToEnd = true;
      this.appendChild(editColumn);
    }
  }
  /** @private */
  __dataProviderWrapper(params, callback) {
    this.__dataProvider(params, (items, size) => {
      if (this.innerHTML === "" && !this.include && items[0]) {
        this._configure(items[0]);
      }
      callback(items, size);
    });
  }
  /**
   * @override
   * @private
   */
  _dataProviderChanged(dataProvider, oldDataProvider) {
    if (this._arrayDataProvider === dataProvider) {
      super._dataProviderChanged(dataProvider, oldDataProvider);
    } else if (this.__dataProviderWrapper !== dataProvider) {
      this.innerHTML = "";
      this.__dataProvider = dataProvider;
      this.dataProvider = this.__dataProviderWrapper;
      super._dataProviderChanged(this.__dataProviderWrapper, oldDataProvider);
    }
  }
  /**
   * Auto-generate grid columns based on the JSON structure of the object provided.
   *
   * Method will be executed when items or dataProvider is assigned.
   * @private
   */
  _configure(item) {
    this.innerHTML = "";
    this.__createColumns(this, item, void 0, this.__getPropertyDepth(item));
    this.__toggleEditColumn();
  }
  /**
   * Return the deepest property depth of the object
   * @private
   */
  __getPropertyDepth(object) {
    if (!object || typeof object !== "object") {
      return 0;
    }
    return Object.keys(object).reduce((deepest, prop) => {
      if (this.exclude && this.exclude.test(prop)) {
        return deepest;
      }
      return Math.max(deepest, 1 + this.__getPropertyDepth(object[prop]));
    }, 0);
  }
  /**
   * Parse the camelCase column names into sentence case headers.
   * @param {string} path
   * @return {string}
   * @protected
   */
  _generateHeader(path) {
    return path.substr(path.lastIndexOf(".") + 1).replace(/([A-Z])/gu, "-$1").toLowerCase().replace(/-/gu, " ").replace(/^./u, (match) => match.toUpperCase());
  }
  /** @private */
  __createColumn(parent, path) {
    let col;
    if (!this.noFilter && !this.noSort && !parent.__sortColumnGroup) {
      col = this.__createGroup(parent);
      col.__sortColumnGroup = true;
      this.__createColumn(col, path);
    } else {
      col = document.createElement("vaadin-grid-column");
      parent.appendChild(col);
      col.renderer = (root, _column, model) => {
        root.textContent = path ? getProperty(path, model.item) : model.item;
      };
    }
    if (!this.noHead && path) {
      col.headerRenderer = (root) => {
        if (root.firstElementChild) {
          return;
        }
        const label = this._generateHeader(path);
        if (col.__sortColumnGroup || this.noFilter && !this.noSort) {
          const sorter = document.createElement("vaadin-grid-sorter");
          sorter.setAttribute("path", path);
          sorter.setAttribute("aria-label", `Sort by ${label}`);
          sorter.textContent = label;
          root.appendChild(sorter);
        } else if (!this.noFilter) {
          const filter = document.createElement("vaadin-grid-filter");
          filter.setAttribute("path", path);
          filter.setAttribute("aria-label", `Filter by ${label}`);
          filter.style.display = "flex";
          const textField = window.document.createElement("vaadin-text-field");
          textField.setAttribute("theme", "small");
          textField.setAttribute("focus-target", true);
          textField.style.width = "100%";
          if (this.noSort) {
            textField.placeholder = label;
          }
          textField.addEventListener("value-changed", (event) => {
            filter.value = event.detail.value;
          });
          filter.appendChild(textField);
          root.appendChild(filter);
        } else if (this.noSort && this.noFilter) {
          root.textContent = label;
        }
      };
    }
  }
  /**
   * Creates the column structure for the (sub)object.
   *
   * @param {HTMLElement} parent May be the crud-grid or a column group.
   * @param {Object} object The object to create the sub-columns for.
   * @param {string} path The property path from the root item to the object.
   * @param {number} depth The depth of the object in the object hierarchy.
   * @private
   */
  __createColumns(parent, object, path, depth) {
    if (object && typeof object === "object") {
      Object.keys(object).forEach((prop) => {
        if (!this.include && this.exclude && this.exclude.test(prop)) {
          return;
        }
        const subObject = object[prop];
        const subObjectPath = path ? `${path}.${prop}` : prop;
        let subObjectColumn = parent;
        if (!this.noHead && depth > 1) {
          const isSubObject = subObject && typeof subObject === "object";
          subObjectColumn = this.__createGroup(parent, isSubObject ? prop : void 0);
        }
        this.__createColumns(subObjectColumn, subObject, subObjectPath, depth - 1);
      });
    } else if (depth > 1) {
      this.__createColumns(this.__createGroup(parent), void 0, path, depth - 1);
    } else {
      this.__createColumn(parent, path);
    }
  }
  /** @private */
  __createGroup(parent, header) {
    const grp = document.createElement("vaadin-grid-column-group");
    if (header) {
      grp.header = capitalize(header);
    }
    parent.appendChild(grp);
    return grp;
  }
};

// node_modules/@vaadin/crud/src/vaadin-crud-grid.js
var CrudGrid = class extends CrudGridMixin(Grid) {
  static get is() {
    return "vaadin-crud-grid";
  }
  static get styles() {
    return crudGridStyles;
  }
};
defineCustomElement(CrudGrid);

// node_modules/@vaadin/crud/src/vaadin-crud-form.js
var CrudForm = class extends IncludedMixin(FormLayout) {
  static get is() {
    return "vaadin-crud-form";
  }
  static get properties() {
    return {
      /**
       * The item being edited.
       * @type {unknown}
       */
      item: {
        type: Object,
        sync: true
      }
    };
  }
  static get observers() {
    return ["__onItemChange(item)"];
  }
  /**
   * Auto-generate form fields based on the JSON structure of the object provided.
   *
   * If not called, the method will be executed the first time an item is assigned.
   * @param {unknown} object
   * @protected
   */
  _configure(object) {
    this.innerHTML = "";
    this._fields = [];
    this.__createFields(this, object);
    this._updateLayout();
  }
  /** @private */
  __onItemChange(item) {
    if (!this._fields) {
      this._configure(item);
    }
  }
  /** @private */
  __createField(parent, path) {
    return createField(this, parent, path);
  }
  /** @private */
  __createFields(parent, object, path) {
    return createFields(this, parent, object, path);
  }
};
defineCustomElement(CrudForm);

// node_modules/@vaadin/crud/src/styles/vaadin-crud-base-styles.js
var crudStyles = css`
  :host {
    --vaadin-grid-border-width: 0px;
    --vaadin-grid-border-radius: var(--vaadin-crud-border-radius, var(--vaadin-radius-l));
    --vaadin-crud-editor-max-height: 40%;
    --vaadin-crud-editor-max-width: 40%;
    border: var(--vaadin-crud-border-width, 1px) solid
      var(--vaadin-crud-border-color, var(--vaadin-border-color-secondary));
    border-radius: var(--vaadin-crud-border-radius, var(--vaadin-radius-m));
    height: 400px;
    width: 100%;
    background: var(--vaadin-crud-background, var(--vaadin-background-color));
  }

  :host,
  #main {
    align-self: stretch;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  #main {
    flex: 1 1 100%;
    height: 100%;
    min-width: 0;
    min-height: 0;
  }

  ::slotted(vaadin-crud-grid) {
    border-end-start-radius: 0;
    border-end-end-radius: 0;
  }

  :host([hidden]),
  [hidden] {
    display: none !important;
  }

  #container {
    display: flex;
    height: 100%;
  }

  :host([editor-position='bottom']) #container {
    flex-direction: column;
  }

  :host([editor-position='aside'][editor-opened]) #main {
    border-inline-end: var(--vaadin-crud-border-width, 1px) solid
      var(--vaadin-crud-border-color, var(--vaadin-border-color-secondary));
  }

  :host([editor-position='aside'][editor-opened]) ::slotted(vaadin-crud-grid) {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host([editor-position='aside'][editor-opened]) :is(#container, [part='editor']) {
    border-start-end-radius: inherit;
    border-end-end-radius: inherit;
  }

  :host([editor-position='bottom'][editor-opened]) #main {
    border-bottom: var(--vaadin-crud-border-width, 1px) solid
      var(--vaadin-crud-border-color, var(--vaadin-border-color-secondary));
  }

  :host([editor-position='bottom'][editor-opened]) :is(#container, [part='editor']) {
    border-end-start-radius: inherit;
    border-end-end-radius: inherit;
  }

  [part='toolbar'] {
    align-items: baseline;
    background: var(--vaadin-crud-toolbar-background, transparent);
    border-top: var(--vaadin-crud-border-width, 1px) solid
      var(--vaadin-crud-border-color, var(--vaadin-border-color-secondary));
    display: flex;
    flex-shrink: 0;
    justify-content: flex-end;
    padding: var(--vaadin-crud-toolbar-padding, var(--vaadin-dialog-padding, var(--vaadin-padding-l)));
  }

  :host([no-toolbar]) [part='toolbar'] {
    display: none;
  }

  [part='editor'] {
    display: flex;
    flex-direction: column;
    height: 100%;
    z-index: 1;
  }

  [part='editor']:focus-visible {
    outline: var(--vaadin-focus-ring-width) solid var(--vaadin-focus-ring-color);
  }

  :host(:not([editor-position=''])[editor-opened]:not([fullscreen])) [part='editor'] {
    flex: 1 0 100%;
  }

  :host([editor-position='bottom'][editor-opened]:not([fullscreen])) [part='editor'] {
    max-height: var(--vaadin-crud-editor-max-height);
  }

  :host([editor-position='aside'][editor-opened]:not([fullscreen])) [part='editor'] {
    max-width: var(--vaadin-crud-editor-max-width);
    min-width: 300px;
  }

  [part='scroller'] {
    display: flex;
    flex: auto;
    flex-direction: column;
    overflow: auto;
  }

  [part='header'] {
    color: var(--vaadin-crud-header-color, var(--vaadin-dialog-title-color, var(--vaadin-text-color)));
    font-size: var(--vaadin-crud-header-font-size, var(--vaadin-dialog-title-font-size, 1em));
    font-weight: var(--vaadin-crud-header-font-weight, var(--vaadin-dialog-title-font-weight, 600));
    line-height: var(--vaadin-crud-header-line-height, var(--vaadin-dialog-title-line-height, inherit));
    padding: var(--vaadin-crud-header-padding, var(--vaadin-dialog-padding, var(--vaadin-padding-l)));
  }

  ::slotted([slot='header']) {
    color: inherit !important;
    display: contents;
    font: inherit !important;
    overflow-wrap: anywhere;
  }

  ::slotted([slot='form']) {
    padding: var(--vaadin-crud-form-padding, var(--vaadin-dialog-padding, var(--vaadin-padding-l)));
    padding-top: 0;
  }

  [part='footer'] {
    background: var(--vaadin-crud-footer-background, transparent);
    border-top: var(--vaadin-crud-border-width, 1px) solid
      var(--vaadin-crud-border-color, var(--vaadin-border-color-secondary));
    display: flex;
    flex: none;
    gap: var(--vaadin-crud-footer-gap, var(--vaadin-gap-s));
    padding: var(--vaadin-crud-footer-padding, var(--vaadin-dialog-padding, var(--vaadin-padding-l)));
  }

  ::slotted([slot='delete-button']) {
    margin-inline-start: auto;
  }

  :host([theme~='no-border']) {
    border: 0;
    border-radius: 0;
  }
`;

// node_modules/@vaadin/crud/src/vaadin-crud-controllers.js
var ButtonSlotController = class extends SlotController {
  constructor(host, type, theme, noDefaultNode) {
    super(host, `${type}-button`, noDefaultNode ? null : "vaadin-button");
    this.type = type;
    this.theme = theme;
  }
  /**
   * Override method inherited from `SlotController`
   * to mark custom slotted button as the default.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initNode(node) {
    if (!node) {
      return;
    }
    if (node._isDefault) {
      this.defaultNode = node;
    }
    if (node === this.defaultNode && this.theme && !node.hasAttribute("theme")) {
      node.setAttribute("theme", this.theme);
    }
    const { host, type } = this;
    const property = `_${type}Button`;
    const listener = `__${type}`;
    if (host[property] && host[property] !== node) {
      host[property].remove();
    }
    node.addEventListener("click", host[listener]);
    host[property] = node;
  }
};
var FormSlotController = class extends SlotController {
  constructor(host) {
    super(host, "form", "vaadin-crud-form");
  }
  /**
   * Override method inherited from `SlotController`
   * to move slotted form to the overlay if needed.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initNode(node) {
    this.host._form = node;
    if (this.host.editorOpened) {
      this.host.__ensureChildren();
    }
  }
};
var GridSlotController = class extends SlotController {
  constructor(host) {
    super(host, "grid", "vaadin-crud-grid");
  }
  /**
   * Override method inherited from `SlotController`
   * to initialize `active-item-changed` listener.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initNode(node) {
    const { host } = this;
    queueMicrotask(() => {
      host.__editOnClickChanged(false, host._grid);
      host._grid = node;
      host.__editOnClickChanged(host.editOnClick, host._grid);
    });
  }
};

// node_modules/@vaadin/crud/src/vaadin-crud-mixin.js
var DEFAULT_I18N = {
  newItem: "New item",
  editItem: "Edit item",
  saveItem: "Save",
  cancel: "Cancel",
  deleteItem: "Delete...",
  editLabel: "Edit",
  confirm: {
    delete: {
      title: "Delete item",
      content: "Are you sure you want to delete this item? This action cannot be undone.",
      button: {
        confirm: "Delete",
        dismiss: "Cancel"
      }
    },
    cancel: {
      title: "Discard changes",
      content: "There are unsaved changes to this item.",
      button: {
        confirm: "Discard",
        dismiss: "Cancel"
      }
    }
  }
};
var CrudMixin = (superClass) => class extends I18nMixin(DEFAULT_I18N, superClass) {
  static get properties() {
    return {
      /**
       * A reference to the grid used for displaying the item list
       * @private
       */
      _grid: {
        type: Object,
        observer: "__gridChanged"
      },
      /**
       * A reference to the editor component which will be teleported to the dialog
       * @private
       */
      _form: {
        type: Object,
        observer: "__formChanged"
      },
      /**
       * A reference to the save button which will be teleported to the dialog
       * @private
       */
      _saveButton: {
        type: Object
      },
      /**
       * A reference to the delete button which will be teleported to the dialog
       * @private
       */
      _deleteButton: {
        type: Object
      },
      /**
       * A reference to the cancel button which will be teleported to the dialog
       * @private
       */
      _cancelButton: {
        type: Object
      },
      /**
       * A reference to the default editor header element created by the CRUD
       * @private
       */
      _defaultHeader: {
        type: Object
      },
      /**
       * A reference to the "New item" button
       * @private
       */
      _newButton: {
        type: Object
      },
      /**
       * An array containing the items which will be stamped to the column template instances.
       * @type {Array<unknown> | undefined}
       */
      items: {
        type: Array,
        notify: true,
        observer: "__itemsChanged",
        sync: true
      },
      /**
       * The item being edited in the dialog.
       * @type {unknown}
       */
      editedItem: {
        type: Object,
        observer: "__editedItemChanged",
        notify: true,
        sync: true
      },
      /**
       * Sets how editor will be presented on desktop screen.
       *
       * Accepted values are:
       *   - `` (default) - form will open as overlay
       *   - `bottom` - form will open below the grid
       *   - `aside` - form will open on the grid side (_right_, if lft and _left_ if rtl)
       * @attr {bottom|aside} editor-position
       * @type {!CrudEditorPosition}
       */
      editorPosition: {
        type: String,
        value: "",
        reflectToAttribute: true,
        observer: "__editorPositionChanged",
        sync: true
      },
      /**
       * Enables user to click on row to edit it.
       * Note: When enabled, auto-generated grid won't show the edit column.
       * @attr {boolean} edit-on-click
       * @type {boolean}
       */
      editOnClick: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       * `params.pageSize` Current page size
       * `params.filters` Currently applied filters
       * `params.sortOrders` Currently applied sorting orders
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items
       * @type {CrudDataProvider | undefined}
       */
      dataProvider: {
        type: Function,
        observer: "__dataProviderChanged"
      },
      /**
       * Disable filtering when grid is autoconfigured.
       * @attr {boolean} no-filter
       */
      noFilter: Boolean,
      /**
       * Disable sorting when grid is autoconfigured.
       * @attr {boolean} no-sort
       */
      noSort: Boolean,
      /**
       * Remove grid headers when it is autoconfigured.
       * @attr {boolean} no-head
       */
      noHead: Boolean,
      /**
       * A comma-separated list of fields to include in the generated grid and the generated editor.
       *
       * It can be used to explicitly define the field order.
       *
       * When it is defined [`exclude`](#/elements/vaadin-crud#property-exclude) is ignored.
       *
       * Default is undefined meaning that all properties in the object should be mapped to fields.
       */
      include: String,
      /**
       * A comma-separated list of fields to be excluded from the generated grid and the generated editor.
       *
       * When [`include`](#/elements/vaadin-crud#property-include) is defined, this parameter is ignored.
       *
       * Default is to exclude all private fields (those properties starting with underscore)
       */
      exclude: String,
      /**
       * Reflects the opened status of the editor.
       */
      editorOpened: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true,
        observer: "__editorOpenedChanged",
        sync: true
      },
      /**
       * Number of items in the data set which is reported by the grid.
       * Typically it reflects the number of filtered items displayed in the grid.
       *
       * Note: As with `<vaadin-grid>`, this property updates automatically only
       * if `items` is used for data.
       */
      size: {
        type: Number,
        readOnly: true,
        notify: true
      },
      /**
       * Controls visibility state of toolbar.
       * When set to false toolbar is hidden and shown when set to true.
       * @attr {boolean} no-toolbar
       */
      noToolbar: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /** @private */
      __dialogAriaLabel: String,
      /** @private */
      __isDirty: {
        type: Boolean,
        sync: true
      },
      /** @private */
      __isNew: Boolean,
      /**
       * @type {boolean}
       * @protected
       */
      _fullscreen: {
        type: Boolean,
        observer: "__fullscreenChanged",
        sync: true
      },
      /**
       * @type {string}
       * @protected
       */
      _fullscreenMediaQuery: {
        value: "(max-width: 600px), (max-height: 600px)"
      }
    };
  }
  static get observers() {
    return [
      "__headerPropsChanged(_defaultHeader, __isNew, __effectiveI18n)",
      "__formPropsChanged(_form, _theme, include, exclude)",
      "__gridPropsChanged(_grid, _theme, include, exclude, noFilter, noHead, noSort, items)",
      "__i18nChanged(__effectiveI18n, _grid)",
      "__editOnClickChanged(editOnClick, _grid)",
      "__saveButtonPropsChanged(_saveButton, __effectiveI18n, __isDirty)",
      "__cancelButtonPropsChanged(_cancelButton, __effectiveI18n)",
      "__deleteButtonPropsChanged(_deleteButton, __effectiveI18n, __isNew)",
      "__newButtonPropsChanged(_newButton, __effectiveI18n)"
    ];
  }
  /**
   * The object used to localize this component. To change the default
   * localization, replace this with an object that provides all properties, or
   * just the individual properties you want to change.
   *
   * The object has the following JSON structure and default values:
   *
   * ```js
   * {
   *   newItem: 'New item',
   *   editItem: 'Edit item',
   *   saveItem: 'Save',
   *   cancel: 'Cancel',
   *   deleteItem: 'Delete...',
   *   editLabel: 'Edit',
   *   confirm: {
   *     delete: {
   *       title: 'Confirm delete',
   *       content: 'Are you sure you want to delete the selected item? This action cannot be undone.',
   *       button: {
   *         confirm: 'Delete',
   *         dismiss: 'Cancel'
   *       }
   *     },
   *     cancel: {
   *       title: 'Unsaved changes',
   *       content: 'There are unsaved modifications to the item.',
   *       button: {
   *         confirm: 'Discard',
   *         dismiss: 'Continue editing'
   *       }
   *     }
   *   }
   * }
   * ```
   * @return {!CrudI18n}
   */
  get i18n() {
    return super.i18n;
  }
  set i18n(value) {
    super.i18n = value;
  }
  constructor() {
    super();
    this.__cancel = this.__cancel.bind(this);
    this.__delete = this.__delete.bind(this);
    this.__save = this.__save.bind(this);
    this.__new = this.__new.bind(this);
    this.__onFormChange = this.__onFormChange.bind(this);
    this.__onGridEdit = this.__onGridEdit.bind(this);
    this.__onGridSizeChanged = this.__onGridSizeChanged.bind(this);
    this.__onGridActiveItemChanged = this.__onGridActiveItemChanged.bind(this);
    this.__focusRestorationController = new FocusRestorationController();
  }
  /** @protected */
  get _headerNode() {
    return this._headerController && this._headerController.node;
  }
  /**
   * A reference to all fields inside the [`_form`](#/elements/vaadin-crud#property-_form) element
   * @return {!Array<!HTMLElement>}
   * @protected
   */
  get _fields() {
    if (!this.__fields || !this.__fields.length) {
      this.__fields = Array.from(this._form.querySelectorAll("*")).filter((e) => e.validate || e.checkValidity);
    }
    return this.__fields;
  }
  /** @private */
  get _editor() {
    return this.shadowRoot.querySelector("#editor");
  }
  /** @private */
  get _scroller() {
    return this.shadowRoot.querySelector("#scroller");
  }
  /** @private */
  get _dialogMode() {
    return this.editorPosition === "" || this._fullscreen;
  }
  /** @protected */
  ready() {
    super.ready();
    this._gridController = new GridSlotController(this);
    this.addController(this._gridController);
    this._newButtonController = new ButtonSlotController(this, "new", null, this._noDefaultButtons);
    this.addController(this._newButtonController);
    this._headerController = new SlotController(this, "header", "h3", {
      initializer: (node) => {
        this._defaultHeader = node;
      }
    });
    this.addController(this._headerController);
    this.addController(new FormSlotController(this));
    this._saveButtonController = new ButtonSlotController(this, "save", "primary", this._noDefaultButtons);
    this._cancelButtonController = new ButtonSlotController(this, "cancel", "tertiary", this._noDefaultButtons);
    this._deleteButtonController = new ButtonSlotController(this, "delete", "tertiary error", this._noDefaultButtons);
    this.addController(this._saveButtonController);
    this.addController(this._cancelButtonController);
    this.addController(this._deleteButtonController);
    this.addController(
      new MediaQueryController(this._fullscreenMediaQuery, (matches) => {
        this._fullscreen = matches;
      })
    );
    this.addController(this.__focusRestorationController);
    this._confirmCancelDialog = this.querySelector('vaadin-confirm-dialog[slot="confirm-cancel"]');
    this._confirmDeleteDialog = this.querySelector('vaadin-confirm-dialog[slot="confirm-delete"]');
  }
  /** @protected */
  updated(props) {
    super.updated(props);
    if (props.has("_grid") || props.has("_newButton") || props.has("editorOpened") || props.has("editorPosition") || props.has("_fullscreen")) {
      const hide = this.editorOpened && this._dialogMode;
      this.__hideElement(this._grid, hide);
      this.__hideElement(this._newButton, hide);
    }
  }
  /**
   * @param {boolean} isDirty
   * @private
   */
  __isSaveBtnDisabled(isDirty) {
    return !isDirty;
  }
  /**
   * @param {HTMLElement | undefined} headerNode
   * @param {boolean} isNew
   * @param {CrudI18n} effectiveI18n
   * @private
   */
  __headerPropsChanged(headerNode, isNew, effectiveI18n) {
    if (headerNode) {
      headerNode.textContent = isNew ? effectiveI18n.newItem : effectiveI18n.editItem;
    }
  }
  /**
   * @param {CrudI18n} effectiveI18n
   * @param {CrudGrid | Grid} grid
   * @private
   */
  __i18nChanged(effectiveI18n, grid) {
    if (!grid) {
      return;
    }
    queueMicrotask(() => {
      Array.from(grid.querySelectorAll("vaadin-crud-edit-column")).forEach((column) => {
        column.ariaLabel = effectiveI18n.editLabel;
      });
    });
  }
  /** @private */
  __editorPositionChanged(editorPosition) {
    if (isValidEditorPosition(editorPosition)) {
      return;
    }
    this.editorPosition = "";
  }
  /** @private */
  __editorOpenedChanged(opened, oldOpened) {
    if (!opened && oldOpened) {
      this.__closeEditor();
    } else {
      this.__formChanged(this._form);
    }
    if (opened) {
      if (this._editor) {
        this._editor.focus();
      }
      setTimeout(() => {
        this.__dialogAriaLabel = this._headerNode.textContent.trim();
      });
    }
    this.__toggleToolbar();
    if (this._scroller) {
      this._scroller.scrollTop = 0;
    }
  }
  /** @private */
  __fullscreenChanged(fullscreen, oldFullscreen) {
    if (fullscreen || oldFullscreen) {
      this.__toggleToolbar();
      this.toggleAttribute("fullscreen", fullscreen);
    }
  }
  /** @private */
  __toggleToolbar() {
    if (this.editorPosition === "bottom" && !this._fullscreen) {
      this.$.toolbar.style.display = this.editorOpened ? "none" : "";
    }
  }
  /** @private */
  __onGridEdit(event) {
    event.stopPropagation();
    this.__confirmBeforeChangingEditedItem(event.detail.item);
  }
  /** @private */
  __onFormChange() {
    this.__isDirty = true;
  }
  /** @private */
  __onGridSizeChanged() {
    this._setSize(this._grid.size);
  }
  /**
   * @param {CrudGrid | Grid} grid
   * @param {CrudGrid | Grid | undefined} oldGrid
   * @private
   */
  __gridChanged(grid, oldGrid) {
    if (oldGrid) {
      oldGrid.removeEventListener("edit", this.__onGridEdit);
      oldGrid.removeEventListener("size-changed", this.__onGridSizeChanged);
    }
    if (this.dataProvider) {
      this.__dataProviderChanged(this.dataProvider);
    }
    if (this.editedItem) {
      this.__editedItemChanged(this.editedItem);
    }
    grid.addEventListener("edit", this.__onGridEdit);
    grid.addEventListener("size-changed", this.__onGridSizeChanged);
    this.__onGridSizeChanged();
  }
  /**
   * @param {HTMLElement | undefined | null} form
   * @param {HTMLElement | undefined | null} oldForm
   * @private
   */
  __formChanged(form, oldForm) {
    if (oldForm) {
      oldForm.removeEventListener("change", this.__onFormChange);
      oldForm.removeEventListener("input", this.__onFormChange);
    }
    if (!form) {
      return;
    }
    if (this.items) {
      this.__itemsChanged(this.items);
    }
    if (this.editedItem) {
      this.__editedItemChanged(this.editedItem);
    }
    form.addEventListener("change", this.__onFormChange);
    form.addEventListener("input", this.__onFormChange);
  }
  /**
   * @param {HTMLElement | undefined} form
   * @param {string} theme
   * @param {string | string[] | undefined} include
   * @param {string | RegExp} exclude
   * @private
   */
  __formPropsChanged(form, theme, include, exclude) {
    if (form) {
      form.include = include;
      form.exclude = exclude;
      if (theme) {
        form.setAttribute("theme", theme);
      } else {
        form.removeAttribute("theme");
      }
    }
  }
  /**
   * @param {HTMLElement | undefined} grid
   * @param {string} theme
   * @param {string | string[] | undefined} include
   * @param {string | RegExp} exclude
   * @param {boolean} noFilter
   * @param {boolean} noHead
   * @param {boolean} noSort
   * @param {Array<unknown> | undefined} items
   * @private
   */
  // eslint-disable-next-line @typescript-eslint/max-params
  __gridPropsChanged(grid, theme, include, exclude, noFilter, noHead, noSort, items) {
    if (!grid) {
      return;
    }
    if (grid === this._gridController.defaultNode) {
      grid.noFilter = noFilter;
      grid.noHead = noHead;
      grid.noSort = noSort;
      grid.include = include;
      grid.exclude = exclude;
      if (theme) {
        grid.setAttribute("theme", theme);
      } else {
        grid.removeAttribute("theme");
      }
    }
    grid.items = items;
  }
  /**
   * @param {HTMLElement | undefined} saveButton
   * @param {CrudI18n} effectiveI18n
   * @param {boolean} isDirty
   * @private
   */
  __saveButtonPropsChanged(saveButton, effectiveI18n, isDirty) {
    if (saveButton) {
      saveButton.toggleAttribute("disabled", this.__isSaveBtnDisabled(isDirty));
      if (saveButton === this._saveButtonController.defaultNode) {
        saveButton.textContent = effectiveI18n.saveItem;
      }
    }
  }
  /**
   * @param {HTMLElement | undefined} deleteButton
   * @param {CrudI18n} effectiveI18n
   * @param {boolean} isNew
   * @private
   */
  __deleteButtonPropsChanged(deleteButton, effectiveI18n, isNew) {
    if (deleteButton) {
      deleteButton.toggleAttribute("hidden", isNew);
      if (deleteButton === this._deleteButtonController.defaultNode) {
        deleteButton.textContent = effectiveI18n.deleteItem;
      }
    }
  }
  /**
   * @param {HTMLElement | undefined} cancelButton
   * @param {CrudI18n} effectiveI18n
   * @private
   */
  __cancelButtonPropsChanged(cancelButton, effectiveI18n) {
    if (cancelButton && cancelButton === this._cancelButtonController.defaultNode) {
      cancelButton.textContent = effectiveI18n.cancel;
    }
  }
  /**
   * @param {HTMLElement | undefined} newButton
   * @param {CrudI18n} effectiveI18n
   * @private
   */
  __newButtonPropsChanged(newButton, effectiveI18n) {
    if (newButton && newButton === this._newButtonController.defaultNode) {
      newButton.textContent = effectiveI18n.newItem;
    }
  }
  /** @private */
  __dataProviderChanged(dataProvider) {
    if (this._grid) {
      this._grid.dataProvider = this.__createDataProviderProxy(dataProvider);
    }
  }
  /** @private */
  __editOnClickChanged(editOnClick, grid) {
    if (!grid) {
      return;
    }
    grid.hideEditColumn = editOnClick;
    if (editOnClick) {
      grid.addEventListener("active-item-changed", this.__onGridActiveItemChanged);
    } else {
      grid.removeEventListener("active-item-changed", this.__onGridActiveItemChanged);
    }
  }
  /** @private */
  __onGridActiveItemChanged(event) {
    const item = event.detail.value;
    if (this.editorOpened && this.__isDirty) {
      this.__confirmBeforeChangingEditedItem(item);
      return;
    }
    if (item) {
      this.__edit(item);
    } else if (!this.__keepOpened) {
      this.__closeEditor();
    }
  }
  /** @private */
  __confirmBeforeChangingEditedItem(item, keepOpened) {
    if (this.editorOpened && // Editor opened
    this.__isDirty && // Form change has been made
    this.editedItem !== item) {
      this._confirmCancelDialog.opened = true;
      this.addEventListener(
        "cancel",
        (event) => {
          event.preventDefault();
          if (item || keepOpened) {
            this.__edit(item);
            this.__clearItemAndKeepEditorOpened(item, keepOpened);
          } else {
            this.__closeEditor();
          }
        },
        { once: true }
      );
    } else {
      this.__edit(item);
      this.__clearItemAndKeepEditorOpened(item, keepOpened);
    }
  }
  /** @private */
  __clearItemAndKeepEditorOpened(item, keepOpened) {
    if (!item) {
      setTimeout(() => {
        this.__keepOpened = keepOpened;
        this.editedItem = this._grid.activeItem = void 0;
      });
    }
  }
  /** @private */
  __createDataProviderProxy(dataProvider) {
    return (params, callback) => {
      const callbackProxy = (chunk, size) => {
        if (chunk && chunk[0]) {
          this.__model = chunk[0];
        }
        callback(chunk, size);
      };
      dataProvider(params, callbackProxy);
    };
  }
  /** @private */
  __itemsChanged(items) {
    if (this.items && this.items[0]) {
      this.__model = items[0];
    }
  }
  /** @private */
  __editedItemChanged(item) {
    if (!this._form) {
      return;
    }
    if (item) {
      if (!this._fields.length && this._form._configure) {
        if (this.__model) {
          this._form._configure(this.__model);
        } else {
          console.warn(
            "<vaadin-crud> Unable to autoconfigure form because the data structure is unknown. Either specify `include` or ensure at least one item is available beforehand."
          );
        }
      }
      this._form.item = item;
      this._fields.forEach((e) => {
        const path = e.path || e.getAttribute("path");
        if (path) {
          e.value = getProperty(path, item);
        }
      });
      this.__isNew = !!(this.__isNew || this.items && this.items.indexOf(item) < 0);
      this.editorOpened = true;
    }
  }
  /** @private */
  __validate() {
    return this._fields.every((e) => (e.validate || e.checkValidity).call(e));
  }
  /** @private */
  __setHighlightedItem(item) {
    if (this._grid === this._gridController.defaultNode) {
      this._grid.selectedItems = item ? [item] : [];
    }
  }
  /** @private */
  __closeEditor() {
    this.editorOpened = false;
    this.__isDirty = false;
    this.__setHighlightedItem(null);
    setTimeout(() => this.__clearItemAndKeepEditorOpened(null, false));
  }
  /** @private */
  __new() {
    this.__confirmBeforeChangingEditedItem(null, true);
  }
  /** @private */
  __edit(item) {
    if (this.editedItem === item) {
      return;
    }
    this.__setHighlightedItem(item);
    this.__openEditor(item);
  }
  /** @private */
  __fireEvent(type, item) {
    const event = new CustomEvent(type, { detail: { item }, cancelable: true });
    this.dispatchEvent(event);
    return event.defaultPrevented === false;
  }
  /** @private */
  __openEditor(item) {
    this.__focusRestorationController.saveFocus();
    this.__isDirty = false;
    this.__isNew = !item;
    const result = this.__fireEvent(this.__isNew ? "new" : "edit", item);
    if (result) {
      this.editedItem = item || {};
    } else {
      this.editorOpened = true;
    }
  }
  /** @private */
  __restoreFocusOnDelete() {
    if (this._grid._flatSize === 1) {
      this._newButton.focus();
    } else {
      this._grid._focusFirstVisibleRow();
    }
  }
  /** @private */
  __restoreFocusOnSaveOrCancel() {
    const focusNode = this.__focusRestorationController.focusNode;
    const row = this._grid._getRowContainingNode(focusNode);
    if (!row) {
      this.__focusRestorationController.restoreFocus();
      return;
    }
    if (this._grid._isItemAssignedToRow(this.editedItem, row) && this._grid._isInViewport(row)) {
      this.__focusRestorationController.restoreFocus();
    } else {
      this._grid._focusFirstVisibleRow();
    }
  }
  /** @private */
  __save() {
    if (!this.__validate()) {
      return;
    }
    const item = { ...this.editedItem };
    this._fields.forEach((e) => {
      const path = e.path || e.getAttribute("path");
      if (path) {
        setProperty(path, e.value, item);
      }
    });
    const result = this.__fireEvent("save", item);
    if (result) {
      if (this.__isNew && !this.dataProvider) {
        if (!this.items) {
          this.items = [item];
        } else {
          this.items.push(item);
        }
      } else {
        if (!this.editedItem) {
          this.editedItem = {};
        }
        Object.assign(this.editedItem, item);
      }
      this.__restoreFocusOnSaveOrCancel();
      this._grid.clearCache();
      this.__closeEditor();
    }
  }
  /** @private */
  __cancel() {
    if (this.__isDirty) {
      this._confirmCancelDialog.opened = true;
    } else {
      this.__confirmCancel();
    }
  }
  /** @private */
  __confirmCancel() {
    const result = this.__fireEvent("cancel", this.editedItem);
    if (result) {
      this.__restoreFocusOnSaveOrCancel();
      this.__closeEditor();
    }
  }
  /** @private */
  __delete() {
    this._confirmDeleteDialog.opened = true;
  }
  /** @private */
  __confirmDelete() {
    const result = this.__fireEvent("delete", this.editedItem);
    if (result) {
      if (this.items && this.items.indexOf(this.editedItem) >= 0) {
        this.items.splice(this.items.indexOf(this.editedItem), 1);
      }
      this.__restoreFocusOnDelete();
      this._grid.clearCache();
      this.__closeEditor();
    }
  }
  /** @private */
  __hideElement(element, value) {
    if (!element) return;
    if (value) {
      element.setAttribute("aria-hidden", "true");
    } else {
      element.removeAttribute("aria-hidden");
    }
  }
  /**
   * Fired when user wants to edit an existing item. If the default is prevented, then
   * a new item is not assigned to the form, giving that responsibility to the app, though
   * dialog is always opened.
   *
   * @event edit
   * @param {Object} detail.item the item to edit
   */
  /**
   * Fired when user wants to create a new item.
   *
   * @event new
   */
  /**
   * Fired when user wants to delete item. If the default is prevented, then
   * no action is performed, items array is not modified nor dialog closed
   *
   * @event delete
   * @param {Object} detail.item the item to delete
   */
  /**
   * Fired when user discards edition. If the default is prevented, then
   * no action is performed, user is responsible to close dialog and reset
   * item and grid.
   *
   * @event cancel
   * @param {Object} detail.item the item to delete
   */
  /**
   * Fired when user wants to save a new or an existing item. If the default is prevented, then
   * no action is performed, items array is not modified nor dialog closed
   *
   * @event save
   * @param {Object} detail.item the item to save
   * @param {Object} detail.new whether the item is a new one
   */
};

// node_modules/@vaadin/crud/src/vaadin-crud.js
var Crud = class extends CrudMixin(ElementMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-crud";
  }
  static get cvdlName() {
    return "vaadin-crud";
  }
  static get styles() {
    return crudStyles;
  }
  /** @protected */
  render() {
    return html`
      <div id="container">
        <div id="main">
          <slot name="grid"></slot>

          <div id="toolbar" part="toolbar">
            <slot name="toolbar"></slot>
            <slot name="new-button"></slot>
          </div>
        </div>

        ${!this._dialogMode ? html`
              <div
                part="editor"
                id="editor"
                role="group"
                aria-labelledby="header"
                tabindex="0"
                ?hidden="${!this.editorOpened}"
              >
                <div part="scroller" id="scroller">
                  <div part="header" id="header">
                    <slot name="header"></slot>
                  </div>
                  <slot name="form"></slot>
                </div>

                <div part="footer" role="toolbar">
                  <slot name="save-button"></slot>
                  <slot name="cancel-button"></slot>
                  <slot name="delete-button"></slot>
                </div>
              </div>
            ` : nothing}
      </div>

      ${this._dialogMode ? html`
            <vaadin-crud-dialog
              id="dialog"
              aria-label="${ifDefined(this.__dialogAriaLabel)}"
              theme="${ifDefined(this._theme)}"
              exportparts="backdrop, overlay, header, content, footer"
              .crudElement="${this}"
              .opened="${this.editorOpened}"
              .fullscreen="${this._fullscreen}"
              .noCloseOnOutsideClick="${this.__isDirty}"
              .noCloseOnEsc="${this.__isDirty}"
              @cancel="${this.__cancel}"
            >
              <slot name="header" slot="header"></slot>
              <slot name="form" slot="form"></slot>
              <slot name="save-button" slot="save-button"></slot>
              <slot name="cancel-button" slot="cancel-button"></slot>
              <slot name="delete-button" slot="delete-button"></slot>
            </vaadin-crud-dialog>
          ` : nothing}

      <slot name="confirm-cancel"></slot>

      <slot name="confirm-delete"></slot>
    `;
  }
  /**
   * Override update to render slotted overlays into light DOM after rendering shadow DOM.
   * @param changedProperties
   * @protected
   */
  update(changedProperties) {
    super.update(changedProperties);
    this.__renderSlottedOverlays();
  }
  /** @private */
  __renderSlottedOverlays() {
    render(
      html`
        <vaadin-confirm-dialog
          theme="${ifDefined(this._theme)}"
          slot="confirm-cancel"
          @confirm="${this.__confirmCancel}"
          cancel-button-visible
          .confirmText="${this.__effectiveI18n.confirm.cancel.button.confirm}"
          .cancelText="${this.__effectiveI18n.confirm.cancel.button.dismiss}"
          .header="${this.__effectiveI18n.confirm.cancel.title}"
          .message="${this.__effectiveI18n.confirm.cancel.content}"
          confirm-theme="primary"
        ></vaadin-confirm-dialog>

        <vaadin-confirm-dialog
          theme="${ifDefined(this._theme)}"
          slot="confirm-delete"
          @confirm="${this.__confirmDelete}"
          cancel-button-visible
          .confirmText="${this.__effectiveI18n.confirm.delete.button.confirm}"
          .cancelText="${this.__effectiveI18n.confirm.delete.button.dismiss}"
          .header="${this.__effectiveI18n.confirm.delete.title}"
          .message="${this.__effectiveI18n.confirm.delete.content}"
          confirm-theme="primary error"
        ></vaadin-confirm-dialog>
      `,
      this,
      { host: this }
    );
  }
};
defineCustomElement(Crud);
export {
  Crud
};
//# sourceMappingURL=@vaadin_crud_src_vaadin-crud__js.js.map
