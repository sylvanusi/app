import {
  screenReaderOnly
} from "./chunk-RM22DGSP.js";
import {
  listBoxStyles
} from "./chunk-TYZ7RCV5.js";
import {
  MediaQueryController
} from "./chunk-QMCKCKIE.js";
import {
  inputFieldShared
} from "./chunk-F6FMTQFS.js";
import {
  ItemMixin
} from "./chunk-3V4YUPS4.js";
import {
  ListMixin
} from "./chunk-GDVAXDUZ.js";
import {
  itemStyles
} from "./chunk-WEJ2XI2Y.js";
import {
  PositionMixin
} from "./chunk-FOQZPEJP.js";
import {
  ifDefined
} from "./chunk-OSWHV746.js";
import {
  OverlayMixin,
  overlayStyles
} from "./chunk-PFI4EOEJ.js";
import {
  FieldMixin
} from "./chunk-ZZO67D7M.js";
import {
  LabelController
} from "./chunk-WJXDM45A.js";
import {
  setAriaIDReference
} from "./chunk-722MDOVI.js";
import {
  DelegateFocusMixin
} from "./chunk-R7PLRAV7.js";
import {
  DelegateStateMixin
} from "./chunk-SFISAMYO.js";
import {
  TooltipController
} from "./chunk-XFKQJ73Z.js";
import {
  SlotController
} from "./chunk-X5EEA4XV.js";
import {
  generateUniqueId
} from "./chunk-Z5LHTDPJ.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  ButtonMixin
} from "./chunk-GXEMU344.js";
import {
  KeyboardMixin
} from "./chunk-WT6HVPMS.js";
import {
  isKeyboardActive
} from "./chunk-5DESY7LS.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import {
  DirMixin
} from "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/select/src/vaadin-select-item.js
var SelectItem = class extends ItemMixin(ThemableMixin(DirMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-select-item";
  }
  static get styles() {
    return itemStyles;
  }
  static get properties() {
    return {
      /**
       * Use property instead of setting an attribute in `ready()`
       * for cloning the selected item attached to the value button:
       * in this case, `role` attribute is removed synchronously, and
       * using `ready()` would incorrectly restore the attribute.
       *
       * @protected
       */
      role: {
        type: String,
        value: "option",
        reflectToAttribute: true
      }
    };
  }
  /** @protected */
  render() {
    return html`
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
};
defineCustomElement(SelectItem);

// node_modules/@vaadin/select/src/vaadin-select-list-box.js
var SelectListBox = class extends ListMixin(ThemableMixin(DirMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-select-list-box";
  }
  static get styles() {
    return listBoxStyles;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  render() {
    return html`
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "listbox");
  }
};
defineCustomElement(SelectListBox);

// node_modules/@vaadin/select/src/styles/vaadin-select-overlay-base-styles.js
var selectOverlayStyles = css`
  :host {
    align-items: flex-start;
    justify-content: flex-start;
  }

  [part='overlay'] {
    min-width: var(--vaadin-select-overlay-width, var(--_vaadin-select-overlay-default-width));
  }

  [part='content'] {
    padding: var(--vaadin-item-overlay-padding, 4px);
  }

  [part='backdrop'] {
    background: transparent;
  }

  :host([theme~='align-start']) [part='overlay'] {
    text-align: start;
  }

  :host([theme~='align-center']) [part='overlay'] {
    text-align: center;
  }

  :host([theme~='align-end']) [part='overlay'] {
    text-align: end;
  }

  :host([theme~='align-left']) [part='overlay'] {
    text-align: left;
  }

  :host([theme~='align-right']) [part='overlay'] {
    text-align: right;
  }
`;

// node_modules/@vaadin/select/src/vaadin-select-overlay-mixin.js
var SelectOverlayMixin = (superClass) => class SelectOverlayMixin extends PositionMixin(OverlayMixin(DirMixin(superClass))) {
  static get observers() {
    return ["_updateOverlayWidth(opened, positionTarget)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.restoreFocusOnClose = true;
  }
  /**
   * Override method from OverlayFocusMixin to use slotted div as content root.
   * @protected
   * @override
   */
  get _contentRoot() {
    return this._rendererRoot;
  }
  /**
   * Override method from OverlayMixin to use slotted div as a renderer root.
   * @protected
   * @override
   */
  get _rendererRoot() {
    if (!this.__savedRoot) {
      const root = document.createElement("div");
      root.setAttribute("slot", "overlay");
      this.owner.appendChild(root);
      this.__savedRoot = root;
    }
    return this.__savedRoot;
  }
  /**
   * Override method inherited from `Overlay` to always close on outside click,
   * in order to avoid problem when using inside of the modeless dialog.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(_event) {
    return true;
  }
  /**
   * @protected
   * @override
   */
  _mouseDownListener(event) {
    super._mouseDownListener(event);
    event.preventDefault();
  }
  /** @protected */
  _getMenuElement() {
    return Array.from(this._rendererRoot.children).find((el) => el.localName !== "style");
  }
  /** @private */
  _updateOverlayWidth(opened, positionTarget) {
    if (opened && positionTarget) {
      this.style.setProperty("--_vaadin-select-overlay-default-width", `${positionTarget.offsetWidth}px`);
    }
  }
  requestContentUpdate() {
    super.requestContentUpdate();
    if (this.owner) {
      const menuElement = this._getMenuElement();
      this.owner._assignMenuElement(menuElement);
    }
  }
};

// node_modules/@vaadin/select/src/vaadin-select-overlay.js
var SelectOverlay = class extends SelectOverlayMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement)))) {
  static get is() {
    return "vaadin-select-overlay";
  }
  static get styles() {
    return [overlayStyles, selectOverlayStyles];
  }
  /** @protected */
  render() {
    return html`
      <div id="backdrop" part="backdrop" ?hidden="${!this.withBackdrop}"></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
  /** @protected */
  updated(props) {
    super.updated(props);
    if (props.has("renderer")) {
      this.requestContentUpdate();
    }
  }
};
defineCustomElement(SelectOverlay);

// node_modules/@vaadin/select/src/styles/vaadin-select-value-button-base-styles.js
var valueButton = css`
  :host {
    min-height: 1lh;
    outline: none;
    overflow: hidden;
    white-space: nowrap;
    width: 100%;
  }

  ::slotted(*) {
    padding: 0;
    cursor: inherit;
  }

  .vaadin-button-container,
  [part='label'] {
    display: contents;
  }

  :host([placeholder]) {
    color: var(--vaadin-input-field-placeholder-color, var(--vaadin-text-color-secondary));
  }

  :host([disabled]) {
    pointer-events: none;
  }
`;

// node_modules/@vaadin/select/src/vaadin-select-value-button.js
var SelectValueButton = class extends ButtonMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement)))) {
  static get is() {
    return "vaadin-select-value-button";
  }
  static get styles() {
    return valueButton;
  }
  /** @protected */
  render() {
    return html`
      <div class="vaadin-button-container">
        <span part="label">
          <slot></slot>
        </span>
      </div>
    `;
  }
};
defineCustomElement(SelectValueButton);

// node_modules/@vaadin/select/src/styles/vaadin-select-base-styles.js
var selectStyles = css`
  :host {
    position: relative;
  }

  ::slotted([slot='value']) {
    flex: 1;
  }

  ::slotted(div[slot='overlay']) {
    display: contents;
  }

  :host(:not([focus-ring])) [part='input-field'] {
    outline: none;
  }

  :host([readonly]:not([focus-ring])) [part='input-field'] {
    --vaadin-input-field-border-color: inherit;
  }

  [part='input-field'],
  :host(:not([readonly])) ::slotted([slot='value']) {
    cursor: var(--vaadin-clickable-cursor);
  }

  [part~='toggle-button']::before {
    mask-image: var(--_vaadin-icon-chevron-down);
  }

  :host([readonly]) [part~='toggle-button'] {
    display: none;
  }
`;

// node_modules/@vaadin/select/src/button-controller.js
var ButtonController = class extends SlotController {
  constructor(host) {
    super(host, "value", "vaadin-select-value-button", {
      initializer: (button, host2) => {
        host2._setFocusElement(button);
        host2.ariaTarget = button;
        host2.stateTarget = button;
        button.setAttribute("aria-haspopup", "listbox");
      }
    });
  }
};

// node_modules/@vaadin/select/src/vaadin-select-base-mixin.js
var SelectBaseMixin = (superClass) => class SelectBaseMixin extends DelegateFocusMixin(DelegateStateMixin(KeyboardMixin(FieldMixin(superClass)))) {
  static get properties() {
    return {
      /**
       * An array containing items that will be rendered as the options of the select.
       *
       * #### Example
       * ```js
       * select.items = [
       *   { label: 'Most recent first', value: 'recent' },
       *   { component: 'hr' },
       *   { label: 'Rating: low to high', value: 'rating-asc', className: 'asc' },
       *   { label: 'Rating: high to low', value: 'rating-desc', className: 'desc' },
       *   { component: 'hr' },
       *   { label: 'Price: low to high', value: 'price-asc', disabled: true },
       *   { label: 'Price: high to low', value: 'price-desc', disabled: true }
       * ];
       * ```
       *
       * Note: each item is rendered by default as the internal `<vaadin-select-item>` that is an extension of `<vaadin-item>`.
       * To render the item with a custom component, provide a tag name by the `component` property.
       *
       * @type {!Array<!SelectItem>}
       */
      items: {
        type: Array,
        observer: "__itemsChanged"
      },
      /**
       * Set when the select is open
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        observer: "_openedChanged",
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Custom function for rendering the content of the `<vaadin-select>`.
       * Receives two arguments:
       *
       * - `root` The internal container DOM element. Append your content to it.
       * - `select` The reference to the `<vaadin-select>` element.
       * @type {!SelectRenderer | undefined}
       */
      renderer: {
        type: Object
      },
      /**
       * The `value` property of the selected item, or an empty string
       * if no item is selected.
       * On change or initialization, the component finds the item which matches the
       * value and displays it.
       * If no value is provided to the component, it selects the first item without
       * value or empty value.
       * Hint: If you do not want to select any item by default, you can either set all
       * the values of inner vaadin-items, or set the vaadin-select value to
       * an inexistent value in the items list.
       * @type {string}
       */
      value: {
        type: String,
        value: "",
        notify: true,
        observer: "_valueChanged",
        sync: true
      },
      /**
       * The name of this element.
       */
      name: {
        type: String
      },
      /**
       * A hint to the user of what can be entered in the control.
       * The placeholder will be displayed in the case that there
       * is no item selected, or the selected item has an empty
       * string label, or the selected item has no label and it's
       * DOM content is empty.
       */
      placeholder: {
        type: String
      },
      /**
       * When present, it specifies that the element is read-only.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Defines whether the overlay should overlap the target element
       * in the y-axis, or be positioned right above/below it.
       *
       * @attr {boolean} no-vertical-overlap
       */
      noVerticalOverlap: {
        type: Boolean,
        value: false
      },
      /** @private */
      _phone: Boolean,
      /** @private */
      _phoneMediaQuery: {
        value: "(max-width: 450px), (max-height: 450px)"
      },
      /** @private */
      _inputContainer: Object,
      /** @private */
      _items: Object
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "invalid"];
  }
  static get observers() {
    return ["_updateAriaExpanded(opened, focusElement)", "_updateSelectedItem(value, _items, placeholder)"];
  }
  constructor() {
    super();
    this._itemId = `value-${this.localName}-${generateUniqueId()}`;
    this._srLabelController = new LabelController(this);
    this._srLabelController.slotName = "sr-label";
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.opened = false;
  }
  /** @protected */
  ready() {
    super.ready();
    this._inputContainer = this.shadowRoot.querySelector('[part~="input-field"]');
    this._overlayElement = this.$.overlay;
    this._valueButtonController = new ButtonController(this);
    this.addController(this._valueButtonController);
    this.addController(this._srLabelController);
    this.addController(
      new MediaQueryController(this._phoneMediaQuery, (matches) => {
        this._phone = matches;
      })
    );
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.focusElement);
    this.addController(this._tooltipController);
  }
  /** @protected */
  updated(props) {
    super.updated(props);
    if (props.has("_phone")) {
      this.toggleAttribute("phone", this._phone);
    }
  }
  /**
   * Requests an update for the content of the select.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this._overlayElement) {
      return;
    }
    this._overlayElement.requestContentUpdate();
  }
  /**
   * Override an observer from `FieldMixin`
   * to validate when required is removed.
   *
   * @protected
   * @override
   */
  _requiredChanged(required) {
    super._requiredChanged(required);
    if (required === false) {
      this._requestValidation();
    }
  }
  /**
   * @param {SelectItem[] | undefined | null} newItems
   * @param {SelectItem[] | undefined | null} oldItems
   * @private
   */
  __itemsChanged(newItems, oldItems) {
    if (newItems || oldItems) {
      this.requestContentUpdate();
    }
  }
  /**
   * @param {HTMLElement} menuElement
   * @protected
   */
  _assignMenuElement(menuElement) {
    if (menuElement && menuElement !== this.__lastMenuElement) {
      this._menuElement = menuElement;
      this.__initMenuItems(menuElement);
      menuElement.addEventListener("items-changed", () => {
        this.__initMenuItems(menuElement);
      });
      menuElement.addEventListener("selected-changed", () => this.__updateValueButton());
      menuElement.addEventListener("keydown", (e) => this._onKeyDownInside(e), true);
      menuElement.addEventListener(
        "click",
        (e) => {
          const item = e.composedPath().find((el) => el._hasVaadinItemMixin);
          this.__dispatchChangePending = Boolean(item && item.value !== void 0 && item.value !== this.value);
          this.opened = false;
        },
        true
      );
      this.__lastMenuElement = menuElement;
    }
    if (this._menuElement && this._menuElement.items) {
      this._updateSelectedItem(this.value, this._menuElement.items);
    }
  }
  /** @private */
  __initMenuItems(menuElement) {
    if (menuElement.items) {
      this._items = menuElement.items;
    }
  }
  /** @private */
  _valueChanged(value, oldValue) {
    this.toggleAttribute("has-value", Boolean(value));
    if (oldValue !== void 0 && !this.__dispatchChangePending) {
      this._requestValidation();
    }
  }
  /**
   * Opens the overlay if the field is not read-only.
   *
   * @private
   */
  _onClick(event) {
    if (this.disabled) {
      return;
    }
    event.preventDefault();
    this.opened = !this.readonly;
  }
  /**
   * Override an event listener from `KeyboardMixin`
   * stop propagation when closing overlay on Escape.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (this.opened) {
      event.stopPropagation();
      this.opened = false;
    }
  }
  /** @private */
  _onToggleMouseDown(event) {
    event.preventDefault();
    if (!this.opened) {
      this.focusElement.focus();
    }
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(e) {
    super._onKeyDown(e);
    if (e.altKey || e.shiftKey || e.ctrlKey || e.metaKey) {
      return;
    }
    if (e.target === this.focusElement && !this.readonly && !this.disabled && !this.opened) {
      if (/^(Enter|SpaceBar|\s|ArrowDown|Down|ArrowUp|Up)$/u.test(e.key)) {
        e.preventDefault();
        this.opened = true;
      } else if (/[\p{L}\p{Nd}]/u.test(e.key) && e.key.length === 1) {
        const selected = this._menuElement.selected;
        const currentIdx = selected !== void 0 ? selected : -1;
        const newIdx = this._menuElement._searchKey(currentIdx, e.key);
        if (newIdx >= 0) {
          this.__dispatchChangePending = true;
          this._updateAriaLive(true);
          this._menuElement.selected = newIdx;
        }
      }
    }
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   */
  _onKeyDownInside(e) {
    if (e.key === "Tab") {
      this.focusElement.setAttribute("tabindex", "-1");
      this._overlayElement.restoreFocusOnClose = false;
      this.opened = false;
      setTimeout(() => {
        this.focusElement.setAttribute("tabindex", "0");
        this._overlayElement.restoreFocusOnClose = true;
      });
    }
  }
  /** @private */
  _openedChanged(opened, oldOpened) {
    if (opened) {
      if (this.disabled || this.readonly) {
        this.opened = false;
        return;
      }
      this._updateAriaLive(false);
      const hasFocusRing = this.hasAttribute("focus-ring");
      this._openedWithFocusRing = hasFocusRing;
      if (hasFocusRing) {
        this.removeAttribute("focus-ring");
      }
    } else if (oldOpened) {
      if (this._openedWithFocusRing) {
        this.setAttribute("focus-ring", "");
      }
      if (!this.__dispatchChangePending && !this._keyboardActive) {
        this._requestValidation();
      }
    }
  }
  /** @private */
  _updateAriaExpanded(opened, focusElement) {
    if (focusElement) {
      focusElement.setAttribute("aria-expanded", opened ? "true" : "false");
    }
  }
  /** @private */
  _updateAriaLive(ariaLive) {
    if (this.focusElement) {
      if (ariaLive) {
        this.focusElement.setAttribute("aria-live", "polite");
      } else {
        this.focusElement.removeAttribute("aria-live");
      }
    }
  }
  /** @private */
  __attachSelectedItem(selected) {
    let labelItem;
    const label = selected.getAttribute("label");
    if (label) {
      labelItem = this.__createItemElement({ label });
    } else {
      labelItem = selected.cloneNode(true);
    }
    labelItem._sourceItem = selected;
    this.__appendValueItemElement(labelItem, this.focusElement);
    labelItem.selected = true;
  }
  /**
   * @param {!SelectItem} item
   * @private
   */
  __createItemElement(item) {
    const itemElement = document.createElement(item.component || "vaadin-select-item");
    if (item.label) {
      itemElement.textContent = item.label;
    }
    if (item.value) {
      itemElement.value = item.value;
    }
    if (item.disabled) {
      itemElement.disabled = item.disabled;
    }
    if (item.className) {
      itemElement.className = item.className;
    }
    return itemElement;
  }
  /**
   * @param {!HTMLElement} itemElement
   * @param {!HTMLElement} parent
   * @private
   */
  __appendValueItemElement(itemElement, parent) {
    parent.appendChild(itemElement);
    itemElement.removeAttribute("tabindex");
    itemElement.removeAttribute("aria-selected");
    itemElement.removeAttribute("role");
    itemElement.removeAttribute("focused");
    itemElement.removeAttribute("focus-ring");
    itemElement.removeAttribute("active");
    itemElement.setAttribute("id", this._itemId);
  }
  /**
   * @param {string} accessibleName
   * @protected
   */
  _accessibleNameChanged(accessibleName) {
    this._srLabelController.setLabel(accessibleName);
    this._setCustomAriaLabelledBy(accessibleName ? this._srLabelController.defaultId : null);
  }
  /**
   * @param {string} accessibleNameRef
   * @protected
   */
  _accessibleNameRefChanged(accessibleNameRef) {
    this._setCustomAriaLabelledBy(accessibleNameRef);
  }
  /**
   * @param {string} ariaLabelledby
   * @private
   */
  _setCustomAriaLabelledBy(ariaLabelledby) {
    const labelId = this._getLabelIdWithItemId(ariaLabelledby);
    this._fieldAriaController.setLabelId(labelId, true);
  }
  /**
   * @param {string | null} labelId
   * @returns string | null
   * @private
   */
  _getLabelIdWithItemId(labelId) {
    const selected = this._items ? this._items[this._menuElement.selected] : false;
    const itemId = selected || this.placeholder ? this._itemId : "";
    return labelId ? `${labelId} ${itemId}`.trim() : null;
  }
  /** @private */
  __updateValueButton() {
    const valueButton2 = this.focusElement;
    if (!valueButton2) {
      return;
    }
    valueButton2.innerHTML = "";
    const selected = this._items[this._menuElement.selected];
    valueButton2.removeAttribute("placeholder");
    if (this._hasContent(selected)) {
      this.__attachSelectedItem(selected);
    } else if (this.placeholder) {
      const item = this.__createItemElement({ label: this.placeholder });
      this.__appendValueItemElement(item, valueButton2);
      valueButton2.setAttribute("placeholder", "");
    }
    if (!this._valueChanging && selected) {
      this._selectedChanging = true;
      this.value = selected.value || "";
      if (this.__dispatchChangePending) {
        this.__dispatchChange();
      }
      delete this._selectedChanging;
    }
    const labelledIdReferenceConfig = selected || this.placeholder ? { newId: this._itemId } : { oldId: this._itemId };
    setAriaIDReference(valueButton2, "aria-labelledby", labelledIdReferenceConfig);
    if (this.accessibleName || this.accessibleNameRef) {
      this._setCustomAriaLabelledBy(this.accessibleNameRef || this._srLabelController.defaultId);
    }
  }
  /** @private */
  _hasContent(item) {
    if (!item) {
      return false;
    }
    const hasText = Boolean(item.hasAttribute("label") ? item.getAttribute("label") : item.textContent.trim());
    const hasChildren = item.childElementCount > 0;
    return hasText || hasChildren;
  }
  /** @private */
  _updateSelectedItem(value, items) {
    if (items) {
      const valueAsString = value == null ? value : value.toString();
      this._menuElement.selected = items.reduce((prev, item, idx) => {
        return prev === void 0 && item.value === valueAsString ? idx : prev;
      }, void 0);
      if (!this._selectedChanging) {
        this._valueChanging = true;
        this.__updateValueButton();
        delete this._valueChanging;
      }
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when select is opened and focus moves to list-box.
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(event) {
    return !this.contains(event.relatedTarget);
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /**
   * Returns true if the current value satisfies all constraints (if any)
   *
   * @return {boolean}
   */
  checkValidity() {
    return !this.required || this.readonly || !!this.value;
  }
  /**
   * Renders items when they are provided by the `items` property and clears the content otherwise.
   * @param {!HTMLElement} root
   * @param {!Select} _select
   * @private
   */
  __defaultRenderer(root, _select) {
    if (!this.items || this.items.length === 0) {
      root.textContent = "";
      return;
    }
    let listBox = root.firstElementChild;
    if (!listBox) {
      listBox = document.createElement("vaadin-select-list-box");
      root.appendChild(listBox);
    }
    listBox.textContent = "";
    this.items.forEach((item) => {
      listBox.appendChild(this.__createItemElement(item));
    });
  }
  /** @private */
  __dispatchChange() {
    this._requestValidation();
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    this.__dispatchChangePending = false;
  }
};

// node_modules/@vaadin/select/src/vaadin-select.js
var Select = class extends SelectBaseMixin(ElementMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-select";
  }
  static get styles() {
    return [inputFieldShared, screenReaderOnly, selectStyles];
  }
  /** @protected */
  render() {
    return html`
      <div class="vaadin-select-container">
        <div part="label" @click="${this._onClick}">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" @click="${this.focus}"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          .readonly="${this.readonly}"
          .disabled="${this.disabled}"
          .invalid="${this.invalid}"
          theme="${ifDefined(this._theme)}"
          @click="${this._onClick}"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="value"></slot>
          <div
            part="field-button toggle-button"
            slot="suffix"
            aria-hidden="true"
            @mousedown="${this._onToggleMouseDown}"
          ></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-select-overlay
        id="overlay"
        .owner="${this}"
        .positionTarget="${this._inputContainer}"
        .opened="${this.opened}"
        .withBackdrop="${this._phone}"
        .renderer="${this.renderer || this.__defaultRenderer}"
        ?phone="${this._phone}"
        theme="${ifDefined(this._theme)}"
        ?no-vertical-overlap="${this.noVerticalOverlap}"
        exportparts="backdrop, overlay, content"
        @opened-changed="${this._onOpenedChanged}"
        @vaadin-overlay-open="${this._onOverlayOpen}"
      >
        <slot name="overlay"></slot>
      </vaadin-select-overlay>

      <slot name="tooltip"></slot>
      <div class="sr-only">
        <slot name="sr-label"></slot>
      </div>
    `;
  }
  /** @private */
  _onOpenedChanged(event) {
    this.opened = event.detail.value;
  }
  /** @private */
  _onOverlayOpen() {
    if (this._menuElement) {
      this._menuElement.focus({ focusVisible: isKeyboardActive() });
    }
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
};
defineCustomElement(Select);

export {
  Select
};
//# sourceMappingURL=chunk-UZNLLE6E.js.map
