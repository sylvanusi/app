{
  "version": 3,
  "sources": ["../../@vaadin/grid/src/vaadin-grid-helpers.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2016 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { microTask } from '@vaadin/component-base/src/async.js';\nimport { Debouncer } from '@vaadin/component-base/src/debounce.js';\n\n/**\n * Returns the cells of the given row, excluding the details cell.\n *\n * @param {HTMLTableRowElement} row the table row\n * @return {HTMLTableCellElement[]} array of cells\n */\nexport function getBodyRowCells(row) {\n  // If available, return the cached cells. Otherwise, query the cells directly from the row.\n  return row.__cells || Array.from(row.querySelectorAll('[part~=\"cell\"]:not([part~=\"details-cell\"])'));\n}\n\n/**\n * @param {HTMLElement} container the DOM element with children\n * @param {Function} callback function to call on each child\n */\nexport function iterateChildren(container, callback) {\n  [...container.children].forEach(callback);\n}\n\n/**\n * Iterates over the cells of a row. This includes the details cell if\n * present and any other cell that may be physically detached from the row\n * due to lazy column reordering.\n *\n * @param {HTMLTableRowElement} row the table row\n * @param {Function} callback function to call on each cell\n */\nexport function iterateRowCells(row, callback) {\n  getBodyRowCells(row).forEach(callback);\n  if (row.__detailsCell) {\n    callback(row.__detailsCell);\n  }\n}\n\n/**\n * @param {Array<Object>} columns array of columns to be modified\n * @param {number} scope multiplier added to base order for each column\n * @param {number} baseOrder base number used for order\n */\nexport function updateColumnOrders(columns, scope, baseOrder) {\n  let c = 1;\n  columns.forEach((column) => {\n    // Avoid multiples of 10 because they introduce and extra zero and\n    // causes the underlying calculations for child order goes wrong\n    if (c % 10 === 0) {\n      c += 1;\n    }\n    column._order = baseOrder + c * scope;\n    c += 1;\n  });\n}\n\n/**\n * @param {!HTMLElement} element\n * @param {string} attribute\n * @param {boolean | string | null | undefined} value\n */\nexport function updateState(element, attribute, value) {\n  switch (typeof value) {\n    case 'boolean':\n      element.toggleAttribute(attribute, value);\n      break;\n    case 'string':\n      element.setAttribute(attribute, value);\n      break;\n    default:\n      // Value set to null / undefined\n      element.removeAttribute(attribute);\n      break;\n  }\n}\n\n/**\n * @param {!HTMLElement} element\n * @param {string} part\n * @param {boolean | string | null | undefined} value\n */\nexport function updatePart(element, part, value) {\n  element.classList.toggle(part, value || value === '');\n  element.part.toggle(part, value || value === '');\n  element.part.length === 0 && element.removeAttribute('part');\n}\n\n/**\n * @param {HTMLTableCellElement[]} cells\n * @param {string} part\n * @param {boolean | string | null | undefined} value\n */\nexport function updateCellsPart(cells, part, value) {\n  cells.forEach((cell) => {\n    updatePart(cell, part, value);\n  });\n}\n\n/**\n * @param {!HTMLElement} row\n * @param {Object} states\n */\nexport function updateBooleanRowStates(row, states) {\n  const cells = getBodyRowCells(row);\n\n  Object.entries(states).forEach(([state, value]) => {\n    // Row state attribute\n    updateState(row, state, value);\n\n    const rowPart = `${state}-row`;\n\n    // Row part attribute\n    updatePart(row, rowPart, value);\n\n    // Cells part attribute\n    updateCellsPart(cells, `${rowPart}-cell`, value);\n  });\n}\n\n/**\n * @param {!HTMLElement} row\n * @param {Object} states\n */\nexport function updateStringRowStates(row, states) {\n  const cells = getBodyRowCells(row);\n\n  Object.entries(states).forEach(([state, value]) => {\n    const prevValue = row.getAttribute(state);\n\n    // Row state attribute\n    updateState(row, state, value);\n\n    // remove previous part from row and cells if there was any\n    if (prevValue) {\n      const prevRowPart = `${state}-${prevValue}-row`;\n      updatePart(row, prevRowPart, false);\n      updateCellsPart(cells, `${prevRowPart}-cell`, false);\n    }\n\n    // set new part to rows and cells if there is a value\n    if (value) {\n      const rowPart = `${state}-${value}-row`;\n      updatePart(row, rowPart, value);\n      updateCellsPart(cells, `${rowPart}-cell`, value);\n    }\n  });\n}\n\n/**\n * @param {!HTMLElement} cell\n * @param {string} attribute\n * @param {boolean | string | null | undefined} value\n * @param {string} part\n * @param {?string} oldPart\n */\nexport function updateCellState(cell, attribute, value, part, oldPart) {\n  // Toggle state attribute on the cell\n  updateState(cell, attribute, value);\n\n  // Remove old part from the attribute\n  if (oldPart) {\n    updatePart(cell, oldPart, false);\n  }\n\n  // Add new part to the cell attribute\n  updatePart(cell, part || `${attribute}-cell`, value);\n}\n\n/**\n * Finds the cell containing the tree toggle element\n * @param {!HTMLElement} row\n * @return {HTMLElement | null}\n */\nexport function findTreeToggleCell(row) {\n  return getBodyRowCells(row).find((cell) => cell._content.querySelector('vaadin-grid-tree-toggle'));\n}\n\n/**\n * A helper for observing flattened child column list of an element.\n */\nexport class ColumnObserver {\n  constructor(host, callback) {\n    this.__host = host;\n    this.__callback = callback;\n    this.__currentSlots = [];\n\n    this.__onMutation = this.__onMutation.bind(this);\n    this.__observer = new MutationObserver(this.__onMutation);\n    this.__observer.observe(host, {\n      childList: true,\n    });\n\n    // The observer callback is invoked once initially.\n    this.__initialCallDebouncer = Debouncer.debounce(this.__initialCallDebouncer, microTask, () => this.__onMutation());\n  }\n\n  disconnect() {\n    this.__observer.disconnect();\n    this.__initialCallDebouncer.cancel();\n    this.__toggleSlotChangeListeners(false);\n  }\n\n  flush() {\n    this.__onMutation();\n  }\n\n  __toggleSlotChangeListeners(add) {\n    this.__currentSlots.forEach((slot) => {\n      if (add) {\n        slot.addEventListener('slotchange', this.__onMutation);\n      } else {\n        slot.removeEventListener('slotchange', this.__onMutation);\n      }\n    });\n  }\n\n  __onMutation() {\n    // Detect if this is the initial call\n    const initialCall = !this.__currentColumns;\n    this.__currentColumns = this.__currentColumns || [];\n\n    // Detect added and removed columns or if the columns order has changed\n    const columns = ColumnObserver.getColumns(this.__host);\n    const addedColumns = columns.filter((column) => !this.__currentColumns.includes(column));\n    const removedColumns = this.__currentColumns.filter((column) => !columns.includes(column));\n    const orderChanged = this.__currentColumns.some((column, index) => column !== columns[index]);\n    this.__currentColumns = columns;\n\n    // Update the list of child slots and toggle their slotchange listeners\n    this.__toggleSlotChangeListeners(false);\n    this.__currentSlots = [...this.__host.children].filter((child) => child instanceof HTMLSlotElement);\n    this.__toggleSlotChangeListeners(true);\n\n    // Invoke the callback if there are changes in the child columns or if this is the initial call\n    const invokeCallback = initialCall || addedColumns.length || removedColumns.length || orderChanged;\n    if (invokeCallback) {\n      this.__callback(addedColumns, removedColumns);\n    }\n  }\n\n  /**\n   * Default filter for column elements.\n   */\n  static __isColumnElement(node) {\n    return node.nodeType === Node.ELEMENT_NODE && /\\bcolumn\\b/u.test(node.localName);\n  }\n\n  static getColumns(host) {\n    const columns = [];\n\n    // A temporary workaround for backwards compatibility\n    const isColumnElement = host._isColumnElement || ColumnObserver.__isColumnElement;\n\n    [...host.children].forEach((child) => {\n      if (isColumnElement(child)) {\n        // The child is a column element, add it to the list\n        columns.push(child);\n      } else if (child instanceof HTMLSlotElement) {\n        // The child is a slot, add all assigned column elements to the list\n        [...child.assignedElements({ flatten: true })]\n          .filter((assignedElement) => isColumnElement(assignedElement))\n          .forEach((assignedElement) => columns.push(assignedElement));\n      }\n    });\n\n    return columns;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
