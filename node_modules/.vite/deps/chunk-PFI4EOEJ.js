import {
  isIOS
} from "./chunk-T3UXCKHJ.js";
import {
  FocusTrapController
} from "./chunk-472KGBTN.js";
import {
  getDeepActiveElement,
  isKeyboardActive
} from "./chunk-5DESY7LS.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/overlay/src/vaadin-overlay-stack-mixin.js
var attachedInstances = /* @__PURE__ */ new Set();
var getAttachedInstances = () => [...attachedInstances].filter((el) => !el.hasAttribute("closing"));
var hasOnlyNestedOverlays = (overlay) => {
  const instances = getAttachedInstances();
  const next = instances[instances.indexOf(overlay) + 1];
  if (!next) {
    return true;
  }
  if (!overlay._deepContains(next)) {
    return false;
  }
  return hasOnlyNestedOverlays(next);
};
var isLastOverlay = (overlay, filter = (_overlay) => true) => {
  const filteredOverlays = getAttachedInstances().filter(filter);
  return overlay === filteredOverlays.pop();
};
var OverlayStackMixin = (superClass) => class OverlayStackMixin extends superClass {
  /**
   * Returns true if this is the last one in the opened overlays stack.
   *
   * @return {boolean}
   * @protected
   */
  get _last() {
    return isLastOverlay(this);
  }
  /**
   * Returns true if this is overlay is attached.
   *
   * @return {boolean}
   * @protected
   */
  get _isAttached() {
    return attachedInstances.has(this);
  }
  /**
   * Brings the overlay as visually the frontmost one.
   */
  bringToFront() {
    if (isLastOverlay(this) || hasOnlyNestedOverlays(this)) {
      return;
    }
    if (this.matches(":popover-open")) {
      this.hidePopover();
      this.showPopover();
    }
    this._removeAttachedInstance();
    this._appendAttachedInstance();
  }
  /** @protected */
  _enterModalState() {
    if (document.body.style.pointerEvents !== "none") {
      this._previousDocumentPointerEvents = document.body.style.pointerEvents;
      document.body.style.pointerEvents = "none";
    }
    getAttachedInstances().forEach((el) => {
      if (el !== this) {
        el.$.overlay.style.pointerEvents = "none";
      }
    });
  }
  /** @protected */
  _exitModalState() {
    if (this._previousDocumentPointerEvents !== void 0) {
      document.body.style.pointerEvents = this._previousDocumentPointerEvents;
      delete this._previousDocumentPointerEvents;
    }
    const instances = getAttachedInstances();
    let el;
    while (el = instances.pop()) {
      if (el === this) {
        continue;
      }
      el.$.overlay.style.removeProperty("pointer-events");
      if (!el.modeless) {
        break;
      }
    }
  }
  /** @protected */
  _appendAttachedInstance() {
    attachedInstances.add(this);
  }
  /** @protected */
  _removeAttachedInstance() {
    if (this._isAttached) {
      attachedInstances.delete(this);
    }
  }
};

// node_modules/@vaadin/overlay/src/styles/vaadin-overlay-base-styles.js
var overlayStyles = css`
  :host {
    z-index: 200;
    position: fixed;

    /* Despite of what the names say, <vaadin-overlay> is just a container
          for position/sizing/alignment. The actual overlay is the overlay part. */

    /* Default position constraints. Themes can
          override this to adjust the gap between the overlay and the viewport. */
    inset: max(env(safe-area-inset-top, 0px), var(--vaadin-overlay-viewport-inset, 8px))
      max(env(safe-area-inset-right, 0px), var(--vaadin-overlay-viewport-inset, 8px))
      max(env(safe-area-inset-bottom, 0px), var(--vaadin-overlay-viewport-bottom))
      max(env(safe-area-inset-left, 0px), var(--vaadin-overlay-viewport-inset, 8px));

    /* Override native [popover] user agent styles */
    width: auto;
    height: auto;
    border: none;
    padding: 0;
    background-color: transparent;
    overflow: visible;

    /* Use flexbox alignment for the overlay part. */
    display: flex;
    flex-direction: column; /* makes dropdowns sizing easier */
    /* Align to center by default. */
    align-items: center;
    justify-content: center;

    /* Allow centering when max-width/max-height applies. */
    margin: auto;

    /* The host is not clickable, only the overlay part is. */
    pointer-events: none;

    /* Remove tap highlight on touch devices. */
    -webkit-tap-highlight-color: transparent;

    /* CSS API for host */
    --vaadin-overlay-viewport-bottom: 8px;
  }

  :host([hidden]),
  :host(:not([opened]):not([closing])),
  :host(:not([opened]):not([closing])) [part='overlay'] {
    display: none !important;
  }

  [part='overlay'] {
    background: var(--vaadin-overlay-background, var(--vaadin-background-color));
    border: var(--vaadin-overlay-border-width, 1px) solid
      var(--vaadin-overlay-border-color, var(--vaadin-border-color-secondary));
    border-radius: var(--vaadin-overlay-border-radius, var(--vaadin-radius-m));
    box-shadow: var(--vaadin-overlay-shadow, 0 8px 24px -4px rgba(0, 0, 0, 0.3));
    box-sizing: border-box;
    max-width: 100%;
    overflow: auto;
    overscroll-behavior: contain;
    pointer-events: auto;
    -webkit-tap-highlight-color: initial;

    /* CSS reset for font styles */
    color: initial;
    font: initial;
    letter-spacing: initial;
    text-align: initial;
    text-decoration: initial;
    text-indent: initial;
    text-transform: initial;
    user-select: text;
    white-space: initial;
    word-spacing: initial;

    /* Inherit font-family */
    font-family: inherit;
  }

  [part='backdrop'] {
    background: var(--vaadin-overlay-backdrop-background, rgba(0, 0, 0, 0.2));
    content: '';
    inset: 0;
    pointer-events: auto;
    position: fixed;
    z-index: -1;
  }

  [part='overlay']:focus-visible {
    outline: var(--vaadin-focus-ring-width) solid var(--vaadin-focus-ring-color);
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      border: 3px solid !important;
    }
  }
`;

// node_modules/@vaadin/a11y-base/src/focus-restoration-controller.js
var FocusRestorationController = class {
  /**
   * Saves the given node as a target for restoring focus to
   * when `restoreFocus()` is called. If no node is provided,
   * the currently focused node in the DOM is saved as a target.
   *
   * @param {Node | null | undefined} focusNode
   */
  saveFocus(focusNode) {
    this.focusNode = focusNode || getDeepActiveElement();
  }
  /**
   * Restores focus to the target node that was saved previously with `saveFocus()`.
   */
  restoreFocus(options) {
    const focusNode = this.focusNode;
    if (!focusNode) {
      return;
    }
    const focusOptions = {
      preventScroll: options ? options.preventScroll : false,
      focusVisible: options ? options.focusVisible : false
    };
    if (getDeepActiveElement() === document.body) {
      setTimeout(() => focusNode.focus(focusOptions));
    } else {
      focusNode.focus(focusOptions);
    }
    this.focusNode = null;
  }
};

// node_modules/@vaadin/overlay/src/vaadin-overlay-focus-mixin.js
var OverlayFocusMixin = (superClass) => class OverlayFocusMixin extends superClass {
  static get properties() {
    return {
      /**
       * When true, opening the overlay moves focus to the first focusable child,
       * or to the overlay part with tabindex if there are no focusable children.
       * @attr {boolean} focus-trap
       */
      focusTrap: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to enable restoring of focus when overlay is closed.
       * @attr {boolean} restore-focus-on-close
       */
      restoreFocusOnClose: {
        type: Boolean,
        value: false
      },
      /**
       * Set to specify the element which should be focused on overlay close,
       * if `restoreFocusOnClose` is set to true.
       * @type {HTMLElement}
       */
      restoreFocusNode: {
        type: HTMLElement
      }
    };
  }
  constructor() {
    super();
    this.__focusTrapController = new FocusTrapController(this);
    this.__focusRestorationController = new FocusRestorationController();
  }
  /**
   * Override to specify another element used as a content root,
   * e.g. slotted into the overlay, rather than overlay itself.
   * @protected
   */
  get _contentRoot() {
    return this;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this.__focusTrapController);
    this.addController(this.__focusRestorationController);
  }
  /**
   * Override to specify another element used as a focus trap root,
   * e.g. the overlay's owner element, rather than overlay part.
   * @protected
   */
  get _focusTrapRoot() {
    return this.$.overlay;
  }
  /**
   * Release focus and restore focus after the overlay is closed.
   *
   * @protected
   */
  _resetFocus() {
    if (this.focusTrap) {
      this.__focusTrapController.releaseFocus();
    }
    if (this.restoreFocusOnClose && this._shouldRestoreFocus()) {
      const focusVisible = isKeyboardActive();
      const preventScroll = !focusVisible;
      this.__focusRestorationController.restoreFocus({ preventScroll, focusVisible });
    }
  }
  /**
   * Save the previously focused node when the overlay starts to open.
   *
   * @protected
   */
  _saveFocus() {
    if (this.restoreFocusOnClose) {
      this.__focusRestorationController.saveFocus(this.restoreFocusNode);
    }
  }
  /**
   * Trap focus within the overlay after opening has completed.
   *
   * @protected
   */
  _trapFocus() {
    if (this.focusTrap) {
      this.__focusTrapController.trapFocus(this._focusTrapRoot);
    }
  }
  /**
   * Returns true if focus is still inside the overlay or on the body element,
   * otherwise false.
   *
   * Focus shouldn't be restored if it's been moved elsewhere by another
   * component or as a result of a user interaction e.g. the user clicked
   * on a button outside the overlay while the overlay was open.
   *
   * @protected
   * @return {boolean}
   */
  _shouldRestoreFocus() {
    const activeElement = getDeepActiveElement();
    return activeElement === document.body || this._deepContains(activeElement);
  }
  /**
   * Returns true if the overlay contains the given node,
   * including those within shadow DOM trees.
   *
   * @param {Node} node
   * @return {boolean}
   * @protected
   */
  _deepContains(node) {
    if (this._contentRoot.contains(node)) {
      return true;
    }
    let n = node;
    const doc = node.ownerDocument;
    while (n && n !== doc && n !== this._contentRoot) {
      n = n.parentNode || n.host;
    }
    return n === this._contentRoot;
  }
};

// node_modules/@vaadin/overlay/src/vaadin-overlay-utils.js
function observeMove(element, callback) {
  let io = null;
  let timeout;
  const root = document.documentElement;
  function cleanup() {
    timeout && clearTimeout(timeout);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip = false, threshold = 1) {
    cleanup();
    const { left, top, width, height } = element.getBoundingClientRect();
    if (!skip) {
      callback();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = Math.floor(top);
    const insetRight = Math.floor(root.clientWidth - (left + width));
    const insetBottom = Math.floor(root.clientHeight - (top + height));
    const insetLeft = Math.floor(left);
    const rootMargin = `${-insetTop}px ${-insetRight}px ${-insetBottom}px ${-insetLeft}px`;
    const options = {
      rootMargin,
      threshold: Math.max(0, Math.min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeout = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    io = new IntersectionObserver(handleObserve, options);
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function setOverlayStateAttribute(overlay, name, value) {
  const elements = [overlay];
  if (overlay.owner) {
    elements.push(overlay.owner);
  }
  if (typeof value === "string") {
    elements.forEach((element) => {
      element.setAttribute(name, value);
    });
  } else if (value) {
    elements.forEach((element) => {
      element.setAttribute(name, "");
    });
  } else {
    elements.forEach((element) => {
      element.removeAttribute(name);
    });
  }
}

// node_modules/@vaadin/overlay/src/vaadin-overlay-mixin.js
var OverlayMixin = (superClass) => class OverlayMixin extends OverlayFocusMixin(OverlayStackMixin(superClass)) {
  static get properties() {
    return {
      /**
       * When true, the overlay is visible and attached to body.
       */
      opened: {
        type: Boolean,
        notify: true,
        observer: "_openedChanged",
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Owner element passed with renderer function
       * @type {HTMLElement}
       */
      owner: {
        type: Object,
        sync: true
      },
      /**
       * Object with properties that is passed to `renderer` function
       */
      model: {
        type: Object,
        sync: true
      },
      /**
       * Custom function for rendering the content of the overlay.
       * Receives three arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `owner` The host element of the renderer function.
       * - `model` The object with the properties related with rendering.
       * @type {OverlayRenderer | null | undefined}
       */
      renderer: {
        type: Object,
        sync: true
      },
      /**
       * When true the overlay won't disable the main content, showing
       * it doesn't change the functionality of the user interface.
       * @type {boolean}
       */
      modeless: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_modelessChanged",
        sync: true
      },
      /**
       * When set to true, the overlay is hidden. This also closes the overlay
       * immediately in case there is a closing animation in progress.
       * @type {boolean}
       */
      hidden: {
        type: Boolean,
        reflectToAttribute: true,
        observer: "_hiddenChanged",
        sync: true
      },
      /**
       * When true the overlay has backdrop on top of content when opened.
       * @type {boolean}
       */
      withBackdrop: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_withBackdropChanged",
        sync: true
      }
    };
  }
  static get observers() {
    return ["_rendererOrDataChanged(renderer, owner, model, opened)"];
  }
  /**
   * Override to specify another element used as a renderer root,
   * e.g. slotted into the overlay, rather than overlay itself.
   * @protected
   */
  get _rendererRoot() {
    return this;
  }
  constructor() {
    super();
    this._boundMouseDownListener = this._mouseDownListener.bind(this);
    this._boundMouseUpListener = this._mouseUpListener.bind(this);
    this._boundOutsideClickListener = this._outsideClickListener.bind(this);
    this._boundKeydownListener = this._keydownListener.bind(this);
    if (isIOS) {
      this._boundIosResizeListener = () => this._detectIosNavbar();
    }
  }
  /** @protected */
  firstUpdated() {
    super.firstUpdated();
    this.popover = "manual";
    this.addEventListener("click", () => {
    });
    if (this.$.backdrop) {
      this.$.backdrop.addEventListener("click", () => {
      });
    }
    this.addEventListener("mouseup", () => {
      if (document.activeElement === document.body && this.$.overlay.getAttribute("tabindex") === "0") {
        this.$.overlay.focus();
      }
    });
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this._boundIosResizeListener) {
      this._detectIosNavbar();
      window.addEventListener("resize", this._boundIosResizeListener);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.__scheduledOpen) {
      cancelAnimationFrame(this.__scheduledOpen);
      this.__scheduledOpen = null;
    }
    if (this._boundIosResizeListener) {
      window.removeEventListener("resize", this._boundIosResizeListener);
    }
  }
  /**
   * Requests an update for the content of the overlay.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this.renderer) {
      this.renderer.call(this.owner, this._rendererRoot, this.owner, this.model);
    }
  }
  /**
   * @param {Event=} sourceEvent
   */
  close(sourceEvent) {
    const event = new CustomEvent("vaadin-overlay-close", {
      bubbles: true,
      cancelable: true,
      detail: { overlay: this, sourceEvent }
    });
    this.dispatchEvent(event);
    document.body.dispatchEvent(event);
    if (!event.defaultPrevented) {
      this.opened = false;
    }
  }
  /**
   * Updates the coordinates of the overlay.
   * @param {!OverlayBoundsParam} bounds
   * @param {boolean} absolute
   */
  setBounds(bounds, absolute = true) {
    const overlay = this.$.overlay;
    const parsedBounds = { ...bounds };
    if (absolute && overlay.style.position !== "absolute") {
      overlay.style.position = "absolute";
    }
    Object.keys(parsedBounds).forEach((arg) => {
      if (parsedBounds[arg] !== null && !isNaN(parsedBounds[arg])) {
        parsedBounds[arg] = `${parsedBounds[arg]}px`;
      }
    });
    Object.assign(overlay.style, parsedBounds);
  }
  /** @private */
  _detectIosNavbar() {
    if (!this.opened) {
      return;
    }
    const innerHeight = window.innerHeight;
    const innerWidth = window.innerWidth;
    const landscape = innerWidth > innerHeight;
    const clientHeight = document.documentElement.clientHeight;
    if (landscape && clientHeight > innerHeight) {
      this.style.setProperty("--vaadin-overlay-viewport-bottom", `${clientHeight - innerHeight}px`);
    } else {
      this.style.setProperty("--vaadin-overlay-viewport-bottom", "0");
    }
  }
  /**
   * Whether to add global listeners for closing on outside click.
   * By default, listeners are not added for a modeless overlay.
   *
   * @return {boolean}
   * @protected
   */
  _shouldAddGlobalListeners() {
    return !this.modeless;
  }
  /** @private */
  _addGlobalListeners() {
    if (this.__hasGlobalListeners) {
      return;
    }
    this.__hasGlobalListeners = true;
    document.addEventListener("mousedown", this._boundMouseDownListener);
    document.addEventListener("mouseup", this._boundMouseUpListener);
    document.documentElement.addEventListener("click", this._boundOutsideClickListener, true);
  }
  /** @private */
  _removeGlobalListeners() {
    if (!this.__hasGlobalListeners) {
      return;
    }
    this.__hasGlobalListeners = false;
    document.removeEventListener("mousedown", this._boundMouseDownListener);
    document.removeEventListener("mouseup", this._boundMouseUpListener);
    document.documentElement.removeEventListener("click", this._boundOutsideClickListener, true);
  }
  /** @private */
  _rendererOrDataChanged(renderer, owner, model, opened) {
    const ownerOrModelChanged = this._oldOwner !== owner || this._oldModel !== model;
    this._oldModel = model;
    this._oldOwner = owner;
    const rendererChanged = this._oldRenderer !== renderer;
    const hasOldRenderer = this._oldRenderer !== void 0;
    this._oldRenderer = renderer;
    const openedChanged = this._oldOpened !== opened;
    this._oldOpened = opened;
    if (rendererChanged && hasOldRenderer) {
      this._rendererRoot.innerHTML = "";
      delete this._rendererRoot._$litPart$;
    }
    if (opened && renderer && (rendererChanged || openedChanged || ownerOrModelChanged)) {
      this.requestContentUpdate();
    }
  }
  /** @private */
  _modelessChanged(modeless) {
    if (this.opened) {
      if (this._shouldAddGlobalListeners()) {
        this._addGlobalListeners();
      } else {
        this._removeGlobalListeners();
      }
    }
    if (!modeless) {
      if (this.opened) {
        this._enterModalState();
      }
    } else {
      this._exitModalState();
    }
    setOverlayStateAttribute(this, "modeless", modeless);
  }
  /** @private */
  _withBackdropChanged(withBackdrop) {
    setOverlayStateAttribute(this, "with-backdrop", withBackdrop);
  }
  /** @private */
  _openedChanged(opened, wasOpened) {
    if (opened) {
      if (!this.isConnected) {
        this.opened = false;
        return;
      }
      this._saveFocus();
      this._animatedOpening();
      this.__scheduledOpen = requestAnimationFrame(() => {
        setTimeout(() => {
          this._trapFocus();
          const event = new CustomEvent("vaadin-overlay-open", { detail: { overlay: this }, bubbles: true });
          this.dispatchEvent(event);
          document.body.dispatchEvent(event);
        });
      });
      document.addEventListener("keydown", this._boundKeydownListener);
      if (this._shouldAddGlobalListeners()) {
        this._addGlobalListeners();
      }
    } else if (wasOpened) {
      if (this.__scheduledOpen) {
        cancelAnimationFrame(this.__scheduledOpen);
        this.__scheduledOpen = null;
      }
      this._resetFocus();
      this._animatedClosing();
      document.removeEventListener("keydown", this._boundKeydownListener);
      if (this._shouldAddGlobalListeners()) {
        this._removeGlobalListeners();
      }
    }
  }
  /** @private */
  _hiddenChanged(hidden) {
    if (hidden && this.hasAttribute("closing")) {
      this._flushAnimation("closing");
    }
  }
  /**
   * @return {boolean}
   * @private
   */
  _shouldAnimate() {
    const style = getComputedStyle(this);
    const name = style.getPropertyValue("animation-name");
    const hidden = style.getPropertyValue("display") === "none";
    return !hidden && name && name !== "none";
  }
  /**
   * @param {string} type
   * @param {Function} callback
   * @private
   */
  _enqueueAnimation(type, callback) {
    const handler = `__${type}Handler`;
    const listener = (event) => {
      if (event && event.target !== this) {
        return;
      }
      callback();
      this.removeEventListener("animationend", listener);
      delete this[handler];
    };
    this[handler] = listener;
    this.addEventListener("animationend", listener);
  }
  /**
   * @param {string} type
   * @protected
   */
  _flushAnimation(type) {
    const handler = `__${type}Handler`;
    if (typeof this[handler] === "function") {
      this[handler]();
    }
  }
  /** @private */
  _animatedOpening() {
    if (this._isAttached && this.hasAttribute("closing")) {
      this._flushAnimation("closing");
    }
    this._attachOverlay();
    this._appendAttachedInstance();
    this.bringToFront();
    if (!this.modeless) {
      this._enterModalState();
    }
    setOverlayStateAttribute(this, "opening", true);
    if (this._shouldAnimate()) {
      this._enqueueAnimation("opening", () => {
        this._finishOpening();
      });
    } else {
      this._finishOpening();
    }
  }
  /** @private */
  _attachOverlay() {
    this.showPopover();
  }
  /** @private */
  _finishOpening() {
    setOverlayStateAttribute(this, "opening", false);
  }
  /** @private */
  _finishClosing() {
    this._detachOverlay();
    this._removeAttachedInstance();
    this.$.overlay.style.removeProperty("pointer-events");
    setOverlayStateAttribute(this, "closing", false);
    this.dispatchEvent(new CustomEvent("vaadin-overlay-closed"));
  }
  /** @private */
  _animatedClosing() {
    if (this.hasAttribute("opening")) {
      this._flushAnimation("opening");
    }
    if (this._isAttached) {
      this._exitModalState();
      setOverlayStateAttribute(this, "closing", true);
      this.dispatchEvent(new CustomEvent("vaadin-overlay-closing"));
      if (this._shouldAnimate()) {
        this._enqueueAnimation("closing", () => {
          this._finishClosing();
        });
      } else {
        this._finishClosing();
      }
    }
  }
  /** @private */
  _detachOverlay() {
    this.hidePopover();
  }
  /** @private */
  _mouseDownListener(event) {
    this._mouseDownInside = event.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /** @private */
  _mouseUpListener(event) {
    this._mouseUpInside = event.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /**
   * Whether to close the overlay on outside click or not.
   * Override this method to customize the closing logic.
   *
   * @param {Event} _event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(_event) {
    return this._last;
  }
  /**
   * Outside click listener used in capture phase to close the overlay before
   * propagating the event to the listener on the element that triggered it.
   * Otherwise, calling `open()` would result in closing and re-opening.
   *
   * @private
   */
  _outsideClickListener(event) {
    if (event.composedPath().includes(this.$.overlay) || this._mouseDownInside || this._mouseUpInside) {
      this._mouseDownInside = false;
      this._mouseUpInside = false;
      return;
    }
    if (!this._shouldCloseOnOutsideClick(event)) {
      return;
    }
    const evt = new CustomEvent("vaadin-overlay-outside-click", {
      cancelable: true,
      detail: { sourceEvent: event }
    });
    this.dispatchEvent(evt);
    if (this.opened && !evt.defaultPrevented) {
      this.close(event);
    }
  }
  /**
   * Listener used to close whe overlay on Escape press, if it is the last one.
   * @private
   */
  _keydownListener(event) {
    if (!this._last || event.defaultPrevented) {
      return;
    }
    if (!this._shouldAddGlobalListeners() && !event.composedPath().includes(this._focusTrapRoot)) {
      return;
    }
    if (event.key === "Escape") {
      const evt = new CustomEvent("vaadin-overlay-escape-press", {
        cancelable: true,
        detail: { sourceEvent: event }
      });
      this.dispatchEvent(evt);
      if (this.opened && !evt.defaultPrevented) {
        this.close(event);
      }
    }
  }
};

export {
  overlayStyles,
  FocusRestorationController,
  OverlayFocusMixin,
  hasOnlyNestedOverlays,
  isLastOverlay,
  observeMove,
  setOverlayStateAttribute,
  OverlayMixin
};
//# sourceMappingURL=chunk-PFI4EOEJ.js.map
