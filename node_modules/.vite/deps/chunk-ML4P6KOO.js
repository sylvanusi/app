import {
  injectLumoStyleSheet,
  removeLumoStyleSheet
} from "./chunk-MKNWHZM7.js";
import {
  issueWarning
} from "./chunk-TMRBPE5K.js";

// node_modules/@vaadin/vaadin-themable-mixin/src/css-property-observer.js
var CSSPropertyObserver = class _CSSPropertyObserver extends EventTarget {
  #root;
  #properties = /* @__PURE__ */ new Set();
  #styleSheet;
  #isConnected = false;
  constructor(root) {
    super();
    this.#root = root;
    this.#styleSheet = new CSSStyleSheet();
  }
  #handleTransitionEvent(event) {
    const { propertyName } = event;
    if (this.#properties.has(propertyName)) {
      this.dispatchEvent(new CustomEvent("property-changed", { detail: { propertyName } }));
    }
  }
  observe(property) {
    this.connect();
    if (this.#properties.has(property)) {
      return;
    }
    this.#properties.add(property);
    this.#styleSheet.replaceSync(`
      :root::before, :host::before {
        content: '' !important;
        position: absolute !important;
        top: -9999px !important;
        left: -9999px !important;
        visibility: hidden !important;
        transition: 1ms allow-discrete step-end !important;
        transition-property: ${[...this.#properties].join(", ")} !important;
      }
    `);
  }
  connect() {
    if (this.#isConnected) {
      return;
    }
    this.#root.adoptedStyleSheets.unshift(this.#styleSheet);
    this.#rootHost.addEventListener("transitionstart", (event) => this.#handleTransitionEvent(event));
    this.#rootHost.addEventListener("transitionend", (event) => this.#handleTransitionEvent(event));
    this.#isConnected = true;
  }
  disconnect() {
    this.#properties.clear();
    this.#root.adoptedStyleSheets = this.#root.adoptedStyleSheets.filter((s) => s !== this.#styleSheet);
    this.#rootHost.removeEventListener("transitionstart", this.#handleTransitionEvent);
    this.#rootHost.removeEventListener("transitionend", this.#handleTransitionEvent);
    this.#isConnected = false;
  }
  get #rootHost() {
    return this.#root.documentElement ?? this.#root.host;
  }
  /**
   * Gets or creates the CSSPropertyObserver for the given root.
   * @param {DocumentOrShadowRoot} root
   * @returns {CSSPropertyObserver}
   */
  static for(root) {
    root.__cssPropertyObserver ||= new _CSSPropertyObserver(root);
    return root.__cssPropertyObserver;
  }
};

// node_modules/@vaadin/vaadin-themable-mixin/src/lumo-modules.js
var cache = /* @__PURE__ */ new WeakMap();
function getRuleMediaText(rule) {
  try {
    return rule.media.mediaText;
  } catch {
    issueWarning(
      '[LumoInjector] Browser denied to access property "mediaText" for some CSS rules, so they were skipped.'
    );
    return "";
  }
}
function getStyleSheetRules(styleSheet) {
  try {
    return styleSheet.cssRules;
  } catch {
    issueWarning(
      '[LumoInjector] Browser denied to access property "cssRules" for some CSS stylesheets, so they were skipped.'
    );
    return [];
  }
}
function parseStyleSheet(styleSheet, result = {
  tags: /* @__PURE__ */ new Map(),
  modules: /* @__PURE__ */ new Map()
}) {
  for (const rule of getStyleSheetRules(styleSheet)) {
    if (rule instanceof CSSImportRule) {
      const mediaText = getRuleMediaText(rule);
      if (mediaText.startsWith("lumo_")) {
        result.modules.set(mediaText, [...rule.styleSheet.cssRules]);
      } else {
        parseStyleSheet(rule.styleSheet, result);
      }
      continue;
    }
    if (rule instanceof CSSMediaRule) {
      const mediaText = getRuleMediaText(rule);
      if (mediaText.startsWith("lumo_")) {
        result.modules.set(mediaText, [...rule.cssRules]);
      }
      continue;
    }
    if (rule instanceof CSSStyleRule && rule.cssText.includes("-inject")) {
      for (const property of rule.style) {
        const tagName = property.match(/^--_lumo-(.*)-inject-modules$/u)?.[1];
        if (!tagName) {
          continue;
        }
        const value = rule.style.getPropertyValue(property);
        result.tags.set(
          tagName,
          value.split(",").map((module) => module.trim().replace(/'|"/gu, ""))
        );
      }
      continue;
    }
  }
  return result;
}
function parseStyleSheets(styleSheets) {
  let tags = /* @__PURE__ */ new Map();
  let modules = /* @__PURE__ */ new Map();
  for (const styleSheet of styleSheets) {
    let result = cache.get(styleSheet);
    if (!result) {
      result = parseStyleSheet(styleSheet);
      cache.set(styleSheet, result);
    }
    tags = new Map([...tags, ...result.tags]);
    modules = new Map([...modules, ...result.modules]);
  }
  return { tags, modules };
}

// node_modules/@vaadin/vaadin-themable-mixin/src/lumo-injector.js
function getLumoInjectorPropName(lumoInjector) {
  return `--_lumo-${lumoInjector.is}-inject`;
}
var LumoInjector = class {
  /** @type {Document | ShadowRoot} */
  #root;
  /** @type {CSSPropertyObserver} */
  #cssPropertyObserver;
  /** @type {Map<string, CSSStyleSheet>} */
  #styleSheetsByTag = /* @__PURE__ */ new Map();
  /** @type {Map<string, Set<HTMLElement>>} */
  #componentsByTag = /* @__PURE__ */ new Map();
  constructor(root = document) {
    this.#root = root;
    this.handlePropertyChange = this.handlePropertyChange.bind(this);
    this.#cssPropertyObserver = CSSPropertyObserver.for(root);
    this.#cssPropertyObserver.addEventListener("property-changed", this.handlePropertyChange);
  }
  disconnect() {
    this.#cssPropertyObserver.removeEventListener("property-changed", this.handlePropertyChange);
    this.#styleSheetsByTag.clear();
    this.#componentsByTag.values().forEach((components) => components.forEach(removeLumoStyleSheet));
  }
  /**
   * Adds a component to the list of elements monitored for style injection.
   * If the styles have already been detected, they are injected into the
   * component's shadow DOM immediately. Otherwise, the class watches the
   * custom property `--_lumo-{tagName}-inject` to trigger injection when
   * the styles are added to the document or root element.
   *
   * @param {HTMLElement} component
   */
  componentConnected(component) {
    const { lumoInjector } = component.constructor;
    const { is: tagName } = lumoInjector;
    this.#componentsByTag.set(tagName, this.#componentsByTag.get(tagName) ?? /* @__PURE__ */ new Set());
    this.#componentsByTag.get(tagName).add(component);
    const stylesheet = this.#styleSheetsByTag.get(tagName);
    if (stylesheet) {
      if (stylesheet.cssRules.length > 0) {
        injectLumoStyleSheet(component, stylesheet);
      }
      return;
    }
    this.#initStyleSheet(tagName);
    const propName = getLumoInjectorPropName(lumoInjector);
    this.#cssPropertyObserver.observe(propName);
  }
  /**
   * Removes the component from the list of elements monitored for
   * style injection and cleans up any previously injected styles.
   *
   * @param {HTMLElement} component
   */
  componentDisconnected(component) {
    const { is: tagName } = component.constructor.lumoInjector;
    this.#componentsByTag.get(tagName)?.delete(component);
    removeLumoStyleSheet(component);
  }
  handlePropertyChange(event) {
    const { propertyName } = event.detail;
    const tagName = propertyName.match(/^--_lumo-(.*)-inject$/u)?.[1];
    if (tagName) {
      this.#updateStyleSheet(tagName);
    }
  }
  #initStyleSheet(tagName) {
    this.#styleSheetsByTag.set(tagName, new CSSStyleSheet());
    this.#updateStyleSheet(tagName);
  }
  #updateStyleSheet(tagName) {
    const { tags, modules } = parseStyleSheets(this.#rootStyleSheets);
    const cssText = (tags.get(tagName) ?? []).flatMap((moduleName) => modules.get(moduleName) ?? []).map((rule) => rule.cssText).join("\n");
    const stylesheet = this.#styleSheetsByTag.get(tagName);
    stylesheet.replaceSync(cssText);
    this.#componentsByTag.get(tagName)?.forEach((component) => {
      if (cssText) {
        injectLumoStyleSheet(component, stylesheet);
      } else {
        removeLumoStyleSheet(component);
      }
    });
  }
  get #rootStyleSheets() {
    let styleSheets = /* @__PURE__ */ new Set();
    for (const root of [this.#root, document]) {
      styleSheets = styleSheets.union(new Set(root.styleSheets));
      styleSheets = styleSheets.union(new Set(root.adoptedStyleSheets));
    }
    return [...styleSheets];
  }
};

// node_modules/@vaadin/vaadin-themable-mixin/lumo-injection-mixin.js
var registeredProperties = /* @__PURE__ */ new Set();
function findRoot(element) {
  const root = element.getRootNode();
  if (root.host && root.host.constructor.version) {
    return findRoot(root.host);
  }
  return root;
}
var LumoInjectionMixin = (superClass) => class LumoInjectionMixinClass extends superClass {
  static finalize() {
    super.finalize();
    const propName = getLumoInjectorPropName(this.lumoInjector);
    if (this.is && !registeredProperties.has(propName)) {
      registeredProperties.add(propName);
      CSS.registerProperty({
        name: propName,
        syntax: "<number>",
        inherits: true,
        initialValue: "0"
      });
    }
  }
  static get lumoInjector() {
    return {
      is: this.is,
      includeBaseStyles: false
    };
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    const root = findRoot(this);
    if (root.__lumoInjectorDisabled) {
      return;
    }
    if (this.isConnected) {
      root.__lumoInjector ||= new LumoInjector(root);
      this.__lumoInjector = root.__lumoInjector;
      this.__lumoInjector.componentConnected(this);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.__lumoInjector) {
      this.__lumoInjector.componentDisconnected(this);
      this.__lumoInjector = void 0;
    }
  }
};

export {
  LumoInjectionMixin
};
//# sourceMappingURL=chunk-ML4P6KOO.js.map
