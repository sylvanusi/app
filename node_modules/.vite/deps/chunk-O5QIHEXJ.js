import {
  group
} from "./chunk-QGIE6N2M.js";
import {
  FieldMixin
} from "./chunk-ZZO67D7M.js";
import {
  field
} from "./chunk-WJXDM45A.js";
import {
  TooltipController
} from "./chunk-XFKQJ73Z.js";
import {
  generateUniqueId
} from "./chunk-Z5LHTDPJ.js";
import {
  SlotObserver
} from "./chunk-VNVGWFKZ.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  DisabledMixin
} from "./chunk-M3HWWZVG.js";
import {
  KeyboardMixin
} from "./chunk-WT6HVPMS.js";
import {
  FocusMixin
} from "./chunk-ERLMGG3V.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/radio-group/src/styles/vaadin-radio-group-base-styles.js
var radioGroupStyles = [
  field,
  group,
  css`
    :host([readonly]) ::slotted(vaadin-radio-button) {
      --vaadin-radio-button-background: transparent;
      --vaadin-radio-button-border-color: var(--vaadin-border-color);
      --vaadin-radio-button-marker-color: var(--vaadin-text-color);
      --_border-style: dashed;
    }
  `
];

// node_modules/@vaadin/radio-group/src/vaadin-radio-group-mixin.js
var RadioGroupMixin = (superclass) => class RadioGroupMixinClass extends FieldMixin(FocusMixin(DisabledMixin(KeyboardMixin(superclass)))) {
  static get properties() {
    return {
      /**
       * The name of the control, which is submitted with the form data.
       */
      name: {
        type: String,
        observer: "__nameChanged",
        sync: true
      },
      /**
       * The value of the radio group.
       *
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        sync: true,
        observer: "__valueChanged"
      },
      /**
       * When present, the user cannot modify the value of the radio group.
       * The property works similarly to the `disabled` property.
       * While the `disabled` property disables all radio buttons inside the group,
       * the `readonly` property disables only unchecked ones.
       *
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true,
        observer: "__readonlyChanged"
      },
      /**
       * @type {string}
       * @private
       */
      _fieldName: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.__registerRadioButton = this.__registerRadioButton.bind(this);
    this.__unregisterRadioButton = this.__unregisterRadioButton.bind(this);
    this.__onRadioButtonCheckedChange = this.__onRadioButtonCheckedChange.bind(this);
    this._tooltipController = new TooltipController(this);
    this._tooltipController.addEventListener("tooltip-changed", (event) => {
      const tooltip = event.detail.node;
      if (tooltip && tooltip.isConnected) {
        const inputs = this.__radioButtons.map((radio) => radio.inputElement);
        this._tooltipController.setAriaTarget(inputs);
      } else {
        this._tooltipController.setAriaTarget([]);
      }
    });
  }
  /**
   * A collection of the group's radio buttons.
   *
   * @return {!Array<!RadioButton>}
   * @private
   */
  get __radioButtons() {
    return this.__filterRadioButtons([...this.children]);
  }
  /**
   * A currently selected radio button.
   *
   * @return {!RadioButton | undefined}
   * @private
   */
  get __selectedRadioButton() {
    return this.__radioButtons.find((radioButton) => radioButton.checked);
  }
  /**
   * @return {boolean}
   * @private
   */
  get isHorizontalRTL() {
    return this.__isRTL && this._theme !== "vertical";
  }
  /** @protected */
  ready() {
    super.ready();
    this.ariaTarget = this;
    this.setAttribute("role", "radiogroup");
    this._fieldName = `${this.localName}-${generateUniqueId()}`;
    const slot = this.shadowRoot.querySelector("slot:not([name])");
    this._observer = new SlotObserver(slot, ({ addedNodes, removedNodes }) => {
      this.__filterRadioButtons(addedNodes).reverse().forEach(this.__registerRadioButton);
      this.__filterRadioButtons(removedNodes).forEach(this.__unregisterRadioButton);
      const inputs = this.__radioButtons.map((radio) => radio.inputElement);
      this._tooltipController.setAriaTarget(inputs);
    });
    this.addController(this._tooltipController);
  }
  /**
   * @param {!Array<!Node>} nodes
   * @return {!Array<!RadioButton>}
   * @private
   */
  __filterRadioButtons(nodes) {
    return nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && node.localName === "vaadin-radio-button");
  }
  /**
   * Override method inherited from `KeyboardMixin`
   * to implement the custom keyboard navigation as a replacement for the native one
   * in order for the navigation to work the same way across different browsers.
   *
   * @param {!KeyboardEvent} event
   * @override
   * @protected
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    const radioButton = event.composedPath().find((node) => node.nodeType === Node.ELEMENT_NODE && node.localName === "vaadin-radio-button");
    if (["ArrowLeft", "ArrowUp"].includes(event.key)) {
      event.preventDefault();
      this.__selectNextRadioButton(radioButton);
    }
    if (["ArrowRight", "ArrowDown"].includes(event.key)) {
      event.preventDefault();
      this.__selectPrevRadioButton(radioButton);
    }
  }
  /**
   * Override an observer from `FieldMixin`.
   *
   * @param {boolean} invalid
   * @protected
   * @override
   */
  _invalidChanged(invalid) {
    super._invalidChanged(invalid);
    if (invalid) {
      this.setAttribute("aria-invalid", "true");
    } else {
      this.removeAttribute("aria-invalid");
    }
  }
  /** @private */
  __nameChanged(name) {
    this.__radioButtons.forEach((radioButton) => {
      radioButton.name = name || this._fieldName;
    });
  }
  /**
   * @param {HTMLElement} radioButton
   * @private
   */
  __selectNextRadioButton(radioButton) {
    const index = this.__radioButtons.indexOf(radioButton);
    this.__selectIncRadioButton(index, this.isHorizontalRTL ? 1 : -1);
  }
  /**
   * @param {HTMLElement} radioButton
   * @private
   */
  __selectPrevRadioButton(radioButton) {
    const index = this.__radioButtons.indexOf(radioButton);
    this.__selectIncRadioButton(index, this.isHorizontalRTL ? -1 : 1);
  }
  /**
   * @param {number} index
   * @param {number} step
   * @private
   */
  __selectIncRadioButton(index, step) {
    const newIndex = (this.__radioButtons.length + index + step) % this.__radioButtons.length;
    const newRadioButton = this.__radioButtons[newIndex];
    if (newRadioButton.disabled) {
      this.__selectIncRadioButton(newIndex, step);
    } else {
      newRadioButton.focusElement.focus();
      newRadioButton.focusElement.click();
    }
  }
  /**
   * Registers the radio button after adding it to the group.
   *
   * @param {!RadioButton} radioButton
   * @private
   */
  __registerRadioButton(radioButton) {
    radioButton.name = this.name || this._fieldName;
    radioButton.addEventListener("checked-changed", this.__onRadioButtonCheckedChange);
    if (this.disabled || this.readonly) {
      radioButton.disabled = true;
    }
    if (radioButton.checked) {
      this.__selectRadioButton(radioButton);
    }
  }
  /**
   * Unregisters the radio button before removing it from the group.
   *
   * @param {!RadioButton} radioButton
   * @private
   */
  __unregisterRadioButton(radioButton) {
    radioButton.removeEventListener("checked-changed", this.__onRadioButtonCheckedChange);
    if (radioButton.value === this.value) {
      this.__selectRadioButton(null);
    }
  }
  /**
   * @param {!CustomEvent} event
   * @private
   */
  __onRadioButtonCheckedChange(event) {
    if (event.target.checked) {
      this.__selectRadioButton(event.target);
    }
  }
  /**
   * Whenever the user sets a non-empty value,
   * the method tries to select the radio button with that value
   * showing a warning if no radio button was found with the given value.
   * If the new value is empty, the method deselects the currently selected radio button.
   * At last, the method toggles the `has-value` attribute considering the new value.
   *
   * @param {string | null | undefined} newValue
   * @param {string | null | undefined} oldValue
   * @private
   */
  __valueChanged(newValue, oldValue) {
    if (oldValue === void 0 && newValue === "") {
      return;
    }
    if (newValue) {
      const newSelectedRadioButton = this.__radioButtons.find((radioButton) => {
        return radioButton.value === newValue;
      });
      if (newSelectedRadioButton) {
        this.__selectRadioButton(newSelectedRadioButton);
        this.toggleAttribute("has-value", true);
      } else {
        console.warn(`The radio button with the value "${newValue}" was not found.`);
      }
    } else {
      this.__selectRadioButton(null);
      this.removeAttribute("has-value");
    }
    if (oldValue !== void 0) {
      this._requestValidation();
    }
  }
  /**
   * Whenever `readonly` property changes on the group element,
   * the method updates the `disabled` property for the radio buttons.
   *
   * @param {boolean} newValue
   * @param {boolean} oldValue
   * @private
   */
  __readonlyChanged(newValue, oldValue) {
    if (!newValue && oldValue === void 0) {
      return;
    }
    if (oldValue !== newValue) {
      this.__updateRadioButtonsDisabledProperty();
    }
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to update the `disabled` property for the radio buttons
   * whenever the property changes on the group element.
   *
   * @param {boolean} newValue
   * @param {boolean} oldValue
   * @override
   * @protected
   */
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (!newValue && oldValue === void 0) {
      return;
    }
    if (oldValue !== newValue) {
      this.__updateRadioButtonsDisabledProperty();
    }
  }
  /**
   * Override method inherited from `FocusMixin`
   * to prevent removing the `focused` attribute
   * when focus moves between radio buttons inside the group.
   *
   * @param {!FocusEvent} event
   * @return {boolean}
   * @protected
   */
  _shouldRemoveFocus(event) {
    return !this.contains(event.relatedTarget);
  }
  /**
   * Override method inherited from `FocusMixin`
   * to run validation when the group loses focus.
   *
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /**
   * @param {RadioButton} radioButton
   * @private
   */
  __selectRadioButton(radioButton) {
    if (radioButton) {
      this.value = radioButton.value;
    } else {
      this.value = "";
    }
    this.__radioButtons.forEach((button) => {
      button.checked = button === radioButton;
    });
    if (this.readonly) {
      this.__updateRadioButtonsDisabledProperty();
    }
  }
  /**
   * If the group is read-only, the method disables the unchecked radio buttons.
   * Otherwise, the method propagates the group's `disabled` property to the radio buttons.
   *
   * @private
   */
  __updateRadioButtonsDisabledProperty() {
    this.__radioButtons.forEach((button) => {
      if (this.readonly) {
        button.disabled = button !== this.__selectedRadioButton;
      } else {
        button.disabled = this.disabled;
      }
    });
  }
};

// node_modules/@vaadin/radio-group/src/vaadin-radio-group.js
var RadioGroup = class extends RadioGroupMixin(ElementMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-radio-group";
  }
  static get styles() {
    return radioGroupStyles;
  }
  /** @protected */
  render() {
    return html`
      <div class="vaadin-group-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div part="group-field">
          <slot></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
};
defineCustomElement(RadioGroup);

export {
  RadioGroup
};
//# sourceMappingURL=chunk-O5QIHEXJ.js.map
