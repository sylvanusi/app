import {
  Grid,
  gridStyles
} from "./chunk-HFI5WLB3.js";
import "./chunk-NSMHBY24.js";
import "./chunk-7JJPFFGU.js";
import "./chunk-Y26XBQLX.js";
import "./chunk-K6BWFOYR.js";
import {
  iterateRowCells,
  updatePart
} from "./chunk-TZCAYWP4.js";
import "./chunk-6KHZPEKJ.js";
import "./chunk-DIP5G4YG.js";
import "./chunk-SP7V2F3Y.js";
import "./chunk-OSWHV746.js";
import {
  SlotStylesMixin
} from "./chunk-2WIP7T36.js";
import "./chunk-XFKQJ73Z.js";
import "./chunk-X5EEA4XV.js";
import "./chunk-Z5LHTDPJ.js";
import "./chunk-VNVGWFKZ.js";
import "./chunk-T3UXCKHJ.js";
import "./chunk-V6ISAKNA.js";
import {
  Debouncer
} from "./chunk-OWHE56FA.js";
import "./chunk-ZBUMLMW2.js";
import "./chunk-5W5MB6YY.js";
import "./chunk-M3HWWZVG.js";
import "./chunk-SVPOVVYN.js";
import "./chunk-5DESY7LS.js";
import "./chunk-ML4P6KOO.js";
import "./chunk-ULNR4UH6.js";
import "./chunk-MKNWHZM7.js";
import "./chunk-TMRBPE5K.js";
import "./chunk-56IVV4NW.js";
import {
  get,
  set
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import "./chunk-4MR6LGSU.js";
import "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";
import {
  animationFrame
} from "./chunk-MWWP2LZ3.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/grid-pro/src/styles/vaadin-grid-pro-base-styles.js
var gridPro = css`
  [part~='body-cell'] {
    --_highlight-color: color-mix(in srgb, currentColor 5%, transparent);
    --_highlight-color2: color-mix(in srgb, currentColor 10%, transparent);
  }

  [part~='editable-cell'] {
    display: flex;
    align-items: inherit;
    align-self: stretch;
    flex-grow: 1;
    min-width: 0;
    cursor: var(--vaadin-clickable-cursor);
    outline: 0;
  }

  /* Show cell focus outline */
  [part~='cell']:is([part~='editable-cell']:focus, :has([part~='editable-cell']:focus))::after {
    content: '';
  }

  /* On macOS the editable-cell part is a button inside the body cell. On other platforms the body cell is the editable-cell part. */

  @media (any-hover: hover) {
    [part~='body-cell']:is([part~='editable-cell'], :has([part~='editable-cell'])):hover {
      --vaadin-grid-row-hover-background-color: var(--_highlight-color);
    }
  }

  :host([navigating]) [part~='body-cell']:is([part~='editable-cell']:focus, :has([part~='editable-cell']:focus)) {
    --vaadin-grid-row-highlight-background-color: var(--_highlight-color);
  }

  /* Indicate editable cells */

  :host([theme~='highlight-editable-cells'])
    [part~='body-cell']:is([part~='editable-cell'], :has([part~='editable-cell'])) {
    --vaadin-grid-row-highlight-background-color: var(
      --vaadin-grid-pro-editable-cell-background-color,
      var(--_highlight-color)
    );
  }

  /* Indicate read-only cells */

  :host([theme~='highlight-read-only-cells'])
    [part~='body-cell']:not([part~='editable-cell'], :has([part~='editable-cell'])) {
    --_highlight-background-image: repeating-linear-gradient(
        -45deg,
        transparent,
        transparent 30%,
        var(--_highlight-color2) 30%,
        var(--_highlight-color2) 50%
      )
      padding-box 0 0 / 6px 6px;
  }

  /* Loading editor cell styles are used by Flow GridPro */
  :host([loading-editor]) [part~='focused-cell']::before {
    content: '';
    position: absolute;
    inset: 0;
    pointer-events: none;
    box-shadow: inset 0 0 0 var(--vaadin-focus-ring-width) var(--vaadin-focus-ring-color);
    animation: loading-editor 1.4s infinite;
    opacity: 0;
  }

  @keyframes loading-editor {
    50% {
      opacity: 1;
    }
  }

  [part~='updating-cell']::after {
    content: '';
    position: absolute;
    inset: var(--_cell-padding);
    margin: var(--vaadin-focus-ring-width);
    border-radius: 4px;
    background-size: max(4em, 50%);
    background-repeat: no-repeat;
    background-position: min(-200%, -4em) 0;
    background-image: linear-gradient(90deg, transparent, currentColor, transparent);
    animation: updating-cell 1.3s ease-out infinite;
    opacity: 0.1;
  }

  @keyframes updating-cell {
    100% {
      background-position: max(300%, 8em) 0;
    }
  }

  :host([loading-editor]) [part~='focused-cell'] ::slotted(vaadin-grid-cell-content),
  [part~='updating-cell'] ::slotted(vaadin-grid-cell-content) {
    opacity: 0;
    pointer-events: none;
  }
`;
var gridProStyles = [gridPro, gridStyles];

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-inline-editing-mixin.js
var InlineEditingMixin = (superClass) => class InlineEditingMixin extends superClass {
  static get properties() {
    return {
      /**
       * When true, pressing Enter while in cell edit mode
       * will move focus to the editable cell in the next row
       * (Shift + Enter - same, but for previous row).
       * @attr {boolean} enter-next-row
       */
      enterNextRow: {
        type: Boolean,
        notify: true
        // FIXME(yuriy-fix): needed by Flow counterpart
      },
      /**
       * When true, after moving to next or previous editable cell using
       * Tab / Shift+Tab, it will be focused without edit mode.
       *
       * When `enterNextRow` is true, pressing Enter will also
       * preserve edit mode, otherwise, it will have no effect.
       * @attr {boolean} single-cell-edit
       */
      singleCellEdit: {
        type: Boolean,
        notify: true
        // FIXME(yuriy-fix): needed by Flow counterpart
      },
      /**
       * When true, the grid enters cell edit mode on a single click
       * instead of the default double click.
       * @attr {boolean} edit-on-click
       */
      editOnClick: {
        type: Boolean
      },
      /** @private */
      _editingDisabled: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.__boundItemPropertyChanged = this._onItemPropertyChanged.bind(this);
    this.__boundEditorFocusOut = this._onEditorFocusOut.bind(this);
    this.__boundEditorFocusIn = this._onEditorFocusIn.bind(this);
    this._addEditColumnListener("mousedown", (e) => {
      e.stopImmediatePropagation();
      this.toggleAttribute("navigating", true);
    });
    this._addEditColumnListener("focusout", (e) => {
      e.stopImmediatePropagation();
    });
  }
  /** @protected */
  ready() {
    this.addEventListener(
      "keydown",
      (e) => {
        if (this.hasAttribute("loading-editor") && !["Tab", "Escape", "Enter"].includes(e.key)) {
          e.preventDefault();
          e.stopPropagation();
        }
      },
      true
    );
    this.addEventListener("keydown", (e) => {
      switch (e.keyCode) {
        case 27:
          if (this.__edited) {
            this._stopEdit(true);
          }
          break;
        case 9:
          if (this.__edited) {
            this._switchEditCell(e);
          }
          break;
        case 13:
          if (this.__edited) {
            this._switchEditCell(e);
          } else {
            this._enterEditFromEvent(e);
          }
          break;
        case 32:
          if (!this.__edited) {
            this._enterEditFromEvent(e);
          }
          break;
        default:
          if (e.key && e.key.length === 1) {
            this._enterEditFromEvent(e, "text");
          }
          break;
      }
    });
    super.ready();
    this.$.table.addEventListener("click", (e) => {
      const column = this.getEventContext(e).column;
      if (column && this._isEditColumn(column)) {
        if (this.editOnClick) {
          this._enterEditFromEvent(e);
        }
      }
    });
    if (this._ios) {
      let firstClickTime;
      let waitingSecondClick = false;
      this.addEventListener("click", (e) => {
        if (!waitingSecondClick) {
          firstClickTime = (/* @__PURE__ */ new Date()).getTime();
          waitingSecondClick = true;
          setTimeout(() => {
            waitingSecondClick = false;
          }, 300);
        } else {
          waitingSecondClick = false;
          const time = (/* @__PURE__ */ new Date()).getTime();
          if (time - firstClickTime < 300) {
            this._enterEditFromEvent(e);
          }
        }
      });
    } else {
      this.addEventListener("dblclick", (e) => {
        if (!this.editOnClick) {
          this._enterEditFromEvent(e);
        }
      });
    }
  }
  /**
   * Prevents making an edit column cell's parent row active on click.
   *
   * @override
   * @protected
   */
  _shouldPreventCellActivationOnClick(e) {
    return super._shouldPreventCellActivationOnClick(e) || // The clicked cell is editable
    this._isEditColumn(this.getEventContext(e).column);
  }
  /**
   * Override an observer from `DisabledMixin` to stop
   * editing when grid element becomes disabled.
   *
   * @param {boolean} disabled
   * @param {boolean} oldDisabled
   * @protected
   * @override
   */
  _disabledChanged(disabled, oldDisabled) {
    super._disabledChanged(disabled, oldDisabled);
    if (disabled && this.__edited) {
      this._stopEdit(true);
    }
  }
  /** @protected */
  _checkImports() {
    super._checkImports();
    ["vaadin-grid-pro-edit-column"].forEach((elementName) => {
      const element = this.querySelector(elementName);
      if (element && !customElements.get(elementName)) {
        console.warn(`Make sure you have imported the required module for <${elementName}> element.`);
      }
    });
  }
  /** @private */
  _applyEdit({ path, value, item }) {
    set(path, value, item);
    this.requestContentUpdate();
  }
  /** @private */
  _addEditColumnListener(type, callback) {
    this.addEventListener(type, (e) => {
      const context = this.getEventContext(e);
      const column = context.column;
      const edited = this.__edited;
      if (context.item && this._isEditColumn(column)) {
        const { cell } = this._getGridEventLocation(e);
        if (!cell || cell.getAttribute("part").indexOf("details-cell") > -1) {
          return;
        }
        if (edited && edited.cell === cell) {
          return;
        }
        if (!this._isCellEditable(cell)) {
          return;
        }
        callback(e);
      }
    });
  }
  /** @private */
  _onItemPropertyChanged(e) {
    if (!e.defaultPrevented) {
      this._applyEdit(e.detail);
    }
  }
  /** @private */
  _getRowByIndex(index) {
    return Array.from(this.$.items.children).find((el) => el.index === index);
  }
  /** @private */
  _isEditColumn(column) {
    return column && column.localName.toLowerCase() === "vaadin-grid-pro-edit-column";
  }
  /** @private */
  _getEditColumns() {
    const columnTreeLevel = this._columnTree.length - 1;
    return this._columnTree[columnTreeLevel].filter((column) => this._isEditColumn(column) && !column.hidden).sort((a, b) => a._order - b._order);
  }
  /** @private */
  _cancelStopEdit() {
    if (this._debouncerStopEdit) {
      this._debouncerStopEdit.cancel();
      delete this._debouncerStopEdit;
    }
  }
  /** @private */
  _flushStopEdit() {
    if (this._debouncerStopEdit) {
      this._debouncerStopEdit.flush();
      delete this._debouncerStopEdit;
    }
  }
  /** @private */
  _enterEditFromEvent(e, type) {
    const context = this.getEventContext(e);
    const column = context.column;
    const edited = this.__edited;
    if (context.item && this._isEditColumn(column)) {
      const { cell } = this._getGridEventLocation(e);
      if (!cell || cell.getAttribute("part").indexOf("details-cell") > -1) {
        return;
      }
      if (type && column.editorType !== type) {
        return;
      }
      if (edited && edited.cell === cell && column._getEditorComponent(cell).contains(e.target)) {
        return;
      }
      this._flushStopEdit();
      this._startEdit(cell, column);
    } else if (edited) {
      this._stopEdit();
    }
  }
  /** @private */
  _onEditorFocusOut(event) {
    if (this.__shouldIgnoreFocusOut(event)) {
      return;
    }
    this._debouncerStopEdit = Debouncer.debounce(this._debouncerStopEdit, animationFrame, this._stopEdit.bind(this));
  }
  /** @private */
  __shouldIgnoreFocusOut(event) {
    const edited = this.__edited;
    if (edited) {
      const { cell, column } = this.__edited;
      const editor = column._getEditorComponent(cell);
      const path = event.composedPath();
      const nodes = path.slice(0, path.indexOf(editor) + 1).filter((node) => node.nodeType === Node.ELEMENT_NODE);
      if (nodes.some((el) => typeof el._shouldRemoveFocus === "function" && !el._shouldRemoveFocus(event))) {
        return true;
      }
    }
  }
  /** @private */
  _onEditorFocusIn() {
    this._cancelStopEdit();
  }
  /** @private */
  _startEdit(cell, column) {
    const isCellEditable = this._isCellEditable(cell);
    if (this.disabled || this._editingDisabled || !isCellEditable) {
      return;
    }
    this._cancelStopEdit();
    this._scrollHorizontallyToCell(cell);
    const model = this.__getRowModel(cell.parentElement);
    this.__edited = { cell, column, model };
    column._startCellEdit(cell, model);
    this.dispatchEvent(
      new CustomEvent("cell-edit-started", {
        detail: {
          index: model.index,
          item: model.item,
          path: column.path
        },
        composed: true
      })
    );
    this.addEventListener("item-property-changed", this.__boundItemPropertyChanged);
  }
  /**
   * @param {boolean=} shouldCancel
   * @param {boolean=} shouldRestoreFocus
   * @protected
   */
  _stopEdit(shouldCancel, shouldRestoreFocus) {
    if (!this.__edited) {
      return;
    }
    const { cell, column, model } = this.__edited;
    if (!shouldCancel && !this.hasAttribute("loading-editor")) {
      const editor = column._getEditorComponent(cell);
      if (editor) {
        const value = column._getEditorValue(editor);
        if (value !== get(column.path, model.item)) {
          editor.blur();
          this.dispatchEvent(
            new CustomEvent("item-property-changed", {
              detail: {
                index: model.index,
                item: model.item,
                path: column.path,
                value
              },
              bubbles: true,
              cancelable: true,
              composed: true
            })
          );
        }
      }
    }
    column._stopCellEdit(cell, model);
    this.__edited = null;
    this.removeEventListener("item-property-changed", this.__boundItemPropertyChanged);
    if (shouldRestoreFocus) {
      cell.focus();
    }
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   */
  async _switchEditCell(e) {
    if (e.defaultPrevented && e.keyCode === 9) {
      return;
    }
    this._cancelStopEdit();
    const editableColumns = this._getEditColumns();
    const { cell, column, model } = this.__edited;
    e.stopImmediatePropagation();
    const editor = column._getEditorComponent(cell);
    if (e.key === "Tab" && editor && editor.contains(e.target)) {
      const ignore = await new Promise((resolve) => {
        editor.addEventListener(
          "focusout",
          (event) => {
            resolve(this.__shouldIgnoreFocusOut(event));
          },
          { once: true }
        );
      });
      if (ignore) {
        return;
      }
    } else {
      e.preventDefault();
    }
    this._stopEdit();
    let nextIndex = model.index;
    let nextColumn = column;
    let nextCell = cell;
    let directionX = 0;
    let directionY = 0;
    if (e.keyCode === 13 && this.enterNextRow) {
      directionY = e.shiftKey ? -1 : 1;
    }
    if (e.keyCode === 9) {
      directionX = e.shiftKey ? -1 : 1;
    }
    if (directionX || directionY) {
      while (nextCell) {
        if (directionX) {
          nextColumn = editableColumns[editableColumns.indexOf(nextColumn) + directionX];
          if (!nextColumn) {
            nextIndex += directionX;
            nextColumn = editableColumns[directionX > 0 ? 0 : editableColumns.length - 1];
          }
        }
        if (directionY) {
          nextIndex += directionY;
        }
        const nextRow = this._getRowByIndex(nextIndex);
        nextCell = nextRow && Array.from(nextRow.children).find((cell2) => cell2._column === nextColumn);
        if (nextCell && this._isCellEditable(nextCell)) {
          break;
        }
      }
    }
    if (!nextCell) {
      nextCell = cell;
      nextIndex = model.index;
    }
    if (!this.singleCellEdit && nextCell !== cell) {
      this._startEdit(nextCell, nextColumn);
    } else {
      this.__ensureFlatIndexInViewport(nextIndex);
      nextCell.focus();
    }
  }
  /**
   * @param {!HTMLElement} row
   * @private
   */
  __updateRow(row) {
    const item = this.__getRowItem(row);
    if (this.__edited) {
      const { cell, model } = this.__edited;
      if (cell.parentNode === row && this.getItemId(model.item) !== this.getItemId(item)) {
        this._stopEdit();
      }
    }
    super.__updateRow(row, item);
  }
  /**
   * Override method from `StylingMixin` to apply `editable-cell` part to the
   * cells of edit columns.
   *
   * @override
   */
  _generateCellPartNames(row, model) {
    super._generateCellPartNames(row, model);
    iterateRowCells(row, (cell) => {
      const isEditable = !row.hasAttribute("loading") && this._isCellEditable(cell);
      const target = cell._focusButton || cell;
      updatePart(target, "editable-cell", isEditable);
    });
  }
  /** @private */
  _isCellEditable(cell) {
    const column = cell._column;
    if (!this._isEditColumn(column)) {
      return false;
    }
    if (!column.isCellEditable) {
      return true;
    }
    const model = this.__getRowModel(cell.parentElement);
    const isEditable = column.isCellEditable(model);
    if (this.__edited && this.__edited.cell === cell && !isEditable) {
      this._stopEdit(true, true);
    }
    return isEditable;
  }
  /**
   * Fired before exiting the cell edit mode, if the value has been changed.
   * If the default is prevented, value change would not be applied.
   *
   * @event item-property-changed
   * @param {Object} detail
   * @param {Object} detail.index the row index of the edited cell
   * @param {Object} detail.item the grid item rendered to the row of the edited cell
   * @param {Object} detail.path the column path of the edited cell
   * @param {Object} detail.value the new value of the edited cell
   */
  /**
   * Fired when the user starts editing a grid cell.
   *
   * @event cell-edit-started
   * @param {Object} detail
   * @param {Object} detail.index the row index of the edited cell
   * @param {Object} detail.item the grid item rendered to the row of the edited cell
   * @param {Object} detail.path the column path of the edited cell
   */
};

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro.js
var GridPro = class extends SlotStylesMixin(InlineEditingMixin(Grid)) {
  static get is() {
    return "vaadin-grid-pro";
  }
  static get cvdlName() {
    return "vaadin-grid-pro";
  }
  static get styles() {
    return gridProStyles;
  }
  get slotStyles() {
    const tag = this.localName;
    return [
      `
      ${tag} [theme="grid-pro-editor"] {
        --vaadin-input-field-border-radius: 0px;
        --vaadin-input-field-border-width: 0px;
        width: 100%;
      }

      ${tag} [theme="grid-pro-editor"]::part(input-field) {
        height: 100%;
        outline-offset: calc(var(--vaadin-focus-ring-width) * -1);
      }

      vaadin-grid-cell-content:has([theme="grid-pro-editor"]) {
        padding: 0;
        overflow: visible;
      }
    `
    ];
  }
};
defineCustomElement(GridPro);
export {
  GridPro
};
//# sourceMappingURL=@vaadin_grid-pro_src_vaadin-grid-pro__js.js.map
