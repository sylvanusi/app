import "./chunk-RT3X2VXI.js";
import "./chunk-MIDFCHJR.js";
import "./chunk-TB3BFBAM.js";
import "./chunk-FOQZPEJP.js";
import {
  ifDefined
} from "./chunk-OSWHV746.js";
import "./chunk-PFI4EOEJ.js";
import "./chunk-ETQJ5U4W.js";
import {
  SlotStylesMixin
} from "./chunk-2WIP7T36.js";
import {
  KeyboardDirectionMixin
} from "./chunk-HJJCYWLA.js";
import "./chunk-XFKQJ73Z.js";
import {
  SlotController
} from "./chunk-X5EEA4XV.js";
import "./chunk-Z5LHTDPJ.js";
import "./chunk-VNVGWFKZ.js";
import "./chunk-WSKWP5BQ.js";
import "./chunk-T3UXCKHJ.js";
import "./chunk-472KGBTN.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import "./chunk-OWHE56FA.js";
import "./chunk-WT6HVPMS.js";
import {
  FocusMixin
} from "./chunk-ERLMGG3V.js";
import "./chunk-SVPOVVYN.js";
import "./chunk-5DESY7LS.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import "./chunk-ULNR4UH6.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import "./chunk-TMRBPE5K.js";
import "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html,
  render
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";
import "./chunk-MWWP2LZ3.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/message-list/src/styles/vaadin-message-base-styles.js
var messageStyles = css`
  :host {
    display: flex;
    flex-direction: row;
    padding: var(--vaadin-message-padding, var(--vaadin-padding-s) var(--vaadin-padding-m));
    gap: var(--vaadin-message-gap, var(--vaadin-gap-xs) var(--vaadin-gap-s));
  }

  :host([hidden]) {
    display: none !important;
  }

  :host(:is(:focus-visible, [focus-ring])) {
    outline: var(--vaadin-focus-ring-width) solid var(--vaadin-focus-ring-color);
    outline-offset: calc(var(--vaadin-focus-ring-width) * -1);
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    gap: inherit;
  }

  [part='header'] {
    align-items: baseline;
    display: flex;
    flex-flow: row wrap;
    gap: inherit;
    row-gap: 0;
    line-height: var(--vaadin-message-header-line-height, inherit);
  }

  [part='name'] {
    font-size: var(--vaadin-message-name-font-size, inherit);
    font-weight: var(--vaadin-message-name-font-weight, 500);
    color: var(--vaadin-message-name-color, var(--vaadin-text-color));
  }

  [part='time'] {
    font-size: var(--vaadin-message-time-font-size, max(11px, 0.75em));
    font-weight: var(--vaadin-message-time-font-weight, inherit);
    color: var(--vaadin-message-time-color, var(--vaadin-text-color-secondary));
  }

  [part='message'] {
    white-space: pre-wrap;
    font-size: var(--vaadin-message-font-size, inherit);
    font-weight: var(--vaadin-message-font-weight, inherit);
    line-height: var(--vaadin-message-line-height, inherit);
    color: var(--vaadin-message-text-color, var(--vaadin-text-color));
  }

  ::slotted([slot='avatar']) {
    flex: none;
  }

  ::slotted(vaadin-markdown) {
    white-space: normal;
  }
`;

// node_modules/@vaadin/message-list/src/vaadin-message-mixin.js
var MessageMixin = (superClass) => class MessageMixinClass extends FocusMixin(superClass) {
  static get properties() {
    return {
      /**
       * Time of sending the message. It is rendered as-is to the part='time' slot,
       * so the formatting is up to you.
       */
      time: {
        type: String
      },
      /**
       * The name of the user posting the message.
       * It will be placed in the name part to indicate who has sent the message.
       * It is also used as a tooltip for the avatar.
       * Example: `message.userName = "Jessica Jacobs";`
       * @attr {string} user-name
       */
      userName: {
        type: String
      },
      /**
       * The abbreviation of the user.
       * The abbreviation will be passed on to avatar of the message.
       * If the user does not have an avatar picture set with `userImg`, `userAbbr` will be shown in the avatar.
       * Example: `message.userAbbr = "JJ";`
       * @attr {string} user-abbr
       */
      userAbbr: {
        type: String
      },
      /**
       * An URL for a user image.
       * The image will be used in the avatar component to show who has sent the message.
       * Example: `message.userImg = "/static/img/avatar.jpg";`
       * @attr {string} user-img
       */
      userImg: {
        type: String
      },
      /**
       * A color index to be used to render the color of the avatar.
       * With no `userColorIndex` set, the basic avatar color will be used.
       * By setting a userColorIndex, the component will check if there exists a CSS variable defining the color, and uses it if there is one.
       * If now CSS variable is found for the color index, the property for the color will not be set.
       *
       * Example:
       * CSS:
       * ```css
       * html {
       *   --vaadin-user-color-1: red;
       * }
       * ```
       *
       * JavaScript:
       * ```js
       * message.userColorIndex = 1;
       * ```
       * @attr {number} user-color-index
       */
      userColorIndex: {
        type: Number
      },
      /** @private */
      _avatar: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__avatarChanged(_avatar, userName, userAbbr, userImg, userColorIndex)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this._avatarController = new SlotController(this, "avatar", "vaadin-avatar", {
      initializer: (avatar) => {
        avatar.setAttribute("aria-hidden", "true");
        this._avatar = avatar;
      }
    });
    this.addController(this._avatarController);
  }
  /** @private */
  __avatarChanged(avatar, userName, userAbbr, userImg, userColorIndex) {
    if (avatar) {
      avatar.setProperties({
        name: userName,
        abbr: userAbbr,
        img: userImg,
        colorIndex: userColorIndex
      });
    }
  }
};

// node_modules/@vaadin/message-list/src/vaadin-message.js
var Message = class extends MessageMixin(ElementMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-message";
  }
  static get styles() {
    return messageStyles;
  }
  static get lumoInjector() {
    return { ...super.lumoInjector, includeBaseStyles: true };
  }
  /** @protected */
  render() {
    return html`
      <slot name="avatar"></slot>
      <div part="content">
        <div part="header">
          <span part="name">${this.userName}</span>
          <span part="time">${this.time}</span>
        </div>
        <div part="message"><slot></slot></div>
      </div>
    `;
  }
};
defineCustomElement(Message);

// node_modules/@vaadin/message-list/src/vaadin-message-list-mixin.js
var MessageListMixin = (superClass) => class MessageListMixinClass extends KeyboardDirectionMixin(superClass) {
  static get properties() {
    return {
      /**
       * An array of objects which will be rendered as messages.
       * The message objects can have the following properties:
       * ```js
       * Array<{
       *   text: string,
       *   time: string,
       *   userName: string,
       *   userAbbr: string,
       *   userImg: string,
       *   userColorIndex: number,
       *   className: string,
       *   theme: string
       * }>
       * ```
       */
      items: {
        type: Array,
        value: () => [],
        observer: "_itemsChanged",
        sync: true
      },
      /**
       * When set to `true`, the message text is parsed as Markdown.
       * @type {boolean}
       */
      markdown: {
        type: Boolean,
        observer: "__markdownChanged",
        reflectToAttribute: true
      },
      /**
       * When set to `true`, new messages are announced to assistive technologies using ARIA live regions.
       * @attr {boolean} announce-messages
       * @type {boolean}
       */
      announceMessages: {
        type: Boolean,
        value: false,
        observer: "__announceChanged",
        sync: true
      }
    };
  }
  /** @protected */
  get _messages() {
    return [...this.querySelectorAll("vaadin-message")];
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("aria-relevant", "additions");
    this.setAttribute("role", "region");
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to use the list of message elements as items.
   *
   * @return {Element[]}
   * @protected
   * @override
   */
  _getItems() {
    return this._messages;
  }
  /** @private */
  _itemsChanged(newVal, oldVal) {
    const items = newVal || [];
    const oldItems = oldVal || [];
    if (items.length || oldItems.length) {
      const focusedIndex = this._getIndexOfFocusableElement();
      const closeToBottom = this.scrollHeight < this.clientHeight + this.scrollTop + 50;
      this._renderMessages(items);
      this._setTabIndexesByIndex(focusedIndex);
      requestAnimationFrame(() => {
        if (items.length > oldItems.length && closeToBottom) {
          this._scrollToLastMessage();
        }
      });
    }
  }
  /** @private */
  __markdownChanged(markdown) {
    if (markdown && !customElements.get("vaadin-markdown")) {
      import("./@vaadin_markdown_src_vaadin-markdown__js.js").then(() => customElements.whenDefined("vaadin-markdown")).then(() => this._renderMessages(this.items));
    }
    this._renderMessages(this.items);
  }
  /** @private */
  _renderMessages(items) {
    const loadingMarkdown = this.markdown && !customElements.get("vaadin-markdown");
    render(
      html`
          ${items.map(
        (item) => html`
              <vaadin-message
                role="listitem"
                .time="${item.time}"
                .userAbbr="${item.userAbbr}"
                .userName="${item.userName}"
                .userImg="${item.userImg}"
                .userColorIndex="${item.userColorIndex}"
                theme="${ifDefined(item.theme)}"
                class="${ifDefined(item.className)}"
                @focusin="${this._onMessageFocusIn}"
                style="${ifDefined(loadingMarkdown ? "visibility: hidden" : void 0)}"
                >${this.markdown ? html`<vaadin-markdown .content=${item.text}></vaadin-markdown>` : item.text}<vaadin-avatar slot="avatar"></vaadin-avatar
              ></vaadin-message>
            `
      )}
        `,
      this,
      { host: this }
    );
  }
  /** @private */
  _scrollToLastMessage() {
    if (this.items.length > 0) {
      this.scrollTop = this.scrollHeight - this.clientHeight;
    }
  }
  /** @private */
  _onMessageFocusIn(e) {
    const target = e.composedPath().find((node) => node instanceof customElements.get("vaadin-message"));
    this._setTabIndexesByMessage(target);
  }
  /**
   * @param {number} index
   * @protected
   */
  _setTabIndexesByIndex(index) {
    const message = this._messages[index] || this._messages[0];
    this._setTabIndexesByMessage(message);
  }
  /** @private */
  _setTabIndexesByMessage(message) {
    this._messages.forEach((e) => {
      e.tabIndex = e === message ? 0 : -1;
    });
  }
  /** @private */
  _getIndexOfFocusableElement() {
    const index = this._messages.findIndex((e) => e.tabIndex === 0);
    return index !== -1 ? index : 0;
  }
  /** @private */
  __announceChanged(announceMessages) {
    this.ariaLive = announceMessages ? "polite" : null;
  }
};

// node_modules/@vaadin/message-list/src/vaadin-message-list.js
var MessageList = class extends SlotStylesMixin(MessageListMixin(ElementMixin(ThemableMixin(PolylitMixin(LitElement))))) {
  static get is() {
    return "vaadin-message-list";
  }
  static get styles() {
    return css`
      :host {
        display: block;
        overflow: auto;
        padding: var(--vaadin-message-list-padding, var(--vaadin-padding-xs) 0);
      }

      :host([hidden]) {
        display: none !important;
      }
    `;
  }
  /** @protected */
  render() {
    return html`
      <div part="list" role="list">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      `
      ${tag} :where(vaadin-markdown > :is(h1, h2, h3, h4, h5, h6, p, ul, ol):first-child) {
        margin-top: 0;
      }

      ${tag} :where(vaadin-markdown > :is(h1, h2, h3, h4, h5, h6, p, ul, ol):last-child) {
        margin-bottom: 0;
      }
      `
    ];
  }
};
defineCustomElement(MessageList);
export {
  MessageList
};
//# sourceMappingURL=@vaadin_message-list_src_vaadin-message-list__js.js.map
