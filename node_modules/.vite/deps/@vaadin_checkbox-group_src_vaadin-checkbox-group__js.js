import {
  group
} from "./chunk-QGIE6N2M.js";
import "./chunk-WCDJXOAW.js";
import "./chunk-EV2VABJA.js";
import "./chunk-6KCLDTNY.js";
import "./chunk-C63QNJWN.js";
import "./chunk-2WIP7T36.js";
import {
  FieldMixin
} from "./chunk-ZZO67D7M.js";
import {
  field
} from "./chunk-WJXDM45A.js";
import "./chunk-722MDOVI.js";
import "./chunk-ME7RDPE7.js";
import "./chunk-R7PLRAV7.js";
import "./chunk-SFISAMYO.js";
import "./chunk-44TEYO45.js";
import {
  TooltipController
} from "./chunk-XFKQJ73Z.js";
import "./chunk-X5EEA4XV.js";
import "./chunk-Z5LHTDPJ.js";
import {
  SlotObserver
} from "./chunk-VNVGWFKZ.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import "./chunk-OWHE56FA.js";
import "./chunk-ZBUMLMW2.js";
import "./chunk-EIHDKHUQ.js";
import "./chunk-5W5MB6YY.js";
import {
  DisabledMixin
} from "./chunk-M3HWWZVG.js";
import "./chunk-WT6HVPMS.js";
import {
  FocusMixin
} from "./chunk-ERLMGG3V.js";
import "./chunk-SVPOVVYN.js";
import "./chunk-5DESY7LS.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import "./chunk-ULNR4UH6.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import "./chunk-TMRBPE5K.js";
import "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import "./chunk-5IHOHWXL.js";
import "./chunk-MWWP2LZ3.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/checkbox-group/src/styles/vaadin-checkbox-group-base-styles.js
var checkboxGroupStyles = [field, group];

// node_modules/@vaadin/checkbox-group/src/vaadin-checkbox-group-mixin.js
var CheckboxGroupMixin = (superclass) => class CheckboxGroupMixinClass extends FieldMixin(FocusMixin(DisabledMixin(superclass))) {
  static get properties() {
    return {
      /**
       * An array containing values of the currently checked checkboxes.
       *
       * The array is immutable so toggling checkboxes always results in
       * creating a new array.
       *
       * @type {!Array<!string>}
       */
      value: {
        type: Array,
        value: () => [],
        notify: true,
        sync: true,
        observer: "__valueChanged"
      },
      /**
       * When true, the user cannot modify the value of the checkbox group.
       * The difference between `disabled` and `readonly` is that in the
       * read-only checkbox group, all the checkboxes are also read-only,
       * and therefore remain focusable and announced by screen readers.
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "__readonlyChanged"
      }
    };
  }
  constructor() {
    super();
    this.__registerCheckbox = this.__registerCheckbox.bind(this);
    this.__unregisterCheckbox = this.__unregisterCheckbox.bind(this);
    this.__onCheckboxCheckedChanged = this.__onCheckboxCheckedChanged.bind(this);
    this._tooltipController = new TooltipController(this);
    this._tooltipController.addEventListener("tooltip-changed", (event) => {
      const tooltip = event.detail.node;
      if (tooltip && tooltip.isConnected) {
        const inputs = this.__checkboxes.map((checkbox) => checkbox.inputElement);
        this._tooltipController.setAriaTarget(inputs);
      } else {
        this._tooltipController.setAriaTarget([]);
      }
    });
  }
  /**
   * A collection of the checkboxes.
   *
   * @return {!Array<!Checkbox>}
   * @private
   */
  get __checkboxes() {
    return this.__filterCheckboxes([...this.children]);
  }
  /** @protected */
  ready() {
    super.ready();
    this.ariaTarget = this;
    this.setAttribute("role", "group");
    const slot = this.shadowRoot.querySelector("slot:not([name])");
    this._observer = new SlotObserver(slot, ({ addedNodes, removedNodes }) => {
      const addedCheckboxes = this.__filterCheckboxes(addedNodes);
      const removedCheckboxes = this.__filterCheckboxes(removedNodes);
      addedCheckboxes.forEach(this.__registerCheckbox);
      removedCheckboxes.forEach(this.__unregisterCheckbox);
      const inputs = this.__checkboxes.map((checkbox) => checkbox.inputElement);
      this._tooltipController.setAriaTarget(inputs);
      this.__warnOfCheckboxesWithoutValue(addedCheckboxes);
    });
    this.addController(this._tooltipController);
  }
  /**
   * Override method inherited from `ValidateMixin`
   * to validate the value array.
   *
   * @override
   * @return {boolean}
   */
  checkValidity() {
    return !this.required || Boolean(this.value && this.value.length > 0);
  }
  /**
   * @param {!Array<!Node>} nodes
   * @return {!Array<!Checkbox>}
   * @private
   */
  __filterCheckboxes(nodes) {
    return nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && node.localName === "vaadin-checkbox");
  }
  /**
   * @param {!Array<!Checkbox>} checkboxes
   * @private
   */
  __warnOfCheckboxesWithoutValue(checkboxes) {
    const hasCheckboxesWithoutValue = checkboxes.some((checkbox) => {
      const { value } = checkbox;
      return !checkbox.hasAttribute("value") && (!value || value === "on");
    });
    if (hasCheckboxesWithoutValue) {
      console.warn("Please provide the value attribute to all the checkboxes inside the checkbox group.");
    }
  }
  /**
   * Registers the checkbox after adding it to the group.
   *
   * @param {!Checkbox} checkbox
   * @private
   */
  __registerCheckbox(checkbox) {
    checkbox.addEventListener("checked-changed", this.__onCheckboxCheckedChanged);
    if (this.disabled) {
      checkbox.disabled = true;
    }
    if (this.readonly) {
      checkbox.readonly = true;
    }
    if (checkbox.checked) {
      this.__addCheckboxToValue(checkbox.value);
    } else if (this.value && this.value.includes(checkbox.value)) {
      checkbox.checked = true;
    }
  }
  /**
   * Unregisters the checkbox before removing it from the group.
   *
   * @param {!Checkbox} checkbox
   * @private
   */
  __unregisterCheckbox(checkbox) {
    checkbox.removeEventListener("checked-changed", this.__onCheckboxCheckedChanged);
    if (checkbox.checked) {
      this.__removeCheckboxFromValue(checkbox.value);
    }
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to propagate the `disabled` property to the checkboxes.
   *
   * @param {boolean} newValue
   * @param {boolean} oldValue
   * @override
   * @protected
   */
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (!newValue && oldValue === void 0) {
      return;
    }
    if (oldValue !== newValue) {
      this.__checkboxes.forEach((checkbox) => {
        checkbox.disabled = newValue;
      });
    }
  }
  /**
   * @param {string} value
   * @private
   */
  __addCheckboxToValue(value) {
    if (!this.value) {
      this.value = [value];
    } else if (!this.value.includes(value)) {
      this.value = [...this.value, value];
    }
  }
  /**
   * @param {string} value
   * @private
   */
  __removeCheckboxFromValue(value) {
    if (this.value && this.value.includes(value)) {
      this.value = this.value.filter((v) => v !== value);
    }
  }
  /**
   * @param {!CustomEvent} event
   * @private
   */
  __onCheckboxCheckedChanged(event) {
    const checkbox = event.target;
    if (checkbox.checked) {
      this.__addCheckboxToValue(checkbox.value);
    } else {
      this.__removeCheckboxFromValue(checkbox.value);
    }
  }
  /**
   * @param {string[] | null | undefined} value
   * @param {string[] | null | undefined} oldValue
   * @private
   */
  __valueChanged(value, oldValue) {
    if (value && value.length === 0 && oldValue === void 0) {
      return;
    }
    this.toggleAttribute("has-value", value && value.length > 0);
    this.__checkboxes.forEach((checkbox) => {
      checkbox.checked = value && value.includes(checkbox.value);
    });
    if (oldValue !== void 0) {
      this._requestValidation();
    }
  }
  /** @private */
  __readonlyChanged(readonly, oldReadonly) {
    if (readonly || oldReadonly) {
      this.__checkboxes.forEach((checkbox) => {
        checkbox.readonly = readonly;
      });
    }
  }
  /**
   * Override method inherited from `FocusMixin`
   * to prevent removing the `focused` attribute
   * when focus moves between checkboxes inside the group.
   *
   * @param {!FocusEvent} event
   * @return {boolean}
   * @protected
   */
  _shouldRemoveFocus(event) {
    return !this.contains(event.relatedTarget);
  }
  /**
   * Override method inherited from `FocusMixin`
   * to run validation when the group loses focus.
   *
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
};

// node_modules/@vaadin/checkbox-group/src/vaadin-checkbox-group.js
var CheckboxGroup = class extends CheckboxGroupMixin(
  ElementMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))
) {
  static get is() {
    return "vaadin-checkbox-group";
  }
  static get styles() {
    return checkboxGroupStyles;
  }
  /** @protected */
  render() {
    return html`
      <div class="vaadin-group-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div part="group-field">
          <slot></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
};
defineCustomElement(CheckboxGroup);
export {
  CheckboxGroup
};
//# sourceMappingURL=@vaadin_checkbox-group_src_vaadin-checkbox-group__js.js.map
