import {
  ensureSvgLiteral,
  unsafeSvgLiteral
} from "./chunk-FCPXKJGY.js";
import {
  ifDefined
} from "./chunk-OSWHV746.js";
import {
  ResizeMixin
} from "./chunk-J36B4EVN.js";
import {
  SlotStylesMixin
} from "./chunk-2WIP7T36.js";
import {
  TooltipController
} from "./chunk-XFKQJ73Z.js";
import {
  isSafari
} from "./chunk-T3UXCKHJ.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/icon/src/styles/vaadin-icon-base-styles.js
var iconStyles = css`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    box-sizing: border-box;
    vertical-align: middle;
    width: var(--vaadin-icon-size, 1lh);
    height: var(--vaadin-icon-size, 1lh);
    flex: none;
    fill: var(--vaadin-icon-color, currentColor);
    container-type: size;
  }

  :host::after,
  :host::before {
    line-height: 1;
    font-size: var(--vaadin-icon-visual-size, 100cqh);
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    -moz-osx-font-smoothing: grayscale;
  }

  :host([hidden]) {
    display: none !important;
  }

  svg {
    display: block;
    width: var(--vaadin-icon-visual-size, 100%);
    height: var(--vaadin-icon-visual-size, 100%);
    /* prevent overflowing icon from clipping, see https://github.com/vaadin/flow-components/issues/5872 */
    overflow: visible;

    @container style(--vaadin-icon-stroke-width) {
      stroke-width: var(--vaadin-icon-stroke-width);
    }
  }

  :host(:is([icon-class], [font-icon-content])) svg {
    display: none;
  }

  :host([font-icon-content])::before {
    content: attr(font-icon-content);
  }

  .baseline {
    order: -1;
  }

  .baseline::before {
    content: '\\2003' / '';
    display: inline-block;
    width: 0;
  }
`;

// node_modules/@vaadin/icon/src/vaadin-icon-helpers.js
function supportsCQUnitsForPseudoElements() {
  const testStyle = document.createElement("style");
  testStyle.textContent = `
    .vaadin-icon-test-element {
      container-type: size;
      height: 2px;
      visibility: hidden;
      position: fixed;
    }

    .vaadin-icon-test-element::before {
      content: '';
      display: block;
      height: 100cqh;
    `;
  const testElement = document.createElement("div");
  testElement.classList.add("vaadin-icon-test-element");
  const shadowParent = document.createElement("div");
  shadowParent.attachShadow({ mode: "open" });
  shadowParent.shadowRoot.innerHTML = "<slot></slot>";
  shadowParent.append(testElement.cloneNode());
  document.body.append(testStyle, testElement, shadowParent);
  const needsFallback = [...document.querySelectorAll(".vaadin-icon-test-element")].find(
    (el) => getComputedStyle(el, "::before").height !== "2px"
  );
  testStyle.remove();
  testElement.remove();
  shadowParent.remove();
  return !needsFallback;
}
function needsFontIconSizingFallback() {
  if (!CSS.supports("container-type: inline-size")) {
    return true;
  }
  if (!isSafari) {
    return false;
  }
  return !supportsCQUnitsForPseudoElements();
}

// node_modules/@vaadin/icon/src/vaadin-icon-font-size-mixin.js
var usesFontIconSizingFallback = needsFontIconSizingFallback();
var IconFontSizeMixin = (superclass) => !usesFontIconSizingFallback ? superclass : class extends ResizeMixin(superclass) {
  static get styles() {
    return css`
            :host::after,
            :host::before {
              font-size: var(--vaadin-icon-visual-size, var(--_vaadin-font-icon-size));
            }
          `;
  }
  /** @protected */
  updated(props) {
    super.updated(props);
    if (props.has("char") || props.has("iconClass") || props.has("ligature")) {
      this.__updateFontIconSize();
    }
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this.__updateFontIconSize();
  }
  /**
   * Updates the --_vaadin-font-icon-size CSS variable value if font icons are used.
   *
   * @private
   */
  __updateFontIconSize() {
    if (this.char || this.iconClass || this.ligature) {
      const { paddingTop, paddingBottom, height } = getComputedStyle(this);
      const fontIconSize = parseFloat(height) - parseFloat(paddingTop) - parseFloat(paddingBottom);
      this.style.setProperty("--_vaadin-font-icon-size", `${fontIconSize}px`);
    }
  }
};

// node_modules/@vaadin/icon/src/vaadin-icon-mixin.js
var srcCache = /* @__PURE__ */ new Map();
var Iconset = customElements.get("vaadin-iconset");
var IconMixin = (superClass) => class extends IconFontSizeMixin(SlotStylesMixin(superClass)) {
  static get properties() {
    return {
      /**
       * The name of the icon to use. The name should be of the form:
       * `iconset_name:icon_name`. When using `vaadin-icons` it is possible
       * to omit the first part and only use `icon_name` as a value.
       *
       * Setting the `icon` property updates the `svg` and `size` based on the
       * values provided by the corresponding `vaadin-iconset` element.
       *
       * See also [`name`](#/elements/vaadin-iconset#property-name) property of `vaadin-iconset`.
       *
       * @attr {string} icon
       * @type {string}
       */
      icon: {
        type: String,
        reflectToAttribute: true,
        observer: "__iconChanged",
        sync: true
      },
      /**
       * The SVG icon wrapped in a Lit template literal.
       */
      svg: {
        type: Object,
        sync: true
      },
      /**
       * The SVG source to be loaded as the icon. It can be:
       * - an URL to a file containing the icon
       * - an URL in the format `/path/to/file.svg#objectID`, where the `objectID` refers to an ID attribute contained
       *   inside the SVG referenced by the path. Note that the file needs to follow the same-origin policy.
       * - a string in the format `data:image/svg+xml,<svg>...</svg>`. You may need to use the `encodeURIComponent`
       *   function for the SVG content passed
       *
       * @type {string}
       */
      src: {
        type: String,
        sync: true
      },
      /**
       * The symbol identifier that references an ID of an element contained in the SVG element assigned to the
       * `src` property
       *
       * @type {string}
       */
      symbol: {
        type: String,
        sync: true
      },
      /**
       * Class names defining an icon font and/or a specific glyph inside an icon font.
       *
       * Example: "fa-solid fa-user"
       *
       * @attr {string} icon-class
       * @type {string}
       */
      iconClass: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * A hexadecimal code point that specifies a glyph from an icon font.
       *
       * Example: "e001"
       *
       * @type {string}
       */
      char: {
        type: String,
        sync: true
      },
      /**
       * A ligature name that specifies an icon from an icon font with support for ligatures.
       *
       * Example: "home".
       *
       * @type {string}
       */
      ligature: {
        type: String,
        sync: true
      },
      /**
       * The font family to use for the font icon.
       *
       * @attr {string} font-family
       * @type {string}
       */
      fontFamily: {
        type: String,
        observer: "__fontFamilyChanged",
        sync: true
      },
      /**
       * The size of an icon, used to set the `viewBox` attribute.
       */
      size: {
        type: Number,
        value: 24,
        sync: true
      },
      /** @private */
      __preserveAspectRatio: String,
      /** @private */
      __useRef: String,
      /** @private */
      __viewBox: String,
      /** @private */
      __fill: String,
      /** @private */
      __stroke: String,
      /** @private */
      __strokeWidth: String,
      /** @private */
      __strokeLinecap: String,
      /** @private */
      __strokeLinejoin: String
    };
  }
  static get observers() {
    return ["__fontChanged(iconClass, char, ligature)", "__srcChanged(src, symbol)"];
  }
  static get observedAttributes() {
    return [...super.observedAttributes, "class"];
  }
  constructor() {
    super();
    this.__fetch = fetch.bind(window);
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      `
        ${tag}[icon-class] {
          display: inline-flex;
          vertical-align: middle;
          font-size: inherit;
        }
      `
    ];
  }
  /** @private */
  get __iconClasses() {
    return this.iconClass ? this.iconClass.split(" ") : [];
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    Iconset.attachedIcons.add(this);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    Iconset.attachedIcons.delete(this);
  }
  /** @protected */
  _applyIcon() {
    const { preserveAspectRatio, svg, size, viewBox } = Iconset.getIconSvg(this.icon);
    if (viewBox) {
      this.__viewBox = viewBox;
    }
    if (preserveAspectRatio) {
      this.__preserveAspectRatio = preserveAspectRatio;
    }
    if (size && size !== this.size) {
      this.size = size;
    }
    this.svg = svg;
  }
  /** @private */
  __iconChanged(icon) {
    if (icon) {
      this._applyIcon();
    } else {
      this.svg = null;
    }
  }
  /** @private */
  async __srcChanged(src, symbol) {
    if (!src) {
      this.svg = null;
      return;
    }
    this.icon = "";
    if (!src.startsWith("data:") && (symbol || src.includes("#"))) {
      const [path, iconId] = src.split("#");
      this.__useRef = `${path}#${symbol || iconId}`;
    } else {
      try {
        if (!srcCache.has(src)) {
          srcCache.set(
            src,
            this.__fetch(src, {
              mode: "cors"
            }).then((data) => {
              if (!data.ok) {
                throw new Error("Error loading icon");
              }
              return data.text();
            })
          );
        }
        const svgData = await srcCache.get(src);
        if (!superClass.__domParser) {
          superClass.__domParser = new DOMParser();
        }
        const parsedResponse = superClass.__domParser.parseFromString(svgData, "text/html");
        const svgElement = parsedResponse.querySelector("svg");
        if (!svgElement) {
          throw new Error(`SVG element not found on path: ${src}`);
        }
        this.svg = unsafeSvgLiteral(svgElement.innerHTML);
        if (symbol) {
          this.__useRef = `#${symbol}`;
        }
        this.__viewBox = svgElement.getAttribute("viewBox");
        this.__fill = svgElement.getAttribute("fill");
        this.__stroke = svgElement.getAttribute("stroke");
        this.__strokeWidth = svgElement.getAttribute("stroke-width");
        this.__strokeLinecap = svgElement.getAttribute("stroke-linecap");
        this.__strokeLinejoin = svgElement.getAttribute("stroke-linejoin");
      } catch (e) {
        console.error(e);
        this.svg = null;
      }
    }
  }
  /** @private */
  __fontChanged(iconClass, char, ligature) {
    this.classList.remove(...this.__addedIconClasses || []);
    if (iconClass) {
      this.__addedIconClasses = [...this.__iconClasses];
      this.classList.add(...this.__addedIconClasses);
    }
    if (char) {
      this.setAttribute("font-icon-content", char.length > 1 ? String.fromCodePoint(parseInt(char, 16)) : char);
    } else if (ligature) {
      this.setAttribute("font-icon-content", ligature);
    } else {
      this.removeAttribute("font-icon-content");
    }
    if ((iconClass || char || ligature) && !this.icon) {
      this.icon = "";
    }
  }
  /** @protected */
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (name === "class" && this.__iconClasses.some((className) => !this.classList.contains(className))) {
      this.classList.add(...this.__iconClasses);
    }
  }
  /** @private */
  __fontFamilyChanged(fontFamily) {
    this.style.fontFamily = `'${fontFamily}'`;
  }
};

// node_modules/@vaadin/icon/src/vaadin-icon.js
var Icon = class extends IconMixin(ElementMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-icon";
  }
  static get styles() {
    return [iconStyles, super.styles].filter(Boolean);
  }
  static get lumoInjector() {
    return { ...super.lumoInjector, includeBaseStyles: true };
  }
  /** @protected */
  render() {
    return html`
      <span class="baseline"></span>
      <svg
        version="1.1"
        xmlns="http://www.w3.org/2000/svg"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        viewBox="${this.__viewBox || `0 0 ${this.size} ${this.size}`}"
        preserveAspectRatio="${this.__preserveAspectRatio || "xMidYMid meet"}"
        fill="${ifDefined(this.__fill)}"
        stroke="${ifDefined(this.__stroke)}"
        stroke-width="${ifDefined(this.__strokeWidth)}"
        stroke-linecap="${ifDefined(this.__strokeLinecap)}"
        stroke-linejoin="${ifDefined(this.__strokeLinejoin)}"
        aria-hidden="true"
      >
        <g id="svg-group">${ensureSvgLiteral(this.svg)}</g>
        <g id="use-group" visibility="${this.__useRef ? "visible" : "hidden"}">
          <use href="${ifDefined(this.__useRef)}" />
        </g>
      </svg>

      <slot name="tooltip"></slot>
    `;
  }
};
defineCustomElement(Icon);

export {
  Icon
};
//# sourceMappingURL=chunk-7TDQ7TW4.js.map
