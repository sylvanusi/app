import {
  PopoverOverlayMixin,
  PopoverPositionMixin,
  PopoverTargetMixin
} from "./chunk-TB3BFBAM.js";
import {
  ifDefined
} from "./chunk-OSWHV746.js";
import {
  hasOnlyNestedOverlays,
  isLastOverlay,
  overlayStyles
} from "./chunk-PFI4EOEJ.js";
import {
  generateUniqueId
} from "./chunk-Z5LHTDPJ.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  getDeepActiveElement,
  getFocusableElements,
  isElementFocused,
  isKeyboardActive
} from "./chunk-5DESY7LS.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  ThemableMixin,
  ThemePropertyMixin
} from "./chunk-MKNWHZM7.js";
import {
  DirMixin
} from "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/popover/src/styles/vaadin-popover-overlay-base-styles.js
var popoverOverlay = css`
  :host {
    --_arrow-size: var(--vaadin-popover-arrow-size, 8px);
    --_default-offset: 4px;
    --_rtl-multiplier: 1;
    --_border-width: var(--vaadin-popover-border-width, var(--vaadin-overlay-border-width, 1px));
  }

  [part='overlay']:focus-visible {
    outline: var(--vaadin-focus-ring-width) solid var(--vaadin-focus-ring-color);
  }

  :host([dir='rtl']) {
    --_rtl-multiplier: -1;
  }

  :host([modeless][with-backdrop]) [part='backdrop'] {
    pointer-events: none;
  }

  :host([position^='top'][top-aligned]) [part='overlay'],
  :host([position^='bottom'][top-aligned]) [part='overlay'] {
    margin-top: var(--vaadin-popover-offset-top, var(--_default-offset));
  }

  [part='overlay'] {
    position: relative;
    overflow: visible;
    max-height: 100%;
    border: var(--_border-width) solid
      var(--vaadin-popover-border-color, var(--vaadin-overlay-border-color, var(--vaadin-border-color-secondary)));
    background: var(--vaadin-popover-background, var(--vaadin-overlay-background, var(--vaadin-background-color)));
    box-shadow: var(--vaadin-popover-shadow, var(--vaadin-overlay-shadow, 0 8px 24px -4px rgba(0, 0, 0, 0.3)));
    border-radius: var(--vaadin-popover-border-radius, var(--vaadin-overlay-border-radius, var(--vaadin-radius-m)));
  }

  [part='content'] {
    overflow: auto;
    overscroll-behavior: contain;
    box-sizing: border-box;
    max-height: 100%;
    padding: var(--vaadin-popover-padding, var(--vaadin-padding-s));
  }

  :host([theme~='no-padding']) [part='content'] {
    padding: 0 !important;
  }

  /* Increase the area of the popover so the pointer can go from the target directly to it. */
  [part='overlay']::before {
    position: absolute;
    content: '';
    inset-block: calc(var(--vaadin-popover-offset-top, var(--_default-offset)) * -1)
      calc(var(--vaadin-popover-offset-bottom, var(--_default-offset)) * -1);
    inset-inline: calc(var(--vaadin-popover-offset-start, var(--_default-offset)) * -1)
      calc(var(--vaadin-popover-offset-end, var(--_default-offset)) * -1);
    z-index: -1;
    pointer-events: auto;
  }

  :host([position^='top'][bottom-aligned]) [part='overlay'],
  :host([position^='bottom'][bottom-aligned]) [part='overlay'] {
    margin-bottom: var(--vaadin-popover-offset-bottom, var(--_default-offset));
  }

  :host([position^='start'][start-aligned]) [part='overlay'],
  :host([position^='end'][start-aligned]) [part='overlay'] {
    margin-inline-start: var(--vaadin-popover-offset-start, var(--_default-offset));
  }

  :host([position^='start'][end-aligned]) [part='overlay'],
  :host([position^='end'][end-aligned]) [part='overlay'] {
    margin-inline-end: var(--vaadin-popover-offset-end, var(--_default-offset));
  }

  [part='arrow'] {
    display: none;
  }

  :host([theme~='arrow']) {
    --_default-offset: var(--_arrow-size);
  }

  :host([theme~='arrow']) [part='arrow'] {
    display: block;
    position: absolute;
    background: inherit;
    border: inherit;
    border-start-start-radius: var(--vaadin-popover-arrow-border-radius, 0);
    outline: inherit;
    box-shadow: inherit;
    width: var(--_arrow-size);
    height: var(--_arrow-size);
    rotate: 45deg;
    --o: 20px; /* clip-path outset, how far outward it extends to reveal the outline and box shadow */
    --b: var(--_border-width);
    /* We need this elaborate clip-path to allow the arrow bg and border to cover
      the overlay border but prevent the outline and box-shadow from covering it */
    clip-path: polygon(
      calc(var(--o) * -1) calc(var(--o) * -1),
      calc(100% + var(--o) - var(--b)) calc(var(--o) * -1),
      calc(100% - var(--b) * 1.4) 0,
      100% 0,
      calc(100% - var(--b)) var(--b),
      calc(100% - var(--b)) calc(var(--b) + var(--ff, 0px)),
      calc(var(--b) + var(--ff, 0px)) calc(100% - var(--b)),
      calc(var(--b)) calc(100% - var(--b)),
      0 100%,
      0 calc(100% - var(--b) * 1.4),
      calc(var(--o) * -1) calc(100% + var(--o) - var(--b))
    );
  }

  /* Firefox renders a blurry edge for a diagonal clip-path + rotation,
    so we need to extend the clip-path slightly further on the diagonal */
  @supports (-moz-appearance: none) {
    :host([theme~='arrow']) [part='arrow'] {
      --ff: 1px;
    }
  }

  /* bottom / top */
  :host([theme~='arrow']:is([position^='bottom'], [position^='top'])[start-aligned]) [part='arrow'] {
    inset-inline-start: calc(var(--_arrow-size) * 2);
  }

  :host([theme~='arrow']:is([position^='bottom'], [position^='top'])[end-aligned]) [part='arrow'] {
    inset-inline-end: calc(var(--_arrow-size) * 2);
  }

  :host([theme~='arrow']:is([position^='bottom'], [position^='top'])[arrow-centered]) [part='arrow'] {
    inset-inline-start: 50%;
  }

  /* bottom */
  :host([theme~='arrow']:is([position^='bottom'], [position^='top'])[top-aligned]) [part='arrow'] {
    top: 0;
    translate: calc(-50% * var(--_rtl-multiplier)) -50%;
  }

  :host([theme~='arrow']:is([position^='bottom'], [position^='top'])[end-aligned][top-aligned]) [part='arrow'] {
    translate: calc(50% * var(--_rtl-multiplier)) -50%;
  }

  /* top */
  :host([theme~='arrow']:is([position^='bottom'], [position^='top'])[bottom-aligned]) [part='arrow'] {
    bottom: 0;
    rotate: 225deg;
    translate: calc(-50% * var(--_rtl-multiplier)) 50%;
  }

  :host([theme~='arrow']:is([position^='bottom'], [position^='top'])[end-aligned][bottom-aligned]) [part='arrow'] {
    translate: calc(50% * var(--_rtl-multiplier)) 50%;
  }

  /* start / end */
  :host([theme~='arrow']:is([position^='start'], [position^='end'])[top-aligned]) [part='arrow'] {
    rotate: -45deg;
    top: calc(var(--_arrow-size) * 2);
  }

  :host([theme~='arrow']:is([position^='start'], [position^='end'])[bottom-aligned]) [part='arrow'] {
    rotate: -45deg;
    bottom: calc(var(--_arrow-size) * 2);
  }

  :host([theme~='arrow']:is([position='start'], [position='end'])[top-aligned]) [part='arrow'] {
    top: 50%;
  }

  :host([dir='rtl'][theme~='arrow']:is([position^='start'], [position^='end'])) [part='arrow'] {
    scale: -1;
  }

  /* end */
  :host([theme~='arrow']:is([position^='start'], [position^='end'])[start-aligned]) [part='arrow'] {
    inset-inline-start: 0;
    translate: calc(-50% * var(--_rtl-multiplier)) -50%;
  }

  :host([theme~='arrow']:is([position^='start'], [position^='end'])[start-aligned][bottom-aligned]) [part='arrow'] {
    translate: calc(-50% * var(--_rtl-multiplier)) 50%;
  }

  /* start */
  :host([theme~='arrow']:is([position^='start'], [position^='end'])[end-aligned]) [part='arrow'] {
    rotate: 135deg;
    inset-inline-end: 0;
    translate: calc(50% * var(--_rtl-multiplier)) -50%;
  }

  :host([theme~='arrow']:is([position^='start'], [position^='end'])[end-aligned][bottom-aligned]) [part='arrow'] {
    translate: calc(50% * var(--_rtl-multiplier)) 50%;
  }

  @media (forced-colors: active) {
    :host {
      --_border-width: 3px;
    }
  }
`;
var popoverOverlayStyles = [overlayStyles, popoverOverlay];

// node_modules/@vaadin/popover/src/vaadin-popover-overlay.js
var PopoverOverlay = class extends PopoverOverlayMixin(
  DirMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))
) {
  static get is() {
    return "vaadin-popover-overlay";
  }
  static get styles() {
    return popoverOverlayStyles;
  }
  static get lumoInjector() {
    return { ...super.lumoInjector, includeBaseStyles: true };
  }
  /** @protected */
  render() {
    return html`
      <div id="backdrop" part="backdrop" hidden ?hidden="${!this.withBackdrop}"></div>
      <div part="overlay" id="overlay">
        <div part="arrow"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
  /** @protected */
  updated(props) {
    super.updated(props);
    if (props.has("restoreFocusNode") && this.opened) {
      if (this.restoreFocusNode && isElementFocused(this.restoreFocusNode.focusElement || this.restoreFocusNode)) {
        this.__focusRestorationController.saveFocus();
      } else if (!this.restoreFocusNode) {
        this.__focusRestorationController.focusNode = null;
      }
    }
  }
  /**
   * @override
   * @protected
   */
  get _contentRoot() {
    return this.owner;
  }
  /**
   * @override
   * @protected
   */
  get _rendererRoot() {
    return this.owner;
  }
  /**
   * Override method from OverlayFocusMixin to use owner as focus trap root
   * @protected
   * @override
   */
  get _focusTrapRoot() {
    return this.owner;
  }
  /**
   * Override method from `OverlayMixin` to always add outside
   * click listener so that it can be used by modeless popover.
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldAddGlobalListeners() {
    return true;
  }
  /**
   * Override method from `OverlayMixin` to prevent closing when clicking on target.
   * Clicking the target will already close the popover when using the click trigger.
   *
   * @override
   * @protected
   */
  _shouldCloseOnOutsideClick(event) {
    if (event.composedPath().includes(this.positionTarget)) {
      return false;
    }
    return super._shouldCloseOnOutsideClick(event);
  }
};
defineCustomElement(PopoverOverlay);

// node_modules/@vaadin/popover/src/vaadin-popover.js
var DEFAULT_DELAY = 500;
var defaultFocusDelay = DEFAULT_DELAY;
var defaultHoverDelay = DEFAULT_DELAY;
var defaultHideDelay = DEFAULT_DELAY;
var PopoverOpenedStateController = class {
  constructor(host) {
    this.host = host;
  }
  /**
   * Whether closing is currently in progress.
   * @return {boolean}
   */
  get isClosing() {
    return this.__closeTimeout != null;
  }
  /** @private */
  get __focusDelay() {
    const popover = this.host;
    return popover.focusDelay != null && popover.focusDelay >= 0 ? popover.focusDelay : defaultFocusDelay;
  }
  /** @private */
  get __hoverDelay() {
    const popover = this.host;
    return popover.hoverDelay != null && popover.hoverDelay >= 0 ? popover.hoverDelay : defaultHoverDelay;
  }
  /** @private */
  get __hideDelay() {
    const popover = this.host;
    return popover.hideDelay != null && popover.hideDelay >= 0 ? popover.hideDelay : defaultHideDelay;
  }
  /**
   * Schedule opening the popover.
   * @param {Object} options
   */
  open(options = { immediate: false }) {
    if (this.isClosing) {
      this.__abortClose();
      return;
    }
    const { immediate, trigger } = options;
    const shouldDelayHover = trigger === "hover" && this.__hoverDelay > 0;
    const shouldDelayFocus = trigger === "focus" && this.__focusDelay > 0;
    if (!immediate && (shouldDelayHover || shouldDelayFocus)) {
      this.__scheduleOpen(trigger);
    } else {
      this.__showPopover();
    }
  }
  /**
   * Schedule closing the popover.
   * @param {boolean} immediate
   */
  close(immediate) {
    if (this.__openTimeout != null) {
      this.__abortOpen();
    } else if (immediate || this.__hideDelay === 0) {
      this.__abortClose();
      this.__setOpened(false);
    } else {
      this.__scheduleClose();
    }
  }
  /** @private */
  __setOpened(opened) {
    this.host.opened = opened;
  }
  /** @private */
  __showPopover() {
    this.__abortClose();
    this.__setOpened(true);
  }
  /** @private */
  __abortClose() {
    if (this.__closeTimeout) {
      clearTimeout(this.__closeTimeout);
      this.__closeTimeout = null;
    }
  }
  /** @private */
  __abortOpen() {
    if (this.__openTimeout) {
      clearTimeout(this.__openTimeout);
      this.__openTimeout = null;
    }
  }
  /** @private */
  __scheduleClose() {
    this.__closeTimeout = setTimeout(() => {
      this.__closeTimeout = null;
      this.__setOpened(false);
    }, this.__hideDelay);
  }
  /** @private */
  __scheduleOpen(trigger) {
    this.__abortOpen();
    const delay = trigger === "focus" ? this.__focusDelay : this.__hoverDelay;
    this.__openTimeout = setTimeout(() => {
      this.__openTimeout = null;
      this.__showPopover();
    }, delay);
  }
};
var isLastOverlay2 = (overlay) => {
  const filter = (o) => o.localName !== "vaadin-tooltip-overlay";
  return isLastOverlay(overlay, filter);
};
var Popover = class extends PopoverPositionMixin(
  PopoverTargetMixin(ThemePropertyMixin(ElementMixin(PolylitMixin(LitElement))))
) {
  static get is() {
    return "vaadin-popover";
  }
  static get styles() {
    return css`
      :host([opened]),
      :host([opening]),
      :host([closing]) {
        display: block !important;
        position: absolute;
        outline: none;
      }

      :host,
      :host([hidden]) {
        display: none !important;
      }

      :host(:focus-visible) ::part(overlay) {
        outline: var(--vaadin-focus-ring-width) solid var(--vaadin-focus-ring-color);
      }
    `;
  }
  static get properties() {
    return {
      /**
       * String used to label the popover to screen reader users.
       *
       * @attr {string} accessible-name
       * @deprecated Use `aria-label` attribute on the popover instead
       */
      accessibleName: {
        type: String
      },
      /**
       * Id of the element used as label of the popover to screen reader users.
       *
       * @attr {string} accessible-name-ref
       * @deprecated Use `aria-labelledby` attribute on the popover instead
       */
      accessibleNameRef: {
        type: String
      },
      /**
       * When true, the popover content automatically receives focus after
       * it is opened. Modal popovers use this behavior by default.
       */
      autofocus: {
        type: Boolean
      },
      /**
       * Set the height of the popover.
       * If a unitless number is provided, pixels are assumed.
       */
      height: {
        type: String
      },
      /**
       * Set the width of the popover.
       * If a unitless number is provided, pixels are assumed.
       */
      width: {
        type: String
      },
      /**
       * The delay in milliseconds before the popover is opened
       * on focus when the corresponding trigger is used.
       *
       * When not specified, the global default (500ms) is used.
       *
       * @attr {number} focus-delay
       */
      focusDelay: {
        type: Number
      },
      /**
       * The delay in milliseconds before the popover is closed
       * on losing hover, when the corresponding trigger is used.
       * On blur, the popover is closed immediately.
       *
       * When not specified, the global default (500ms) is used.
       *
       * @attr {number} hide-delay
       */
      hideDelay: {
        type: Number
      },
      /**
       * The delay in milliseconds before the popover is opened
       * on hover when the corresponding trigger is used.
       *
       * When not specified, the global default (500ms) is used.
       *
       * @attr {number} hover-delay
       */
      hoverDelay: {
        type: Number
      },
      /**
       * True if the popover is visible and available for interaction.
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true,
        observer: "__openedChanged"
      },
      /**
       * The `role` attribute value to be set on the popover.
       * When not specified, defaults to 'dialog'.
       */
      role: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * The `role` attribute value to be set on the popover.
       *
       * @attr {string} overlay-role
       * @deprecated Use standard `role` attribute on the popover instead
       */
      overlayRole: {
        type: String
      },
      /**
       * Custom function for rendering the content of the popover.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `popover` The reference to the `vaadin-popover` element.
       *
       * @deprecated Use the content in the `vaadin-popover` via default slot
       */
      renderer: {
        type: Object
      },
      /**
       * When true, the popover prevents interacting with background elements
       * by setting `pointer-events` style on the document body to `none`.
       * This also enables trapping focus inside the popover.
       */
      modal: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to disable closing popover on outside click.
       *
       * @attr {boolean} no-close-on-outside-click
       */
      noCloseOnOutsideClick: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to disable closing popover on Escape press.
       *
       * @attr {boolean} no-close-on-esc
       */
      noCloseOnEsc: {
        type: Boolean,
        value: false
      },
      /**
       * Popover trigger mode, used to configure how the popover is opened or closed.
       * Could be set to multiple by providing an array, e.g. `trigger = ['hover', 'focus']`.
       *
       * Supported values:
       * - `click` (default) - opens and closes on target click.
       * - `hover` - opens on target mouseenter, closes on target mouseleave. Moving mouse
       * to the popover content keeps the popover opened.
       * - `focus` - opens on target focus, closes on target blur. Moving focus to the
       * popover content keeps the popover opened.
       *
       * In addition to the behavior specified by `trigger`, the popover can be closed by:
       * - pressing Escape key (unless `noCloseOnEsc` property is true)
       * - outside click (unless `noCloseOnOutsideClick` property is true)
       *
       * When setting `trigger` property to `null`, `undefined` or empty array, the popover
       * can be only opened programmatically by changing `opened` property. Note, closing
       * on Escape press or outside click is still allowed unless explicitly disabled.
       */
      trigger: {
        type: Array,
        value: () => ["click"]
      },
      /**
       * When true, the popover has a backdrop (modality curtain) on top of the
       * underlying page content, covering the whole viewport.
       *
       * @attr {boolean} with-backdrop
       */
      withBackdrop: {
        type: Boolean,
        value: false
      },
      /** @private */
      __shouldRestoreFocus: {
        type: Boolean,
        value: false,
        sync: true
      }
    };
  }
  static get observers() {
    return ["__updateAriaAttributes(opened, role, target)"];
  }
  /**
   * Sets the default focus delay to be used by all popover instances,
   * except for those that have focus delay configured using property.
   *
   * @param {number} focusDelay
   */
  static setDefaultFocusDelay(focusDelay) {
    defaultFocusDelay = focusDelay != null && focusDelay >= 0 ? focusDelay : DEFAULT_DELAY;
  }
  /**
   * Sets the default hide delay to be used by all popover instances,
   * except for those that have hide delay configured using property.
   *
   * @param {number} hideDelay
   */
  static setDefaultHideDelay(hideDelay) {
    defaultHideDelay = hideDelay != null && hideDelay >= 0 ? hideDelay : DEFAULT_DELAY;
  }
  /**
   * Sets the default hover delay to be used by all popover instances,
   * except for those that have hover delay configured using property.
   *
   * @param {number} hoverDelay
   */
  static setDefaultHoverDelay(hoverDelay) {
    defaultHoverDelay = hoverDelay != null && hoverDelay >= 0 ? hoverDelay : DEFAULT_DELAY;
  }
  constructor() {
    super();
    this.__generatedId = `vaadin-popover-${generateUniqueId()}`;
    this.__onGlobalKeyDown = this.__onGlobalKeyDown.bind(this);
    this.__onTargetClick = this.__onTargetClick.bind(this);
    this.__onTargetFocusIn = this.__onTargetFocusIn.bind(this);
    this.__onTargetFocusOut = this.__onTargetFocusOut.bind(this);
    this.__onTargetMouseEnter = this.__onTargetMouseEnter.bind(this);
    this.__onTargetMouseLeave = this.__onTargetMouseLeave.bind(this);
    this._openedStateController = new PopoverOpenedStateController(this);
  }
  /** @protected */
  render() {
    const effectivePosition = this.__effectivePosition;
    return html`
      <vaadin-popover-overlay
        id="overlay"
        .renderer="${this.renderer}"
        .owner="${this}"
        theme="${ifDefined(this._theme)}"
        .positionTarget="${this.target}"
        .position="${effectivePosition}"
        .opened="${this.opened}"
        .modeless="${!this.modal}"
        .focusTrap="${this.modal}"
        .withBackdrop="${this.withBackdrop}"
        ?no-horizontal-overlap="${this.__computeNoHorizontalOverlap(effectivePosition)}"
        ?no-vertical-overlap="${this.__computeNoVerticalOverlap(effectivePosition)}"
        .horizontalAlign="${this.__computeHorizontalAlign(effectivePosition)}"
        .verticalAlign="${this.__computeVerticalAlign(effectivePosition)}"
        @mousedown="${this.__onOverlayMouseDown}"
        @mouseenter="${this.__onOverlayMouseEnter}"
        @mouseleave="${this.__onOverlayMouseLeave}"
        @focusin="${this.__onOverlayFocusIn}"
        @focusout="${this.__onOverlayFocusOut}"
        @opened-changed="${this.__onOpenedChanged}"
        .restoreFocusOnClose="${this.__shouldRestoreFocus}"
        .restoreFocusNode="${this.target}"
        exportparts="backdrop, overlay, content, arrow"
        @vaadin-overlay-escape-press="${this.__onEscapePress}"
        @vaadin-overlay-outside-click="${this.__onOutsideClick}"
        @vaadin-overlay-open="${this.__onOverlayOpened}"
        @vaadin-overlay-closed="${this.__onOverlayClosed}"
      >
        <slot></slot>
      </vaadin-popover-overlay>
    `;
  }
  /**
   * Requests an update for the content of the popover.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   *
   * @deprecated Add content elements as children of the popover using default slot
   */
  requestContentUpdate() {
    if (!this.renderer || !this._overlayElement) {
      return;
    }
    this._overlayElement.requestContentUpdate();
  }
  /** @protected */
  ready() {
    super.ready();
    this._overlayElement = this.$.overlay;
    this.setAttribute("tabindex", "0");
    this.addEventListener("focusin", (e) => {
      this.__onFocusIn(e);
    });
    this.addEventListener("focusout", (e) => {
      this.__onFocusOut(e);
    });
    if (!this.hasAttribute("role")) {
      this.role = "dialog";
    }
  }
  /** @protected */
  willUpdate(props) {
    super.willUpdate(props);
    if (props.has("overlayRole")) {
      this.role = this.overlayRole;
    }
  }
  /** @protected */
  updated(props) {
    super.updated(props);
    if (props.has("width") || props.has("height")) {
      const { width, height } = this;
      requestAnimationFrame(() => this.$.overlay.setBounds({ width, height }, false));
    }
    if (props.has("accessibleName")) {
      if (this.accessibleName) {
        this.setAttribute("aria-label", this.accessibleName);
      } else {
        this.removeAttribute("aria-label");
      }
    }
    if (props.has("accessibleNameRef")) {
      if (this.accessibleNameRef) {
        this.setAttribute("aria-labelledby", this.accessibleNameRef);
      } else {
        this.removeAttribute("aria-labelledby");
      }
    }
    if (props.has("modal")) {
      if (this.modal) {
        this.setAttribute("aria-modal", "true");
      } else {
        this.removeAttribute("aria-modal");
      }
    }
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (!this.id) {
      this.id = this.__generatedId;
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    queueMicrotask(() => {
      if (!this.isConnected) {
        this._openedStateController.close(true);
      }
    });
  }
  /**
   * @param {HTMLElement} target
   * @protected
   * @override
   */
  _addTargetListeners(target) {
    target.addEventListener("click", this.__onTargetClick);
    target.addEventListener("mouseenter", this.__onTargetMouseEnter);
    target.addEventListener("mouseleave", this.__onTargetMouseLeave);
    target.addEventListener("focusin", this.__onTargetFocusIn);
    target.addEventListener("focusout", this.__onTargetFocusOut);
  }
  /**
   * @param {HTMLElement} target
   * @protected
   * @override
   */
  _removeTargetListeners(target) {
    target.removeEventListener("click", this.__onTargetClick);
    target.removeEventListener("mouseenter", this.__onTargetMouseEnter);
    target.removeEventListener("mouseleave", this.__onTargetMouseLeave);
    target.removeEventListener("focusin", this.__onTargetFocusIn);
    target.removeEventListener("focusout", this.__onTargetFocusOut);
  }
  /** @private */
  __openedChanged(opened, oldOpened) {
    if (opened) {
      document.addEventListener("keydown", this.__onGlobalKeyDown, true);
    } else if (oldOpened) {
      document.removeEventListener("keydown", this.__onGlobalKeyDown, true);
    }
  }
  /** @private */
  __updateAriaAttributes(opened, role, target) {
    if (this.__oldTarget) {
      const oldEffectiveTarget = this.__oldTarget.ariaTarget || this.__oldTarget;
      oldEffectiveTarget.removeAttribute("aria-haspopup");
      oldEffectiveTarget.removeAttribute("aria-expanded");
      oldEffectiveTarget.removeAttribute("aria-controls");
    }
    if (target) {
      const effectiveTarget = target.ariaTarget || target;
      const isDialog = role === "dialog" || role === "alertdialog";
      effectiveTarget.setAttribute("aria-haspopup", isDialog ? "dialog" : "true");
      effectiveTarget.setAttribute("aria-expanded", opened ? "true" : "false");
      if (opened) {
        effectiveTarget.setAttribute("aria-controls", this.id);
      } else {
        effectiveTarget.removeAttribute("aria-controls");
      }
      this.__oldTarget = target;
    }
  }
  /** @private */
  __onTargetClick() {
    if (this.__hasTrigger("click")) {
      if (!this.opened) {
        this.__shouldRestoreFocus = true;
      }
      if (this.opened) {
        this._openedStateController.close(true);
      } else {
        this._openedStateController.open({ immediate: true });
      }
    }
  }
  /**
   * Overlay's global Escape press listener doesn't work when
   * the overlay is modeless, so we use a separate listener.
   * @private
   */
  __onGlobalKeyDown(event) {
    if (this.modal) {
      return;
    }
    if (event.key === "Tab") {
      if (event.shiftKey) {
        this.__onGlobalShiftTab(event);
      } else {
        this.__onGlobalTab(event);
      }
    }
  }
  /** @private */
  __onGlobalTab(event) {
    if (this.target && isElementFocused(this.__getTargetFocusable())) {
      event.preventDefault();
      this.focus();
      return;
    }
    const lastFocusable = this.__getLastFocusable(this);
    if (lastFocusable && isElementFocused(lastFocusable)) {
      const focusable = this.__getNextBodyFocusable(this.__getTargetFocusable());
      if (focusable && focusable !== this) {
        event.preventDefault();
        focusable.focus();
        return;
      }
    }
    const activeElement = getDeepActiveElement();
    const nextFocusable = this.__getNextBodyFocusable(activeElement);
    if (nextFocusable === this && lastFocusable) {
      lastFocusable.focus();
    }
  }
  /** @private */
  __onGlobalShiftTab(event) {
    if (this.target && isElementFocused(this.__getTargetFocusable()) && this.__shouldRestoreFocus) {
      this.__shouldRestoreFocus = false;
      return;
    }
    if (this.target && isElementFocused(this)) {
      event.preventDefault();
      this.__getTargetFocusable().focus();
      return;
    }
    const nextFocusable = this.__getNextBodyFocusable(this.__getTargetFocusable());
    if (nextFocusable && isElementFocused(nextFocusable)) {
      const lastFocusable = this.__getLastFocusable(this);
      if (lastFocusable) {
        event.preventDefault();
        lastFocusable.focus();
      }
    }
  }
  /** @private */
  __getNextBodyFocusable(target) {
    const focusables = getFocusableElements(document.body);
    const idx = focusables.findIndex((el) => el === target);
    return focusables[idx + 1];
  }
  /** @private */
  __getLastFocusable(container) {
    const focusables = getFocusableElements(container);
    return focusables.pop();
  }
  /** @private */
  __getTargetFocusable() {
    if (!this.target) {
      return null;
    }
    return this.target.focusElement || this.target;
  }
  /** @private */
  __onTargetFocusIn() {
    this.__focusInside = true;
    if (this.__hasTrigger("focus")) {
      if (this.__hasTrigger("click") && !isKeyboardActive()) {
        return;
      }
      if (!this.__shouldRestoreFocus) {
        this.__shouldRestoreFocus = true;
        this._openedStateController.open({ trigger: "focus" });
      }
    }
  }
  /** @private */
  __onTargetFocusOut(event) {
    if (this._overlayElement.opened && !isLastOverlay2(this._overlayElement) && hasOnlyNestedOverlays(this._overlayElement)) {
      return;
    }
    if (this.__hasTrigger("focus") && this.__mouseDownInside || this.contains(event.relatedTarget)) {
      return;
    }
    this.__handleFocusout();
  }
  /** @private */
  __onTargetMouseEnter() {
    this.__hoverInside = true;
    if (this.__hasTrigger("hover") && !this.opened) {
      if (this.modal) {
        this.target.style.pointerEvents = "auto";
      }
      this._openedStateController.open({ trigger: "hover" });
    }
  }
  /** @private */
  __onTargetMouseLeave(event) {
    if (this.contains(event.relatedTarget)) {
      return;
    }
    if (this._overlayElement.opened && !isLastOverlay2(this._overlayElement) && hasOnlyNestedOverlays(this._overlayElement)) {
      return;
    }
    this.__handleMouseLeave();
  }
  /** @private */
  __onFocusIn() {
    this.__focusInside = true;
    if (this.__hasTrigger("focus") || this.__hasTrigger("click")) {
      this.__shouldRestoreFocus = true;
    }
  }
  /** @private */
  __onFocusOut(event) {
    if (!isLastOverlay2(this._overlayElement) && hasOnlyNestedOverlays(this._overlayElement)) {
      return;
    }
    if (this.__hasTrigger("focus") && this.__mouseDownInside || event.relatedTarget === this.target || this.contains(event.relatedTarget)) {
      return;
    }
    this.__handleFocusout();
  }
  /** @private */
  __onOverlayMouseDown() {
    if (this.__hasTrigger("focus")) {
      this.__mouseDownInside = true;
      document.addEventListener(
        "mouseup",
        () => {
          this.__mouseDownInside = false;
        },
        { once: true }
      );
    }
  }
  /** @private */
  __onOverlayMouseEnter() {
    this.__hoverInside = true;
    if (this.__hasTrigger("hover") && this._openedStateController.isClosing) {
      this._openedStateController.open({ immediate: true });
    }
  }
  /** @private */
  __onOverlayMouseLeave(event) {
    if (event.relatedTarget === this.target) {
      return;
    }
    if (!isLastOverlay2(this._overlayElement) && hasOnlyNestedOverlays(this._overlayElement)) {
      return;
    }
    this.__handleMouseLeave();
  }
  /** @private */
  __handleFocusout() {
    this.__focusInside = false;
    if (this.__hasTrigger("hover") && this.__hoverInside) {
      return;
    }
    if (this.__hasTrigger("focus")) {
      if (isKeyboardActive()) {
        this.__shouldRestoreFocus = false;
      }
      this._openedStateController.close(true);
    }
  }
  /** @private */
  __handleMouseLeave() {
    this.__hoverInside = false;
    if (this.__hasTrigger("focus") && this.__focusInside) {
      return;
    }
    if (this.__hasTrigger("hover")) {
      this._openedStateController.close();
    }
  }
  /** @private */
  __onOpenedChanged(event) {
    this.opened = event.detail.value;
  }
  /** @private */
  __onOverlayOpened() {
    if (this.autofocus && !this.modal) {
      this.focus();
    }
  }
  /** @private */
  __onOverlayClosed() {
    if (this.__shouldRestoreFocus) {
      setTimeout(() => {
        this.__shouldRestoreFocus = false;
      });
    }
    if (this.modal && this.target && this.target.style.pointerEvents) {
      this.target.style.pointerEvents = "";
    }
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /**
   * Close the popover if `noCloseOnEsc` isn't set to true.
   * @private
   */
  __onEscapePress(e) {
    if (this.noCloseOnEsc) {
      e.preventDefault();
    }
  }
  /**
   * Close the popover if `noCloseOnOutsideClick` isn't set to true.
   * @private
   */
  __onOutsideClick(e) {
    if (this.noCloseOnOutsideClick) {
      e.preventDefault();
    }
  }
  /** @private */
  __hasTrigger(trigger) {
    return Array.isArray(this.trigger) && this.trigger.includes(trigger);
  }
  /**
   * Fired when the popover is closed.
   *
   * @event closed
   */
};
defineCustomElement(Popover);

export {
  Popover
};
//# sourceMappingURL=chunk-OJ4IZ7CK.js.map
