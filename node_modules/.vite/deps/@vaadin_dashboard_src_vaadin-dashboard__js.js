import "./chunk-I3CFTXMI.js";
import {
  DashboardSection,
  SYNCHRONIZED_ATTRIBUTES,
  WRAPPER_LOCAL_NAME,
  getDefaultI18n,
  getElementItem,
  getItemsArrayOfItem,
  itemsEqual
} from "./chunk-P6BRS3N6.js";
import {
  ResizeMixin
} from "./chunk-J36B4EVN.js";
import "./chunk-XFKQJ73Z.js";
import "./chunk-X5EEA4XV.js";
import "./chunk-Z5LHTDPJ.js";
import "./chunk-VNVGWFKZ.js";
import {
  I18nMixin
} from "./chunk-WSKWP5BQ.js";
import "./chunk-472KGBTN.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import "./chunk-OWHE56FA.js";
import "./chunk-YZIAODF7.js";
import "./chunk-GXEMU344.js";
import "./chunk-ZBUMLMW2.js";
import "./chunk-EIHDKHUQ.js";
import {
  addListener,
  setTouchAction
} from "./chunk-5W5MB6YY.js";
import "./chunk-M3HWWZVG.js";
import "./chunk-WT6HVPMS.js";
import "./chunk-ERLMGG3V.js";
import "./chunk-SVPOVVYN.js";
import "./chunk-5DESY7LS.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import "./chunk-ULNR4UH6.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import "./chunk-TMRBPE5K.js";
import "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";
import "./chunk-MWWP2LZ3.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/dashboard/src/styles/vaadin-dashboard-layout-base-styles.js
var dashboardLayoutStyles = css`
  :host {
    display: block;
    overflow: auto;
    box-sizing: border-box;
    width: 100%;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([dense-layout]) #grid {
    grid-auto-flow: dense;
  }

  #grid {
    box-sizing: border-box;

    /* Padding around dashboard edges */
    --_default-padding: var(--vaadin-padding-l);
    --_padding: max(0px, var(--vaadin-dashboard-padding, var(--_default-padding)));
    padding: var(--_padding);

    /* Gap between widgets */
    --_default-gap: var(--vaadin-gap-s);
    --_gap: max(0px, var(--vaadin-dashboard-gap, var(--_default-gap)));
    gap: var(--_gap);

    /* Default min and max column widths */
    --_default-col-min-width: 25em;
    --_default-col-max-width: 1fr;

    /* Effective min and max column widths */
    --_col-min-width: var(--vaadin-dashboard-col-min-width, var(--_default-col-min-width));
    --_col-max-width: var(--vaadin-dashboard-col-max-width, var(--_default-col-max-width));

    /* Effective max column count */
    --_col-max-count: var(--vaadin-dashboard-col-max-count, var(--_col-count));

    /* Effective column count */
    --_effective-col-count: min(var(--_col-count), var(--_col-max-count));

    /* Default row min height */
    --_default-row-min-height: 12em;
    /* Effective row min height */
    --_row-min-height: var(--vaadin-dashboard-row-min-height, var(--_default-row-min-height));
    /* Effective row height */
    --_row-height: minmax(var(--_row-min-height, auto), auto);

    display: grid;
    overflow: hidden;
    min-width: calc(var(--_col-min-width) + var(--_padding) * 2);

    grid-template-columns: repeat(
      var(--_effective-col-count, auto-fill),
      minmax(var(--_col-min-width), var(--_col-max-width))
    );

    grid-auto-rows: var(--_row-height);
  }

  ::slotted(*) {
    /* The grid-column value applied to children */
    --_item-column: span min(var(--vaadin-dashboard-widget-colspan, 1), var(--_effective-col-count, var(--_col-count)));

    grid-column: var(--_item-column);

    /* The grid-row value applied to children */
    --_item-row: span var(--vaadin-dashboard-widget-rowspan, 1);
    grid-row: var(--_item-row);
  }
`;

// node_modules/@vaadin/dashboard/src/styles/vaadin-dashboard-base-styles.js
var dashboard = css`
  #grid[item-resizing] {
    -webkit-user-select: none;
    user-select: none;
  }

  ::slotted(vaadin-dashboard-widget-wrapper) {
    display: contents;
  }
`;
var dashboardStyles = [dashboardLayoutStyles, dashboard];

// node_modules/@vaadin/dashboard/src/vaadin-dashboard-layout-mixin.js
var DashboardLayoutMixin = (superClass) => class DashboardLayoutMixinClass extends ResizeMixin(superClass) {
  static get properties() {
    return {
      /**
       * Whether the dashboard layout is dense.
       *
       * @attr {boolean} dense-layout
       * @type {boolean}
       */
      denseLayout: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Root heading level for sections and widgets. Defaults to 2.
       *
       * If changed to e.g. 1:
       * - sections will have the attribute `aria-level` with value 1
       * - non-nested widgets will have the attribute `aria-level` with value 1
       * - nested widgets will have the attribute `aria-level` with value 2
       *
       * @attr {number} root-heading-level
       */
      rootHeadingLevel: {
        type: Number,
        value: 2,
        sync: true,
        reflectToAttribute: true,
        observer: "__rootHeadingLevelChanged"
      }
    };
  }
  constructor() {
    super();
    this.__hasVaadinDashboardLayoutMixin = true;
  }
  /** @protected */
  ready() {
    super.ready();
    this._onResize();
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this.$.grid.style.width = `${this.offsetWidth}px`;
    this.__updateColumnCount();
  }
  /**
   * @private
   */
  __updateColumnCount() {
    this.$.grid.style.removeProperty("--_col-count");
    const columnCount = getComputedStyle(this.$.grid).gridTemplateColumns.split(" ").length;
    this.$.grid.style.setProperty("--_col-count", columnCount);
  }
  /** @private */
  __rootHeadingLevelChanged(rootHeadingLevel) {
    this.dispatchEvent(
      new CustomEvent("dashboard-root-heading-level-changed", { detail: { value: rootHeadingLevel } })
    );
  }
};

// node_modules/@vaadin/dashboard/src/widget-reorder-controller.js
var REORDER_EVENT_TIMEOUT = 200;
var REORDER_MOVE_THRESHOLD = 10;
var WidgetReorderController = class {
  constructor(host) {
    this.host = host;
    this.draggedElementRemoveObserver = new MutationObserver(() => this.__restoreDraggedElement());
    host.addEventListener("dragstart", (e) => this.__dragStart(e));
    host.addEventListener("dragend", (e) => this.__dragEnd(e));
    host.addEventListener("dragover", (e) => this.__dragOver(e));
    host.addEventListener("drop", (e) => this.__drop(e));
    host.addEventListener("item-move", (e) => this.__itemMove(e));
  }
  /** @private */
  __dragStart(e) {
    const handle = [...e.composedPath()].find((el) => el.classList && el.classList.contains("drag-handle"));
    if (!handle) {
      return;
    }
    this.__draggedElement = e.target;
    this.__draggedElement.__exitMode();
    this.__draggedElement.__focused = false;
    this.__draggedElement.__selected = false;
    this.draggedItem = getElementItem(this.__draggedElement);
    const { left, top } = this.__draggedElement.getBoundingClientRect();
    e.dataTransfer.setDragImage(this.__draggedElement, e.clientX - left, e.clientY - top);
    e.dataTransfer.setData("text/plain", "item");
    this.draggedElementRemoveObserver.observe(this.host, { childList: true, subtree: true });
    requestAnimationFrame(() => {
      this.host.items = [...this.host.items];
    });
  }
  /** @private */
  __dragOver(e) {
    if (!this.draggedItem) {
      return;
    }
    this.__startX ||= e.clientX;
    this.__startY ||= e.clientY;
    const currentDx = e.clientX - (this.__previousX || e.clientX);
    const currentDy = e.clientY - (this.__previousY || e.clientY);
    this.__previousX = e.clientX;
    this.__previousY = e.clientY;
    if (currentDx && this.__dx && Math.sign(currentDx) !== Math.sign(this.__dx)) {
      this.__startX = e.clientX;
    }
    if (currentDy && this.__dy && Math.sign(currentDy) !== Math.sign(this.__dy)) {
      this.__startY = e.clientY;
    }
    this.__dx = e.clientX - this.__startX;
    this.__dy = e.clientY - this.__startY;
    e.preventDefault();
    e.dataTransfer.dropEffect = "move";
    const dragContextElements = this.__getDragContextElements(this.__draggedElement);
    const draggedElement = dragContextElements.find((element) => getElementItem(element) === this.draggedItem);
    if (!draggedElement) {
      return;
    }
    const otherElements = dragContextElements.filter((element) => element !== draggedElement);
    if (otherElements.length === 0) {
      return;
    }
    let targetElement = otherElements.find((other) => other.contains(e.target));
    if (!targetElement) {
      targetElement = this.__getClosestElement(otherElements, e.clientX, e.clientY);
    }
    if (!this.__reordering && this.__isDraggedOver(draggedElement, targetElement, {
      x: e.clientX,
      y: e.clientY,
      dx: this.__dx,
      dy: this.__dy
    })) {
      this.__reordering = true;
      setTimeout(() => {
        this.__reordering = false;
      }, REORDER_EVENT_TIMEOUT);
      const targetItem = getElementItem(targetElement);
      const targetItems = getItemsArrayOfItem(targetItem, this.host.items);
      const targetIndex = targetItems.indexOf(targetItem);
      this.__reorderItems(this.draggedItem, targetIndex);
    }
  }
  /** @private */
  __dragEnd() {
    if (!this.draggedItem) {
      return;
    }
    this.__previousX = null;
    this.__previousY = null;
    this.__startX = null;
    this.__startY = null;
    this.__dx = null;
    this.__dy = null;
    if (this.__draggedElement.parentElement === this.host) {
      this.__draggedElement.remove();
    }
    this.__fireItemMovedEvent(this.draggedItem);
    this.__draggedElement = null;
    this.draggedItem = null;
    this.host.items = [...this.host.items];
    this.draggedElementRemoveObserver.disconnect();
  }
  /** @private */
  __fireItemMovedEvent(item) {
    const section = this.host.items.find((hostItem) => hostItem.items && hostItem.items.includes(item));
    this.host.dispatchEvent(
      new CustomEvent("dashboard-item-moved", {
        detail: { item, items: this.host.items, section }
      })
    );
  }
  /** @private */
  __drop(e) {
    if (!this.draggedItem) {
      return;
    }
    e.preventDefault();
  }
  /**
   * Returns the element closest to the given coordinates.
   * @private
   */
  __getClosestElement(elements, x, y) {
    return elements.reduce(
      (closest, element) => {
        const { left, top, width, height } = element.getBoundingClientRect();
        const centerX = left + width / 2;
        const centerY = top + height / 2;
        const distance = Math.hypot(centerX - x, centerY - y);
        return distance < closest.distance ? { element, distance } : closest;
      },
      { element: null, distance: Number.MAX_VALUE }
    ).element;
  }
  /**
   * Returns true if the dragged element is dragged enough over the target element in
   * the direction relative to their positions where x and y are the coordinates
   * of the drag event.
   * @private
   */
  __isDraggedOver(draggedElement, targetElement, { x, y, dx, dy }) {
    const draggedPos = draggedElement.getBoundingClientRect();
    const targetPos = targetElement.getBoundingClientRect();
    if (draggedPos.top >= targetPos.bottom) {
      return y < targetPos.bottom && dy < -REORDER_MOVE_THRESHOLD;
    } else if (draggedPos.bottom <= targetPos.top) {
      return y > targetPos.top && dy > REORDER_MOVE_THRESHOLD;
    } else if (draggedPos.left >= targetPos.right) {
      return x < targetPos.right && dx < -REORDER_MOVE_THRESHOLD;
    } else if (draggedPos.right <= targetPos.left) {
      return x > targetPos.left && dx > REORDER_MOVE_THRESHOLD;
    }
  }
  /**
   * Returns the elements (widgets or sections) that are candidates for reordering with the
   * currently dragged item. Effectively, this is the list of child widgets or sections inside
   * the same parent container (host or a section) as the dragged item.
   * @private
   */
  __getDragContextElements() {
    const draggedItemWrapper = [...this.host.querySelectorAll(WRAPPER_LOCAL_NAME)].find(
      (el) => itemsEqual(el.__item, this.draggedItem)
    );
    if (!draggedItemWrapper) {
      return [];
    }
    return [...draggedItemWrapper.parentElement.children].filter((el) => el.localName === WRAPPER_LOCAL_NAME && el.firstElementChild).map((el) => el.firstElementChild);
  }
  /** @private */
  __reorderItems(draggedItem, targetIndex) {
    if (targetIndex < 0 || targetIndex >= getItemsArrayOfItem(draggedItem, this.host.items).length) {
      return;
    }
    const items = getItemsArrayOfItem(draggedItem, this.host.items);
    const draggedIndex = items.indexOf(draggedItem);
    items.splice(draggedIndex, 1);
    items.splice(targetIndex, 0, draggedItem);
    this.host.items = [...this.host.items];
  }
  /**
   * The dragged element might be removed from the DOM during the drag operation if
   * the widgets get re-rendered. This method restores the dragged element if it's not
   * present in the DOM to ensure the dragend event is fired.
   * @private
   */
  __restoreDraggedElement() {
    if (!this.host.contains(this.__draggedElement)) {
      this.__draggedElement.style.display = "none";
      this.host.appendChild(this.__draggedElement);
    }
  }
  /**
   * Handle the item-move event dispatched by a widget / section.
   * @private
   */
  __itemMove(e) {
    e.stopImmediatePropagation();
    const item = getElementItem(e.target);
    const items = getItemsArrayOfItem(item, this.host.items);
    this.__reorderItems(item, items.indexOf(item) + e.detail.delta);
    this.__fireItemMovedEvent(item);
  }
};

// node_modules/@vaadin/dashboard/src/widget-resize-controller.js
var WidgetResizeController = class {
  constructor(host) {
    this.host = host;
    this.__resizedElementRemoveObserver = new MutationObserver(() => this.__restoreResizedElement());
    this.__touchMoveCancelListener = (e) => e.preventDefault();
    addListener(host, "track", (e) => this.__onTrack(e));
    setTouchAction(host, "");
    host.addEventListener("item-resize", (e) => this.__itemResize(e));
  }
  /** @private */
  __onTrack(e) {
    if (e.detail.state === "start") {
      this.__onResizeStart(e);
    } else if (e.detail.state === "track") {
      this.__onResize(e);
    } else if (e.detail.state === "end") {
      this.__onResizeEnd(e);
    }
  }
  /** @private */
  __onResizeStart(e) {
    const handle = [...e.composedPath()].find((el) => el.classList && el.classList.contains("resize-handle"));
    if (!handle) {
      return;
    }
    this.host.$.grid.toggleAttribute("item-resizing", true);
    this.resizedItem = getElementItem(e.target);
    this.__resizeStartWidth = e.target.offsetWidth;
    this.__resizeStartHeight = e.target.offsetHeight;
    this.__resizeWidth = this.__resizeStartWidth + e.detail.dx;
    this.__resizeHeight = this.__resizeStartHeight + e.detail.dy;
    this.__updateWidgetStyles();
    this.__resizedElement = e.target;
    this.__resizedElementRemoveObserver.observe(this.host, { childList: true, subtree: true });
    document.addEventListener("touchmove", this.__touchMoveCancelListener, { passive: false });
  }
  /** @private */
  __onResize(e) {
    if (!this.resizedItem) {
      return;
    }
    this.__resizeWidth = this.__resizeStartWidth + (document.dir === "rtl" ? -e.detail.dx : e.detail.dx);
    this.__resizeHeight = this.__resizeStartHeight + e.detail.dy;
    this.__updateWidgetStyles();
    const itemWrapper = this.__getItemWrapper(this.resizedItem);
    if (!itemWrapper.firstElementChild) {
      return;
    }
    const gridStyle = getComputedStyle(this.host.$.grid);
    const gapSize = parseFloat(gridStyle.gap || 0);
    const currentElementWidth = itemWrapper.firstElementChild.offsetWidth;
    const columns = gridStyle.gridTemplateColumns.split(" ");
    const columnWidth = parseFloat(columns[0]);
    if (this.__resizeWidth > currentElementWidth + gapSize + columnWidth / 2) {
      this.__updateResizedItem(1, 0);
    } else if (this.__resizeWidth < currentElementWidth - columnWidth / 2) {
      this.__updateResizedItem(-1, 0);
    }
    const currentElementHeight = itemWrapper.firstElementChild.offsetHeight;
    const rowMinHeight = Math.min(...gridStyle.gridTemplateRows.split(" ").map((height) => parseFloat(height)));
    if (e.detail.ddy > 0 && this.__resizeHeight > currentElementHeight + gapSize + rowMinHeight / 2) {
      this.__updateResizedItem(0, 1);
    } else if (e.detail.ddy < 0 && this.__resizeHeight < currentElementHeight - rowMinHeight / 2) {
      this.__updateResizedItem(0, -1);
    }
  }
  /** @private */
  __onResizeEnd() {
    if (!this.resizedItem) {
      return;
    }
    if (this.__resizedElement.parentElement === this.host) {
      this.__resizedElement.remove();
    }
    const itemWrapper = this.__getItemWrapper(this.resizedItem);
    itemWrapper.style.removeProperty("--_widget-resizer-width");
    itemWrapper.style.removeProperty("--_widget-resizer-height");
    if (itemWrapper.firstElementChild) {
      itemWrapper.firstElementChild.toggleAttribute("resizing", false);
    }
    this.host.$.grid.toggleAttribute("item-resizing", false);
    this.__resizedElementRemoveObserver.disconnect();
    document.removeEventListener("touchmove", this.__touchMoveCancelListener);
    this.__fireItemResizedEvent(this.resizedItem);
    this.resizedItem = null;
  }
  /** @private */
  __fireItemResizedEvent(item) {
    this.host.dispatchEvent(
      new CustomEvent("dashboard-item-resized", {
        detail: { item, items: this.host.items }
      })
    );
  }
  /** @private */
  __getItemWrapper(item) {
    return [...this.host.querySelectorAll(WRAPPER_LOCAL_NAME)].find((el) => itemsEqual(el.__item, item));
  }
  /** @private */
  __updateResizedItem(colspanDelta, rowspanDelta) {
    this.__resizeItem(this.resizedItem, colspanDelta, rowspanDelta);
    requestAnimationFrame(() => this.__updateWidgetStyles());
  }
  /** @private */
  __resizeItem(item, colspanDelta, rowspanDelta) {
    if (item.items) {
      return;
    }
    const gridStyle = getComputedStyle(this.host.$.grid);
    if (rowspanDelta && gridStyle.getPropertyValue("--_row-min-height") === "auto") {
      return;
    }
    const columns = gridStyle.gridTemplateColumns.split(" ");
    const currentColspan = item.colspan || 1;
    const currentRowspan = item.rowspan || 1;
    const newColspan = Math.min(Math.max(currentColspan + colspanDelta, 1), columns.length);
    const newRowspan = Math.max(currentRowspan + rowspanDelta, 1);
    if ((item.colspan || 1) === newColspan && (item.rowspan || 1) === newRowspan) {
      return;
    }
    item.colspan = newColspan;
    item.rowspan = newRowspan;
    this.host.items = [...this.host.items];
  }
  /** @private */
  __updateWidgetStyles() {
    const itemWrapper = this.__getItemWrapper(this.resizedItem);
    itemWrapper.style.setProperty("--_widget-resizer-width", `${this.__resizeWidth}px`);
    itemWrapper.style.setProperty("--_widget-resizer-height", `${this.__resizeHeight}px`);
    if (itemWrapper.firstElementChild) {
      itemWrapper.firstElementChild.toggleAttribute("resizing", true);
    }
  }
  /** @private */
  __restoreResizedElement() {
    if (!this.host.contains(this.__resizedElement)) {
      this.__resizedElement.style.display = "none";
      this.host.appendChild(this.__resizedElement);
    }
  }
  /**
   * Handle the item-resize event dispatched by a widget / section.
   * @private
   */
  __itemResize(e) {
    e.stopImmediatePropagation();
    const item = getElementItem(e.target);
    this.__resizeItem(item, e.detail.colspanDelta, e.detail.rowspanDelta);
    this.__fireItemResizedEvent(item);
  }
  hostDisconnected() {
    document.removeEventListener("touchmove", this.__touchMoveCancelListener);
  }
};

// node_modules/@vaadin/dashboard/src/vaadin-dashboard.js
var Dashboard = class extends DashboardLayoutMixin(
  I18nMixin(getDefaultI18n(), ElementMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement)))))
) {
  static get is() {
    return "vaadin-dashboard";
  }
  static get cvdlName() {
    return "vaadin-dashboard";
  }
  static get styles() {
    return dashboardStyles;
  }
  static get lumoInjector() {
    return { ...super.lumoInjector, includeBaseStyles: true };
  }
  static get properties() {
    return {
      /**
       * An array containing the items of the dashboard
       * @type {!Array<!DashboardItem> | null | undefined}
       */
      items: {
        type: Array
      },
      /**
       * Custom function for rendering a widget for each dashboard item.
       * Placing something else than a widget in the wrapper is not supported.
       * Receives three arguments:
       *
       * - `root` The container for the widget.
       * - `dashboard` The reference to the `<vaadin-dashboard>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.item` The item.
       *
       * @type {DashboardRenderer | null | undefined}
       */
      renderer: {
        type: Function
      },
      /**
       * Whether the dashboard is editable.
       */
      editable: {
        type: Boolean
      },
      /** @private */
      __childCount: {
        type: Number,
        value: 0
      }
    };
  }
  static get observers() {
    return ["__itemsOrRendererChanged(items, renderer, editable, __effectiveI18n)"];
  }
  /**
   * The object used to localize this component. To change the default
   * localization, replace this with an object that provides all properties, or
   * just the individual properties you want to change.
   *
   * The object has the following structure and default values:
   * ```js
   * {
   *   selectSection: 'Select section for editing',
   *   selectWidget: 'Select widget for editing',
   *   remove: 'Remove',
   *   resize: 'Resize',
   *   resizeApply: 'Apply',
   *   resizeShrinkWidth: 'Shrink width',
   *   resizeGrowWidth: 'Grow width',
   *   resizeShrinkHeight: 'Shrink height',
   *   resizeGrowHeight: 'Grow height',
   *   move: 'Move',
   *   moveApply: 'Apply',
   *   moveForward: 'Move Forward',
   *   moveBackward: 'Move Backward',
   * }
   * ```
   * @return {!DashboardI18n}
   */
  get i18n() {
    return super.i18n;
  }
  set i18n(value) {
    super.i18n = value;
  }
  constructor() {
    super();
    this.__widgetReorderController = new WidgetReorderController(this);
    this.__widgetResizeController = new WidgetResizeController(this);
    this.addEventListener("item-remove", (e) => this.__itemRemove(e));
    this.addEventListener("item-selected-changed", (e) => this.__itemSelectedChanged(e));
    this.addEventListener("item-move-mode-changed", (e) => this.__itemMoveModeChanged(e));
    this.addEventListener("item-resize-mode-changed", (e) => this.__itemResizeModeChanged(e));
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this.__widgetReorderController);
    this.addController(this.__widgetResizeController);
  }
  /** @protected */
  render() {
    return html`<div id="grid">
      ${[...Array(this.__childCount)].map((_, index) => html`<slot name="slot-${index}"></slot>`)}
    </div>`;
  }
  /** @private */
  __itemsOrRendererChanged(items, renderer) {
    this.__childCount = items ? items.length : 0;
    this.__renderItemWrappers(items || []);
    this.querySelectorAll(WRAPPER_LOCAL_NAME).forEach((wrapper) => {
      if (wrapper.firstElementChild && wrapper.firstElementChild.localName === "vaadin-dashboard-section") {
        return;
      }
      const item = getElementItem(wrapper);
      if (item.component instanceof HTMLElement) {
        if (item.component.parentElement !== wrapper) {
          wrapper.textContent = "";
          wrapper.appendChild(item.component);
        }
      } else if (renderer) {
        renderer(wrapper, this, { item });
      } else {
        wrapper.innerHTML = "";
      }
      if (wrapper.firstElementChild) {
        SYNCHRONIZED_ATTRIBUTES.forEach((attr) => {
          wrapper.firstElementChild.toggleAttribute(attr, !!wrapper[attr]);
        });
        wrapper.firstElementChild.__i18n = this.__effectiveI18n;
      }
    });
  }
  /** @private */
  __renderItemWrappers(items, hostElement = this) {
    let wrappers = [...hostElement.children].filter((el) => el.localName === WRAPPER_LOCAL_NAME);
    const focusedWrapper = wrappers.find((wrapper) => wrapper.querySelector(":focus"));
    const focusedWrapperWillBeRemoved = focusedWrapper && !this.__isActiveWrapper(focusedWrapper);
    const wrapperClosestToRemovedFocused = focusedWrapperWillBeRemoved && this.__getClosestActiveWrapper(focusedWrapper);
    items.forEach((item, index) => {
      const wrapper = wrappers.find((el) => itemsEqual(getElementItem(el), item)) || this.__createWrapper(item);
      wrappers = wrappers.filter((el) => el !== wrapper);
      if (!wrapper.isConnected) {
        hostElement.appendChild(wrapper);
      }
      this.__updateWrapper(wrapper, item);
      wrapper.slot = `slot-${index}`;
      if (item.items) {
        let section = wrapper.firstElementChild;
        const isComponentSection = item.component instanceof DashboardSection;
        if (!(section instanceof DashboardSection)) {
          section = isComponentSection ? item.component : document.createElement("vaadin-dashboard-section");
          wrapper.appendChild(section);
        }
        if (!isComponentSection) {
          section.sectionTitle = item.title;
        }
        SYNCHRONIZED_ATTRIBUTES.forEach((attr) => section.toggleAttribute(attr, !!wrapper[attr]));
        section.__i18n = this.__effectiveI18n;
        section.__childCount = item.items.length;
        this.__renderItemWrappers(item.items, section);
      }
    });
    wrappers.forEach((wrapper) => wrapper.remove());
    requestAnimationFrame(() => {
      if (focusedWrapperWillBeRemoved) {
        this.__focusWrapperContent(wrapperClosestToRemovedFocused || this.querySelector(WRAPPER_LOCAL_NAME));
      }
      const focusedItem = this.querySelector(":focus");
      if (focusedItem && this.__outsideViewport(focusedItem)) {
        focusedItem.scrollIntoView();
      }
    });
  }
  /** @private */
  __outsideViewport(element) {
    const rect = element.getBoundingClientRect();
    const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
    const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);
    if (rect.bottom < 0 || rect.right < 0 || rect.top > viewportHeight || rect.left > viewportWidth) {
      return true;
    }
    const dashboardRect = this.getBoundingClientRect();
    if (rect.bottom < dashboardRect.top || rect.right < dashboardRect.left || rect.top > dashboardRect.bottom || rect.left > dashboardRect.right) {
      return true;
    }
    return false;
  }
  /** @private */
  __focusWrapperContent(wrapper) {
    if (wrapper && wrapper.firstElementChild) {
      wrapper.firstElementChild.focus();
    }
  }
  /**
   * Checks if the wrapper represents an item that is part of the dashboard's items array
   * @private
   */
  __isActiveWrapper(wrapper) {
    if (!wrapper || wrapper.localName !== WRAPPER_LOCAL_NAME) {
      return false;
    }
    return getItemsArrayOfItem(getElementItem(wrapper), this.items);
  }
  /**
   * Parses the slot name to get the index of the item in the dashboard
   * For example, slot name "slot-12" will return 12
   * @private
   */
  __parseSlotIndex(slotName) {
    return parseInt(slotName.split("-")[1]);
  }
  /** @private */
  __getClosestActiveWrapper(wrapper) {
    if (!wrapper || this.__isActiveWrapper(wrapper)) {
      return wrapper;
    }
    const siblingWrappers = [...wrapper.parentElement.children].sort((a, b) => {
      return this.__parseSlotIndex(a.slot) - this.__parseSlotIndex(b.slot);
    });
    const findSiblingWrapper = (wrapper2, dir) => {
      while (wrapper2) {
        if (this.__isActiveWrapper(wrapper2)) {
          return wrapper2;
        }
        const currentIndex = siblingWrappers.indexOf(wrapper2);
        wrapper2 = dir === 1 ? siblingWrappers[currentIndex + 1] : siblingWrappers[currentIndex - 1];
      }
    };
    return findSiblingWrapper(wrapper, 1) || findSiblingWrapper(wrapper, -1) || this.__getClosestActiveWrapper(wrapper.parentElement.closest(WRAPPER_LOCAL_NAME));
  }
  /** @private */
  __createWrapper(item) {
    const wrapper = document.createElement(WRAPPER_LOCAL_NAME);
    wrapper.__item = item;
    return wrapper;
  }
  /** @private */
  __updateWrapper(wrapper, item) {
    const style = `
      ${item.colspan ? `--vaadin-dashboard-widget-colspan: ${item.colspan};` : ""}
      ${item.rowspan ? `--vaadin-dashboard-widget-rowspan: ${item.rowspan};` : ""}
    `.trim();
    wrapper.__item = item;
    wrapper.setAttribute("style", style);
    wrapper.editable = this.editable;
    wrapper.dragging = this.__widgetReorderController.draggedItem === item;
    wrapper["first-child"] = item === getItemsArrayOfItem(item, this.items)[0];
    wrapper["last-child"] = item === getItemsArrayOfItem(item, this.items).slice(-1)[0];
    wrapper.i18n = this.__effectiveI18n;
  }
  /** @private */
  __itemRemove(e) {
    e.stopImmediatePropagation();
    const item = getElementItem(e.target);
    const items = getItemsArrayOfItem(item, this.items);
    items.splice(items.indexOf(item), 1);
    this.items = [...this.items];
    this.toggleAttribute("item-selected", false);
    this.dispatchEvent(
      new CustomEvent("dashboard-item-removed", { cancelable: true, detail: { item, items: this.items } })
    );
  }
  /** @private */
  __dispatchCustomEvent(eventName, item, value) {
    if (!item) {
      return;
    }
    this.dispatchEvent(
      new CustomEvent(eventName, {
        detail: {
          item,
          value
        }
      })
    );
  }
  /** @private */
  __itemSelectedChanged(e) {
    e.stopImmediatePropagation();
    this.__dispatchCustomEvent("dashboard-item-selected-changed", getElementItem(e.target), e.detail.value);
    this.toggleAttribute("item-selected", e.detail.value);
  }
  /** @private */
  __itemMoveModeChanged(e) {
    e.stopImmediatePropagation();
    this.__dispatchCustomEvent("dashboard-item-move-mode-changed", getElementItem(e.target), e.detail.value);
  }
  /** @private */
  __itemResizeModeChanged(e) {
    e.stopImmediatePropagation();
    this.__dispatchCustomEvent("dashboard-item-resize-mode-changed", getElementItem(e.target), e.detail.value);
  }
  /**
   * @private
   */
  __updateColumnCount() {
    const previousColumnCount = this.$.grid.style.getPropertyValue("--_col-count");
    super.__updateColumnCount();
    if (previousColumnCount !== this.$.grid.style.getPropertyValue("--_col-count")) {
      this.querySelectorAll(WRAPPER_LOCAL_NAME).forEach((wrapper) => {
        if (wrapper.firstElementChild && "requestUpdate" in wrapper.firstElementChild) {
          wrapper.firstElementChild.requestUpdate();
        }
      });
    }
  }
  /**
   * Fired when an item selected state changed
   *
   * @event dashboard-item-selected-changed
   */
  /**
   * Fired when an item move mode changed
   *
   * @event dashboard-item-move-mode-changed
   */
  /**
   * Fired when an item resize mode changed
   *
   * @event dashboard-item-resize-mode-changed
   */
  /**
   * Fired when an item was moved
   *
   * @event dashboard-item-moved
   */
  /**
   * Fired when an item was resized
   *
   * @event dashboard-item-resized
   */
  /**
   * Fired when an item was removed
   *
   * @event dashboard-item-removed
   */
};
defineCustomElement(Dashboard);
export {
  Dashboard
};
//# sourceMappingURL=@vaadin_dashboard_src_vaadin-dashboard__js.js.map
