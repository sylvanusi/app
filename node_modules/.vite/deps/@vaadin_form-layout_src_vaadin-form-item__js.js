import {
  generateUniqueId
} from "./chunk-Z5LHTDPJ.js";
import {
  addValueToAttribute,
  removeValueFromAttribute
} from "./chunk-SVPOVVYN.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import "./chunk-ULNR4UH6.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import {
  issueWarning
} from "./chunk-TMRBPE5K.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/form-layout/src/styles/vaadin-form-item-base-styles.js
var formItemStyles = css`
  :host {
    /* By default, when auto-responsive mode is disabled, labels should be displayed beside the fields. */
    --_form-item-labels-above: ' '; /* false */
    --_form-item-labels-aside: initial; /* true */

    align-items: var(--_form-item-labels-aside, baseline);
    display: inline-flex;
    flex-flow: var(--_form-item-labels-above, column) nowrap;
    justify-self: stretch;
  }

  :host([label-position='top']) {
    --_form-item-labels-above: initial; /* true */
    --_form-item-labels-aside: ' '; /* false */
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='label'] {
    color: var(--vaadin-form-item-label-color, var(--vaadin-text-color));
    flex: 0 0 auto;
    font-size: var(--vaadin-form-item-label-font-size, inherit);
    font-weight: var(--vaadin-form-item-label-font-weight, 500);
    line-height: var(--vaadin-form-item-label-line-height, inherit);
    width: var(--_form-item-labels-aside, var(--_label-width, 8em));
    word-break: break-word;
  }

  #spacing {
    flex: 0 0 auto;
    width: var(--_label-spacing, 1em);
  }

  #content {
    flex: 1 1 auto;
    min-width: 0;
  }

  #content ::slotted(.full-width) {
    box-sizing: border-box;
    min-width: 0;
    width: 100%;
  }
`;

// node_modules/@vaadin/form-layout/src/vaadin-form-item-mixin.js
var FormItemMixin = (superClass) => class extends superClass {
  constructor() {
    super();
    this.__onFieldInteraction = this.__onFieldInteraction.bind(this);
    this.__fieldNodeObserver = new MutationObserver(() => this.__synchronizeAttributes());
    this.__labelNode = null;
    this.__fieldNode = null;
    this.__isFieldDirty = false;
  }
  /** @protected */
  ready() {
    super.ready();
  }
  /**
   * Returns a target element to add ARIA attributes to for a field.
   *
   * - For Vaadin field components, the method returns an element
   * obtained through the `ariaTarget` property defined in `FieldMixin`.
   * - In other cases, the method returns the field element itself.
   *
   * @param {HTMLElement} field
   * @protected
   */
  _getFieldAriaTarget(field) {
    return field.ariaTarget || field;
  }
  /**
   * Links the label to a field by adding the label id to
   * the `aria-labelledby` attribute of the field's ARIA target element.
   *
   * @param {HTMLElement} field
   * @private
   */
  __linkLabelToField(field) {
    addValueToAttribute(this._getFieldAriaTarget(field), "aria-labelledby", this.__labelId);
  }
  /**
   * Unlinks the label from a field by removing the label id from
   * the `aria-labelledby` attribute of the field's ARIA target element.
   *
   * @param {HTMLElement} field
   * @private
   */
  __unlinkLabelFromField(field) {
    removeValueFromAttribute(this._getFieldAriaTarget(field), "aria-labelledby", this.__labelId);
  }
  /** @private */
  __onLabelClick() {
    const fieldNode = this.__fieldNode;
    if (fieldNode) {
      fieldNode.focus({ focusVisible: false });
      fieldNode.click();
    }
  }
  /**
   * A `slotchange` event handler for the label slot.
   *
   * - Ensures the label id is only assigned to the first label node.
   * - Ensures the label node is linked to the first field node via the `aria-labelledby` attribute
   * if both nodes are provided, and unlinked otherwise.
   *
   * @private
   */
  __onLabelSlotChange() {
    if (this.__labelNode) {
      this.__labelNode = null;
      if (this.__fieldNode) {
        this.__unlinkLabelFromField(this.__fieldNode);
      }
    }
    const newLabelNode = this.$.labelSlot.assignedElements()[0];
    if (newLabelNode) {
      this.__labelNode = newLabelNode;
      if (this.__labelNode.id) {
        this.__labelId = this.__labelNode.id;
      } else {
        this.__labelId = `label-${this.localName}-${generateUniqueId()}`;
        this.__labelNode.id = this.__labelId;
      }
      if (this.__fieldNode) {
        this.__linkLabelToField(this.__fieldNode);
      }
    }
  }
  /**
   * A `slotchange` event handler for the content slot.
   *
   * - Ensures the label node is only linked to the first field node via the `aria-labelledby` attribute.
   * - Sets up an observer for the `required` attribute changes on the first field
   * to reflect the attribute on the component. Ensures the observer is disconnected from the field
   * as soon as it is removed or replaced by another one.
   *
   * @private
   */
  __onContentSlotChange() {
    if (this.__fieldNode) {
      this.__unlinkLabelFromField(this.__fieldNode);
      this.__fieldNodeObserver.disconnect();
      this.__fieldNode.removeEventListener("blur", this.__onFieldInteraction);
      this.__fieldNode.removeEventListener("change", this.__onFieldInteraction);
      this.__fieldNode = null;
      this.__isFieldDirty = false;
    }
    const fieldNodes = this.$.contentSlot.assignedElements();
    if (fieldNodes.length > 1) {
      issueWarning(
        `WARNING: Since Vaadin 23, placing multiple fields directly to a <vaadin-form-item> is deprecated.
Please wrap fields with a <vaadin-custom-field> instead.`
      );
    }
    const newFieldNode = fieldNodes.find((field) => field.validate || field.checkValidity);
    if (newFieldNode) {
      this.__fieldNode = newFieldNode;
      this.__fieldNode.addEventListener("blur", this.__onFieldInteraction);
      this.__fieldNode.addEventListener("change", this.__onFieldInteraction);
      this.__fieldNodeObserver.observe(this.__fieldNode, {
        attributes: true,
        attributeFilter: ["required", "invalid"]
      });
      if (this.__labelNode) {
        this.__linkLabelToField(this.__fieldNode);
      }
    }
    this.__synchronizeAttributes();
  }
  /** @private */
  __onFieldInteraction() {
    this.__isFieldDirty = true;
    this.__synchronizeAttributes();
  }
  /** @private */
  __synchronizeAttributes() {
    const field = this.__fieldNode;
    if (!field) {
      this.removeAttribute("required");
      this.removeAttribute("invalid");
      return;
    }
    this.toggleAttribute("required", field.hasAttribute("required"));
    this.toggleAttribute(
      "invalid",
      field.hasAttribute("invalid") || field.matches(":invalid") && this.__isFieldDirty
    );
  }
};

// node_modules/@vaadin/form-layout/src/vaadin-form-item.js
var FormItem = class extends FormItemMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement)))) {
  static get is() {
    return "vaadin-form-item";
  }
  static get styles() {
    return formItemStyles;
  }
  static get lumoInjector() {
    return { ...super.lumoInjector, includeBaseStyles: true };
  }
  /** @protected */
  render() {
    return html`
      <div id="label" part="label" @click="${this.__onLabelClick}">
        <slot name="label" id="labelSlot" @slotchange="${this.__onLabelSlotChange}"></slot>
        <span part="required-indicator" aria-hidden="true"></span>
      </div>
      <div id="spacing"></div>
      <div id="content">
        <slot id="contentSlot" @slotchange="${this.__onContentSlotChange}"></slot>
      </div>
    `;
  }
};
defineCustomElement(FormItem);
export {
  FormItem
};
//# sourceMappingURL=@vaadin_form-layout_src_vaadin-form-item__js.js.map
