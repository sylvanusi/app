import {
  ContextMenuMixin,
  MenuOverlayMixin,
  contextMenuItemStyles,
  menuOverlayStyles
} from "./chunk-B3S5CQFG.js";
import {
  listBoxStyles
} from "./chunk-TYZ7RCV5.js";
import {
  Directive,
  directive
} from "./chunk-2AVGUHGC.js";
import {
  ItemMixin
} from "./chunk-3V4YUPS4.js";
import {
  ListMixin
} from "./chunk-GDVAXDUZ.js";
import {
  ifDefined
} from "./chunk-OSWHV746.js";
import {
  OverlayMixin,
  overlayStyles
} from "./chunk-PFI4EOEJ.js";
import {
  Button
} from "./chunk-4QGJQDIU.js";
import {
  ResizeMixin
} from "./chunk-J36B4EVN.js";
import {
  KeyboardDirectionMixin
} from "./chunk-HJJCYWLA.js";
import {
  TooltipController
} from "./chunk-XFKQJ73Z.js";
import {
  SlotController
} from "./chunk-X5EEA4XV.js";
import {
  I18nMixin
} from "./chunk-WSKWP5BQ.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  Debouncer
} from "./chunk-OWHE56FA.js";
import {
  DisabledMixin
} from "./chunk-M3HWWZVG.js";
import {
  FocusMixin
} from "./chunk-ERLMGG3V.js";
import {
  isElementFocused,
  isElementHidden,
  isKeyboardActive
} from "./chunk-5DESY7LS.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  ThemableMixin,
  ThemePropertyMixin
} from "./chunk-MKNWHZM7.js";
import {
  DirMixin
} from "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html,
  noChange,
  nothing,
  render
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";
import {
  microTask
} from "./chunk-MWWP2LZ3.js";

// node_modules/@vaadin/menu-bar/src/styles/vaadin-menu-bar-item-base-styles.js
var menuBarItemStyles = contextMenuItemStyles;

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-item.js
var MenuBarItem = class extends ItemMixin(ThemableMixin(DirMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-menu-bar-item";
  }
  static get styles() {
    return menuBarItemStyles;
  }
  /** @protected */
  render() {
    return html`
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "menuitem");
  }
};
defineCustomElement(MenuBarItem);

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-list-box.js
var MenuBarListBox = class extends ListMixin(ThemableMixin(DirMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-menu-bar-list-box";
  }
  static get styles() {
    return listBoxStyles;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        type: String,
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  render() {
    return html`
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menu");
  }
};
defineCustomElement(MenuBarListBox);

// node_modules/@vaadin/menu-bar/src/styles/vaadin-menu-bar-overlay-base-styles.js
var menuBarOverlayStyles = [overlayStyles, menuOverlayStyles];

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-overlay.js
var MenuBarOverlay = class extends MenuOverlayMixin(
  OverlayMixin(DirMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement)))))
) {
  static get is() {
    return "vaadin-menu-bar-overlay";
  }
  static get styles() {
    return menuBarOverlayStyles;
  }
  /** @protected */
  render() {
    return html`
      <div id="backdrop" part="backdrop" ?hidden="${!this.withBackdrop}"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
          <slot name="submenu"></slot>
        </div>
      </div>
    `;
  }
};
defineCustomElement(MenuBarOverlay);

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-submenu.js
var MenuBarSubmenu = class extends ContextMenuMixin(ThemePropertyMixin(PolylitMixin(LitElement))) {
  static get is() {
    return "vaadin-menu-bar-submenu";
  }
  static get styles() {
    return css`
      :host {
        display: block;
      }

      :host([hidden]) {
        display: none !important;
      }
    `;
  }
  static get properties() {
    return {
      isRoot: {
        type: Boolean,
        reflectToAttribute: true,
        sync: true
      }
    };
  }
  constructor() {
    super();
    this.openOn = "opensubmenu";
  }
  /**
   * Tag name prefix used by overlay, list-box and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-menu-bar";
  }
  /** @protected */
  render() {
    return html`
      <vaadin-menu-bar-overlay
        id="overlay"
        .owner="${this}"
        .opened="${this.opened}"
        .model="${this._context}"
        .modeless="${this._modeless}"
        .renderer="${this.__itemsRenderer}"
        .withBackdrop="${this._phone}"
        .positionTarget="${this._positionTarget}"
        ?no-horizontal-overlap="${!this.isRoot}"
        ?phone="${this._phone}"
        theme="${ifDefined(this._theme)}"
        exportparts="backdrop, overlay, content"
        @opened-changed="${this._onOverlayOpened}"
        @vaadin-overlay-open="${this._onVaadinOverlayOpen}"
      >
        <slot name="overlay"></slot>
        <slot name="submenu" slot="submenu"></slot>
      </vaadin-menu-bar-overlay>
    `;
  }
  /**
   * Overriding the observer to not add global "contextmenu" listener.
   * @override
   */
  _openedChanged() {
  }
  /**
   * Overriding the public method to reset expanded button state.
   */
  close() {
    super.close();
    if (this.hasAttribute("is-root")) {
      this.parentElement._close();
    }
  }
  /**
   * Override method from `ContextMenuMixin` to prevent closing
   * sub-menu on the same click event that was used to open it.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldCloseOnOutsideClick(event) {
    if (this.hasAttribute("is-root") && event.composedPath().includes(this.listenOn)) {
      return false;
    }
    return super._shouldCloseOnOutsideClick(event);
  }
};
defineCustomElement(MenuBarSubmenu);

// node_modules/@vaadin/menu-bar/src/styles/vaadin-menu-bar-button-base-styles.js
var menuBarButtonStyles = css`
  :host {
    flex-shrink: 0;
  }

  :host([focus-ring]) {
    z-index: 1;
  }

  :host([slot='overflow']) {
    margin-inline-end: 0;
  }

  .vaadin-button-container {
    gap: inherit;
  }

  :host(:not([slot='overflow'])[aria-haspopup]) [part='suffix'] {
    display: flex;
    align-items: center;
    gap: inherit;
  }

  :host(:not([slot='overflow'])[aria-haspopup]) [part='suffix']::after {
    background: currentColor;
    content: '';
    height: var(--vaadin-icon-size, 1lh);
    mask: var(--_vaadin-icon-chevron-down) 50% / var(--vaadin-icon-visual-size, 100%) no-repeat;
    width: var(--vaadin-icon-size, 1lh);
  }

  ::slotted(vaadin-menu-bar-item) {
    padding: 0;
    gap: 0;
  }

  ::slotted(vaadin-menu-bar-item)::after {
    display: none;
  }
`;

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-button.js
var MenuBarButton = class extends Button {
  static get is() {
    return "vaadin-menu-bar-button";
  }
  static get styles() {
    return [super.styles, menuBarButtonStyles];
  }
  /**
   * Override method inherited from `ButtonMixin` to set a flag based on whether the key
   * is Enter and Space. Unlike mouse click, these keys should also focus the first item.
   * This flag is used in menu bar to identify the action that triggered the click.
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    this.__triggeredWithActiveKeys = this._activeKeys.includes(event.key);
    super._onKeyDown(event);
    this.__triggeredWithActiveKeys = null;
  }
  /**
   * Override method inherited from `ButtonMixin` to allow keyboard navigation with
   * arrow keys in the menu bar when the button is focusable in the disabled state.
   *
   * @override
   */
  __shouldSuppressInteractionEvent(event) {
    if (event.type === "keydown" && ["ArrowLeft", "ArrowRight"].includes(event.key)) {
      return false;
    }
    return super.__shouldSuppressInteractionEvent(event);
  }
};
defineCustomElement(MenuBarButton);

// node_modules/@vaadin/menu-bar/src/styles/vaadin-menu-bar-base-styles.js
var menuBarStyles = css`
  :host {
    display: block;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='container'] {
    display: flex;
    flex-wrap: nowrap;
    margin: calc((var(--vaadin-focus-ring-width) + 2px) * -1);
    overflow: hidden;
    padding: calc(var(--vaadin-focus-ring-width) + 2px);
    position: relative;
    width: 100%;
    --_gap: var(--vaadin-menu-bar-gap, 0px);
    --_bw: var(--vaadin-button-border-width, 1px);
    gap: var(--_gap);
    --_rad-button: var(--vaadin-button-border-radius, var(--vaadin-radius-m));
  }

  :host(:not([has-single-button])) ::slotted(vaadin-menu-bar-button:not(:first-of-type)) {
    margin-inline-start: min(var(--_bw) * -1 + var(--_gap) * 1000, 0px);
  }

  ::slotted(vaadin-menu-bar-button) {
    border-radius: 0;
  }

  ::slotted([first-visible]),
  :host([has-single-button]) ::slotted([slot='overflow']),
  ::slotted(vaadin-menu-bar-button[theme~='tertiary']) {
    border-start-start-radius: var(--_rad-button);
    border-end-start-radius: var(--_rad-button);
  }

  ::slotted(:is([last-visible], [slot='overflow'])),
  ::slotted(vaadin-menu-bar-button[theme~='tertiary']) {
    border-start-end-radius: var(--_rad-button);
    border-end-end-radius: var(--_rad-button);
  }

  :host([theme~='end-aligned']) ::slotted(vaadin-menu-bar-button[first-visible]),
  :host([theme~='end-aligned'][has-single-button]) ::slotted(vaadin-menu-bar-button) {
    margin-inline-start: auto;
  }
`;

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-mixin.js
var ItemComponentDirective = class extends Directive {
  update(part, [{ component, text }]) {
    const { parentNode, startNode } = part;
    const newNode = component || (text ? document.createTextNode(text) : null);
    const oldNode = this.getOldNode(part);
    if (oldNode === newNode) {
      return noChange;
    } else if (oldNode && newNode) {
      parentNode.replaceChild(newNode, oldNode);
    } else if (oldNode) {
      parentNode.removeChild(oldNode);
    } else if (newNode) {
      startNode.after(newNode);
    }
    return noChange;
  }
  getOldNode(part) {
    const { startNode, endNode } = part;
    if (startNode.nextSibling === endNode) {
      return null;
    }
    return startNode.nextSibling;
  }
};
var componentDirective = directive(ItemComponentDirective);
var DEFAULT_I18N = {
  moreOptions: "More options"
};
var MenuBarMixin = (superClass) => class MenuBarMixinClass extends I18nMixin(
  DEFAULT_I18N,
  KeyboardDirectionMixin(ResizeMixin(FocusMixin(DisabledMixin(superClass))))
) {
  static get properties() {
    return {
      /**
       * @typedef MenuBarItem
       * @type {object}
       * @property {string} text - Text to be set as the menu button component's textContent.
       * @property {string} tooltip - Text to be set as the menu button's tooltip.
       * Requires a `<vaadin-tooltip slot="tooltip">` element to be added inside the `<vaadin-menu-bar>`.
       * @property {string | HTMLElement} component - The component to represent the button content.
       * Either a tagName or an element instance. Defaults to "vaadin-menu-bar-item".
       * @property {boolean} disabled - If true, the button is disabled and cannot be activated.
       * @property {string | string[]} theme - Theme(s) to be set as the theme attribute of the button, overriding any theme set on the menu bar.
       * @property {SubMenuItem[]} children - Array of submenu items.
       */
      /**
       * @typedef SubMenuItem
       * @type {object}
       * @property {string} text - Text to be set as the menu item component's textContent.
       * @property {string | HTMLElement} component - The component to represent the item.
       * Either a tagName or an element instance. Defaults to "vaadin-menu-bar-item".
       * @property {boolean} disabled - If true, the item is disabled and cannot be selected.
       * @property {boolean} checked - If true, the item shows a checkmark next to it.
       * @property {SubMenuItem[]} children - Array of child submenu items.
       */
      /**
       * Defines a hierarchical structure, where root level items represent menu bar buttons,
       * and `children` property configures a submenu with items to be opened below
       * the button on click, Enter, Space, Up and Down arrow keys.
       *
       * #### Example
       *
       * ```js
       * menubar.items = [
       *   {
       *     text: 'File',
       *     className: 'file',
       *     children: [
       *       {text: 'Open', className: 'file open'}
       *       {text: 'Auto Save', checked: true},
       *     ]
       *   },
       *   {component: 'hr'},
       *   {
       *     text: 'Edit',
       *     children: [
       *       {text: 'Undo', disabled: true},
       *       {text: 'Redo'}
       *     ]
       *   },
       *   {text: 'Help'}
       * ];
       * ```
       *
       * #### Disabled buttons
       *
       * When disabled, menu bar buttons (root-level items) are rendered
       * as "dimmed" and prevent all user interactions (mouse and keyboard).
       *
       * Since disabled buttons are not focusable and cannot react to hover
       * events by default, it can cause accessibility issues by making them
       * entirely invisible to assistive technologies, and prevents the use
       * of Tooltips to explain why the action is not available. This can be
       * addressed by enabling the feature flag `accessibleDisabledButtons`,
       * which makes disabled buttons focusable and hoverable, while still
       * preventing them from being triggered:
       *
       * ```js
       * // Set before any menu bar is attached to the DOM.
       * window.Vaadin.featureFlags.accessibleDisabledButtons = true;
       * ```
       *
       * @type {!Array<!MenuBarItem>}
       */
      items: {
        type: Array,
        sync: true,
        value: () => []
      },
      /**
       * If true, the submenu will open on hover (mouseover) instead of click.
       * @attr {boolean} open-on-hover
       */
      openOnHover: {
        type: Boolean
      },
      /**
       * If true, the buttons will be collapsed into the overflow menu
       * starting from the "start" end of the bar instead of the "end".
       * @attr {boolean} reverse-collapse
       */
      reverseCollapse: {
        type: Boolean,
        sync: true
      },
      /**
       * If true, the top-level menu items is traversable by tab
       * instead of arrow keys (i.e. disabling roving tabindex)
       * @attr {boolean} tab-navigation
       */
      tabNavigation: {
        type: Boolean,
        sync: true
      }
    };
  }
  /**
   * The object used to localize this component. To change the default
   * localization, replace this with an object that provides all properties, or
   * just the individual properties you want to change.
   *
   * The object has the following JSON structure and default values:
   * ```js
   * {
   *   moreOptions: 'More options'
   * }
   * ```
   * @return {!MenuBarI18n}
   */
  get i18n() {
    return super.i18n;
  }
  set i18n(value) {
    super.i18n = value;
  }
  constructor() {
    super();
    this.__boundOnContextMenuKeydown = this.__onContextMenuKeydown.bind(this);
    this.__boundOnTooltipMouseLeave = this.__onTooltipOverlayMouseLeave.bind(this);
  }
  /**
   * Override getter from `KeyboardDirectionMixin`
   * to use expanded button for arrow navigation
   * when the sub-menu is opened and has focus.
   *
   * @return {Element | null}
   * @protected
   * @override
   */
  get focused() {
    return (this._getItems() || []).find(isElementFocused) || this._expandedButton;
  }
  /**
   * Override getter from `KeyboardDirectionMixin`.
   *
   * @return {boolean}
   * @protected
   * @override
   */
  get _vertical() {
    return false;
  }
  /**
   * Override getter from `KeyboardDirectionMixin`.
   *
   * @return {boolean}
   * @protected
   * @override
   */
  get _tabNavigation() {
    return this.tabNavigation;
  }
  /**
   * Override getter from `ResizeMixin` to observe parent.
   *
   * @protected
   * @override
   */
  get _observeParent() {
    return true;
  }
  /**
   * @return {!Array<!HTMLElement>}
   * @protected
   */
  get _buttons() {
    return Array.from(this.querySelectorAll("vaadin-menu-bar-button"));
  }
  /** @private */
  get _hasOverflow() {
    return this._overflow && !this._overflow.hasAttribute("hidden");
  }
  /** @private */
  set _hasOverflow(hasOverflow) {
    if (this._overflow) {
      this._overflow.toggleAttribute("hidden", !hasOverflow);
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menubar");
    this._subMenuController = new SlotController(this, "submenu", "vaadin-menu-bar-submenu", {
      initializer: (menu) => {
        menu.setAttribute("is-root", "");
        menu.addEventListener("item-selected", this.__onItemSelected.bind(this));
        menu.addEventListener("close-all-menus", this.__onEscapeClose.bind(this));
        const overlay = menu._overlayElement;
        overlay._contentRoot.addEventListener("keydown", this.__boundOnContextMenuKeydown);
        this._subMenu = menu;
      }
    });
    this._overflowController = new SlotController(this, "overflow", "vaadin-menu-bar-button", {
      initializer: (btn) => {
        btn.setAttribute("hidden", "");
        const dots = document.createElement("div");
        dots.setAttribute("aria-hidden", "true");
        dots.innerHTML = "&centerdot;".repeat(3);
        btn.appendChild(dots);
        btn.setAttribute("aria-haspopup", "true");
        btn.setAttribute("aria-expanded", "false");
        btn.setAttribute("role", this.tabNavigation ? "button" : "menuitem");
        this._overflow = btn;
      }
    });
    this.addController(this._subMenuController);
    this.addController(this._overflowController);
    this.addEventListener("mousedown", () => this._hideTooltip(true));
    this.addEventListener("mouseleave", () => this._hideTooltip());
    this._container = this.shadowRoot.querySelector('[part="container"]');
  }
  /** @protected */
  updated(props) {
    super.updated(props);
    if (props.has("items") || props.has("_theme") || props.has("disabled")) {
      this.__renderButtons(this.items);
    }
    if (props.has("items") || props.has("_theme") || props.has("reverseCollapse")) {
      this.__scheduleOverflow();
    }
    if (props.has("items")) {
      this.__updateSubMenu();
    }
    if (props.has("_theme")) {
      this._themeChanged(this._theme);
    }
    if (props.has("disabled")) {
      this._overflow.toggleAttribute("disabled", this.disabled);
    }
    if (props.has("tabNavigation")) {
      this._tabNavigationChanged(this.tabNavigation);
    }
    if (props.has("__effectiveI18n")) {
      this.__i18nChanged(this.__effectiveI18n);
    }
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to use the list of menu-bar buttons as items.
   *
   * @return {Element[]}
   * @protected
   * @override
   */
  _getItems() {
    return this._buttons;
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this._hideTooltip(true);
  }
  /**
   * Implement callback from `ResizeMixin` to update buttons
   * and detect whether to show or hide the overflow button.
   *
   * @protected
   * @override
   */
  _onResize() {
    this.__scheduleOverflow();
  }
  /** @private */
  _themeChanged(theme) {
    if (theme) {
      this._overflow.setAttribute("theme", theme);
      this._subMenu.setAttribute("theme", theme);
    } else {
      this._overflow.removeAttribute("theme");
      this._subMenu.removeAttribute("theme");
    }
  }
  /** @private */
  _tabNavigationChanged(tabNavigation) {
    const target = this.querySelector('[tabindex="0"]');
    this._buttons.forEach((btn) => {
      if (target) {
        this._setTabindex(btn, btn === target);
      } else {
        this._setTabindex(btn, false);
      }
      btn.setAttribute("role", tabNavigation ? "button" : "menuitem");
    });
    this.setAttribute("role", tabNavigation ? "group" : "menubar");
  }
  /** @private */
  __updateSubMenu() {
    const subMenu = this._subMenu;
    if (subMenu && subMenu.opened) {
      const button = subMenu._positionTarget;
      if (!button.isConnected || !Array.isArray(button.item.children) || button.item.children.length === 0) {
        subMenu.close();
      }
    }
  }
  /** @private */
  __i18nChanged(effectiveI18n) {
    if (effectiveI18n && effectiveI18n.moreOptions !== void 0) {
      if (effectiveI18n.moreOptions) {
        this._overflow.setAttribute("aria-label", effectiveI18n.moreOptions);
      } else {
        this._overflow.removeAttribute("aria-label");
      }
    }
  }
  /** @private */
  __getOverflowCount(overflow) {
    return overflow.item && overflow.item.children && overflow.item.children.length || 0;
  }
  /** @private */
  __restoreButtons(buttons) {
    buttons.forEach((button) => {
      button.style.visibility = "";
      button.style.position = "";
      button.style.width = "";
      const item = button.item && button.item.component;
      if (item instanceof HTMLElement && item.getAttribute("role") === "menuitem") {
        this.__restoreItem(button, item);
      }
    });
    this.__updateOverflow([]);
  }
  /** @private */
  __restoreItem(button, item) {
    button.appendChild(item);
    item.removeAttribute("role");
    item.removeAttribute("aria-expanded");
    item.removeAttribute("aria-haspopup");
    item.removeAttribute("tabindex");
  }
  /** @private */
  __updateOverflow(items) {
    this._overflow.item = { children: items };
    this._hasOverflow = items.length > 0;
  }
  /** @private */
  __setOverflowItems(buttons, overflow) {
    const container = this._container;
    if (container.offsetWidth < container.scrollWidth) {
      this._hasOverflow = true;
      const isRTL = this.__isRTL;
      const containerLeft = container.offsetLeft;
      const remaining = [...buttons];
      while (remaining.length) {
        const lastButton = remaining[remaining.length - 1];
        const btnLeft = lastButton.offsetLeft - containerLeft;
        if (!isRTL && btnLeft + lastButton.offsetWidth < container.offsetWidth - overflow.offsetWidth || isRTL && btnLeft >= overflow.offsetWidth) {
          break;
        }
        const btn = this.reverseCollapse ? remaining.shift() : remaining.pop();
        btn.style.width = getComputedStyle(btn).width;
        btn.style.visibility = "hidden";
        btn.style.position = "absolute";
      }
      const items = buttons.filter((b) => !remaining.includes(b)).map((b) => b.item);
      this.__updateOverflow(items);
    }
  }
  /** @private */
  __scheduleOverflow() {
    this._overflowDebouncer = Debouncer.debounce(this._overflowDebouncer, microTask, () => {
      this.__detectOverflow();
    });
  }
  /** @private */
  __detectOverflow() {
    const overflow = this._overflow;
    const buttons = this._buttons.filter((btn) => btn !== overflow);
    const oldOverflowCount = this.__getOverflowCount(overflow);
    this.__restoreButtons(buttons);
    this.__setOverflowItems(buttons, overflow);
    const newOverflowCount = this.__getOverflowCount(overflow);
    if (oldOverflowCount !== newOverflowCount && this._subMenu.opened) {
      this._subMenu.close();
    }
    const isSingleButton = newOverflowCount === buttons.length || newOverflowCount === 0 && buttons.length === 1;
    this.toggleAttribute("has-single-button", isSingleButton);
    const visibleButtons = buttons.filter((btn) => btn.style.visibility !== "hidden");
    if (!visibleButtons.length) {
      this._overflow.setAttribute("tabindex", "0");
    } else if (!visibleButtons.some((btn) => btn.getAttribute("tabindex") === "0")) {
      this._setTabindex(visibleButtons[visibleButtons.length - 1], true);
    }
    visibleButtons.forEach((btn, index, visibleButtons2) => {
      btn.toggleAttribute("first-visible", index === 0);
      btn.toggleAttribute("last-visible", !this._hasOverflow && index === visibleButtons2.length - 1);
    });
  }
  /** @private */
  __getButtonTheme(item, hostTheme) {
    let theme = hostTheme;
    const itemTheme = item && item.theme;
    if (itemTheme != null) {
      theme = Array.isArray(itemTheme) ? itemTheme.join(" ") : itemTheme;
    }
    return theme;
  }
  /** @private */
  __getComponent(item) {
    const itemComponent = item.component;
    let component;
    const isElement = itemComponent instanceof HTMLElement;
    if (isElement && itemComponent.localName === "vaadin-menu-bar-item") {
      component = itemComponent;
    } else {
      component = document.createElement("vaadin-menu-bar-item");
      component.appendChild(isElement ? itemComponent : document.createElement(itemComponent));
    }
    if (item.text) {
      const node = component.firstChild || component;
      node.textContent = item.text;
    }
    return component;
  }
  /** @private */
  __renderButtons(items = []) {
    render(
      html`
          ${items.map((item) => {
        const itemCopy = { ...item };
        const hasChildren = Boolean(item && item.children);
        if (itemCopy.component) {
          const component = this.__getComponent(itemCopy);
          itemCopy.component = component;
          component.item = itemCopy;
        }
        return html`
              <vaadin-menu-bar-button
                .item="${itemCopy}"
                .disabled="${this.disabled || item.disabled}"
                role="${this.tabNavigation ? "button" : "menuitem"}"
                aria-haspopup="${ifDefined(hasChildren ? "true" : nothing)}"
                aria-expanded="${ifDefined(hasChildren ? "false" : nothing)}"
                class="${ifDefined(item.className || nothing)}"
                theme="${ifDefined(this.__getButtonTheme(item, this._theme) || nothing)}"
                @click="${this.__onRootButtonClick}"
                >${componentDirective(itemCopy)}</vaadin-menu-bar-button
              >
            `;
      })}
        `,
      this,
      { renderBefore: this._overflow }
    );
  }
  /** @private */
  __onRootButtonClick(event) {
    const button = event.target;
    if (button.item && button.item.component && !event.composedPath().includes(button.item.component)) {
      event.stopPropagation();
      button.item.component.click();
    }
  }
  /**
   * @param {HTMLElement} button
   * @protected
   */
  _showTooltip(button, isHover) {
    const tooltip = this._tooltipController.node;
    if (tooltip && tooltip.isConnected) {
      if (tooltip.generator === void 0) {
        tooltip.generator = ({ item }) => item && item.tooltip;
      }
      if (!tooltip._mouseLeaveListenerAdded) {
        tooltip._overlayElement.addEventListener("mouseleave", this.__boundOnTooltipMouseLeave);
        tooltip._mouseLeaveListenerAdded = true;
      }
      if (!this._subMenu.opened) {
        this._tooltipController.setTarget(button);
        this._tooltipController.setContext({ item: button.item });
        tooltip._stateController.open({
          hover: isHover,
          focus: !isHover
        });
      }
    }
  }
  /** @protected */
  _hideTooltip(immediate) {
    const tooltip = this._tooltipController && this._tooltipController.node;
    if (tooltip) {
      this._tooltipController.setContext({ item: null });
      tooltip._stateController.close(immediate);
    }
  }
  /** @private */
  __onTooltipOverlayMouseLeave(event) {
    if (event.relatedTarget !== this._tooltipController.target) {
      this._hideTooltip();
    }
  }
  /** @protected */
  _setExpanded(button, expanded) {
    button.toggleAttribute("expanded", expanded);
    button.toggleAttribute("active", expanded);
    button.setAttribute("aria-expanded", expanded ? "true" : "false");
  }
  /** @protected */
  _setTabindex(button, focused) {
    if (this.tabNavigation && this._isItemFocusable(button)) {
      button.setAttribute("tabindex", "0");
    } else {
      button.setAttribute("tabindex", focused ? "0" : "-1");
    }
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to close the submenu for the previously focused button
   * and open another one for the newly focused button.
   *
   * @param {Element} item
   * @param {FocusOptions=} options
   * @param {boolean} navigating
   * @protected
   * @override
   */
  _focusItem(item, options, navigating) {
    const wasExpanded = navigating && this.focused === this._expandedButton;
    if (wasExpanded) {
      this._close();
    }
    super._focusItem(item, options, navigating);
    this._buttons.forEach((btn) => {
      this._setTabindex(btn, btn === item);
    });
    if (wasExpanded && item.item && item.item.children) {
      this.__openSubMenu(item, true, { keepFocus: true });
    } else if (item === this._overflow) {
      this._hideTooltip();
    } else {
      this._showTooltip(item);
    }
  }
  /** @private */
  _getButtonFromEvent(e) {
    return Array.from(e.composedPath()).find((el) => el.localName === "vaadin-menu-bar-button");
  }
  /**
   * Override method inherited from `FocusMixin`
   *
   * @override
   * @protected
   */
  _shouldSetFocus(event) {
    if (event.composedPath().includes(this._subMenu)) {
      return false;
    }
    return super._shouldSetFocus(event);
  }
  /**
   * Override method inherited from `FocusMixin`
   *
   * @override
   * @protected
   */
  _shouldRemoveFocus(event) {
    if (event.composedPath().includes(this._subMenu)) {
      return false;
    }
    return super._shouldRemoveFocus(event);
  }
  /**
   * Override method inherited from `FocusMixin`
   *
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    if (focused) {
      const target = this.__getFocusTarget();
      if (target) {
        this._buttons.forEach((btn) => {
          this._setTabindex(btn, btn === target);
          if (btn === target && btn !== this._overflow && isKeyboardActive()) {
            this._showTooltip(btn);
          }
        });
      }
    } else {
      this._hideTooltip();
    }
  }
  /** @private */
  __getFocusTarget() {
    let target = this._buttons.find((btn) => isElementFocused(btn));
    if (!target) {
      const selector = this.tabNavigation ? "[focused]" : '[tabindex="0"]';
      target = this.querySelector(`vaadin-menu-bar-button${selector}`);
      if (isElementHidden(target)) {
        target = this._buttons[this._getFocusableIndex()];
      }
    }
    return target;
  }
  /**
   * @param {!KeyboardEvent} event
   * @private
   */
  _onArrowDown(event) {
    event.preventDefault();
    const button = this._getButtonFromEvent(event);
    if (button === this._expandedButton) {
      this._focusFirstItem();
    } else {
      this.__openSubMenu(button, true);
    }
  }
  /**
   * @param {!KeyboardEvent} event
   * @private
   */
  _onArrowUp(event) {
    event.preventDefault();
    const button = this._getButtonFromEvent(event);
    if (button === this._expandedButton) {
      this._focusLastItem();
    } else {
      this.__openSubMenu(button, true, { focusLast: true });
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`:
   * - to close the sub-menu for expanded button,
   * - to close a tooltip for collapsed button.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (event.composedPath().includes(this._expandedButton)) {
      this._close(true);
    }
    this._hideTooltip(true);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    if (event.composedPath().includes(this._subMenu)) {
      return;
    }
    this._handleKeyDown(event);
  }
  /** @private */
  _handleKeyDown(event) {
    switch (event.key) {
      case "ArrowDown":
        this._onArrowDown(event);
        break;
      case "ArrowUp":
        this._onArrowUp(event);
        break;
      default:
        super._onKeyDown(event);
        break;
    }
  }
  /**
   * @param {!MouseEvent} event
   * @protected
   */
  _onMouseOver(event) {
    if (event.composedPath().includes(this._subMenu)) {
      return;
    }
    const button = this._getButtonFromEvent(event);
    if (!button) {
      this._hideTooltip();
    } else if (button !== this._expandedButton) {
      if (button.item.children && (this.openOnHover || this._subMenu.opened)) {
        this.__openSubMenu(button, false);
      }
      if (button === this._overflow || this.openOnHover && button.item.children) {
        this._hideTooltip();
      } else {
        this._showTooltip(button, true);
      }
    }
  }
  /** @private */
  __onContextMenuKeydown(e) {
    const item = Array.from(e.composedPath()).find((el) => el._item);
    if (item) {
      const list = item.parentNode;
      if (e.keyCode === 38 && item === list.items[0]) {
        this._close(true);
      }
      if (e.keyCode === 37 || e.keyCode === 39 && !item._item.children) {
        e.stopImmediatePropagation();
        this._handleKeyDown(e);
      }
      if (e.key === "Tab" && this.tabNavigation) {
        this._handleKeyDown(e);
      }
    }
  }
  /** @private */
  __fireItemSelected(value) {
    this.dispatchEvent(new CustomEvent("item-selected", { detail: { value } }));
  }
  /** @private */
  __onButtonClick(e) {
    const button = this._getButtonFromEvent(e);
    if (button) {
      this.__openSubMenu(button, button.__triggeredWithActiveKeys);
    }
  }
  /** @private */
  __openSubMenu(button, keydown, options = {}) {
    if (button.disabled) {
      return;
    }
    const subMenu = this._subMenu;
    const item = button.item;
    if (subMenu.opened) {
      this._close();
      if (subMenu.listenOn === button) {
        return;
      }
    }
    const items = item && item.children;
    if (!items || items.length === 0) {
      this.__fireItemSelected(item);
      return;
    }
    subMenu.items = items;
    subMenu.listenOn = button;
    subMenu._positionTarget = button;
    const overlay = subMenu._overlayElement;
    overlay.noVerticalOverlap = true;
    this._hideTooltip(true);
    this._expandedButton = button;
    this._setExpanded(button, true);
    this.style.pointerEvents = "auto";
    button.dispatchEvent(
      new CustomEvent("opensubmenu", {
        detail: {
          children: items
        }
      })
    );
    overlay.addEventListener(
      "vaadin-overlay-open",
      () => {
        if (options.focusLast) {
          this._focusLastItem();
        }
        if (options.keepFocus) {
          const focusOptions = { focusVisible: isKeyboardActive() };
          this._focusItem(this._expandedButton, focusOptions, false);
        }
        if (!keydown) {
          overlay.$.overlay.focus();
        }
      },
      { once: true }
    );
  }
  /** @private */
  _focusFirstItem() {
    const list = this._subMenu._overlayElement._contentRoot.firstElementChild;
    list.focus();
  }
  /** @private */
  _focusLastItem() {
    const list = this._subMenu._overlayElement._contentRoot.firstElementChild;
    const item = list.items[list.items.length - 1];
    if (item) {
      item.focus();
    }
  }
  /** @private */
  __onItemSelected(e) {
    e.stopPropagation();
    this.__fireItemSelected(e.detail.value);
  }
  /** @private */
  __onEscapeClose() {
    this.__deactivateButton(true);
  }
  /** @private */
  __deactivateButton(restoreFocus) {
    const button = this._expandedButton;
    if (button && button.hasAttribute("expanded")) {
      this._setExpanded(button, false);
      if (restoreFocus) {
        const focusOptions = { focusVisible: isKeyboardActive() };
        this._focusItem(button, focusOptions, false);
      }
      this._expandedButton = null;
    }
  }
  /**
   * @param {boolean} restoreFocus
   * @protected
   */
  _close(restoreFocus = false) {
    this.style.pointerEvents = "";
    this.__deactivateButton(restoreFocus);
    if (this._subMenu.opened) {
      this._subMenu.close();
    }
  }
  /**
   * Closes the current submenu.
   */
  close() {
    this._close();
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin` to allow
   * focusing disabled buttons that are configured so.
   *
   * @param {Element} button
   * @protected
   * @override
   */
  _isItemFocusable(button) {
    if (button.disabled && button.__shouldAllowFocusWhenDisabled) {
      return button.__shouldAllowFocusWhenDisabled();
    }
    return super._isItemFocusable(button);
  }
};

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar.js
var MenuBar = class extends MenuBarMixin(ElementMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-menu-bar";
  }
  static get styles() {
    return menuBarStyles;
  }
  /** @protected */
  render() {
    return html`
      <div part="container" @click="${this.__onButtonClick}" @mouseover="${this._onMouseOver}">
        <slot></slot>
        <slot name="overflow"></slot>
      </div>

      <slot name="submenu"></slot>

      <slot name="tooltip"></slot>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setManual(true);
    this.addController(this._tooltipController);
  }
  /**
   * Fired when either a submenu item or menu bar button without nested children is clicked.
   *
   * @event item-selected
   * @param {Object} detail
   * @param {Object} detail.value the selected menu bar item
   */
};
defineCustomElement(MenuBar);

export {
  MenuBar
};
//# sourceMappingURL=chunk-I4OMFQPS.js.map
