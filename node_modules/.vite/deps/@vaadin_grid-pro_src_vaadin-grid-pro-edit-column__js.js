import {
  Select
} from "./chunk-UZNLLE6E.js";
import "./chunk-RM22DGSP.js";
import "./chunk-TYZ7RCV5.js";
import {
  TextField
} from "./chunk-6QV6LNZP.js";
import "./chunk-MNTMWC4G.js";
import "./chunk-QMCKCKIE.js";
import {
  GridColumn
} from "./chunk-Y26XBQLX.js";
import "./chunk-K6BWFOYR.js";
import "./chunk-TZCAYWP4.js";
import "./chunk-ETYEORRM.js";
import "./chunk-F6FMTQFS.js";
import "./chunk-3V4YUPS4.js";
import "./chunk-GDVAXDUZ.js";
import "./chunk-SP7V2F3Y.js";
import "./chunk-WEJ2XI2Y.js";
import "./chunk-FOQZPEJP.js";
import "./chunk-OSWHV746.js";
import "./chunk-PFI4EOEJ.js";
import {
  Checkbox
} from "./chunk-WCDJXOAW.js";
import "./chunk-EV2VABJA.js";
import "./chunk-6KCLDTNY.js";
import "./chunk-C63QNJWN.js";
import "./chunk-2WIP7T36.js";
import "./chunk-ZZO67D7M.js";
import "./chunk-WJXDM45A.js";
import "./chunk-722MDOVI.js";
import "./chunk-ME7RDPE7.js";
import "./chunk-HJJCYWLA.js";
import "./chunk-R7PLRAV7.js";
import "./chunk-SFISAMYO.js";
import "./chunk-44TEYO45.js";
import "./chunk-XFKQJ73Z.js";
import "./chunk-X5EEA4XV.js";
import "./chunk-Z5LHTDPJ.js";
import "./chunk-VNVGWFKZ.js";
import "./chunk-T3UXCKHJ.js";
import "./chunk-472KGBTN.js";
import "./chunk-V6ISAKNA.js";
import "./chunk-OWHE56FA.js";
import "./chunk-GXEMU344.js";
import "./chunk-ZBUMLMW2.js";
import "./chunk-EIHDKHUQ.js";
import "./chunk-5W5MB6YY.js";
import "./chunk-M3HWWZVG.js";
import "./chunk-WT6HVPMS.js";
import "./chunk-ERLMGG3V.js";
import "./chunk-SVPOVVYN.js";
import {
  getDeepActiveElement
} from "./chunk-5DESY7LS.js";
import "./chunk-ML4P6KOO.js";
import "./chunk-ULNR4UH6.js";
import "./chunk-MKNWHZM7.js";
import "./chunk-TMRBPE5K.js";
import "./chunk-56IVV4NW.js";
import {
  get,
  set
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import "./chunk-4MR6LGSU.js";
import "./chunk-ZCNTBWU5.js";
import "./chunk-5IHOHWXL.js";
import "./chunk-MWWP2LZ3.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-checkbox.js
var GridProEditCheckbox = class extends Checkbox {
  static get is() {
    return "vaadin-grid-pro-edit-checkbox";
  }
};
defineCustomElement(GridProEditCheckbox);

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-select-mixin.js
var GridProEditSelectMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      options: {
        type: Array,
        value: () => []
      },
      _grid: {
        type: Object
      },
      _initialized: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["_optionsChanged(options)"];
  }
  ready() {
    super.ready();
    this.setAttribute("theme", "grid-pro-editor");
  }
  _onKeyDown(e) {
    super._onKeyDown(e);
    if (this.options.length === 0 && /^(ArrowDown|Down|ArrowUp|Up|Enter|SpaceBar| )$/u.test(e.key)) {
      console.warn('Missing "editorOptions" for <vaadin-grid-pro-edit-column> select editor!');
    }
    if (e.defaultPrevented) {
      e.stopPropagation();
    }
  }
  /**
   * Override list-box event listener inherited from `Select`:
   * - Enter: set flag for moving to next row on value change,
   * - Tab: switch to next cell when "singleCellEdit" is false.
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDownInside(event) {
    if (event.keyCode === 13) {
      this._enterKeydown = event;
    }
    if (event.keyCode === 9) {
      if (!this._grid.singleCellEdit) {
        this._grid._switchEditCell(event);
      }
    }
    super._onKeyDownInside(event);
  }
  _valueChanged(value, oldValue) {
    super._valueChanged(value, oldValue);
    if (value === "" && oldValue === void 0) {
      return;
    }
    if (this._initialized) {
      const enter = this._enterKeydown;
      if (enter && this._grid.enterNextRow) {
        this._grid._switchEditCell(enter);
      } else if (this._grid.singleCellEdit) {
        this._grid._stopEdit(false, true);
      } else {
        this.focus();
      }
    }
  }
  _optionsChanged(options) {
    if (options && options.length) {
      this.items = options.map((option) => ({
        label: option,
        value: option
      }));
      this._overlayElement = this._overlayElement || this.shadowRoot.querySelector("vaadin-select-overlay");
      this._overlayElement.addEventListener("vaadin-overlay-outside-click", () => {
        this._grid._stopEdit();
      });
      setTimeout(() => {
        this.opened = true;
        this._initialized = true;
      });
    }
  }
};

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-select.js
var GridProEditSelect = class extends GridProEditSelectMixin(Select) {
  static get is() {
    return "vaadin-grid-pro-edit-select";
  }
};
defineCustomElement(GridProEditSelect);

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-text-field.js
var GridProEditText = class extends TextField {
  static get is() {
    return "vaadin-grid-pro-edit-text-field";
  }
  ready() {
    super.ready();
    this.setAttribute("theme", "grid-pro-editor");
  }
};
defineCustomElement(GridProEditText);

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-column-mixin.js
var GridProEditColumnMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      /**
       * Custom function for rendering the cell content in edit mode.
       * Receives three arguments:
       *
       * - `root` The cell content DOM element. Append your editor component to it.
       * - `column` The `<vaadin-grid-pro-edit-column>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *   - `model.detailsOpened` Details opened state.
       * @type {!GridBodyRenderer | null | undefined}
       */
      editModeRenderer: {
        type: Function,
        sync: true
      },
      /**
       * The list of options which should be passed to cell editor component.
       * Used with the `select` editor type, to provide a list of items.
       * @type {!Array<string>}
       */
      editorOptions: {
        type: Array,
        value: () => []
      },
      /**
       * Type of the cell editor component to be rendered. Allowed values:
       * - `text` (default) - renders a text field
       * - `checkbox` - renders a checkbox
       * - `select` - renders a select with a list of items passed as `editorOptions`
       *
       * Editor type is set to `custom` when `editModeRenderer` is set.
       * @attr {text|checkbox|select|custom} editor-type
       * @type {!GridProEditorType}
       */
      editorType: {
        type: String,
        notify: true,
        // FIXME(web-padawan): needed by Flow counterpart
        value: "text"
      },
      /**
       * Path of the property used for the value of the editor component.
       * @attr {string} editor-value-path
       * @type {string}
       */
      editorValuePath: {
        type: String,
        value: "value"
      },
      /**
       * JS Path of the property in the item used for the editable content.
       */
      path: {
        type: String,
        observer: "_pathChanged",
        sync: true
      },
      /**
       * A function to check whether a specific cell of this column can be
       * edited. This allows to disable editing of individual rows or cells,
       * based on the item.
       *
       * Receives a `model` object containing the item for an individual row,
       * and should return a boolean indicating whether the column's cell in
       * that row is editable.
       *
       * The `model` object contains:
       * - `model.index` The index of the item.
       * - `model.item` The item.
       * - `model.expanded` Sublevel toggle state.
       * - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       * - `model.selected` Selected state.
       *
       * @type {(model: GridItemModel) => boolean}
       */
      isCellEditable: {
        type: Function,
        observer: "_isCellEditableChanged"
      },
      /** @private */
      _oldRenderer: Function
    };
  }
  static get observers() {
    return ["_editModeRendererChanged(editModeRenderer, __initialized)"];
  }
  constructor() {
    super();
    this._focusButtonMode = navigator.platform.includes("Mac");
    this.__editModeRenderer = function(root, column) {
      const cell = root.assignedSlot.parentNode;
      const tagName = column._getEditorTagName(cell);
      if (!root.firstElementChild || root.firstElementChild.localName.toLowerCase() !== tagName) {
        root.innerHTML = `
          <${tagName}></${tagName}>
        `;
      }
    };
  }
  /** @private */
  _pathChanged(path) {
    if (!path || path.length === 0) {
      throw new Error("You should specify the path for the edit column");
    }
  }
  /** @private */
  _isCellEditableChanged() {
    this._grid.requestContentUpdate();
  }
  /** @private */
  _editModeRendererChanged(renderer) {
    if (renderer) {
      this.editorType = "custom";
    } else if (this._oldRenderer) {
      this.editorType = "text";
    }
    this._oldRenderer = renderer;
  }
  /**
   * @param {!HTMLElement} cell
   * @return {string}
   * @protected
   */
  _getEditorTagName(cell) {
    return this.editorType === "custom" ? this._getEditorComponent(cell).localName : this._getTagNameByType();
  }
  /**
   * @param {!HTMLElement} cell
   * @return {HTMLElement | null}
   * @protected
   */
  _getEditorComponent(cell) {
    return this.editorType === "custom" ? cell._content.firstElementChild : cell._content.querySelector(this._getEditorTagName(cell));
  }
  /** @private */
  _getTagNameByType() {
    let type;
    switch (this.editorType) {
      case "checkbox":
        type = "checkbox";
        break;
      case "select":
        type = "select";
        break;
      case "text":
      default:
        type = "text-field";
        break;
    }
    return this.constructor.is.replace("column", type);
  }
  /** @private */
  _focusEditor(editor) {
    editor.focus();
    if (this.editorType === "checkbox") {
      editor.setAttribute("focus-ring", "");
    } else if (editor instanceof HTMLInputElement) {
      editor.select();
    } else if (editor.focusElement && editor.focusElement instanceof HTMLInputElement) {
      editor.focusElement.select();
    }
  }
  /**
   * @param {!HTMLElement} editor
   * @return {unknown}
   * @protected
   */
  _getEditorValue(editor) {
    const path = this.editorType === "checkbox" ? "checked" : this.editorValuePath;
    return get(path, editor);
  }
  /** @private */
  _renderEditor(cell, model) {
    cell.__savedRenderer = this._renderer || cell._renderer;
    cell._renderer = this.editModeRenderer || this.__editModeRenderer;
    if (cell._focusButton) {
      cell._focusButton.removeAttribute("role");
    }
    this._clearCellContent(cell);
    this._runRenderer(cell._renderer, cell, model);
  }
  /** @private */
  _removeEditor(cell, _model) {
    if (!cell.__savedRenderer) {
      return;
    }
    cell._renderer = cell.__savedRenderer;
    cell.__savedRenderer = void 0;
    this._clearCellContent(cell);
    if (cell._focusButton) {
      cell._focusButton.setAttribute("role", "button");
    }
    this.__renderCellsContent(cell._renderer, [cell]);
  }
  /** @private */
  _setEditorOptions(editor) {
    if (this.editorOptions && this.editorOptions.length) {
      editor.options = this.editorOptions;
    }
  }
  /** @private */
  _setEditorValue(editor, value) {
    const path = this.editorType === "checkbox" ? "checked" : this.editorValuePath;
    value = this.editorType === "checkbox" && typeof value === "string" ? value === "true" : value;
    set(path, value, editor);
    if (editor.notifyPath) {
      editor.notifyPath(path, value);
    }
  }
  /**
   * @param {!HTMLElement} cell
   * @param {!GridItemModel} model
   * @protected
   */
  _startCellEdit(cell, model) {
    this._renderEditor(cell, model);
    const editor = this._getEditorComponent(cell);
    editor.addEventListener("focusout", this._grid.__boundEditorFocusOut);
    editor.addEventListener("focusin", this._grid.__boundEditorFocusIn);
    this._setEditorOptions(editor);
    this._setEditorValue(editor, get(this.path, model.item));
    editor._grid = this._grid;
    if (editor.updateComplete) {
      editor.updateComplete.then(() => this._focusEditor(editor));
    } else {
      this._focusEditor(editor);
    }
    if (this.editorType === "custom") {
      editor.addEventListener("opened-changed", (event) => {
        const element = event.target;
        const activeElement = getDeepActiveElement();
        if (!element.opened && !element.contains(activeElement)) {
          this._grid._stopEdit();
        }
      });
    }
  }
  /**
   * @param {!HTMLElement} cell
   * @param {!GridItemModel} model
   * @protected
   */
  _stopCellEdit(cell, model) {
    this._removeEditor(cell, model);
  }
};

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-column.js
var GridProEditColumn = class extends GridProEditColumnMixin(GridColumn) {
  static get is() {
    return "vaadin-grid-pro-edit-column";
  }
};
defineCustomElement(GridProEditColumn);
export {
  GridProEditColumn
};
//# sourceMappingURL=@vaadin_grid-pro_src_vaadin-grid-pro-edit-column__js.js.map
