import {
  ListMixin
} from "./chunk-GDVAXDUZ.js";
import {
  getNormalizedScrollLeft
} from "./chunk-SP7V2F3Y.js";
import {
  ResizeMixin
} from "./chunk-J36B4EVN.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/tabs/src/styles/vaadin-tabs-base-styles.js
var tabsStyles = css`
  :host {
    display: flex;
    max-width: 100%;
    max-height: 100%;
    position: relative;
    box-sizing: border-box;
    padding: var(--vaadin-tabs-padding);
    background: var(--vaadin-tabs-background);
    border-radius: var(--vaadin-tabs-border-radius);
    border: var(--vaadin-tabs-border-width, 0) solid
      var(--vaadin-tabs-border-color, var(--vaadin-border-color-secondary));
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([orientation='vertical']) {
    flex-direction: column;
  }

  [part='tabs'] {
    flex: 1;
    overflow: auto;
    overscroll-behavior: contain;
    display: flex;
    flex-direction: column;
    gap: var(--vaadin-tabs-gap, var(--vaadin-gap-s));
  }

  :host([orientation='horizontal']) [part='tabs'] {
    flex-direction: row;
    scrollbar-width: none;
  }

  /* scrollbar-width is supported in Safari 18.2, use the following for earlier */
  :host([orientation='horizontal']) [part='tabs']::-webkit-scrollbar {
    display: none;
  }

  [part$='button'] {
    position: absolute;
    z-index: 1;
    pointer-events: none;
    opacity: 0;
    cursor: var(--vaadin-clickable-cursor);
    box-sizing: border-box;
    height: 100%;
    padding: var(--vaadin-tab-padding, var(--vaadin-padding-block-container) var(--vaadin-padding-inline-container));
    background: var(--vaadin-background-color);
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }

  [part='forward-button'] {
    inset-inline-end: 0;
  }

  :host([overflow~='start']) [part='back-button'],
  :host([overflow~='end']) [part='forward-button'] {
    pointer-events: auto;
    opacity: 1;
  }

  [part$='button']::before {
    content: '';
    display: block;
    width: var(--vaadin-icon-size, 1lh);
    height: var(--vaadin-icon-size, 1lh);
    background: currentColor;
    mask: var(--_vaadin-icon-chevron-down) 50% / var(--vaadin-icon-visual-size, 100%) no-repeat;
    rotate: 90deg;
  }

  [part='forward-button']::before {
    rotate: -90deg;
  }

  :host(:is([orientation='vertical'], [theme~='hide-scroll-buttons'])) [part$='button'] {
    display: none;
  }

  @media (pointer: coarse) {
    :host(:not([theme~='show-scroll-buttons'])) [part$='button'] {
      display: none;
    }
  }

  :host([dir='rtl']) [part$='button']::before {
    scale: 1 -1;
  }

  @media (forced-colors: active) {
    [part$='button']::before {
      background: CanvasText;
    }
  }
`;

// node_modules/@vaadin/tabs/src/vaadin-tabs-mixin.js
var TabsMixin = (superClass) => class TabsMixinClass extends ResizeMixin(ListMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Set tabs disposition. Possible values are `horizontal|vertical`
       * @type {!TabsOrientation}
       */
      orientation: {
        value: "horizontal",
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * The index of the selected tab.
       */
      selected: {
        value: 0,
        type: Number,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["__tabsItemsChanged(items)"];
  }
  constructor() {
    super();
    this.__itemsResizeObserver = new ResizeObserver(() => {
      setTimeout(() => this._updateOverflow());
    });
  }
  /**
   * @return {number}
   * @protected
   */
  get _scrollOffset() {
    return this._vertical ? this._scrollerElement.offsetHeight : this._scrollerElement.offsetWidth;
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.$.scroll;
  }
  /** @private */
  get __direction() {
    return !this._vertical && this.__isRTL ? 1 : -1;
  }
  /** @protected */
  ready() {
    super.ready();
    this._scrollerElement.addEventListener("scroll", () => this._updateOverflow());
    this.setAttribute("role", "tablist");
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this._updateOverflow();
  }
  /** @private */
  __tabsItemsChanged(items) {
    this.__itemsResizeObserver.disconnect();
    (items || []).forEach((item) => {
      this.__itemsResizeObserver.observe(item);
    });
    this._updateOverflow();
  }
  /** @protected */
  _scrollForward() {
    const forwardButtonVisibleWidth = this._getNavigationButtonVisibleWidth("forward-button");
    const backButtonVisibleWidth = this._getNavigationButtonVisibleWidth("back-button");
    const scrollerRect = this._scrollerElement.getBoundingClientRect();
    const itemToScrollTo = [...this.items].reverse().find((item) => this._isItemVisible(item, forwardButtonVisibleWidth, backButtonVisibleWidth, scrollerRect));
    const itemRect = itemToScrollTo.getBoundingClientRect();
    const overflowIndicatorCompensation = 20;
    const totalCompensation = overflowIndicatorCompensation + this.shadowRoot.querySelector('[part="back-button"]').clientWidth;
    let scrollOffset;
    if (this.__isRTL) {
      const scrollerRightEdge = scrollerRect.right - totalCompensation;
      scrollOffset = itemRect.right - scrollerRightEdge;
    } else {
      const scrollerLeftEdge = scrollerRect.left + totalCompensation;
      scrollOffset = itemRect.left - scrollerLeftEdge;
    }
    if (-this.__direction * scrollOffset < 1) {
      scrollOffset = -this.__direction * (this._scrollOffset - totalCompensation);
    }
    this._scroll(scrollOffset);
  }
  /** @protected */
  _scrollBack() {
    const forwardButtonVisibleWidth = this._getNavigationButtonVisibleWidth("forward-button");
    const backButtonVisibleWidth = this._getNavigationButtonVisibleWidth("back-button");
    const scrollerRect = this._scrollerElement.getBoundingClientRect();
    const itemToScrollTo = this.items.find(
      (item) => this._isItemVisible(item, forwardButtonVisibleWidth, backButtonVisibleWidth, scrollerRect)
    );
    const itemRect = itemToScrollTo.getBoundingClientRect();
    const overflowIndicatorCompensation = 20;
    const totalCompensation = overflowIndicatorCompensation + this.shadowRoot.querySelector('[part="forward-button"]').clientWidth;
    let scrollOffset;
    if (this.__isRTL) {
      const scrollerLeftEdge = scrollerRect.left + totalCompensation;
      scrollOffset = itemRect.left - scrollerLeftEdge;
    } else {
      const scrollerRightEdge = scrollerRect.right - totalCompensation;
      scrollOffset = itemRect.right - scrollerRightEdge;
    }
    if (this.__direction * scrollOffset < 1) {
      scrollOffset = this.__direction * (this._scrollOffset - totalCompensation);
    }
    this._scroll(scrollOffset);
  }
  /** @private */
  _isItemVisible(item, forwardButtonVisibleWidth, backButtonVisibleWidth, scrollerRect) {
    if (this._vertical) {
      throw new Error("Visibility check is only supported for horizontal tabs.");
    }
    const buttonOnTheRightWidth = this.__isRTL ? backButtonVisibleWidth : forwardButtonVisibleWidth;
    const buttonOnTheLeftWidth = this.__isRTL ? forwardButtonVisibleWidth : backButtonVisibleWidth;
    const scrollerRightEdge = scrollerRect.right - buttonOnTheRightWidth;
    const scrollerLeftEdge = scrollerRect.left + buttonOnTheLeftWidth;
    const itemRect = item.getBoundingClientRect();
    return scrollerRightEdge > Math.floor(itemRect.left) && scrollerLeftEdge < Math.ceil(itemRect.right);
  }
  /** @private */
  _getNavigationButtonVisibleWidth(buttonPartName) {
    const navigationButton = this.shadowRoot.querySelector(`[part="${buttonPartName}"]`);
    if (window.getComputedStyle(navigationButton).opacity === "0") {
      return 0;
    }
    return navigationButton.clientWidth;
  }
  /** @private */
  _updateOverflow() {
    const scrollPosition = this._vertical ? this._scrollerElement.scrollTop : getNormalizedScrollLeft(this._scrollerElement, this.getAttribute("dir"));
    const scrollSize = this._vertical ? this._scrollerElement.scrollHeight : this._scrollerElement.scrollWidth;
    let overflow = Math.floor(scrollPosition) > 1 ? "start" : "";
    if (Math.ceil(scrollPosition) < Math.ceil(scrollSize - this._scrollOffset)) {
      overflow += " end";
    }
    if (this.__direction === 1) {
      overflow = overflow.replace(/start|end/giu, (matched) => {
        return matched === "start" ? "end" : "start";
      });
    }
    if (overflow) {
      this.setAttribute("overflow", overflow.trim());
    } else {
      this.removeAttribute("overflow");
    }
  }
};

// node_modules/@vaadin/tabs/src/vaadin-tabs.js
var Tabs = class extends TabsMixin(ElementMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-tabs";
  }
  static get styles() {
    return tabsStyles;
  }
  /** @protected */
  render() {
    return html`
      <div @click="${this._scrollBack}" part="back-button" aria-hidden="true"></div>

      <div id="scroll" part="tabs">
        <slot></slot>
      </div>

      <div @click="${this._scrollForward}" part="forward-button" aria-hidden="true"></div>
    `;
  }
};
defineCustomElement(Tabs);

export {
  Tabs
};
//# sourceMappingURL=chunk-XJGJ74SS.js.map
