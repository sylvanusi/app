import {
  SlotStylesMixin
} from "./chunk-2WIP7T36.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  isElementHidden
} from "./chunk-5DESY7LS.js";
import {
  addGlobalThemeStyles
} from "./chunk-ULNR4UH6.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/form-layout/src/styles/vaadin-form-layout-base-styles.js
addGlobalThemeStyles(
  "vaadin-form-layout-base",
  css`
    @layer vaadin.base {
      :where(html) {
        --vaadin-form-layout-label-spacing: var(--vaadin-gap-s);
        --vaadin-form-layout-label-width: 8em;
        --vaadin-form-layout-column-spacing: var(--vaadin-gap-l);
        --vaadin-form-layout-row-spacing: var(--vaadin-gap-l);
      }
    }
  `
);
var formLayoutStyles = css`
  :host {
    /* Default values */
    --_label-spacing: var(--vaadin-form-layout-label-spacing);
    --_label-width: var(--vaadin-form-layout-label-width);
    --_column-spacing: var(--vaadin-form-layout-column-spacing);
    --_row-spacing: var(--vaadin-form-layout-row-spacing);

    align-self: stretch;
    display: block;
    max-width: 100%;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host(:not([auto-responsive])) {
    contain: layout;
  }

  :host(:not([auto-responsive])) #layout {
    align-items: baseline; /* default \`stretch\` is not appropriate */
    display: flex;
    flex-wrap: wrap; /* the items should wrap */
    /* Compensate for row spacing */
    margin-block: calc(-0.5 * var(--_row-spacing));
  }

  :host(:not([auto-responsive])) #layout ::slotted(*) {
    /* Items should neither grow nor shrink. */
    flex-grow: 0;
    flex-shrink: 0;

    /* Margins make spacing between the columns and rows */
    margin-inline: calc(0.5 * var(--_column-spacing));
    margin-block: calc(0.5 * var(--_row-spacing));
  }

  #layout ::slotted(br) {
    display: none;
  }

  :host([auto-responsive]) {
    /* Column width */
    --_column-width: var(--vaadin-field-default-width, 12em);
    --_column-width-labels-above: var(--_column-width);
    --_column-width-labels-aside: calc(var(--_column-width) + var(--_label-width) + var(--_label-spacing));

    /* Column gap */
    --_min-total-gap: calc((var(--_min-columns) - 1) * var(--_column-spacing));
    --_max-total-gap: calc((var(--_max-columns) - 1) * var(--_column-spacing));

    /* Minimum form layout width */
    --_min-width-labels-above: calc(var(--_min-columns) * var(--_column-width-labels-above) + var(--_min-total-gap));
    --_min-width-labels-aside: calc(var(--_min-columns) * var(--_column-width-labels-aside) + var(--_min-total-gap));
    --_min-width: var(--_min-width-labels-above);

    /* Maximum form layout width */
    --_max-width-labels-above: calc(var(--_max-columns) * var(--_column-width-labels-above) + var(--_max-total-gap));
    --_max-width-labels-aside: calc(var(--_max-columns) * var(--_column-width-labels-aside) + var(--_max-total-gap));
    --_max-width: var(--_max-width-labels-above);

    display: flex;
    min-width: var(--_min-width);
  }

  :host([auto-responsive]) #layout {
    /* By default, labels should be displayed above the fields */
    --_form-item-labels-above: initial; /* true */
    --_form-item-labels-aside: ' '; /* false */

    /* CSS grid related properties */
    --_grid-column-width: var(--_column-width-labels-above);
    --_grid-repeat: var(--_grid-column-width);

    display: grid;
    gap: var(--_row-spacing) var(--_column-spacing);

    /*
      Auto-columns can be created when an item's colspan exceeds the rendered column count.
      By setting auto-columns to 0, we exclude these columns from --_grid-rendered-column-count,
      which is then used to cap the colspan.
    */
    grid-auto-columns: 0;

    align-self: start;
    grid-template-columns: repeat(auto-fill, var(--_grid-repeat));
    place-items: baseline start;

    /*
      Firefox requires min-width on both :host and #layout to allow the layout
      to shrink below the value specified in the CSS width property above.
    */
    min-width: var(--_min-width);

    /*
      To prevent the layout from exceeding the column limit defined by --_max-columns,
      its width needs to be constrained:

      1. "width" is used instead of "max-width" because, together with the default "flex: 0 1 auto",
      it allows the layout to shrink to its minimum width inside <vaadin-horizontal-layout>, which
      wouldn't work otherwise.

      2. "width" is used instead of "flex-basis" to make the layout expand to the maximum
      number of columns inside <vaadin-overlay>, which creates a new stacking context
      without a predefined width.
    */
    width: var(--_max-width);
  }

  :host([auto-responsive]) #layout::before {
    background-position-y: var(--_min-width-labels-aside);
  }

  :host([auto-responsive]) #layout ::slotted(*) {
    /* Make form items inherit label position from the layout */
    --_form-item-labels-above: inherit;
    --_form-item-labels-aside: inherit;

    /* By default, place each child on a new row */
    grid-column: 1 / span min(var(--_grid-colspan, 1), var(--_grid-rendered-column-count));

    /* Form items do not need margins in auto-responsive mode */
    margin: 0;
  }

  :host([auto-responsive][auto-rows]) #layout ::slotted(*) {
    grid-column-start: var(--_grid-colstart, auto);
  }

  :host([auto-responsive][labels-aside]) {
    --_max-width: var(--_max-width-labels-aside);
  }

  :host([auto-responsive][labels-aside]) #layout[fits-labels-aside] {
    --_form-item-labels-above: ' '; /* false */
    --_form-item-labels-aside: initial; /* true */
    --_grid-column-width: var(--_column-width-labels-aside);
  }

  :host([auto-responsive][expand-columns]) #layout {
    /*
      The "min" value in minmax ensures that once "maxColumns" is reached, the grid stops adding
      new columns and instead expands the existing ones evenly to fill the available space.

      The "max" value in minmax allows CSS grid columns to grow and evenly distribute any space
      that remains when there isn't room for an additional column and "maxColumns" hasn't been
      reached yet.
    */
    --_grid-repeat: minmax(
      max(var(--_grid-column-width), calc((100% - var(--_max-total-gap)) / var(--_max-columns))),
      1fr
    );

    /* Allow the layout to take up full available width of the parent element. */
    flex-grow: 1;
  }
`;
var formLayoutSlotStyles = css`
  /* Using :where to ensure user styles always take precedence */
  :where(
    vaadin-form-layout[auto-responsive] > *,
    vaadin-form-layout[auto-responsive] vaadin-form-row > *,
    vaadin-form-layout[auto-responsive] vaadin-form-item > *
  ) {
    box-sizing: border-box;
    max-width: 100%;
  }

  :where(
    vaadin-form-layout[auto-responsive][expand-fields] > *,
    vaadin-form-layout[auto-responsive][expand-fields] vaadin-form-row > *,
    vaadin-form-layout[auto-responsive][expand-fields] vaadin-form-item > *
  ) {
    min-width: 100%;
  }
`;

// node_modules/@vaadin/form-layout/src/layouts/abstract-layout.js
var AbstractLayout = class {
  /**
   * @param {HTMLElement} host
   * @param {{ mutationObserverOptions: MutationObserverInit }} config
   */
  constructor(host, config) {
    this.host = host;
    this.props = {};
    this.config = config;
    this.isConnected = false;
    this.__resizeObserver = new ResizeObserver((entries) => setTimeout(() => this._onResize(entries)));
    this.__mutationObserver = new MutationObserver((records) => this._onMutation(records));
  }
  /**
   * Connects the layout to the host element.
   */
  connect() {
    if (this.isConnected) {
      return;
    }
    this.isConnected = true;
    this.__resizeObserver.observe(this.host);
    this.__mutationObserver.observe(this.host, this.config.mutationObserverOptions);
  }
  /**
   * Disconnects the layout from the host element.
   */
  disconnect() {
    if (!this.isConnected) {
      return;
    }
    this.isConnected = false;
    this.__resizeObserver.disconnect();
    this.__mutationObserver.disconnect();
  }
  /**
   * Sets the properties of the layout controller.
   */
  setProps(props) {
    this.props = props;
  }
  /**
   * Updates the layout based on the current properties.
   */
  updateLayout() {
  }
  /**
   * @param {ResizeObserverEntry[]} _entries
   * @protected
   */
  _onResize(_entries) {
  }
  /**
   * @param {MutationRecord[]} _records
   * @protected
   */
  _onMutation(_records) {
  }
};

// node_modules/@vaadin/form-layout/src/layouts/auto-responsive-layout.js
function isBreakLine(el) {
  return el.localName === "br";
}
var AutoResponsiveLayout = class extends AbstractLayout {
  constructor(host) {
    super(host, {
      mutationObserverOptions: {
        subtree: true,
        childList: true,
        attributes: true,
        attributeFilter: ["colspan", "data-colspan", "hidden"]
      }
    });
  }
  /** @override */
  connect() {
    if (this.isConnected) {
      return;
    }
    super.connect();
    this.updateLayout();
  }
  /** @override */
  disconnect() {
    if (!this.isConnected) {
      return;
    }
    super.disconnect();
    const { host } = this;
    host.style.removeProperty("--_column-width");
    host.style.removeProperty("--_max-columns");
    host.$.layout.removeAttribute("fits-labels-aside");
    host.$.layout.style.removeProperty("--_grid-rendered-column-count");
    this.__children.forEach((child) => {
      child.style.removeProperty("--_grid-colstart");
      child.style.removeProperty("--_grid-colspan");
    });
  }
  /** @override */
  setProps(props) {
    super.setProps(props);
    if (this.isConnected) {
      this.updateLayout();
    }
  }
  /** @override */
  updateLayout() {
    const { host, props } = this;
    if (!this.isConnected || isElementHidden(host)) {
      return;
    }
    let columnCount = 0;
    let maxColumns = 0;
    const children = this.__children;
    children.filter((child) => isBreakLine(child) || !isElementHidden(child)).forEach((child, index, children2) => {
      const prevChild = children2[index - 1];
      if (isBreakLine(child)) {
        columnCount = 0;
        return;
      }
      if (prevChild && prevChild.parentElement !== child.parentElement || !props.autoRows && child.parentElement === host) {
        columnCount = 0;
      }
      if (props.autoRows && columnCount === 0) {
        child.style.setProperty("--_grid-colstart", 1);
      } else {
        child.style.removeProperty("--_grid-colstart");
      }
      const colspan = child.getAttribute("colspan") || child.getAttribute("data-colspan");
      if (colspan) {
        columnCount += parseInt(colspan);
        child.style.setProperty("--_grid-colspan", colspan);
      } else {
        columnCount += 1;
        child.style.removeProperty("--_grid-colspan");
      }
      maxColumns = Math.max(maxColumns, columnCount);
    });
    children.filter(isElementHidden).forEach((child) => {
      child.style.removeProperty("--_grid-colstart");
    });
    if (props.columnWidth) {
      host.style.setProperty("--_column-width", props.columnWidth);
    } else {
      host.style.removeProperty("--_column-width");
    }
    host.style.setProperty("--_min-columns", props.minColumns);
    host.style.setProperty("--_max-columns", Math.min(Math.max(props.minColumns, props.maxColumns), maxColumns));
    host.$.layout.toggleAttribute("fits-labels-aside", this.props.labelsAside && this.__fitsLabelsAside);
    host.$.layout.style.setProperty("--_grid-rendered-column-count", this.__renderedColumnCount);
  }
  /** @override */
  _onResize() {
    this.updateLayout();
  }
  /** @override */
  _onMutation(records) {
    const shouldUpdateLayout = records.some(({ target }) => {
      return target === this.host || target.parentElement === this.host || target.parentElement.localName === "vaadin-form-row";
    });
    if (shouldUpdateLayout) {
      this.updateLayout();
    }
  }
  /** @private */
  get __children() {
    return [...this.host.children].flatMap((child) => {
      return child.localName === "vaadin-form-row" ? [...child.children] : child;
    });
  }
  /** @private */
  get __renderedColumnCount() {
    const { gridTemplateColumns } = getComputedStyle(this.host.$.layout);
    return gridTemplateColumns.split(" ").filter((width) => width !== "0px").length;
  }
  /** @private */
  get __minWidthLabelsAside() {
    const { backgroundPositionY } = getComputedStyle(this.host.$.layout, "::before");
    return parseFloat(backgroundPositionY);
  }
  /** @private */
  get __fitsLabelsAside() {
    return this.host.offsetWidth >= this.__minWidthLabelsAside;
  }
};

// node_modules/@vaadin/form-layout/src/layouts/responsive-steps-layout.js
function isValidCSSLength(value) {
  return CSS.supports("word-spacing", value) && !["inherit", "normal"].includes(value);
}
function naturalNumberOrOne(n) {
  if (typeof n === "number" && n >= 1 && n < Infinity) {
    return Math.floor(n);
  }
  return 1;
}
var ResponsiveStepsLayout = class extends AbstractLayout {
  constructor(host) {
    super(host, {
      mutationObserverOptions: {
        subtree: true,
        childList: true,
        attributes: true,
        attributeFilter: ["colspan", "data-colspan", "hidden"]
      }
    });
  }
  /** @override */
  connect() {
    if (this.isConnected) {
      return;
    }
    super.connect();
    this.__selectResponsiveStep();
    this.updateLayout();
    requestAnimationFrame(() => this.__selectResponsiveStep());
    requestAnimationFrame(() => this.updateLayout());
  }
  /** @override */
  disconnect() {
    if (!this.isConnected) {
      return;
    }
    super.disconnect();
    const { host } = this;
    host.$.layout.style.removeProperty("opacity");
    [...host.children].forEach((child) => {
      child.style.removeProperty("width");
      child.style.removeProperty("margin-left");
      child.style.removeProperty("margin-right");
      child.removeAttribute("label-position");
    });
  }
  /** @override */
  setProps(props) {
    const { responsiveSteps } = props;
    if (!Array.isArray(responsiveSteps)) {
      throw new Error('Invalid "responsiveSteps" type, an Array is required.');
    }
    if (responsiveSteps.length < 1) {
      throw new Error('Invalid empty "responsiveSteps" array, at least one item is required.');
    }
    responsiveSteps.forEach((step) => {
      if (naturalNumberOrOne(step.columns) !== step.columns) {
        throw new Error(`Invalid 'columns' value of ${step.columns}, a natural number is required.`);
      }
      if (step.minWidth !== void 0 && !isValidCSSLength(step.minWidth)) {
        throw new Error(`Invalid 'minWidth' value of ${step.minWidth}, a valid CSS length required.`);
      }
      if (step.labelsPosition !== void 0 && ["aside", "top"].indexOf(step.labelsPosition) === -1) {
        throw new Error(
          `Invalid 'labelsPosition' value of ${step.labelsPosition}, 'aside' or 'top' string is required.`
        );
      }
    });
    super.setProps(props);
    if (this.isConnected) {
      this.__selectResponsiveStep();
      this.updateLayout();
    }
  }
  /** @override */
  updateLayout() {
    const { host } = this;
    if (!this.isConnected || isElementHidden(host)) {
      return;
    }
    const style = getComputedStyle(host);
    const columnSpacing = style.getPropertyValue("--_column-spacing");
    const direction = style.direction;
    const marginStartProp = `margin-${direction === "ltr" ? "left" : "right"}`;
    const marginEndProp = `margin-${direction === "ltr" ? "right" : "left"}`;
    const containerWidth = host.offsetWidth;
    let col = 0;
    Array.from(host.children).filter((child) => child.localName === "br" || getComputedStyle(child).display !== "none").forEach((child, index, children) => {
      if (child.localName === "br") {
        col = 0;
        return;
      }
      const attrColspan = child.getAttribute("colspan") || child.getAttribute("data-colspan");
      let colspan;
      colspan = naturalNumberOrOne(parseFloat(attrColspan));
      colspan = Math.min(colspan, this.__columnCount);
      const childRatio = colspan / this.__columnCount;
      child.style.width = `calc(${childRatio * 100}% - ${1 - childRatio} * ${columnSpacing})`;
      if (col + colspan > this.__columnCount) {
        col = 0;
      }
      if (col === 0) {
        child.style.setProperty(marginStartProp, "0px");
      } else {
        child.style.removeProperty(marginStartProp);
      }
      const nextIndex = index + 1;
      const nextLineBreak = nextIndex < children.length && children[nextIndex].localName === "br";
      if (col + colspan === this.__columnCount) {
        child.style.setProperty(marginEndProp, "0px");
      } else if (nextLineBreak) {
        const colspanRatio = (this.__columnCount - col - colspan) / this.__columnCount;
        child.style.setProperty(
          marginEndProp,
          `calc(${colspanRatio * containerWidth}px + ${colspanRatio} * ${columnSpacing})`
        );
      } else {
        child.style.removeProperty(marginEndProp);
      }
      col = (col + colspan) % this.__columnCount;
      if (child.localName === "vaadin-form-item") {
        if (this.__labelsOnTop) {
          if (child.getAttribute("label-position") !== "top") {
            child.__useLayoutLabelPosition = true;
            child.setAttribute("label-position", "top");
          }
        } else if (child.__useLayoutLabelPosition) {
          delete child.__useLayoutLabelPosition;
          child.removeAttribute("label-position");
        }
      }
    });
  }
  /** @override */
  _onResize() {
    const { host } = this;
    if (isElementHidden(host)) {
      host.$.layout.style.opacity = "0";
      return;
    }
    this.__selectResponsiveStep();
    this.updateLayout();
    host.$.layout.style.opacity = "";
  }
  /** @override */
  _onMutation(records) {
    const shouldUpdateLayout = records.some(({ target }) => {
      return target === this.host || target.parentElement === this.host;
    });
    if (shouldUpdateLayout) {
      this.updateLayout();
    }
  }
  /** @private */
  __selectResponsiveStep() {
    if (!this.isConnected) {
      return;
    }
    const { host, props } = this;
    let selectedStep;
    const tmpStyleProp = "background-position";
    props.responsiveSteps.forEach((step) => {
      host.$.layout.style.setProperty(tmpStyleProp, step.minWidth);
      const stepMinWidthPx = parseFloat(getComputedStyle(host.$.layout).getPropertyValue(tmpStyleProp));
      if (stepMinWidthPx <= host.offsetWidth) {
        selectedStep = step;
      }
    });
    host.$.layout.style.removeProperty(tmpStyleProp);
    if (selectedStep) {
      this.__columnCount = selectedStep.columns;
      this.__labelsOnTop = selectedStep.labelsPosition === "top";
    }
  }
};

// node_modules/@vaadin/form-layout/src/vaadin-form-layout-mixin.js
var FormLayoutMixin = (superClass) => class extends SlotStylesMixin(superClass) {
  static get properties() {
    return {
      /**
       * @typedef FormLayoutResponsiveStep
       * @type {object}
       * @property {string} minWidth - The threshold value for this step in CSS length units.
       * @property {number} columns - Number of columns. Only natural numbers are valid.
       * @property {string} labelsPosition - Labels position option, valid values: `"aside"` (default), `"top"`.
       */
      /**
       * Allows specifying a responsive behavior with the number of columns
       * and the label position depending on the layout width.
       *
       * Format: array of objects, each object defines one responsive step
       * with `minWidth` CSS length, `columns` number, and optional
       * `labelsPosition` string of `"aside"` or `"top"`. At least one item is required.
       *
       * NOTE: Responsive steps are ignored in auto-responsive mode, which may be
       * enabled explicitly via the `autoResponsive` property or implicitly
       * if the following feature flag is set:
       *
       * ```js
       * window.Vaadin.featureFlags.defaultAutoResponsiveFormLayout = true
       * ```
       *
       * #### Examples
       *
       * ```javascript
       * formLayout.responsiveSteps = [{columns: 1}];
       * // The layout is always a single column, labels aside.
       * ```
       *
       * ```javascript
       * formLayout.responsiveSteps = [
       *   {minWidth: 0, columns: 1},
       *   {minWidth: '40em', columns: 2}
       * ];
       * // Sets two responsive steps:
       * // 1. When the layout width is < 40em, one column, labels aside.
       * // 2. Width >= 40em, two columns, labels aside.
       * ```
       *
       * ```javascript
       * formLayout.responsiveSteps = [
       *   {minWidth: 0, columns: 1, labelsPosition: 'top'},
       *   {minWidth: '20em', columns: 1},
       *   {minWidth: '40em', columns: 2}
       * ];
       * // Default value. Three responsive steps:
       * // 1. Width < 20em, one column, labels on top.
       * // 2. 20em <= width < 40em, one column, labels aside.
       * // 3. Width >= 40em, two columns, labels aside.
       * ```
       *
       * @type {!Array<!FormLayoutResponsiveStep>}
       */
      responsiveSteps: {
        type: Array,
        value() {
          return [
            { minWidth: 0, columns: 1, labelsPosition: "top" },
            { minWidth: "20em", columns: 1 },
            { minWidth: "40em", columns: 2 }
          ];
        },
        observer: "__responsiveStepsChanged",
        sync: true
      },
      /**
       * When set to `true`, the component automatically creates and adjusts columns based on
       * the container's width. Columns have a fixed width defined by `columnWidth` and their
       * number increases up to the limit set by `maxColumns`. The component dynamically adjusts
       * the number of columns as the container size changes. When this mode is enabled,
       * `responsiveSteps` are ignored.
       *
       * By default, each field is placed on a new row. To organize fields into rows, there are
       * two options:
       *
       * 1. Use `<vaadin-form-row>` to explicitly group fields into rows.
       *
       * 2. Enable the `autoRows` property to automatically arrange fields in available columns,
       *    wrapping to a new row when necessary. `<br>` elements can be used to force a new row.
       *
       * The auto-responsive mode is disabled by default. To enable it for an individual instance,
       * use this property. Alternatively, if you want it to be enabled for all instances by default,
       * enable the `defaultAutoResponsiveFormLayout` feature flag before `<vaadin-form-layout>`
       * elements are added to the DOM:
       *
       * ```js
       * window.Vaadin.featureFlags.defaultAutoResponsiveFormLayout = true;
       * ```
       *
       * @attr {boolean} auto-responsive
       */
      autoResponsive: {
        type: Boolean,
        sync: true,
        value: () => {
          if (window.Vaadin && window.Vaadin.featureFlags && window.Vaadin.featureFlags.defaultAutoResponsiveFormLayout) {
            return true;
          }
          return false;
        },
        reflectToAttribute: true
      },
      /**
       * When `autoResponsive` is enabled, defines the width of each column.
       * The value must be defined in CSS length units, e.g. `100px`.
       *
       * If the column width isn't explicitly set, it defaults to `12em`
       * or `--vaadin-field-default-width` if that CSS property is defined.
       *
       * @attr {string} column-width
       */
      columnWidth: {
        type: String,
        sync: true
      },
      /**
       * When `autoResponsive` is enabled, defines the maximum number of columns
       * that the layout can create. The layout will create columns up to this
       * limit based on the available container width.
       *
       * The default value is `10`.
       *
       * @attr {number} max-columns
       */
      maxColumns: {
        type: Number,
        sync: true,
        value: 10
      },
      /**
       * When `autoResponsive` is enabled, defines the minimum number of columns
       * that the layout can create. The layout will create columns at least up
       * to this limit.
       *
       * The default value is `1`.
       *
       * @attr {number} min-columns
       */
      minColumns: {
        type: Number,
        sync: true,
        value: 1
      },
      /**
       * When enabled with `autoResponsive`, distributes fields across columns
       * by placing each field in the next available column and wrapping to
       * the next row when the current row is full. `<br>` elements can be
       * used to force a new row.
       *
       * The default value is `false`.
       *
       * @attr {boolean} auto-rows
       */
      autoRows: {
        type: Boolean,
        sync: true,
        value: false,
        reflectToAttribute: true
      },
      /**
       * When enabled with `autoResponsive`, `<vaadin-form-item>` prefers positioning
       * labels beside the fields. If the layout is too narrow to fit a single column
       * with a side label, the component will automatically switch labels to their
       * default position above the fields.
       *
       * The default value is `false`.
       *
       * To customize the label width and the gap between the label and the field,
       * use the following CSS properties:
       *
       * - `--vaadin-form-layout-label-width`
       * - `--vaadin-form-layout-label-spacing`
       *
       * @attr {boolean} labels-aside
       */
      labelsAside: {
        type: Boolean,
        sync: true,
        value: false,
        reflectToAttribute: true
      },
      /**
       * When `autoResponsive` is enabled, specifies whether the columns should expand
       * in width to evenly fill any remaining space after all columns have been created.
       *
       * The default value is `false`.
       *
       * @attr {boolean} expand-columns
       */
      expandColumns: {
        type: Boolean,
        sync: true,
        value: false,
        reflectToAttribute: true
      },
      /**
       * When `autoResponsive` is enabled, specifies whether fields should stretch
       * to take up all available space within columns. This setting also applies
       * to fields inside `<vaadin-form-item>` elements.
       *
       * The default value is `false`.
       *
       * @attr {boolean} expand-fields
       */
      expandFields: {
        type: Boolean,
        sync: true,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return [
      "__autoResponsiveLayoutPropsChanged(columnWidth, maxColumns, minColumns, autoRows, labelsAside, expandColumns, expandFields)",
      "__autoResponsiveChanged(autoResponsive)"
    ];
  }
  constructor() {
    super();
    this.__currentLayout;
    this.__autoResponsiveLayout = new AutoResponsiveLayout(this);
    this.__responsiveStepsLayout = new ResponsiveStepsLayout(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__currentLayout.connect();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__currentLayout.disconnect();
  }
  /** @protected */
  get slotStyles() {
    return [`${formLayoutSlotStyles}`.replace("vaadin-form-layout", this.localName)];
  }
  /** @protected */
  _updateLayout() {
    this.__currentLayout.updateLayout();
  }
  /** @private */
  __responsiveStepsChanged(responsiveSteps, oldResponsiveSteps) {
    try {
      this.__responsiveStepsLayout.setProps({ responsiveSteps });
    } catch (e) {
      if (oldResponsiveSteps && oldResponsiveSteps !== responsiveSteps) {
        console.warn(`${e.message} Using previously set 'responsiveSteps' instead.`);
        this.responsiveSteps = oldResponsiveSteps;
      } else {
        console.warn(`${e.message} Using default 'responsiveSteps' instead.`);
        this.responsiveSteps = [
          { minWidth: 0, columns: 1, labelsPosition: "top" },
          { minWidth: "20em", columns: 1 },
          { minWidth: "40em", columns: 2 }
        ];
      }
    }
  }
  /** @private */
  // eslint-disable-next-line @typescript-eslint/max-params
  __autoResponsiveLayoutPropsChanged(columnWidth, maxColumns, minColumns, autoRows, labelsAside, expandColumns, expandFields) {
    this.__autoResponsiveLayout.setProps({
      columnWidth,
      maxColumns,
      minColumns,
      autoRows,
      labelsAside,
      expandColumns,
      expandFields
    });
  }
  /** @private */
  __autoResponsiveChanged(autoResponsive) {
    if (this.__currentLayout) {
      this.__currentLayout.disconnect();
    }
    if (autoResponsive) {
      this.__currentLayout = this.__autoResponsiveLayout;
    } else {
      this.__currentLayout = this.__responsiveStepsLayout;
    }
    this.__currentLayout.connect();
  }
};

// node_modules/@vaadin/form-layout/src/vaadin-form-layout.js
var FormLayout = class extends FormLayoutMixin(ThemableMixin(ElementMixin(PolylitMixin(LitElement)))) {
  static get is() {
    return "vaadin-form-layout";
  }
  static get styles() {
    return formLayoutStyles;
  }
  /** @protected */
  render() {
    return html`
      <div id="layout">
        <slot id="slot"></slot>
      </div>
    `;
  }
};
defineCustomElement(FormLayout);

export {
  FormLayout
};
//# sourceMappingURL=chunk-UVWSZKWE.js.map
