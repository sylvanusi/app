{
  "version": 3,
  "sources": ["../../@vaadin/component-base/src/iron-list-core.js", "../../@vaadin/component-base/src/virtualizer-iron-list-adapter.js", "../../@vaadin/component-base/src/virtualizer.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport { animationFrame, idlePeriod, microTask } from './async.js';\nimport { Debouncer, enqueueDebouncer, flush } from './debounce.js';\n\nconst IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/u);\nconst IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nconst DEFAULT_PHYSICAL_COUNT = 3;\n\n/**\n * DO NOT EDIT THIS FILE!\n *\n * This file includes the iron-list scrolling engine copied from\n * https://github.com/PolymerElements/iron-list/blob/master/iron-list.js\n *\n * If something in the scrolling engine needs to be changed\n * for the virtualizer's purposes, override a function\n * in virtualizer-iron-list-adapter.js instead of changing it here.\n * If a function on this file is no longer needed, the code can be safely deleted.\n *\n * This will allow us to keep the iron-list code here as close to\n * the original as possible.\n */\nexport const ironList = {\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both\n   * directions.\n   */\n  _ratio: 0.5,\n\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n\n  /**\n   * This value is a cached value of `scrollTop` from the last `scroll` event.\n   */\n  _scrollPosition: 0,\n\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n\n  /**\n   * The height of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportHeight: 0,\n\n  /**\n   * The width of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportWidth: 0,\n\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!HTMLElement>}\n   */\n  _physicalItems: null,\n\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n\n  /**\n   * The max number of pages to render. One page is equivalent to the height of\n   * the list.\n   */\n  _maxPages: 2,\n\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    return this._physicalSize - this._viewportHeight;\n  },\n\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n\n  /**\n   * The largest n-th value for an item such that it can be rendered in\n   * `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    const virtualCount = this._virtualCount;\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n    this._virtualStartVal = val;\n  },\n\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val %= this._physicalCount;\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n    this._physicalStartVal = val;\n  },\n\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\n  },\n\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\n  },\n\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    let idx = this._firstVisibleIndexVal;\n    if (idx == null) {\n      let physicalOffset = this._physicalTop + this._scrollOffset;\n\n      idx =\n        this._iterateItems((pidx, vidx) => {\n          physicalOffset += this._getPhysicalSizeIncrement(pidx);\n\n          if (physicalOffset > this._scrollPosition) {\n            return vidx;\n          }\n        }) || 0;\n      this._firstVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    let idx = this._lastVisibleIndexVal;\n    if (idx == null) {\n      let physicalOffset = this._physicalTop + this._scrollOffset;\n      this._iterateItems((pidx, vidx) => {\n        if (physicalOffset < this._scrollBottom) {\n          idx = vidx;\n        }\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n      });\n\n      this._lastVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  get _scrollOffset() {\n    return this._scrollerPaddingTop + this.scrollOffset;\n  },\n\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler() {\n    const scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    let delta = scrollTop - this._scrollPosition;\n    const isScrollingDown = delta >= 0;\n    // Track the current scroll position.\n    this._scrollPosition = scrollTop;\n    // Clear indexes for first and last visible indexes.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n    // Random access.\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta -= this._scrollOffset;\n      const idxAdjustment = Math.round(delta / this._physicalAverage);\n      this._virtualStart += idxAdjustment;\n      this._physicalStart += idxAdjustment;\n      // Estimate new physical offset based on the virtual start index.\n      // adjusts the physical start position to stay in sync with the clamped\n      // virtual start index. It's critical not to let this value be\n      // more than the scroll position however, since that would result in\n      // the physical items not covering the viewport, and leading to\n      // _increasePoolIfNeeded to run away creating items to try to fill it.\n      this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition);\n      this._update();\n    } else if (this._physicalCount > 0) {\n      const reusables = this._getReusables(isScrollingDown);\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart += reusables.indexes.length;\n        this._physicalStart += reusables.indexes.length;\n      } else {\n        this._virtualStart -= reusables.indexes.length;\n        this._physicalStart -= reusables.indexes.length;\n      }\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), microTask);\n    }\n  },\n\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables(fromTop) {\n    let ith, offsetContent, physicalItemHeight;\n    const idxs = [];\n    const protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    const virtualStart = this._virtualStart;\n    const virtualEnd = this._virtualEnd;\n    const physicalCount = this._physicalCount;\n    let top = this._physicalTop + this._scrollOffset;\n    const bottom = this._physicalBottom + this._scrollOffset;\n    // This may be called outside of a scrollHandler, so use last cached position\n    const scrollTop = this._scrollPosition;\n    const scrollBottom = this._scrollBottom;\n\n    if (fromTop) {\n      ith = this._physicalStart;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd;\n      offsetContent = bottom - scrollBottom;\n    }\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent -= physicalItemHeight;\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\n        break;\n      }\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n        idxs.push(ith);\n        top += physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n        idxs.push(ith);\n        top -= physicalItemHeight;\n        ith = ith === 0 ? physicalCount - 1 : ith - 1;\n      }\n    }\n    return { indexes: idxs, physicalTop: top - this._scrollOffset };\n  },\n\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update(itemSet, movingUp) {\n    if ((itemSet && itemSet.length === 0) || this._physicalCount === 0) {\n      return;\n    }\n    this._assignModels(itemSet);\n    this._updateMetrics(itemSet);\n    // Adjust offset after measuring.\n    if (movingUp) {\n      while (movingUp.length) {\n        const idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n    this._positionItems();\n    this._updateScrollerSize();\n  },\n\n  _isClientFull() {\n    return (\n      this._scrollBottom !== 0 &&\n      this._physicalBottom - 1 >= this._scrollBottom &&\n      this._physicalTop <= this._scrollPosition\n    );\n  },\n\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded(count) {\n    const nextPhysicalCount = this._clamp(\n      this._physicalCount + count,\n      DEFAULT_PHYSICAL_COUNT,\n      this._virtualCount - this._virtualStart,\n    );\n    const delta = nextPhysicalCount - this._physicalCount;\n    let nextIncrease = Math.round(this._physicalCount * 0.5);\n\n    if (delta < 0) {\n      return;\n    }\n    if (delta > 0) {\n      const ts = window.performance.now();\n      // Concat arrays in place.\n      [].push.apply(this._physicalItems, this._createPool(delta));\n      // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't\n      // support it.\n      for (let i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n      this._physicalCount += delta;\n      // Update the physical start if it needs to preserve the model of the\n      // focused item. In this situation, the focused item is currently rendered\n      // and its model would have changed after increasing the pool if the\n      // physical start remained unchanged.\n      if (\n        this._physicalStart > this._physicalEnd &&\n        this._isIndexRendered(this._focusedVirtualIndex) &&\n        this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd\n      ) {\n        this._physicalStart += delta;\n      }\n      this._update();\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    }\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {\n      // Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, nextIncrease), microTask);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is\n      // optimal.\n      this._debounce(\n        '_increasePoolIfNeeded',\n        this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)),\n        idlePeriod,\n      );\n    }\n  },\n\n  /**\n   * Renders the a new list.\n   */\n  _render() {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n    if (this._physicalCount !== 0) {\n      const reusables = this._getReusables(true);\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart += reusables.indexes.length;\n      this._physicalStart += reusables.indexes.length;\n      this._update(reusables.indexes);\n      this._update();\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged(change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      if (!this._physicalItems) {\n        this._physicalItems = [];\n      }\n      if (!this._physicalSizes) {\n        this._physicalSizes = [];\n      }\n      this._physicalStart = 0;\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n      this._debounce('_render', this._render, animationFrame);\n    }\n  },\n\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical\n   * indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems(fn, itemSet) {\n    let pidx, vidx, rtn, i;\n\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx(pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\n  },\n\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems() {\n    this._adjustScrollPosition();\n\n    let y = this._physicalTop;\n\n    this._iterateItems((pidx) => {\n      this.translate3d(0, `${y}px`, 0, this._physicalItems[pidx]);\n      y += this._physicalSizes[pidx];\n    });\n  },\n\n  _getPhysicalSizeIncrement(pidx) {\n    return this._physicalSizes[pidx];\n  },\n\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition() {\n    const deltaHeight =\n      this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);\n    // Note: the delta can be positive or negative.\n    if (deltaHeight !== 0) {\n      this._physicalTop -= deltaHeight;\n      // This may be called outside of a scrollHandler, so use last cached position\n      const scrollTop = this._scrollPosition;\n      // Juking scroll position during interial scrolling on iOS is no bueno\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition(pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize(forceUpdate) {\n    const estScrollHeight =\n      this._physicalBottom +\n      Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;\n\n    this._estScrollHeight = estScrollHeight;\n\n    // Amortize height adjustment, so it won't trigger large repaints too often.\n    if (\n      forceUpdate ||\n      this._scrollHeight === 0 ||\n      this._scrollPosition >= estScrollHeight - this._physicalSize ||\n      Math.abs(estScrollHeight - this._scrollHeight) >= this._viewportHeight\n    ) {\n      this.$.items.style.height = `${estScrollHeight}px`;\n      this._scrollHeight = estScrollHeight;\n    }\n  },\n\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex(idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n    flush();\n    // Items should have been rendered prior scrolling to an index.\n    if (this._physicalCount === 0) {\n      return;\n    }\n    idx = this._clamp(idx, 0, this._virtualCount - 1);\n    // Update the virtual start only when needed.\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart = idx - 1;\n    }\n    this._assignModels();\n    this._updateMetrics();\n    // Estimate new physical offset.\n    this._physicalTop = this._virtualStart * this._physicalAverage;\n\n    let currentTopItem = this._physicalStart;\n    let currentVirtualItem = this._virtualStart;\n    let targetOffsetTop = 0;\n    const hiddenContentSize = this._hiddenContentSize;\n    // Scroll to the item as much as we can.\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop += this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem += 1;\n    }\n    this._updateScrollerSize(true);\n    this._positionItems();\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\n    this._increasePoolIfNeeded(0);\n    // Clear cached visible index.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage() {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler() {\n    this._debounce(\n      '_render',\n      () => {\n        // Clear cached visible index.\n        this._firstVisibleIndexVal = null;\n        this._lastVisibleIndexVal = null;\n        if (this._isVisible) {\n          this.updateViewportBoundaries();\n          // Reinstall the scroll event listener.\n          this.toggleScrollListener(true);\n          this._resetAverage();\n          this._render();\n        } else {\n          // Uninstall the scroll event listener.\n          this.toggleScrollListener(false);\n        }\n      },\n      animationFrame,\n    );\n  },\n\n  _isIndexRendered(idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n\n  _getPhysicalIndex(vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\n  },\n\n  _clamp(v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n\n  _debounce(name, cb, asyncModule) {\n    if (!this._debouncers) {\n      this._debouncers = {};\n    }\n    this._debouncers[name] = Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\n    enqueueDebouncer(this._debouncers[name]);\n  },\n};\n", "/**\n * @license\n * Copyright (c) 2021 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { animationFrame, microTask, timeOut } from './async.js';\nimport { isSafari } from './browser-utils.js';\nimport { Debouncer, flush } from './debounce.js';\nimport { ironList } from './iron-list-core.js';\n\n// Iron-list can by default handle sizes up to around 100000.\n// When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used\nconst MAX_VIRTUAL_COUNT = 100000;\nconst OFFSET_ADJUST_MIN_THRESHOLD = 1000;\n\nexport class IronListAdapter {\n  constructor({\n    createElements,\n    updateElement,\n    scrollTarget,\n    scrollContainer,\n    reorderElements,\n    elementsContainer,\n    __disableHeightPlaceholder,\n  }) {\n    this.isAttached = true;\n    this._vidxOffset = 0;\n    this.createElements = createElements;\n    this.updateElement = updateElement;\n    this.scrollTarget = scrollTarget;\n    this.scrollContainer = scrollContainer;\n    this.reorderElements = reorderElements;\n    this.elementsContainer = elementsContainer || scrollContainer;\n\n    // Internal option that disables the heavy height placeholder calculation\n    // (see __afterElementsUpdated) for components that always render virtual\n    // elements with a non-zero height. Not for public use.\n    this.__disableHeightPlaceholder = __disableHeightPlaceholder ?? false;\n\n    // Iron-list uses this value to determine how many pages of elements to render\n    this._maxPages = 1.3;\n\n    // Placeholder height (used for sizing elements that have intrinsic 0 height after update)\n    this.__placeholderHeight = 200;\n    // A queue of 10 previous element heights\n    this.__elementHeightQueue = Array(10);\n\n    this.timeouts = {\n      SCROLL_REORDER: 500,\n      PREVENT_OVERSCROLL: 500,\n      FIX_INVALID_ITEM_POSITIONING: 100,\n    };\n\n    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());\n\n    if (getComputedStyle(this.scrollTarget).overflow === 'visible') {\n      this.scrollTarget.style.overflow = 'auto';\n    }\n\n    if (getComputedStyle(this.scrollContainer).position === 'static') {\n      this.scrollContainer.style.position = 'relative';\n    }\n\n    this.__resizeObserver.observe(this.scrollTarget);\n    this.scrollTarget.addEventListener('scroll', () => this._scrollHandler());\n\n    const attachObserver = new ResizeObserver(([{ contentRect }]) => {\n      const isHidden = contentRect.width === 0 && contentRect.height === 0;\n      if (!isHidden && this.__scrollTargetHidden && this.scrollTarget.scrollTop !== this._scrollPosition) {\n        // When removing element from DOM, its scroll position is lost and\n        // virtualizer doesn't re-render when adding it to the DOM again.\n        // Restore scroll position when the scroll target becomes visible,\n        // which is the case e.g. when virtualizer is used inside a dialog.\n        this.scrollTarget.scrollTop = this._scrollPosition;\n      }\n\n      this.__scrollTargetHidden = isHidden;\n    });\n    attachObserver.observe(this.scrollTarget);\n\n    this._scrollLineHeight = this._getScrollLineHeight();\n\n    this.scrollTarget.addEventListener('virtualizer-element-focused', (e) => this.__onElementFocused(e));\n    this.elementsContainer.addEventListener('focusin', () => {\n      this.scrollTarget.dispatchEvent(\n        new CustomEvent('virtualizer-element-focused', { detail: { element: this.__getFocusedElement() } }),\n      );\n    });\n\n    if (this.reorderElements) {\n      // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.\n      // Need to defer reordering until the user lets go of the scroll bar handle.\n      this.scrollTarget.addEventListener('mousedown', () => {\n        this.__mouseDown = true;\n      });\n      this.scrollTarget.addEventListener('mouseup', () => {\n        this.__mouseDown = false;\n        if (this.__pendingReorder) {\n          this.__reorderElements();\n        }\n      });\n    }\n  }\n\n  get scrollOffset() {\n    return 0;\n  }\n\n  get adjustedFirstVisibleIndex() {\n    return this.firstVisibleIndex + this._vidxOffset;\n  }\n\n  get adjustedLastVisibleIndex() {\n    return this.lastVisibleIndex + this._vidxOffset;\n  }\n\n  get _maxVirtualIndexOffset() {\n    return this.size - this._virtualCount;\n  }\n\n  __hasPlaceholders() {\n    return this.__getVisibleElements().some((el) => el.__virtualizerPlaceholder);\n  }\n\n  scrollToIndex(index) {\n    if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {\n      return;\n    }\n    delete this.__pendingScrollToIndex;\n\n    if (this._physicalCount <= 3 /* iron-list-core.DEFAULT_PHYSICAL_COUNT */) {\n      // The condition here is a performance improvement to avoid an unnecessary\n      // re-render when the physical item pool is already covered.\n\n      // Finish rendering at the current scroll position before scrolling\n      this.flush();\n    }\n\n    index = this._clamp(index, 0, this.size - 1);\n\n    const visibleElementCount = this.__getVisibleElements().length;\n    let targetVirtualIndex = Math.floor((index / this.size) * this._virtualCount);\n    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {\n      targetVirtualIndex = this._virtualCount - (this.size - index);\n      this._vidxOffset = this._maxVirtualIndexOffset;\n    } else if (targetVirtualIndex < visibleElementCount) {\n      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {\n        targetVirtualIndex = index;\n        this._vidxOffset = 0;\n      } else {\n        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;\n        this._vidxOffset = index - targetVirtualIndex;\n      }\n    } else {\n      this._vidxOffset = index - targetVirtualIndex;\n    }\n\n    this.__skipNextVirtualIndexAdjust = true;\n    super.scrollToIndex(targetVirtualIndex);\n\n    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {\n      // Workaround an iron-list issue by manually adjusting the scroll position\n      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;\n    }\n    this._scrollHandler();\n\n    if (this.__hasPlaceholders()) {\n      // After rendering synchronously, there are still placeholders in the DOM.\n      // Try again after the next elements update.\n      this.__pendingScrollToIndex = index;\n    }\n  }\n\n  flush() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n\n    this._resizeHandler();\n    flush();\n    this._scrollHandler();\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.flush();\n    }\n    if (this.__scrollReorderDebouncer) {\n      this.__scrollReorderDebouncer.flush();\n    }\n    if (this.__debouncerWheelAnimationFrame) {\n      this.__debouncerWheelAnimationFrame.flush();\n    }\n  }\n\n  hostConnected() {\n    // Restore scroll position, which is reset when host is removed from DOM,\n    // since virtualizer doesn't re-render when adding it to the DOM again.\n    // If the scroll target isn't visible and its `offsetParent` is `null`, wait\n    // for the ResizeObserver to handle this case (hiding -> moving -> showing).\n    if (this.scrollTarget.offsetParent && this.scrollTarget.scrollTop !== this._scrollPosition) {\n      this.scrollTarget.scrollTop = this._scrollPosition;\n    }\n  }\n\n  update(startIndex = 0, endIndex = this.size - 1) {\n    const updatedElements = [];\n    this.__getVisibleElements().forEach((el) => {\n      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {\n        this.__updateElement(el, el.__virtualIndex, true);\n        updatedElements.push(el);\n      }\n    });\n\n    this.__afterElementsUpdated(updatedElements);\n  }\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics(itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    flush();\n\n    let newPhysicalSize = 0;\n    let oldPhysicalSize = 0;\n    const prevAvgCount = this._physicalAverageCount;\n    const prevPhysicalAvg = this._physicalAverage;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._iterateItems((pidx, vidx) => {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      const elementOldPhysicalSize = this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[pidx]));\n\n      if (this._physicalSizes[pidx] !== elementOldPhysicalSize) {\n        // Physical size changed, but resize observer may not catch it if the original size is restored quickly.\n        // See https://github.com/vaadin/web-components/issues/9077\n        this.__resizeObserver.unobserve(this._physicalItems[pidx]);\n        this.__resizeObserver.observe(this._physicalItems[pidx], { box: 'border-box' });\n      }\n\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n\n    this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n\n    // Update the average if it measured something.\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round(\n        (prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount,\n      );\n    }\n  }\n\n  __getBorderBoxHeight(el) {\n    const style = getComputedStyle(el);\n\n    const itemHeight = parseFloat(style.height) || 0;\n\n    if (style.boxSizing === 'border-box') {\n      return itemHeight;\n    }\n\n    const paddingBottom = parseFloat(style.paddingBottom) || 0;\n    const paddingTop = parseFloat(style.paddingTop) || 0;\n    const borderBottomWidth = parseFloat(style.borderBottomWidth) || 0;\n    const borderTopWidth = parseFloat(style.borderTopWidth) || 0;\n\n    return itemHeight + paddingBottom + paddingTop + borderBottomWidth + borderTopWidth;\n  }\n\n  __updateElement(el, index, forceSameIndexUpdates) {\n    // Clean up temporary placeholder sizing\n    if (el.__virtualizerPlaceholder) {\n      el.style.paddingTop = '';\n      el.style.opacity = '';\n      el.__virtualizerPlaceholder = false;\n    }\n\n    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {\n      this.updateElement(el, index);\n      el.__lastUpdatedIndex = index;\n    }\n  }\n\n  /**\n   * Called synchronously right after elements have been updated.\n   * This is a good place to do any post-update work.\n   *\n   * @param {!Array<!HTMLElement>} updatedElements\n   */\n  __afterElementsUpdated(updatedElements) {\n    if (!this.__disableHeightPlaceholder) {\n      updatedElements.forEach((el) => {\n        const elementHeight = el.offsetHeight;\n        if (elementHeight === 0) {\n          // If the elements have 0 height after update (for example due to lazy rendering),\n          // it results in iron-list requesting to create an unlimited count of elements.\n          // Assign a temporary placeholder sizing to elements that would otherwise end up having\n          // no height.\n          el.style.paddingTop = `${this.__placeholderHeight}px`;\n          el.style.opacity = '0';\n          el.__virtualizerPlaceholder = true;\n\n          // Manually schedule the resize handler to make sure the placeholder padding is\n          // cleared in case the resize observer never triggers.\n          this.__placeholderClearDebouncer = Debouncer.debounce(this.__placeholderClearDebouncer, animationFrame, () =>\n            this._resizeHandler(),\n          );\n        } else {\n          // Add element height to the queue\n          this.__elementHeightQueue.push(elementHeight);\n          this.__elementHeightQueue.shift();\n\n          // Calculate new placeholder height based on the average of the defined values in the\n          // element height queue\n          const filteredHeights = this.__elementHeightQueue.filter((h) => h !== undefined);\n          this.__placeholderHeight = Math.round(filteredHeights.reduce((a, b) => a + b, 0) / filteredHeights.length);\n        }\n      });\n    }\n\n    if (this.__pendingScrollToIndex !== undefined && !this.__hasPlaceholders()) {\n      this.scrollToIndex(this.__pendingScrollToIndex);\n    }\n  }\n\n  __getIndexScrollOffset(index) {\n    const element = this.__getVisibleElements().find((el) => el.__virtualIndex === index);\n    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;\n  }\n\n  get size() {\n    return this.__size;\n  }\n\n  set size(size) {\n    if (size === this.size) {\n      return;\n    }\n    // Cancel active debouncers\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.cancel();\n    }\n    if (this._debouncers && this._debouncers._increasePoolIfNeeded) {\n      // Avoid creating unnecessary elements on the following flush()\n      this._debouncers._increasePoolIfNeeded.cancel();\n    }\n\n    // Prevent element update while the scroll position is being restored\n    this.__preventElementUpdates = true;\n\n    // Record the scroll position before changing the size\n    let fvi; // First visible index\n    let fviOffsetBefore; // Scroll offset of the first visible index\n    if (size > 0) {\n      fvi = this.adjustedFirstVisibleIndex;\n      fviOffsetBefore = this.__getIndexScrollOffset(fvi);\n    }\n\n    // Change the size\n    this.__size = size;\n\n    this._itemsChanged({\n      path: 'items',\n    });\n    flush();\n\n    // Try to restore the scroll position if the new size is larger than 0\n    if (size > 0) {\n      fvi = Math.min(fvi, size - 1);\n      // Note, calling scrollToIndex also updates the virtual index offset,\n      // causing the virtualizer to add more items when size is increased,\n      // and remove exceeding items when size is decreased.\n      this.scrollToIndex(fvi);\n\n      const fviOffsetAfter = this.__getIndexScrollOffset(fvi);\n      if (fviOffsetBefore !== undefined && fviOffsetAfter !== undefined) {\n        this._scrollTop += fviOffsetBefore - fviOffsetAfter;\n      }\n    }\n\n    this.__preventElementUpdates = false;\n\n    // When reducing size while invisible, iron-list does not update items, so\n    // their hidden state is not updated and their __lastUpdatedIndex is not\n    // reset. In that case force an update here.\n    if (!this._isVisible) {\n      this._assignModels();\n    }\n\n    if (!this.elementsContainer.children.length) {\n      requestAnimationFrame(() => this._resizeHandler());\n    }\n\n    // Schedule and flush a resize handler\n    this._resizeHandler();\n    flush();\n    // Schedule an update to ensure item positions are correct after subsequent size changes\n    // Fix for https://github.com/vaadin/flow-components/issues/6269\n    this._debounce('_update', this._update, microTask);\n  }\n\n  /** @private */\n  get _scrollTop() {\n    return this.scrollTarget.scrollTop;\n  }\n\n  /** @private */\n  set _scrollTop(top) {\n    this.scrollTarget.scrollTop = top;\n  }\n\n  /** @private */\n  get items() {\n    return {\n      length: Math.min(this.size, MAX_VIRTUAL_COUNT),\n    };\n  }\n\n  /** @private */\n  get offsetHeight() {\n    return this.scrollTarget.offsetHeight;\n  }\n\n  /** @private */\n  get $() {\n    return {\n      items: this.scrollContainer,\n    };\n  }\n\n  /** @private */\n  updateViewportBoundaries() {\n    const styles = window.getComputedStyle(this.scrollTarget);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.elementsContainer.offsetWidth;\n    this._viewportHeight = this.scrollTarget.offsetHeight;\n    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;\n    if (this.grid) {\n      this._updateGridMetrics();\n    }\n  }\n\n  /** @private */\n  setAttribute() {}\n\n  /** @private */\n  _createPool(size) {\n    const physicalItems = this.createElements(size);\n    const fragment = document.createDocumentFragment();\n    physicalItems.forEach((el) => {\n      el.style.position = 'absolute';\n      fragment.appendChild(el);\n      this.__resizeObserver.observe(el, { box: 'border-box' });\n    });\n    this.elementsContainer.appendChild(fragment);\n    return physicalItems;\n  }\n\n  /** @private */\n  _assignModels(itemSet) {\n    const updatedElements = [];\n    this._iterateItems((pidx, vidx) => {\n      const el = this._physicalItems[pidx];\n      el.hidden = vidx >= this.size;\n      if (!el.hidden) {\n        el.__virtualIndex = vidx + (this._vidxOffset || 0);\n        this.__updateElement(el, el.__virtualIndex);\n        updatedElements.push(el);\n      } else {\n        delete el.__lastUpdatedIndex;\n      }\n    }, itemSet);\n\n    this.__afterElementsUpdated(updatedElements);\n  }\n\n  /** @private */\n  _isClientFull() {\n    // Workaround an issue in iron-list that can cause it to freeze on fast scroll\n    setTimeout(() => {\n      this.__clientFull = true;\n    });\n    return this.__clientFull || super._isClientFull();\n  }\n\n  /** @private */\n  translate3d(_x, y, _z, el) {\n    el.style.transform = `translateY(${y})`;\n  }\n\n  /** @private */\n  toggleScrollListener() {}\n\n  /** @private */\n  __getFocusedElement(visibleElements = this.__getVisibleElements()) {\n    return visibleElements.find(\n      (element) =>\n        element.contains(this.elementsContainer.getRootNode().activeElement) ||\n        element.contains(this.scrollTarget.getRootNode().activeElement),\n    );\n  }\n\n  /** @private */\n  __nextFocusableSiblingMissing(focusedElement, visibleElements) {\n    return (\n      // Check if focused element is the last visible DOM element\n      visibleElements.indexOf(focusedElement) === visibleElements.length - 1 &&\n      // ...while there are more items available\n      this.size > focusedElement.__virtualIndex + 1\n    );\n  }\n\n  /** @private */\n  __previousFocusableSiblingMissing(focusedElement, visibleElements) {\n    return (\n      // Check if focused element is the first visible DOM element\n      visibleElements.indexOf(focusedElement) === 0 &&\n      // ...while there are preceding items available\n      focusedElement.__virtualIndex > 0\n    );\n  }\n\n  /** @private */\n  __onElementFocused(e) {\n    if (!this.reorderElements) {\n      return;\n    }\n\n    const focusedElement = e.detail.element;\n    if (!focusedElement) {\n      return;\n    }\n\n    // User has tabbed to or within a virtualizer element.\n    // Check if a next or previous focusable sibling is missing while it should be there (so the user can continue tabbing).\n    // The focusable sibling might be missing due to the elements not yet being in the correct DOM order.\n    // First try flushing (which also flushes any active __scrollReorderDebouncer).\n    const visibleElements = this.__getVisibleElements();\n    if (\n      this.__previousFocusableSiblingMissing(focusedElement, visibleElements) ||\n      this.__nextFocusableSiblingMissing(focusedElement, visibleElements)\n    ) {\n      this.flush();\n    }\n\n    // If the focusable sibling is still missing (because the focused element is at the edge of the viewport and\n    // the virtual scrolling logic hasn't had the need to recycle elements), scroll the virtualizer just enough to\n    // have the focusable sibling inside the visible viewport to force the virtualizer to recycle.\n    const reorderedVisibleElements = this.__getVisibleElements();\n    if (this.__nextFocusableSiblingMissing(focusedElement, reorderedVisibleElements)) {\n      this._scrollTop +=\n        Math.ceil(focusedElement.getBoundingClientRect().bottom) -\n        Math.floor(this.scrollTarget.getBoundingClientRect().bottom - 1);\n      this.flush();\n    } else if (this.__previousFocusableSiblingMissing(focusedElement, reorderedVisibleElements)) {\n      this._scrollTop -=\n        Math.ceil(this.scrollTarget.getBoundingClientRect().top + 1) -\n        Math.floor(focusedElement.getBoundingClientRect().top);\n      this.flush();\n    }\n  }\n\n  _scrollHandler() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n\n    this._adjustVirtualIndexOffset(this._scrollTop - this._scrollPosition);\n    const delta = this._scrollTop - this._scrollPosition;\n\n    super._scrollHandler();\n\n    if (this._physicalCount !== 0) {\n      const isScrollingDown = delta >= 0;\n      const reusables = this._getReusables(!isScrollingDown);\n\n      if (reusables.indexes.length) {\n        // After running super._scrollHandler, fix internal properties to workaround an iron-list issue.\n        // See https://github.com/vaadin/web-components/issues/1691\n        this._physicalTop = reusables.physicalTop;\n\n        if (isScrollingDown) {\n          this._virtualStart -= reusables.indexes.length;\n          this._physicalStart -= reusables.indexes.length;\n        } else {\n          this._virtualStart += reusables.indexes.length;\n          this._physicalStart += reusables.indexes.length;\n        }\n        this._resizeHandler();\n      }\n    }\n\n    if (delta) {\n      // There was a change in scroll top. Schedule a check for invalid item positioning.\n      this.__fixInvalidItemPositioningDebouncer = Debouncer.debounce(\n        this.__fixInvalidItemPositioningDebouncer,\n        timeOut.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING),\n        () => this.__fixInvalidItemPositioning(),\n      );\n\n      if (!this.__overscrollDebouncer?.isActive()) {\n        this.scrollTarget.style.overscrollBehavior = 'none';\n      }\n\n      this.__overscrollDebouncer = Debouncer.debounce(\n        this.__overscrollDebouncer,\n        timeOut.after(this.timeouts.PREVENT_OVERSCROLL),\n        () => {\n          this.scrollTarget.style.overscrollBehavior = null;\n        },\n      );\n    }\n\n    if (this.reorderElements) {\n      this.__scrollReorderDebouncer = Debouncer.debounce(\n        this.__scrollReorderDebouncer,\n        timeOut.after(this.timeouts.SCROLL_REORDER),\n        () => this.__reorderElements(),\n      );\n    }\n\n    // If the first visible index is not 0 when scrolled to the top,\n    // scroll to index 0 to fix the issue.\n    if (this._scrollPosition === 0 && this.firstVisibleIndex !== 0 && Math.abs(delta) > 0) {\n      this.scrollToIndex(0);\n    }\n  }\n\n  /** @override */\n  _resizeHandler() {\n    super._resizeHandler();\n\n    // Fixes an issue where the new items are not created on scroll target resize when the scroll position is around the end.\n    // See https://github.com/vaadin/flow-components/issues/7307\n    const lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;\n    const emptySpace = this._physicalTop - this._scrollPosition;\n    if (lastIndexVisible && emptySpace > 0) {\n      const idxAdjustment = Math.ceil(emptySpace / this._physicalAverage);\n      this._virtualStart = Math.max(0, this._virtualStart - idxAdjustment);\n      this._physicalStart = Math.max(0, this._physicalStart - idxAdjustment);\n      // Scroll to end for smoother resize\n      super.scrollToIndex(this._virtualCount - 1);\n      this.scrollTarget.scrollTop = this.scrollTarget.scrollHeight - this.scrollTarget.clientHeight;\n    }\n  }\n\n  /**\n   * Work around an iron-list issue with invalid item positioning.\n   * See https://github.com/vaadin/flow-components/issues/4306\n   * @private\n   */\n  __fixInvalidItemPositioning() {\n    if (!this.scrollTarget.isConnected) {\n      return;\n    }\n\n    // Check if the first physical item element is below the top of the viewport\n    const physicalTopBelowTop = this._physicalTop > this._scrollTop;\n    // Check if the last physical item element is above the bottom of the viewport\n    const physicalBottomAboveBottom = this._physicalBottom < this._scrollBottom;\n\n    // Check if the first index is visible\n    const firstIndexVisible = this.adjustedFirstVisibleIndex === 0;\n    // Check if the last index is visible\n    const lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;\n\n    if ((physicalTopBelowTop && !firstIndexVisible) || (physicalBottomAboveBottom && !lastIndexVisible)) {\n      // Invalid state! Try to recover.\n\n      const isScrollingDown = physicalBottomAboveBottom;\n      // Set the \"_ratio\" property temporarily to 0 to make iron-list's _getReusables\n      // place all the free physical items on one side of the viewport.\n      const originalRatio = this._ratio;\n      this._ratio = 0;\n      // Fake a scroll change to make _scrollHandler place the physical items\n      // on the desired side.\n      this._scrollPosition = this._scrollTop + (isScrollingDown ? -1 : 1);\n      this._scrollHandler();\n      // Restore the original \"_ratio\" value.\n      this._ratio = originalRatio;\n    }\n  }\n\n  /**\n   * Increases the pool size.\n   * @override\n   */\n  _increasePoolIfNeeded(count) {\n    if (this._physicalCount > 2 && count) {\n      // The iron-list logic has already created some physical items and\n      // has decided to create more. Since each item creation round is\n      // expensive, let's try to create the remaining items in one go.\n\n      // Calculate the total item count that would be needed to fill the viewport\n      // plus the buffer assuming rest of the items to be of the average size\n      // of the items already created.\n      const totalItemCount = Math.ceil(this._optPhysicalSize / this._physicalAverage);\n      const missingItemCount = totalItemCount - this._physicalCount;\n      // Create the remaining items in one go. Use a maximum of 100 items\n      // as a safety measure.\n      super._increasePoolIfNeeded(Math.max(count, Math.min(100, missingItemCount)));\n    } else {\n      super._increasePoolIfNeeded(count);\n    }\n  }\n\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   * @override\n   */\n  get _optPhysicalSize() {\n    const optPhysicalSize = super._optPhysicalSize;\n    // No need to adjust\n    if (optPhysicalSize <= 0 || this.__hasPlaceholders()) {\n      return optPhysicalSize;\n    }\n    // Item height buffer accounts for the cases where some items are much larger than the average.\n    // This can lead to some items not being rendered and leaving empty space in the viewport.\n    // https://github.com/vaadin/flow-components/issues/6651\n    return optPhysicalSize + this.__getItemHeightBuffer();\n  }\n\n  /**\n   * Extra item height buffer used when calculating optimal physical size.\n   *\n   * The iron list core uses the optimal physical size when determining whether to increase the item pool.\n   * For the cases where some items are much larger than the average, the iron list core might not increase item pool.\n   * This can lead to the large item not being rendered.\n   *\n   * @returns {Number} - Extra item height buffer\n   * @private\n   */\n  __getItemHeightBuffer() {\n    // No need for a buffer with no items\n    if (this._physicalCount === 0) {\n      return 0;\n    }\n    // The regular buffer zone height for either top or bottom\n    const bufferZoneHeight = Math.ceil((this._viewportHeight * (this._maxPages - 1)) / 2);\n    // The maximum height of the currently rendered items\n    const maxItemHeight = Math.max(...this._physicalSizes);\n    // Only add buffer if the item is larger that the other items\n    if (maxItemHeight > Math.min(...this._physicalSizes)) {\n      // Add a buffer height since the large item can still be in the viewport and out of the original buffer\n      return Math.max(0, maxItemHeight - bufferZoneHeight);\n    }\n    return 0;\n  }\n\n  /**\n   * @returns {Number|undefined} - The browser's default font-size in pixels\n   * @private\n   */\n  _getScrollLineHeight() {\n    const el = document.createElement('div');\n    el.style.fontSize = 'initial';\n    el.style.display = 'none';\n    document.body.appendChild(el);\n    const fontSize = window.getComputedStyle(el).fontSize;\n    document.body.removeChild(el);\n    return fontSize ? window.parseInt(fontSize) : undefined;\n  }\n\n  __getVisibleElements() {\n    return Array.from(this.elementsContainer.children).filter((element) => !element.hidden);\n  }\n\n  /** @private */\n  __reorderElements() {\n    if (this.__mouseDown) {\n      this.__pendingReorder = true;\n      return;\n    }\n    this.__pendingReorder = false;\n\n    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);\n\n    // Which row to use as a target?\n    const visibleElements = this.__getVisibleElements();\n    const targetElement = this.__getFocusedElement(visibleElements) || visibleElements[0];\n    if (!targetElement) {\n      // All elements are hidden, don't reorder\n      return;\n    }\n\n    // Where the target row should be?\n    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;\n\n    // Reodrer the DOM elements to keep the target row at the target physical index\n    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;\n    if (delta > 0) {\n      for (let i = 0; i < delta; i++) {\n        this.elementsContainer.appendChild(visibleElements[i]);\n      }\n    } else if (delta < 0) {\n      for (let i = visibleElements.length + delta; i < visibleElements.length; i++) {\n        this.elementsContainer.insertBefore(visibleElements[i], visibleElements[0]);\n      }\n    }\n\n    // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear\n    // on Safari when using sticky positioning in case the scroll target is inside a flexbox.\n    // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)\n    if (isSafari) {\n      const { transform } = this.scrollTarget.style;\n      this.scrollTarget.style.transform = 'translateZ(0)';\n      setTimeout(() => {\n        this.scrollTarget.style.transform = transform;\n      });\n    }\n  }\n\n  /** @private */\n  _adjustVirtualIndexOffset(delta) {\n    const maxOffset = this._maxVirtualIndexOffset;\n\n    if (this._virtualCount >= this.size) {\n      this._vidxOffset = 0;\n    } else if (this.__skipNextVirtualIndexAdjust) {\n      this.__skipNextVirtualIndexAdjust = false;\n    } else if (Math.abs(delta) > 10000) {\n      // Process a large scroll position change\n      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.clientHeight);\n      this._vidxOffset = Math.round(scale * maxOffset);\n    } else {\n      // Make sure user can always swipe/wheel scroll to the start and end\n      const oldOffset = this._vidxOffset;\n      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;\n      const maxShift = 100;\n\n      // Near start\n      if (this._scrollTop === 0) {\n        this._vidxOffset = 0;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(0);\n        }\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n      }\n\n      // Near end\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n        this._vidxOffset = maxOffset;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this._virtualCount - 1);\n        }\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n      }\n    }\n  }\n}\n\nObject.setPrototypeOf(IronListAdapter.prototype, ironList);\n", "/**\n * @license\n * Copyright (c) 2000 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { IronListAdapter } from './virtualizer-iron-list-adapter.js';\n\nexport class Virtualizer {\n  /**\n   * @typedef {Object} VirtualizerConfig\n   * @property {Function} createElements Function that returns the given number of new elements\n   * @property {Function} updateElement Function that updates the element at a specific index\n   * @property {HTMLElement} scrollTarget Reference to the scrolling element\n   * @property {HTMLElement} scrollContainer Reference to a wrapper for the item elements (or a slot) inside the scrollTarget\n   * @property {HTMLElement | undefined} elementsContainer Reference to the container in which the item elements are placed, defaults to scrollContainer\n   * @property {boolean | undefined} reorderElements Determines whether the physical item elements should be kept in order in the DOM\n   * @param {VirtualizerConfig} config Configuration for the virtualizer\n   */\n  constructor(config) {\n    this.__adapter = new IronListAdapter(config);\n  }\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @return {number}\n   */\n  get firstVisibleIndex() {\n    return this.__adapter.adjustedFirstVisibleIndex;\n  }\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @return {number}\n   */\n  get lastVisibleIndex() {\n    return this.__adapter.adjustedLastVisibleIndex;\n  }\n\n  /**\n   * The size of the virtualizer\n   * @return {number | undefined} The size of the virtualizer\n   */\n  get size() {\n    return this.__adapter.size;\n  }\n\n  /**\n   * The size of the virtualizer\n   * @param {number} size The size of the virtualizer\n   */\n  set size(size) {\n    this.__adapter.size = size;\n  }\n\n  /**\n   * Scroll to a specific index in the virtual list\n   *\n   * @method scrollToIndex\n   * @param {number} index The index of the item\n   */\n  scrollToIndex(index) {\n    this.__adapter.scrollToIndex(index);\n  }\n\n  /**\n   * Requests the virtualizer to re-render the item elements on an index range, if currently in the DOM\n   *\n   * @method update\n   * @param {number | undefined} startIndex The start index of the range\n   * @param {number | undefined} endIndex The end index of the range\n   */\n  update(startIndex = 0, endIndex = this.size - 1) {\n    this.__adapter.update(startIndex, endIndex);\n  }\n\n  /**\n   * Flushes active asynchronous tasks so that the component and the DOM end up in a stable state\n   *\n   * @method flush\n   */\n  flush() {\n    this.__adapter.flush();\n  }\n\n  /**\n   * Notifies the virtualizer about its host element connected to the DOM.\n   *\n   * @method hostConnected\n   */\n  hostConnected() {\n    this.__adapter.hostConnected();\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
