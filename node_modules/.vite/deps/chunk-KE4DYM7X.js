import {
  ComboBoxDataProviderMixin,
  ComboBoxItemsMixin,
  comboBoxOverlayStyles,
  comboBoxStyles
} from "./chunk-IDX2ACNH.js";
import {
  ComboBoxItemMixin,
  ComboBoxOverlayMixin,
  ComboBoxScrollerMixin,
  comboBoxScrollerStyles
} from "./chunk-ZDU6TMZE.js";
import {
  InputControlMixin
} from "./chunk-ETYEORRM.js";
import {
  InputContainer,
  inputFieldShared
} from "./chunk-F6FMTQFS.js";
import {
  ComboBoxPlaceholder
} from "./chunk-KSMWKUVB.js";
import {
  itemStyles
} from "./chunk-WEJ2XI2Y.js";
import {
  ifDefined
} from "./chunk-OSWHV746.js";
import {
  OverlayMixin,
  overlayStyles
} from "./chunk-PFI4EOEJ.js";
import {
  ResizeMixin
} from "./chunk-J36B4EVN.js";
import {
  InputController
} from "./chunk-6KCLDTNY.js";
import {
  LabelledInputController
} from "./chunk-C63QNJWN.js";
import {
  announce
} from "./chunk-ME7RDPE7.js";
import {
  TooltipController
} from "./chunk-XFKQJ73Z.js";
import {
  SlotController
} from "./chunk-X5EEA4XV.js";
import {
  I18nMixin
} from "./chunk-WSKWP5BQ.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import {
  DirMixin
} from "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/multi-select-combo-box/src/styles/vaadin-multi-select-combo-box-chip-base-styles.js
var multiSelectComboBoxChipStyles = css`
  :host {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
    box-sizing: border-box;
    gap: var(--vaadin-chip-gap, 0);
    background: var(--vaadin-chip-background, var(--vaadin-background-container));
    color: var(--vaadin-chip-text-color, var(--vaadin-text-color));
    font-size: max(11px, var(--vaadin-chip-font-size, 0.875em));
    font-weight: var(--vaadin-chip-font-weight, 500);
    line-height: var(--vaadin-input-field-value-line-height, inherit);
    padding: 0 var(--vaadin-chip-padding, 0.3em);
    height: var(--vaadin-chip-height, calc(1lh / 0.875));
    border-radius: var(--vaadin-chip-border-radius, var(--vaadin-radius-m));
    border: var(--vaadin-chip-border-width, 1px) solid
      var(--vaadin-chip-border-color, var(--vaadin-border-color-secondary));
    cursor: default;
  }

  :host(:not([slot='overflow'])) {
    min-width: min(max-content, var(--vaadin-multi-select-combo-box-chip-min-width, 48px));
  }

  :host([focused]) {
    outline: var(--vaadin-focus-ring-width) solid var(--vaadin-focus-ring-color);
    outline-offset: calc(var(--vaadin-chip-border-width, 1px) * -1);
  }

  [part='label'] {
    overflow: hidden;
    text-overflow: ellipsis;
    margin-block: calc(var(--vaadin-chip-border-width, 1px) * -1);
  }

  [part='remove-button'] {
    flex: none;
    display: block;
    margin-inline-start: auto;
    margin-block: calc(var(--vaadin-chip-border-width, 1px) * -1);
    color: var(--vaadin-chip-remove-button-text-color, var(--vaadin-text-color-secondary));
    cursor: var(--vaadin-clickable-cursor);
    translate: 25%;
  }

  [part='remove-button']::before {
    content: '';
    display: block;
    width: var(--vaadin-icon-size, 1lh);
    height: var(--vaadin-icon-size, 1lh);
    background: currentColor;
    mask-image: var(--_vaadin-icon-cross);
  }

  :host([disabled]) {
    cursor: var(--vaadin-disabled-cursor);
  }

  :host([disabled]) [part='label'] {
    --vaadin-chip-text-color: var(--vaadin-text-color-disabled);
  }

  :host([hidden]),
  :host(:is([readonly], [disabled], [slot='overflow'])) [part='remove-button'] {
    display: none !important;
  }

  :host([slot='overflow']) {
    position: relative;
    margin-inline-start: 8px;
    min-width: 1.5em;
  }

  :host([slot='overflow'])::before,
  :host([slot='overflow'])::after {
    content: '';
    position: absolute;
    inset: calc(var(--vaadin-chip-border-width, 1px) * -1);
    border-inline-start: 2px solid var(--vaadin-chip-border-color, var(--vaadin-border-color-secondary));
    border-radius: inherit;
  }

  :host([slot='overflow'])::before {
    left: calc(-4px - var(--vaadin-chip-border-width, 1px));
  }

  :host([slot='overflow'])::after {
    left: calc(-8px - var(--vaadin-chip-border-width, 1px));
  }

  :host([count='2']) {
    margin-inline-start: 4px;
  }

  :host([count='1']) {
    margin-inline-start: 0;
  }

  :host([count='2'])::after,
  :host([count='1'])::before,
  :host([count='1'])::after {
    display: none;
  }

  @media (forced-colors: active) {
    :host {
      border: 1px solid !important;
    }

    [part='remove-button']::before {
      background: CanvasText;
    }
  }
`;

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-chip.js
var MultiSelectComboBoxChip = class extends ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))) {
  static get is() {
    return "vaadin-multi-select-combo-box-chip";
  }
  static get styles() {
    return multiSelectComboBoxChipStyles;
  }
  static get properties() {
    return {
      disabled: {
        type: Boolean,
        reflectToAttribute: true,
        sync: true
      },
      readonly: {
        type: Boolean,
        reflectToAttribute: true,
        sync: true
      },
      label: {
        type: String,
        sync: true
      },
      item: {
        type: Object
      }
    };
  }
  /** @protected */
  render() {
    return html`
      <div part="label">${this.label}</div>
      <div part="remove-button" @click="${this._onRemoveClick}"></div>
    `;
  }
  /** @private */
  _onRemoveClick(event) {
    event.stopPropagation();
    this.dispatchEvent(
      new CustomEvent("item-removed", {
        detail: {
          item: this.item
        },
        bubbles: true,
        composed: true
      })
    );
  }
};
defineCustomElement(MultiSelectComboBoxChip);

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-container.js
var MultiSelectComboBoxContainer = class extends InputContainer {
  static get is() {
    return "vaadin-multi-select-combo-box-container";
  }
  static get styles() {
    return [
      super.styles,
      css`
        #wrapper {
          display: flex;
          width: 100%;
          min-width: 0;
          gap: var(--_wrapper-gap);
          align-self: start;
        }

        :host([auto-expand-vertically]) #wrapper {
          flex-wrap: wrap;
        }
      `
    ];
  }
  static get properties() {
    return {
      /**
       * Set to true to not collapse selected items chips into the overflow
       * chip and instead always expand vertically, causing input field to
       * wrap into multiple lines when width is limited.
       * @attr {boolean} auto-expand-vertically
       */
      autoExpandVertically: {
        type: Boolean,
        reflectToAttribute: true
      }
    };
  }
  /** @protected */
  render() {
    return html`
      <div id="wrapper">
        <slot name="prefix"></slot>
        <slot></slot>
      </div>
      <slot name="suffix"></slot>
    `;
  }
};
defineCustomElement(MultiSelectComboBoxContainer);

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-item.js
var MultiSelectComboBoxItem = class extends ComboBoxItemMixin(
  ThemableMixin(DirMixin(PolylitMixin(LumoInjectionMixin(LitElement))))
) {
  static get is() {
    return "vaadin-multi-select-combo-box-item";
  }
  static get styles() {
    return itemStyles;
  }
  /** @protected */
  render() {
    return html`
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
};
defineCustomElement(MultiSelectComboBoxItem);

// node_modules/@vaadin/multi-select-combo-box/src/styles/vaadin-multi-select-combo-box-overlay-base-styles.js
var multiSelectComboBoxOverlayStyles = [
  comboBoxOverlayStyles,
  css`
    #overlay {
      width: var(
        --vaadin-multi-select-combo-box-overlay-width,
        var(--_vaadin-multi-select-combo-box-overlay-default-width, auto)
      );
    }
  `
];

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-overlay.js
var MultiSelectComboBoxOverlay = class extends ComboBoxOverlayMixin(
  OverlayMixin(DirMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement)))))
) {
  static get is() {
    return "vaadin-multi-select-combo-box-overlay";
  }
  static get styles() {
    return [overlayStyles, multiSelectComboBoxOverlayStyles];
  }
  /** @protected */
  render() {
    return html`
      <div part="overlay" id="overlay">
        <div part="loader"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
};
defineCustomElement(MultiSelectComboBoxOverlay);

// node_modules/@vaadin/multi-select-combo-box/src/styles/vaadin-multi-select-combo-box-scroller-base-styles.js
var multiSelectComboBoxScrollerStyles = comboBoxScrollerStyles;

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-scroller.js
var MultiSelectComboBoxScroller = class extends ComboBoxScrollerMixin(PolylitMixin(LitElement)) {
  static get is() {
    return "vaadin-multi-select-combo-box-scroller";
  }
  static get styles() {
    return multiSelectComboBoxScrollerStyles;
  }
  /** @protected */
  render() {
    return html`
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("aria-multiselectable", "true");
  }
  /**
   * @protected
   * @override
   */
  _isItemSelected(item, _selectedItem, itemIdPath) {
    if (item instanceof ComboBoxPlaceholder) {
      return false;
    }
    if (this.owner.readonly) {
      return false;
    }
    return this.owner._findIndex(item, this.owner.selectedItems, itemIdPath) > -1;
  }
  /**
   * @param {HTMLElement} el
   * @param {number} index
   * @protected
   * @override
   */
  _updateElement(el, index) {
    super._updateElement(el, index);
    el.toggleAttribute("readonly", this.owner.readonly);
  }
};
defineCustomElement(MultiSelectComboBoxScroller);

// node_modules/@vaadin/multi-select-combo-box/src/styles/vaadin-multi-select-combo-box-base-styles.js
var multiSelectComboBoxStyles = [
  comboBoxStyles,
  css`
    :host {
      max-width: 100%;
      --_input-min-width: var(--vaadin-multi-select-combo-box-input-min-width, 4rem);
      --_chip-min-width: var(--vaadin-multi-select-combo-box-chip-min-width, 48px);
      --_wrapper-gap: var(--vaadin-multi-select-combo-box-chips-gap, 2px);
    }

    #chips {
      display: flex;
      align-items: center;
      gap: var(--vaadin-multi-select-combo-box-chips-gap, 2px);
    }

    ::slotted(input) {
      box-sizing: border-box;
      flex: 1 0 var(--_input-min-width);
    }

    ::slotted([slot='chip']),
    ::slotted([slot='overflow']) {
      flex: 0 1 auto;
    }

    ::slotted([slot='chip']) {
      overflow: hidden;
    }

    :host(:is([readonly], [disabled])) ::slotted(input) {
      flex-grow: 0;
      flex-basis: 0;
      padding: 0;
    }

    :host([readonly]:not([disabled])) [part~='toggle-button'] {
      display: block;
      color: var(--vaadin-input-field-button-text-color, var(--vaadin-text-color-secondary));
    }

    :host([readonly]:not([disabled])) [part$='button'] {
      cursor: var(--vaadin-clickable-cursor);
    }

    :host([auto-expand-vertically]) #chips {
      display: contents;
    }

    :host([auto-expand-horizontally]) {
      --vaadin-field-default-width: auto;
    }
  `
];

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-mixin.js
var DEFAULT_I18N = {
  cleared: "Selection cleared",
  focused: "focused. Press Backspace to remove",
  selected: "added to selection",
  deselected: "removed from selection",
  total: "{count} items selected"
};
var MultiSelectComboBoxMixin = (superClass) => class MultiSelectComboBoxMixinClass extends I18nMixin(
  DEFAULT_I18N,
  ComboBoxDataProviderMixin(ComboBoxItemsMixin(InputControlMixin(ResizeMixin(superClass))))
) {
  static get properties() {
    return {
      /**
       * Set to true to auto expand horizontally, causing input field to
       * grow until max width is reached.
       * @attr {boolean} auto-expand-horizontally
       */
      autoExpandHorizontally: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Set to true to not collapse selected items chips into the overflow
       * chip and instead always expand vertically, causing input field to
       * wrap into multiple lines when width is limited.
       * @attr {boolean} auto-expand-vertically
       */
      autoExpandVertically: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * A function used to generate CSS class names for dropdown
       * items and selected chips based on the item. The return
       * value should be the generated class name as a string, or
       * multiple class names separated by whitespace characters.
       */
      itemClassNameGenerator: {
        type: Object,
        sync: true
      },
      /**
       * Path for the id of the item, used to detect whether the item is selected.
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        sync: true
      },
      /**
       * When true, filter string isn't cleared after selecting an item.
       */
      keepFilter: {
        type: Boolean,
        value: false
      },
      /**
       * True when loading items from the data provider, false otherwise.
       */
      loading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * When present, it specifies that the field is read-only.
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * The list of selected items.
       * Note: modifying the selected items creates a new array each time.
       */
      selectedItems: {
        type: Array,
        value: () => [],
        notify: true,
        sync: true
      },
      /**
       * When true, the user can input a value that is not present in the items list.
       * @attr {boolean} allow-custom-value
       */
      allowCustomValue: {
        type: Boolean,
        value: false
      },
      /**
       * A hint to the user of what can be entered in the control.
       * The placeholder will be only displayed in the case when
       * there is no item selected.
       */
      placeholder: {
        type: String,
        observer: "_placeholderChanged",
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The `<vaadin-multi-select-combo-box-item>` internal container DOM element.
       * - `comboBox` The reference to the `<vaadin-multi-select-combo-box>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       */
      renderer: {
        type: Function,
        sync: true
      },
      /**
       * Set to true to group selected items at the top of the overlay.
       * @attr {boolean} selected-items-on-top
       */
      selectedItemsOnTop: {
        type: Boolean,
        value: false,
        sync: true
      },
      /** @private */
      value: {
        type: String
      },
      /** @private */
      _overflowItems: {
        type: Array,
        value: () => [],
        sync: true
      },
      /** @private */
      _focusedChipIndex: {
        type: Number,
        value: -1,
        observer: "_focusedChipIndexChanged"
      },
      /** @private */
      _lastFilter: {
        type: String,
        sync: true
      },
      /** @private */
      _topGroup: {
        type: Array,
        observer: "_topGroupChanged",
        sync: true
      },
      /** @private */
      _inputField: {
        type: Object
      }
    };
  }
  static get observers() {
    return [
      "_selectedItemsChanged(selectedItems)",
      "__openedOrItemsChanged(opened, _dropdownItems, loading, __keepOverlayOpened)",
      "__updateOverflowChip(_overflow, _overflowItems, disabled, readonly)",
      "__updateScroller(opened, _dropdownItems, _focusedIndex, _theme)",
      "__updateTopGroup(selectedItemsOnTop, selectedItems, opened)"
    ];
  }
  /**
   * The object used to localize this component. To change the default
   * localization, replace this with an object that provides all properties, or
   * just the individual properties you want to change.
   *
   * The object has the following JSON structure and default values:
   * ```js
   * {
   *   // Screen reader announcement on clear button click.
   *   cleared: 'Selection cleared',
   *   // Screen reader announcement when a chip is focused.
   *   focused: ' focused. Press Backspace to remove',
   *   // Screen reader announcement when item is selected.
   *   selected: 'added to selection',
   *   // Screen reader announcement when item is deselected.
   *   deselected: 'removed from selection',
   *   // Screen reader announcement of the selected items count.
   *   // {count} is replaced with the actual count of items.
   *   total: '{count} items selected',
   * }
   * ```
   * @return {!MultiSelectComboBoxI18n}
   */
  get i18n() {
    return super.i18n;
  }
  set i18n(value) {
    super.i18n = value;
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      ...super.slotStyles,
      `
        ${tag}[has-value] input::placeholder {
          color: transparent !important;
          forced-color-adjust: none;
        }
      `
    ];
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  get _chips() {
    return [...this.querySelectorAll('[slot="chip"]')];
  }
  /**
   * Override a getter from `InputMixin` to compute
   * the presence of value based on `selectedItems`.
   *
   * @protected
   * @override
   */
  get _hasValue() {
    return this.selectedItems && this.selectedItems.length > 0;
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-multi-select-combo-box";
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this._tooltipController.setShouldShow((target) => !target.opened);
    this._toggleElement = this.$.toggleButton;
    this._inputField = this.shadowRoot.querySelector('[part="input-field"]');
    this._overflowController = new SlotController(this, "overflow", "vaadin-multi-select-combo-box-chip", {
      initializer: (chip) => {
        chip.addEventListener("mousedown", (e) => this._preventBlur(e));
        this._overflow = chip;
      }
    });
    this.addController(this._overflowController);
  }
  /** @protected */
  updated(props) {
    super.updated(props);
    ["loading", "itemIdPath", "itemClassNameGenerator", "renderer"].forEach((prop) => {
      if (props.has(prop)) {
        this._scroller[prop] = this[prop];
      }
    });
    if (props.has("selectedItems") && this.opened) {
      this.$.overlay._updateOverlayWidth();
    }
    const chipProps = [
      "autoExpandHorizontally",
      "autoExpandVertically",
      "disabled",
      "readonly",
      "clearButtonVisible",
      "itemClassNameGenerator"
    ];
    if (chipProps.some((prop) => props.has(prop))) {
      this.__updateChips();
    }
    if (props.has("readonly")) {
      this._setDropdownItems(this.filteredItems);
      if (this.dataProvider) {
        this.clearCache();
      }
    }
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any).
   * @return {boolean}
   */
  checkValidity() {
    return this.required && !this.readonly ? this._hasValue : true;
  }
  /**
   * Opens the dropdown list.
   * @override
   */
  open() {
    if (!this.disabled && !(this.readonly && this.selectedItems.length === 0)) {
      this.opened = true;
    }
  }
  /**
   * Clears the selected items.
   */
  clear() {
    this.__updateSelection([]);
    announce(this.__effectiveI18n.cleared);
  }
  /** @private */
  __syncTopGroup() {
    this._topGroup = this.selectedItemsOnTop ? [...this.selectedItems] : [];
  }
  /**
   * Clears the cached pages and reloads data from data provider when needed.
   * @override
   */
  clearCache() {
    if (this.readonly) {
      return;
    }
    super.clearCache();
    this.__syncTopGroup();
  }
  /**
   * @private
   * @override
   */
  _itemsChanged(items, oldItems) {
    super._itemsChanged(items, oldItems);
    this.__syncTopGroup();
  }
  /**
   * Requests an update for the content of items.
   * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this._scroller) {
      return;
    }
    this._scroller.requestContentUpdate();
    this._getItemElements().forEach((item) => {
      item.requestContentUpdate();
    });
  }
  /**
   * Override method from `ComboBoxBaseMixin` to implement clearing logic.
   * @protected
   * @override
   */
  _onClearAction() {
    this.clear();
  }
  /**
   * Override method from `ComboBoxBaseMixin`
   * to commit value on overlay closing.
   * @protected
   * @override
   */
  _onClosed() {
    this._ignoreCommitValue = true;
    if (!this.loading || this.allowCustomValue) {
      this._commitValue();
    }
  }
  /** @private */
  __updateScroller(opened, items, focusedIndex, theme) {
    if (opened) {
      this._scroller.style.maxHeight = getComputedStyle(this).getPropertyValue(`--${this._tagNamePrefix}-overlay-max-height`) || "65vh";
    }
    this._scroller.setProperties({
      items: opened ? items : [],
      opened,
      focusedIndex,
      theme
    });
  }
  /** @private */
  __openedOrItemsChanged(opened, items, loading, keepOverlayOpened) {
    this._overlayOpened = opened && (keepOverlayOpened || loading || !!(items && items.length));
  }
  /**
   * @protected
   */
  _closeOrCommit() {
    if (!this.opened) {
      this._commitValue();
    } else {
      this.close();
    }
  }
  /**
   * @protected
   * @override
   */
  _commitValue() {
    this._lastFilter = this.filter;
    if (this._ignoreCommitValue) {
      this._inputElementValue = "";
      this._focusedIndex = -1;
      this._ignoreCommitValue = false;
    } else {
      this.__commitUserInput();
    }
    if (!this.keepFilter || !this.opened) {
      this.filter = "";
    }
  }
  /** @private */
  __commitUserInput() {
    if (this._focusedIndex > -1) {
      const focusedItem = this._dropdownItems[this._focusedIndex];
      this.__selectItem(focusedItem);
    } else if (this._inputElementValue) {
      const items = [...this._dropdownItems];
      const itemMatchingInputValue = items[this.__getItemIndexByLabel(items, this._inputElementValue)];
      if (this.allowCustomValue && !itemMatchingInputValue) {
        const customValue = this._inputElementValue;
        this._lastCustomValue = customValue;
        this.__clearInternalValue(true);
        this.dispatchEvent(
          new CustomEvent("custom-value-set", {
            detail: customValue,
            composed: true,
            bubbles: true
          })
        );
      } else if (!this.allowCustomValue && !this.opened && itemMatchingInputValue) {
        this.__selectItem(itemMatchingInputValue);
      } else {
        this._inputElementValue = "";
      }
    }
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   */
  _setFocused(focused) {
    if (!focused) {
      this._ignoreCommitValue = true;
    }
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._focusedChipIndex = -1;
      this._requestValidation();
    }
    if (!focused && this.readonly && !this._closeOnBlurIsPrevented) {
      this.close();
    }
  }
  /**
   * Implement callback from `ResizeMixin` to update chips.
   * @protected
   * @override
   */
  _onResize() {
    this.__updateChips();
  }
  /**
   * Override method from `DelegateStateMixin` to set required state
   * using `aria-required` attribute instead of `required`, in order
   * to prevent screen readers from announcing "invalid entry".
   * @protected
   * @override
   */
  _delegateAttribute(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "required") {
      this._delegateAttribute("aria-required", value ? "true" : false);
      return;
    }
    super._delegateAttribute(name, value);
  }
  /** @private */
  _placeholderChanged(placeholder) {
    const tmpPlaceholder = this.__tmpA11yPlaceholder;
    if (tmpPlaceholder !== placeholder) {
      this.__savedPlaceholder = placeholder;
      if (tmpPlaceholder) {
        this.placeholder = tmpPlaceholder;
      }
    }
  }
  /** @private */
  _selectedItemsChanged(selectedItems) {
    this._toggleHasValue(this._hasValue);
    if (this._hasValue) {
      const tmpPlaceholder = this._mergeItemLabels(selectedItems);
      if (this.__tmpA11yPlaceholder === void 0) {
        this.__savedPlaceholder = this.placeholder;
      }
      this.__tmpA11yPlaceholder = tmpPlaceholder;
      this.placeholder = tmpPlaceholder;
    } else if (this.__tmpA11yPlaceholder !== void 0) {
      delete this.__tmpA11yPlaceholder;
      this.placeholder = this.__savedPlaceholder;
    }
    this.__updateChips();
    this.requestContentUpdate();
  }
  /** @private */
  _topGroupChanged(topGroup) {
    if (topGroup) {
      this._setDropdownItems(this.filteredItems);
    }
  }
  /**
   * Override method from `ComboBoxBaseMixin` to handle valid value.
   * @protected
   * @override
   */
  _hasValidInputValue() {
    const hasInvalidOption = this._focusedIndex < 0 && this._inputElementValue !== "";
    return this.allowCustomValue || !hasInvalidOption;
  }
  /**
   * Override method inherited from the combo-box
   * to not request data provider when read-only.
   *
   * @protected
   * @override
   */
  _shouldFetchData() {
    if (this.readonly) {
      return false;
    }
    return super._shouldFetchData();
  }
  /**
   * Override combo-box method to group selected
   * items at the top of the overlay.
   *
   * @protected
   * @override
   */
  _setDropdownItems(items) {
    if (this.readonly) {
      this.__setDropdownItems(this.selectedItems);
      return;
    }
    if (this.filter || !this.selectedItemsOnTop) {
      this.__setDropdownItems(items);
      return;
    }
    if (items && items.length && this._topGroup && this._topGroup.length) {
      const filteredItems = items.filter((item) => this._findIndex(item, this._topGroup, this.itemIdPath) === -1);
      this.__setDropdownItems(this._topGroup.concat(filteredItems));
      return;
    }
    this.__setDropdownItems(items);
  }
  /** @private */
  __setDropdownItems(newItems) {
    const oldItems = this._dropdownItems;
    this._dropdownItems = newItems;
    const focusedItem = oldItems ? oldItems[this._focusedIndex] : null;
    const focusedItemIndex = this.__getItemIndexByValue(newItems, this._getItemValue(focusedItem));
    if (focusedItemIndex > -1) {
      this._focusedIndex = focusedItemIndex;
    } else {
      this._focusedIndex = this.__getItemIndexByLabel(newItems, this.filter);
    }
  }
  /** @private */
  _mergeItemLabels(items) {
    return items.map((item) => this._getItemLabel(item)).join(", ");
  }
  /** @private */
  _findIndex(item, selectedItems, itemIdPath) {
    if (itemIdPath && item) {
      for (let index = 0; index < selectedItems.length; index++) {
        if (selectedItems[index] && selectedItems[index][itemIdPath] === item[itemIdPath]) {
          return index;
        }
      }
      return -1;
    }
    return selectedItems.indexOf(item);
  }
  /**
   * Clear the internal combo box value and filter. Filter will not be cleared
   * when the `keepFilter` option is enabled. Using `force` can enforce clearing
   * the filter.
   * @param {boolean} force overrides the keepFilter option
   * @private
   */
  __clearInternalValue(force = false) {
    if (!this.keepFilter || force) {
      this.filter = "";
      this._inputElementValue = "";
    } else {
      this._inputElementValue = this.filter;
    }
  }
  /** @private */
  __announceItem(itemLabel, isSelected, itemCount) {
    const state = isSelected ? "selected" : "deselected";
    const total = this.__effectiveI18n.total.replace("{count}", itemCount || 0);
    announce(`${itemLabel} ${this.__effectiveI18n[state]} ${total}`);
  }
  /** @private */
  __removeItem(item) {
    const itemsCopy = [...this.selectedItems];
    itemsCopy.splice(itemsCopy.indexOf(item), 1);
    this.__updateSelection(itemsCopy);
    const itemLabel = this._getItemLabel(item);
    this.__announceItem(itemLabel, false, itemsCopy.length);
  }
  /** @private */
  __selectItem(item) {
    const itemsCopy = [...this.selectedItems];
    const index = this._findIndex(item, itemsCopy, this.itemIdPath);
    const itemLabel = this._getItemLabel(item);
    let isSelected = false;
    if (index !== -1) {
      const lastFilter = this._lastFilter;
      if (lastFilter && lastFilter.toLowerCase() === itemLabel.toLowerCase()) {
        this.__clearInternalValue();
        return;
      }
      itemsCopy.splice(index, 1);
    } else {
      itemsCopy.push(item);
      isSelected = true;
    }
    this.__updateSelection(itemsCopy);
    this.__clearInternalValue();
    this.__announceItem(itemLabel, isSelected, itemsCopy.length);
  }
  /** @private */
  __updateSelection(selectedItems) {
    this.selectedItems = selectedItems;
    this._requestValidation();
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  /** @private */
  __updateTopGroup(selectedItemsOnTop, selectedItems, opened) {
    if (!selectedItemsOnTop) {
      this._topGroup = [];
    } else if (!opened || this.__needToSyncTopGroup()) {
      this._topGroup = [...selectedItems];
    }
  }
  /** @private */
  __needToSyncTopGroup() {
    if (!this.itemIdPath) {
      return false;
    }
    return this._topGroup && this._topGroup.some((item) => {
      const selectedItem = this.selectedItems[this._findIndex(item, this.selectedItems, this.itemIdPath)];
      return selectedItem && item !== selectedItem;
    });
  }
  /** @private */
  __createChip(item) {
    const chip = document.createElement("vaadin-multi-select-combo-box-chip");
    chip.setAttribute("slot", "chip");
    chip.item = item;
    chip.disabled = this.disabled;
    chip.readonly = this.readonly;
    const label = this._getItemLabel(item);
    chip.label = label;
    chip.setAttribute("title", label);
    if (typeof this.itemClassNameGenerator === "function") {
      chip.className = this.itemClassNameGenerator(item);
    }
    chip.addEventListener("item-removed", (e) => this._onItemRemoved(e));
    chip.addEventListener("mousedown", (e) => this._preventBlur(e));
    return chip;
  }
  /** @private */
  __getOverflowWidth() {
    const chip = this._overflow;
    chip.style.visibility = "hidden";
    chip.removeAttribute("hidden");
    const count = chip.getAttribute("count");
    chip.setAttribute("count", "99");
    const overflowStyle = getComputedStyle(chip);
    const overflowWidth = chip.clientWidth + parseInt(overflowStyle.marginInlineStart);
    chip.setAttribute("count", count);
    chip.setAttribute("hidden", "");
    chip.style.visibility = "";
    return overflowWidth;
  }
  /** @private */
  __updateChips() {
    if (!this._inputField || !this.inputElement) {
      return;
    }
    this._chips.forEach((chip) => {
      chip.remove();
    });
    const items = [...this.selectedItems];
    const totalWidth = this._inputField.$.wrapper.clientWidth;
    const inputWidth = parseInt(getComputedStyle(this.inputElement).flexBasis);
    let remainingWidth = totalWidth - inputWidth;
    if (items.length > 1) {
      remainingWidth -= this.__getOverflowWidth();
    }
    const chipMinWidth = parseInt(getComputedStyle(this).getPropertyValue("--_chip-min-width"));
    if (this.autoExpandHorizontally) {
      const chips = [];
      for (let i = items.length - 1, refNode = null; i >= 0; i--) {
        const chip = this.__createChip(items[i]);
        this.insertBefore(chip, refNode);
        refNode = chip;
        chips.unshift(chip);
      }
      const overflowItems = [];
      const availableWidth = this._inputField.$.wrapper.clientWidth - this.$.chips.clientWidth;
      if (!this.autoExpandVertically && availableWidth < inputWidth) {
        while (chips.length > 1) {
          const lastChip = chips.pop();
          lastChip.remove();
          overflowItems.unshift(items.pop());
          const neededWidth = overflowItems.length > 0 ? inputWidth + this.__getOverflowWidth() : inputWidth;
          if (this._inputField.$.wrapper.clientWidth - this.$.chips.clientWidth >= neededWidth) {
            break;
          }
        }
        if (chips.length === 1) {
          chips[0].style.maxWidth = `${Math.max(chipMinWidth, remainingWidth)}px`;
        }
      }
      this._overflowItems = overflowItems;
      return;
    }
    for (let i = items.length - 1, refNode = null; i >= 0; i--) {
      const chip = this.__createChip(items[i]);
      this.insertBefore(chip, refNode);
      if (!this.autoExpandVertically) {
        if (this.$.chips.clientWidth > remainingWidth) {
          if (remainingWidth < chipMinWidth || refNode !== null) {
            chip.remove();
            break;
          }
        }
        chip.style.maxWidth = `${remainingWidth}px`;
      }
      items.pop();
      refNode = chip;
    }
    this._overflowItems = items;
  }
  /** @private */
  __updateOverflowChip(overflow, items, disabled, readonly) {
    if (overflow) {
      const count = items.length;
      overflow.label = `${count}`;
      overflow.setAttribute("count", `${count}`);
      overflow.setAttribute("title", this._mergeItemLabels(items));
      overflow.toggleAttribute("hidden", count === 0);
      overflow.disabled = disabled;
      overflow.readonly = readonly;
    }
  }
  /**
   * Override method from `ComboBoxBaseMixin` to deselect
   * dropdown item by requesting content update on clear.
   * @param {Event} event
   * @protected
   */
  _onClearButtonClick(event) {
    event.stopPropagation();
    super._onClearButtonClick(event);
    if (this.opened) {
      this.requestContentUpdate();
    }
  }
  /**
   * Override an event listener from `InputControlMixin` to
   * stop the change event re-targeted from the input.
   *
   * @param {!Event} event
   * @protected
   * @override
   */
  _onChange(event) {
    event.stopPropagation();
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (this.readonly) {
      event.stopPropagation();
      if (this.opened) {
        this.close();
      }
      return;
    }
    if (this.clearButtonVisible && !this.opened && this.selectedItems && this.selectedItems.length) {
      event.stopPropagation();
      this.selectedItems = [];
    }
    super._onEscape(event);
  }
  /**
   * Override method from `ComboBoxBaseMixin` to handle Escape pres.
   * @protected
   * @override
   */
  _onEscapeCancel() {
    this._closeOrCommit();
  }
  /**
   * Override an event listener from `KeyboardMixin` to keep
   * overlay open when item is selected or unselected.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onEnter(event) {
    if (this.opened) {
      event.preventDefault();
      event.stopPropagation();
      if (this.readonly) {
        this.close();
      } else if (this._hasValidInputValue()) {
        const focusedItem = this._dropdownItems[this._focusedIndex];
        this._commitValue();
        this._focusedIndex = this._dropdownItems.indexOf(focusedItem);
      }
      return;
    }
    super._onEnter(event);
  }
  /**
   * Override method inherited from the combo-box
   * to not update focused item when readonly.
   * @protected
   * @override
   */
  _onArrowDown() {
    if (!this.readonly) {
      super._onArrowDown();
    } else if (!this.opened) {
      this.open();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not update focused item when readonly.
   * @protected
   * @override
   */
  _onArrowUp() {
    if (!this.readonly) {
      super._onArrowUp();
    } else if (!this.opened) {
      this.open();
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    const chips = this._chips;
    if (!this.readonly && chips.length > 0) {
      switch (event.key) {
        case "Backspace":
          this._onBackSpace(chips);
          break;
        case "ArrowLeft":
          this._onArrowLeft(chips, event);
          break;
        case "ArrowRight":
          this._onArrowRight(chips, event);
          break;
        default:
          this._focusedChipIndex = -1;
          break;
      }
    }
  }
  /** @private */
  _onArrowLeft(chips, event) {
    if (this.inputElement.selectionStart !== 0) {
      return;
    }
    const idx = this._focusedChipIndex;
    if (idx !== -1) {
      event.preventDefault();
    }
    let newIdx;
    if (!this.__isRTL) {
      if (idx === -1) {
        newIdx = chips.length - 1;
      } else if (idx > 0) {
        newIdx = idx - 1;
      }
    } else if (idx === chips.length - 1) {
      newIdx = -1;
    } else if (idx > -1) {
      newIdx = idx + 1;
    }
    if (newIdx !== void 0) {
      this._focusedChipIndex = newIdx;
    }
  }
  /** @private */
  _onArrowRight(chips, event) {
    if (this.inputElement.selectionStart !== 0) {
      return;
    }
    const idx = this._focusedChipIndex;
    if (idx !== -1) {
      event.preventDefault();
    }
    let newIdx;
    if (this.__isRTL) {
      if (idx === -1) {
        newIdx = chips.length - 1;
      } else if (idx > 0) {
        newIdx = idx - 1;
      }
    } else if (idx === chips.length - 1) {
      newIdx = -1;
    } else if (idx > -1) {
      newIdx = idx + 1;
    }
    if (newIdx !== void 0) {
      this._focusedChipIndex = newIdx;
    }
  }
  /** @private */
  _onBackSpace(chips) {
    if (this.inputElement.selectionStart !== 0) {
      return;
    }
    const idx = this._focusedChipIndex;
    if (idx === -1) {
      this._focusedChipIndex = chips.length - 1;
    } else {
      this.__removeItem(chips[idx].item);
      this._focusedChipIndex = -1;
    }
  }
  /** @private */
  _focusedChipIndexChanged(focusedIndex, oldFocusedIndex) {
    if (focusedIndex > -1 || oldFocusedIndex > -1) {
      const chips = this._chips;
      chips.forEach((chip, index) => {
        chip.toggleAttribute("focused", index === focusedIndex);
      });
      if (focusedIndex > -1) {
        const item = chips[focusedIndex].item;
        const itemLabel = this._getItemLabel(item);
        announce(`${itemLabel} ${this.__effectiveI18n.focused}`);
      }
    }
  }
  /**
   * @param {CustomEvent} event
   * @protected
   * @override
   */
  _overlaySelectedItemChanged(event) {
    event.stopPropagation();
    if (this.readonly) {
      return;
    }
    if (event.detail.item instanceof ComboBoxPlaceholder) {
      return;
    }
    if (this.opened) {
      this._lastFilter = this._inputElementValue;
      this.__selectItem(event.detail.item);
    }
  }
  /** @private */
  _onItemRemoved(event) {
    this.__removeItem(event.detail.item);
  }
  /** @private */
  _preventBlur(event) {
    event.preventDefault();
  }
  /**
   * Fired when the user sets a custom value.
   * @event custom-value-set
   * @param {string} detail the custom value
   */
};

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box.js
var MultiSelectComboBox = class extends MultiSelectComboBoxMixin(
  ThemableMixin(ElementMixin(PolylitMixin(LumoInjectionMixin(LitElement))))
) {
  static get is() {
    return "vaadin-multi-select-combo-box";
  }
  static get styles() {
    return [inputFieldShared, multiSelectComboBoxStyles];
  }
  /** @protected */
  render() {
    return html`
      <div class="vaadin-multi-select-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" @click="${this.focus}"></span>
        </div>

        <vaadin-multi-select-combo-box-container
          part="input-field"
          .autoExpandVertically="${this.autoExpandVertically}"
          .readonly="${this.readonly}"
          .disabled="${this.disabled}"
          .invalid="${this.invalid}"
          theme="${ifDefined(this._theme)}"
        >
          <slot name="overflow" slot="prefix"></slot>
          <div id="chips" part="chips" slot="prefix">
            <slot name="chip"></slot>
          </div>
          <slot name="input"></slot>
          <div id="clearButton" part="field-button clear-button" slot="suffix" aria-hidden="true"></div>
          <div id="toggleButton" part="field-button toggle-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-multi-select-combo-box-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>

        <slot name="tooltip"></slot>
      </div>

      <vaadin-multi-select-combo-box-overlay
        id="overlay"
        exportparts="overlay, content, loader"
        .owner="${this}"
        .dir="${this.dir}"
        .opened="${this._overlayOpened}"
        ?loading="${this.loading}"
        theme="${ifDefined(this._theme)}"
        .positionTarget="${this._inputField}"
        no-vertical-overlap
      >
        <slot name="overlay"></slot>
      </vaadin-multi-select-combo-box-overlay>
    `;
  }
};
defineCustomElement(MultiSelectComboBox);

export {
  MultiSelectComboBox
};
//# sourceMappingURL=chunk-KE4DYM7X.js.map
