import "./chunk-6QV6LNZP.js";
import "./chunk-MNTMWC4G.js";
import "./chunk-ZZVQ6C3W.js";
import "./chunk-7QAQCWIA.js";
import "./chunk-ETYEORRM.js";
import "./chunk-F6FMTQFS.js";
import "./chunk-MIDFCHJR.js";
import "./chunk-TB3BFBAM.js";
import {
  PositionMixin
} from "./chunk-FOQZPEJP.js";
import "./chunk-OSWHV746.js";
import {
  OverlayMixin,
  overlayStyles
} from "./chunk-PFI4EOEJ.js";
import "./chunk-4QGJQDIU.js";
import "./chunk-6KCLDTNY.js";
import "./chunk-C63QNJWN.js";
import "./chunk-2WIP7T36.js";
import "./chunk-ZZO67D7M.js";
import "./chunk-WJXDM45A.js";
import "./chunk-722MDOVI.js";
import "./chunk-ME7RDPE7.js";
import "./chunk-R7PLRAV7.js";
import "./chunk-SFISAMYO.js";
import "./chunk-44TEYO45.js";
import "./chunk-XFKQJ73Z.js";
import "./chunk-X5EEA4XV.js";
import "./chunk-Z5LHTDPJ.js";
import "./chunk-VNVGWFKZ.js";
import {
  I18nMixin
} from "./chunk-WSKWP5BQ.js";
import "./chunk-T3UXCKHJ.js";
import "./chunk-472KGBTN.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  Debouncer
} from "./chunk-OWHE56FA.js";
import "./chunk-YZIAODF7.js";
import "./chunk-GXEMU344.js";
import "./chunk-ZBUMLMW2.js";
import "./chunk-EIHDKHUQ.js";
import "./chunk-5W5MB6YY.js";
import "./chunk-M3HWWZVG.js";
import "./chunk-WT6HVPMS.js";
import "./chunk-ERLMGG3V.js";
import "./chunk-SVPOVVYN.js";
import {
  isKeyboardActive
} from "./chunk-5DESY7LS.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import "./chunk-ULNR4UH6.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import "./chunk-TMRBPE5K.js";
import {
  DirMixin
} from "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html,
  render
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";
import {
  timeOut
} from "./chunk-MWWP2LZ3.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/rich-text-editor/src/styles/vaadin-rich-text-editor-popup-overlay-base-styles.js
var richTextEditorPopupOverlay = css`
  [part='overlay'] {
    padding: var(
      --vaadin-rich-text-editor-overlay-padding,
      var(--vaadin-padding-block-container) var(--vaadin-padding-inline-container)
    );
  }

  [part='content'] {
    display: grid;
    gap: var(--vaadin-rich-text-editor-overlay-gap, var(--vaadin-gap-s));
    grid-template-columns: repeat(7, minmax(0, 1fr));
  }

  [part='content'] ::slotted(button) {
    background-color: var(--_btn-background);
    border: var(--vaadin-rich-text-editor-overlay-color-option-border-width, 1px) solid
      var(--vaadin-rich-text-editor-overlay-color-option-border-color, transparent);
    border-radius: var(--vaadin-rich-text-editor-overlay-color-option-border-radius, 9999px);
    cursor: var(--vaadin-clickable-cursor);
    font: inherit;
    height: var(--vaadin-rich-text-editor-overlay-color-option-height, 1lh);
    padding: 0;
    width: var(--vaadin-rich-text-editor-overlay-color-option-width, 1lh);
  }

  [part='content'] ::slotted(button:first-of-type) {
    background-color: transparent;
    border-color: var(--vaadin-border-color-secondary);
    background-image: repeating-linear-gradient(
      135deg,
      transparent 0%,
      transparent 47%,
      red 50%,
      transparent 53%,
      transparent 100%
    );
  }

  [part='content'] ::slotted(button:focus-visible) {
    outline: var(--vaadin-focus-ring-width) solid var(--vaadin-focus-ring-color);
    outline-offset: 1px;
  }
`;
var richTextEditorPopupOverlayStyles = [overlayStyles, richTextEditorPopupOverlay];

// node_modules/@vaadin/rich-text-editor/src/vaadin-rich-text-editor-popup.js
var RichTextEditorPopup = class extends PolylitMixin(LitElement) {
  static get is() {
    return "vaadin-rich-text-editor-popup";
  }
  static get styles() {
    return css`
      :host([opened]),
      :host([opening]),
      :host([closing]) {
        display: contents !important;
      }

      :host,
      :host([hidden]) {
        display: none !important;
      }
    `;
  }
  static get properties() {
    return {
      target: {
        type: Object
      },
      opened: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true
      },
      colors: {
        type: Array
      }
    };
  }
  static get observers() {
    return ["__openedOrTargetChanged(opened, target)", "__colorsChanged(colors)"];
  }
  /** @protected */
  render() {
    return html`
      <vaadin-rich-text-editor-popup-overlay
        id="overlay"
        .owner="${this}"
        .opened="${this.opened}"
        .positionTarget="${this.target}"
        no-vertical-overlap
        horizontal-align="start"
        vertical-align="top"
        focus-trap
        exportparts="overlay, content"
        @opened-changed="${this._onOpenedChanged}"
        @vaadin-overlay-escape-press="${this._onOverlayEscapePress}"
      >
        <slot></slot>
      </vaadin-rich-text-editor-popup-overlay>
    `;
  }
  /** @private */
  _onOpenedChanged(event) {
    this.opened = event.detail.value;
  }
  /** @private */
  _onOverlayEscapePress() {
    this.target.focus();
  }
  /** @private */
  _onColorClick(e) {
    const { color } = e.target.dataset;
    this.dispatchEvent(new CustomEvent("color-selected", { detail: { color } }));
  }
  /** @private */
  __colorsChanged(colors) {
    render(
      html`
        ${colors.map(
        (color) => html`
            <button data-color="${color}" style="--_btn-background: ${color}" @click="${this._onColorClick}"></button>
          `
      )}
      `,
      this,
      { host: this }
    );
  }
  /** @private */
  __openedOrTargetChanged(opened, target) {
    if (target) {
      target.setAttribute("aria-expanded", opened ? "true" : "false");
    }
  }
};
defineCustomElement(RichTextEditorPopup);
var RichTextEditorPopupOverlay = class extends PositionMixin(
  OverlayMixin(DirMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement)))))
) {
  static get is() {
    return "vaadin-rich-text-editor-popup-overlay";
  }
  static get styles() {
    return richTextEditorPopupOverlayStyles;
  }
  /** @protected */
  render() {
    return html`
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
  /**
   * Override method from OverlayFocusMixin to use owner as content root
   * @protected
   * @override
   */
  get _contentRoot() {
    return this.owner;
  }
  /**
   * Override method from OverlayFocusMixin to use owner as focus trap root
   * @protected
   * @override
   */
  get _focusTrapRoot() {
    return this.owner;
  }
};
defineCustomElement(RichTextEditorPopupOverlay);

// node_modules/@vaadin/rich-text-editor/src/styles/vaadin-rich-text-editor-base-icons.js
var icons = css`
  :host {
    --_vaadin-icon-align-center: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 5H3"/><path d="M17 12H7"/><path d="M19 19H5"/></svg>');
    --_vaadin-icon-align-left: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 5H3"/><path d="M15 12H3"/><path d="M17 19H3"/></svg>');
    --_vaadin-icon-align-right: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 5H3"/><path d="M21 12H9"/><path d="M21 19H7"/></svg>');
    --_vaadin-icon-background: url('data:image/svg+xml,<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.6 12L12 9.4L8 13.4L10.575 16L14.6 12ZM13.425 8L16 10.575L20 6.6L17.4 4L13.425 8ZM11.325 7.275L16.725 12.675L12 17.425C11.6 17.825 11.1292 18.025 10.5875 18.025C10.0458 18.025 9.575 17.825 9.175 17.425L8.5 18H3.5L6.65 14.875C6.25 14.475 6.04167 13.9958 6.025 13.4375C6.00833 12.8792 6.2 12.4 6.6 12L11.325 7.275ZM11.325 7.275L16 2.6C16.4 2.2 16.8708 2 17.4125 2C17.9542 2 18.425 2.2 18.825 2.6L21.425 5.175C21.825 5.575 22.025 6.04583 22.025 6.5875C22.025 7.12917 21.825 7.6 21.425 8L16.725 12.675L11.325 7.275Z" fill="currentColor"/></svg>');
    --_vaadin-icon-bold: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linejoin="round" d="M6.75 3.744h-.753v8.25h7.125a4.125 4.125 0 0 0 0-8.25H6.75Zm0 0v.38m0 16.122h6.747a4.5 4.5 0 0 0 0-9.001h-7.5v9h.753Zm0 0v-.37m0-15.751h6a3.75 3.75 0 1 1 0 7.5h-6m0-7.5v7.5m0 0v8.25m0-8.25h6.375a4.125 4.125 0 0 1 0 8.25H6.75m.747-15.38h4.875a3.375 3.375 0 0 1 0 6.75H7.497v-6.75Zm0 7.5h5.25a3.75 3.75 0 0 1 0 7.5h-5.25v-7.5Z" /></svg>');
    --_vaadin-icon-clear: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" fill="currentColor"><path d="m528-546-93-93-121-121h486v120H568l-40 94ZM792-56 460-388l-80 188H249l119-280L56-792l56-56 736 736-56 56Z"/></svg>');
    --_vaadin-icon-code: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m16 18 6-6-6-6"/><path d="m8 6-6 6 6 6"/></svg>');
    --_vaadin-icon-color: url('data:image/svg+xml,<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.5 17L10.75 3H13.25L18.5 17H16.1L14.85 13.4H9.2L7.9 17H5.5ZM9.9 11.4H14.1L12.05 5.6H11.95L9.9 11.4Z" fill="currentColor"/></svg>');
    --_vaadin-icon-color-underline: url('data:image/svg+xml,<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 24V20H22V24H2Z" fill="currentColor"/></svg>');
    --_vaadin-icon-h1: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12h8"/><path d="M4 18V6"/><path d="M12 18V6"/><path d="m17 12 3-2v8"/></svg>');
    --_vaadin-icon-h2: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12h8"/><path d="M4 18V6"/><path d="M12 18V6"/><path d="M21 18h-4c0-4 4-3 4-6 0-1.5-2-2.5-4-1"/></svg>');
    --_vaadin-icon-h3: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12h8"/><path d="M4 18V6"/><path d="M12 18V6"/><path d="M17.5 10.5c1.7-1 3.5 0 3.5 1.5a2 2 0 0 1-2 2"/><path d="M17 17.5c2 1.5 4 .3 4-1.5a2 2 0 0 0-2-2"/></svg>');
    --_vaadin-icon-indent: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 5H11"/><path d="M21 12H11"/><path d="M21 19H11"/><path d="m3 8 4 4-4 4"/></svg>');
    --_vaadin-icon-italic: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" x2="10" y1="4" y2="4"/><line x1="14" x2="5" y1="20" y2="20"/><line x1="15" x2="9" y1="4" y2="20"/></svg>');
    --_vaadin-icon-list-number: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5h10"/><path d="M11 12h10"/><path d="M11 19h10"/><path d="M4 4h1v5"/><path d="M4 9h2"/><path d="M6.5 20H3.4c0-1 2.6-1.925 2.6-3.5a1.5 1.5 0 0 0-2.6-1.02"/></svg>');
    --_vaadin-icon-list-bullet: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 5h.01"/><path d="M3 12h.01"/><path d="M3 19h.01"/><path d="M8 5h13"/><path d="M8 12h13"/><path d="M8 19h13"/></svg>');
    --_vaadin-icon-outdent: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 5H11"/><path d="M21 12H11"/><path d="M21 19H11"/><path d="m7 8-4 4 4 4"/></svg>');
    --_vaadin-icon-quote: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 5H3"/><path d="M21 12H8"/><path d="M21 19H8"/><path d="M3 12v7"/></svg>');
    --_vaadin-icon-strikethrough: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4H9a3 3 0 0 0-2.83 4"/><path d="M14 12a4 4 0 0 1 0 8H6"/><line x1="4" x2="20" y1="12" y2="12"/></svg>');
    --_vaadin-icon-subscript: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m4 5 8 8"/><path d="m12 5-8 8"/><path d="M20 19h-4c0-1.5.44-2 1.5-2.5S20 15.33 20 14c0-.47-.17-.93-.48-1.29a2.11 2.11 0 0 0-2.62-.44c-.42.24-.74.62-.9 1.07"/></svg>');
    --_vaadin-icon-superscript: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m4 19 8-8"/><path d="m12 19-8-8"/><path d="M20 12h-4c0-1.5.442-2 1.5-2.5S20 8.334 20 7.002c0-.472-.17-.93-.484-1.29a2.105 2.105 0 0 0-2.617-.436c-.42.239-.738.614-.899 1.06"/></svg>');
    --_vaadin-icon-underline: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 4v6a6 6 0 0 0 12 0V4"/><line x1="4" x2="20" y1="20" y2="20"/></svg>');
  }
`;

// node_modules/@vaadin/rich-text-editor/src/styles/vaadin-rich-text-editor-base-styles.js
var base = css`
  :host {
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
  }

  :host([hidden]) {
    display: none !important;
  }

  .announcer {
    clip: rect(0, 0, 0, 0);
    position: fixed;
  }

  input[type='file'] {
    display: none;
  }

  .vaadin-rich-text-editor-container {
    display: flex;
    flex: auto;
    flex-direction: column;
    max-height: inherit;
    min-height: inherit;
    background: var(--vaadin-rich-text-editor-background, var(--vaadin-background-color));
    border: var(--vaadin-input-field-border-width, 1px) solid
      var(--vaadin-input-field-border-color, var(--vaadin-border-color));
    border-radius: var(--vaadin-input-field-border-radius, var(--vaadin-radius-m));
    outline-offset: calc(var(--vaadin-input-field-border-width, 1px) * -1);
    contain: paint;
  }

  .vaadin-rich-text-editor-container:has([part='content']:focus-within),
  .vaadin-rich-text-editor-container:has([part~='toolbar-button']:active) {
    outline: var(--vaadin-focus-ring-width) solid var(--vaadin-focus-ring-color);
  }
`;
var content = css`
  :host {
    --_item-indent: var(--vaadin-padding-s);
    --_marker-indent: var(--vaadin-gap-s);
    --_list-indent: var(--_item-indent);
  }

  [part='content'] {
    box-sizing: border-box;
    display: flex;
    flex: auto;
    flex-direction: column;
    overflow: hidden;
    position: relative;
    cursor: text;
  }

  /*
    Quill core styles.
    CSS selectors removed: margin & padding reset, check list, indentation, video, colors, ordered & unordered list, h1-6, anchor
  */
  .ql-clipboard {
    height: 1px;
    left: -100000px;
    overflow-y: hidden;
    position: absolute;
    top: 50%;
  }

  .ql-clipboard p {
    margin: 0;
    padding: 0;
  }

  .ql-editor {
    box-sizing: border-box;
    color: var(--vaadin-rich-text-editor-content-color, var(--vaadin-text-color));
    flex: 1;
    font-size: var(--vaadin-rich-text-editor-content-font-size, var(--vaadin-input-field-value-font-size, inherit));
    height: 100%;
    line-height: var(--vaadin-rich-text-editor-content-line-height, inherit);
    outline: none;
    overflow-y: auto;
    padding: var(
      --vaadin-rich-text-editor-content-padding,
      var(--vaadin-padding-block-container) var(--vaadin-padding-inline-container)
    );
    tab-size: calc(var(--_item-indent) * 2);
    text-align: left;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .ql-editor > * {
    cursor: text;
  }

  .ql-align-left {
    text-align: left;
  }

  .ql-direction-rtl {
    direction: rtl;
    text-align: inherit;
  }

  .ql-align-center {
    text-align: center;
  }

  .ql-align-justify {
    text-align: justify;
  }

  .ql-align-right {
    text-align: right;
  }

  .ql-code-block-container {
    font-family: monospace;
    background-color: var(--vaadin-background-container);
    border-radius: var(--vaadin-radius-s);
    white-space: pre-wrap;
    margin-block: var(--vaadin-padding-s);
    padding: var(--vaadin-padding-block-container) var(--vaadin-padding-inline-container);
  }

  /* lists */
  .ql-editor ol {
    padding-inline-start: var(--_list-indent);
  }

  .ql-editor li {
    list-style-type: none;
    position: relative;
    padding-inline-start: var(--_item-indent);
  }

  .ql-editor li > .ql-ui::before {
    display: inline-block;
    width: var(--_item-indent);
    margin-inline: calc(var(--_item-indent) * -1) var(--_marker-indent);
    text-align: end;
    white-space: nowrap;
  }

  .ql-editor li[data-list='bullet'] > .ql-ui::before {
    content: '\\2022';
    font-size: 1.5rem;
    line-height: 1rem;
    align-self: baseline;
    vertical-align: text-top;
  }

  .ql-editor p,
  .ql-editor h1,
  .ql-editor h2,
  .ql-editor h3,
  .ql-editor h4,
  .ql-editor h5,
  .ql-editor h6 {
    counter-set: list-0 list-1 list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;
  }

  /* 0 */
  .ql-editor li[data-list='ordered'] {
    counter-increment: list-0;
  }

  .ql-editor li[data-list='ordered'] > .ql-ui::before {
    content: counter(list-0, decimal) '. ';
  }

  /* 1 */
  .ql-editor li[data-list='ordered'].ql-indent-1 {
    counter-increment: list-1;
  }

  .ql-editor li[data-list='ordered'].ql-indent-1 > .ql-ui::before {
    content: counter(list-1, lower-alpha) '. ';
  }

  .ql-editor li[data-list].ql-indent-1 {
    counter-set: list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;
  }

  /* 2 */
  .ql-editor li[data-list='ordered'].ql-indent-2 {
    counter-increment: list-2;
  }

  .ql-editor li[data-list='ordered'].ql-indent-2 > .ql-ui::before {
    content: counter(list-2, lower-roman) '. ';
  }

  .ql-editor li[data-list].ql-indent-2 {
    counter-set: list-3 list-4 list-5 list-6 list-7 list-8 list-9;
  }

  /* 3 */
  .ql-editor li[data-list='ordered'].ql-indent-3 {
    counter-increment: list-3;
  }

  .ql-editor li[data-list='ordered'].ql-indent-3 > .ql-ui::before {
    content: counter(list-3, decimal) '. ';
  }

  .ql-editor li[data-list].ql-indent-3 {
    counter-set: list-4 list-5 list-6 list-7 list-8 list-9;
  }

  /* 4 */
  .ql-editor li[data-list='ordered'].ql-indent-4 {
    counter-increment: list-4;
  }

  .ql-editor li[data-list='ordered'].ql-indent-4 > .ql-ui::before {
    content: counter(list-4, lower-alpha) '. ';
  }

  .ql-editor li[data-list].ql-indent-4 {
    counter-set: list-5 list-6 list-7 list-8 list-9;
  }

  /* 5 */
  .ql-editor li[data-list='ordered'].ql-indent-5 {
    counter-increment: list-5;
  }

  .ql-editor li[data-list='ordered'].ql-indent-5 > .ql-ui::before {
    content: counter(list-5, lower-roman) '. ';
  }

  .ql-editor li[data-list].ql-indent-5 {
    counter-set: list-6 list-7 list-8 list-9;
  }

  /* 6 */
  .ql-editor li[data-list='ordered'].ql-indent-6 {
    counter-increment: list-6;
  }

  .ql-editor li[data-list='ordered'].ql-indent-6 > .ql-ui::before {
    content: counter(list-6, decimal) '. ';
  }

  .ql-editor li[data-list].ql-indent-6 {
    counter-set: list-7 list-8 list-9;
  }

  /* 7 */
  .ql-editor li[data-list='ordered'].ql-indent-7 {
    counter-increment: list-7;
  }

  .ql-editor li[data-list='ordered'].ql-indent-7 > .ql-ui::before {
    content: counter(list-7, lower-alpha) '. ';
  }

  .ql-editor li[data-list].ql-indent-7 {
    counter-set: list-8 list-9;
  }

  /* 8 */
  .ql-editor li[data-list='ordered'].ql-indent-8 {
    counter-increment: list-8;
  }

  .ql-editor li[data-list='ordered'].ql-indent-8 > .ql-ui::before {
    content: counter(list-8, lower-roman) '. ';
  }

  .ql-editor li[data-list].ql-indent-8 {
    counter-set: list-9;
  }

  /* indent 1 */
  .ql-editor .ql-indent-1 {
    padding-inline-start: calc(var(--_item-indent) * 2);
  }

  .ql-editor li.ql-indent-1 {
    padding-inline-start: calc(var(--_list-indent) + var(--_item-indent) * 2);
  }

  /* indent 2 */
  .ql-editor .ql-indent-2 {
    padding-inline-start: calc(var(--_item-indent) * 4);
  }

  .ql-editor li.ql-indent-2 {
    padding-inline-start: calc(var(--_list-indent) * 2 + var(--_item-indent) * 3);
  }

  /* indent 3 */
  .ql-editor .ql-indent-3 {
    padding-inline-start: calc(var(--_item-indent) * 6);
  }

  .ql-editor li.ql-indent-3 {
    padding-inline-start: calc(var(--_list-indent) * 3 + var(--_item-indent) * 4);
  }

  /* indent 4 */
  .ql-editor .ql-indent-4 {
    padding-inline-start: calc(var(--_item-indent) * 8);
  }

  .ql-editor li.ql-indent-4 {
    padding-inline-start: calc(var(--_list-indent) * 4 + var(--_item-indent) * 5);
  }

  /* indent 5 */
  .ql-editor .ql-indent-5 {
    padding-inline-start: calc(var(--_item-indent) * 10);
  }

  .ql-editor li.ql-indent-5 {
    padding-inline-start: calc(var(--_list-indent) * 5 + var(--_item-indent) * 6);
  }

  /* indent 6 */
  .ql-editor .ql-indent-6 {
    padding-inline-start: calc(var(--_item-indent) * 12);
  }

  .ql-editor li.ql-indent-6 {
    padding-inline-start: calc(var(--_list-indent) * 6 + var(--_item-indent) * 7);
  }

  /* indent 7 */
  .ql-editor .ql-indent-7 {
    padding-inline-start: calc(var(--_item-indent) * 14);
  }

  .ql-editor li.ql-indent-7 {
    padding-inline-start: calc(var(--_list-indent) * 7 + var(--_item-indent) * 8);
  }

  /* indent 8 */
  .ql-editor .ql-indent-8 {
    padding-inline-start: calc(var(--_item-indent) * 16);
  }

  .ql-editor li.ql-indent-8 {
    padding-inline-start: calc(var(--_list-indent) * 8 + var(--_item-indent) * 9);
  }
  /* quill core end */

  blockquote {
    border-inline-start: 4px solid var(--vaadin-border-color-secondary);
    margin: var(--vaadin-padding-block-container) var(--vaadin-padding-inline-container);
    padding-inline-start: var(--vaadin-padding-s);
  }

  code {
    background-color: var(--vaadin-background-container);
    border-radius: var(--vaadin-radius-s);
    padding: 0.125rem 0.25rem;
  }

  img {
    max-width: 100%;
  }

  .ql-editor > :is(p, ol, ul, blockquote, .ql-code-block-container):first-child {
    margin-top: 0;
  }

  .ql-editor > :is(p, ol, ul, blockquote, .ql-code-block-container):last-child {
    margin-bottom: 0;
  }

  /* RTL specific styles */
  :host([dir='rtl']) .ql-editor {
    direction: rtl;
    text-align: right;
  }
`;
var toolbar = css`
  [part='toolbar'] {
    background-color: var(--vaadin-rich-text-editor-toolbar-background, var(--vaadin-background-container));
    display: flex;
    flex-shrink: 0;
    flex-wrap: wrap;
    gap: var(--vaadin-rich-text-editor-toolbar-gap, var(--vaadin-gap-s));
    padding: var(--vaadin-rich-text-editor-toolbar-padding, var(--vaadin-padding-s));
  }

  [part~='toolbar-group'] {
    display: flex;
  }

  [part~='toolbar-button'] {
    background: var(--vaadin-rich-text-editor-toolbar-button-background, var(--vaadin-background-container));
    border: var(--vaadin-rich-text-editor-toolbar-button-border-width, 1px) solid
      var(--vaadin-rich-text-editor-toolbar-button-border-color, transparent);
    border-radius: var(--vaadin-rich-text-editor-toolbar-button-border-radius, var(--vaadin-radius-m));
    color: var(--vaadin-rich-text-editor-toolbar-button-text-color, var(--vaadin-text-color));
    cursor: var(--vaadin-clickable-cursor);
    flex-shrink: 0;
    font: inherit;
    padding: var(
      --vaadin-rich-text-editor-toolbar-button-padding,
      var(--vaadin-padding-block-container) var(--vaadin-padding-inline-container)
    );
    position: relative;
  }

  [part~='toolbar-button']::before {
    background: currentColor;
    content: '';
    display: block;
    height: var(--vaadin-icon-size, 1lh);
    width: var(--vaadin-icon-size, 1lh);
    mask-size: var(--vaadin-icon-visual-size, 100%);
    mask-repeat: no-repeat;
    mask-position: 50%;
  }

  [part~='toolbar-button']:focus-visible {
    outline: var(--vaadin-focus-ring-width) solid var(--vaadin-focus-ring-color);
    outline-offset: 1px;
    z-index: 1;
  }

  [part~='toolbar-button-pressed'],
  [part~='toolbar-button'][aria-expanded='true'] {
    --vaadin-rich-text-editor-toolbar-button-background: var(--vaadin-background-container-strong);
  }

  [part~='toolbar-button-undo']::before {
    mask-image: var(--_vaadin-icon-undo);
  }

  [part~='toolbar-button-redo']::before {
    mask-image: var(--_vaadin-icon-redo);
  }

  [part~='toolbar-button-bold']::before {
    mask-image: var(--_vaadin-icon-bold);
  }

  [part~='toolbar-button-italic']::before {
    mask-image: var(--_vaadin-icon-italic);
  }

  [part~='toolbar-button-underline']::before {
    mask-image: var(--_vaadin-icon-underline);
  }

  [part~='toolbar-button-strike']::before {
    mask-image: var(--_vaadin-icon-strikethrough);
  }

  [part~='toolbar-button-color']::before {
    mask-image: var(--_vaadin-icon-color);
  }

  [part~='toolbar-button-color']::after {
    background-color: var(--_color-value, currentColor);
  }

  [part~='toolbar-button-background']::before {
    mask-image: var(--_vaadin-icon-background);
  }

  [part~='toolbar-button-background']::after {
    background-color: var(--_background-value, currentColor);
  }

  [part~='toolbar-button-color']::after,
  [part~='toolbar-button-background']::after {
    bottom: 50%;
    content: '';
    display: block;
    height: var(--vaadin-icon-size, 1lh);
    mask-image: var(--_vaadin-icon-color-underline);
    position: absolute;
    transform: translateY(50%);
    width: var(--vaadin-icon-size, 1lh);
  }

  [part~='toolbar-button-h1']::before {
    mask-image: var(--_vaadin-icon-h1);
  }

  [part~='toolbar-button-h2']::before {
    mask-image: var(--_vaadin-icon-h2);
  }

  [part~='toolbar-button-h3']::before {
    mask-image: var(--_vaadin-icon-h3);
  }

  [part~='toolbar-button-subscript']::before {
    mask-image: var(--_vaadin-icon-subscript);
  }

  [part~='toolbar-button-superscript']::before {
    mask-image: var(--_vaadin-icon-superscript);
  }

  [part~='toolbar-button-list-ordered']::before {
    mask-image: var(--_vaadin-icon-list-number);
  }

  [part~='toolbar-button-list-bullet']::before {
    mask-image: var(--_vaadin-icon-list-bullet);
  }

  [part~='toolbar-button-outdent']::before {
    mask-image: var(--_vaadin-icon-outdent);
  }

  [part~='toolbar-button-indent']::before {
    mask-image: var(--_vaadin-icon-indent);
  }

  [part~='toolbar-button-align-left']::before {
    mask-image: var(--_vaadin-icon-align-left);
  }

  [part~='toolbar-button-align-center']::before {
    mask-image: var(--_vaadin-icon-align-center);
  }

  [part~='toolbar-button-align-right']::before {
    mask-image: var(--_vaadin-icon-align-right);
  }

  [part~='toolbar-button-image']::before {
    mask-image: var(--_vaadin-icon-image);
  }

  [part~='toolbar-button-link']::before {
    mask-image: var(--_vaadin-icon-link);
  }

  [part~='toolbar-button-blockquote']::before {
    mask-image: var(--_vaadin-icon-quote);
  }

  [part~='toolbar-button-code-block']::before {
    mask-image: var(--_vaadin-icon-code);
  }

  [part~='toolbar-button-clean']::before {
    mask-image: var(--_vaadin-icon-clear);
  }

  @media (forced-colors: active) {
    [part~='toolbar-button']::before {
      background: CanvasText;
    }

    [part~='toolbar-button-pressed'] {
      background: Highlight;
    }

    [part~='toolbar-button-pressed']::before {
      background: HighlightText;
    }
  }
`;
var states = css`
  :host([readonly]) [part='toolbar'] {
    display: none;
  }

  :host([disabled]) {
    pointer-events: none;
    opacity: 0.5;
    -webkit-user-select: none;
    user-select: none;
  }
`;
var richTextEditorStyles = [icons, base, content, toolbar, states];

// node_modules/@vaadin/rich-text-editor/vendor/vaadin-quill.js
!(function(t, e) {
  t.Quill = e();
})(window, (function() {
  return (function() {
    "use strict";
    var t = { 698: function(t2, e2, n2) {
      n2.d(e2, { Ay: function() {
        return a;
      }, Ji: function() {
        return h;
      }, zo: function() {
        return c;
      } });
      var s2 = n2(3), i = n2(398), r = n2(36), o = n2(850), l = n2(508);
      class a extends s2.BlockBlot {
        cache = {};
        delta() {
          return null == this.cache.delta && (this.cache.delta = (function(t3) {
            let e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            return t3.descendants(s2.LeafBlot).reduce(((t4, n3) => 0 === n3.length() ? t4 : t4.insert(n3.value(), h(n3, {}, e3))), new i.Ay()).insert("\n", h(t3));
          })(this)), this.cache.delta;
        }
        deleteAt(t3, e3) {
          super.deleteAt(t3, e3), this.cache = {};
        }
        formatAt(t3, e3, n3, i2) {
          e3 <= 0 || (this.scroll.query(n3, s2.Scope.BLOCK) ? t3 + e3 === this.length() && this.format(n3, i2) : super.formatAt(t3, Math.min(e3, this.length() - t3 - 1), n3, i2), this.cache = {});
        }
        insertAt(t3, e3, n3) {
          if (null != n3) return super.insertAt(t3, e3, n3), void (this.cache = {});
          if (0 === e3.length) return;
          const s3 = e3.split("\n"), i2 = s3.shift();
          i2.length > 0 && (t3 < this.length() - 1 || null == this.children.tail ? super.insertAt(Math.min(t3, this.length() - 1), i2) : this.children.tail.insertAt(this.children.tail.length(), i2), this.cache = {});
          let r2 = this;
          s3.reduce(((t4, e4) => (r2 = r2.split(t4, true), r2.insertAt(0, e4), e4.length)), t3 + i2.length);
        }
        insertBefore(t3, e3) {
          const { head: n3 } = this.children;
          super.insertBefore(t3, e3), n3 instanceof r.A && n3.remove(), this.cache = {};
        }
        length() {
          return null == this.cache.length && (this.cache.length = super.length() + 1), this.cache.length;
        }
        moveChildren(t3, e3) {
          super.moveChildren(t3, e3), this.cache = {};
        }
        optimize(t3) {
          super.optimize(t3), this.cache = {};
        }
        path(t3) {
          return super.path(t3, true);
        }
        removeChild(t3) {
          super.removeChild(t3), this.cache = {};
        }
        split(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if (e3 && (0 === t3 || t3 >= this.length() - 1)) {
            const e4 = this.clone();
            return 0 === t3 ? (this.parent.insertBefore(e4, this), this) : (this.parent.insertBefore(e4, this.next), e4);
          }
          const n3 = super.split(t3, e3);
          return this.cache = {}, n3;
        }
      }
      a.blotName = "block", a.tagName = "P", a.defaultChild = r.A, a.allowedChildren = [r.A, o.A, s2.EmbedBlot, l.A];
      class c extends s2.EmbedBlot {
        attach() {
          super.attach(), this.attributes = new s2.AttributorStore(this.domNode);
        }
        delta() {
          return new i.Ay().insert(this.value(), { ...this.formats(), ...this.attributes.values() });
        }
        format(t3, e3) {
          const n3 = this.scroll.query(t3, s2.Scope.BLOCK_ATTRIBUTE);
          null != n3 && this.attributes.attribute(n3, e3);
        }
        formatAt(t3, e3, n3, s3) {
          this.format(n3, s3);
        }
        insertAt(t3, e3, n3) {
          if (null != n3) return void super.insertAt(t3, e3, n3);
          const s3 = e3.split("\n"), i2 = s3.pop(), r2 = s3.map(((t4) => {
            const e4 = this.scroll.create(a.blotName);
            return e4.insertAt(0, t4), e4;
          })), o2 = this.split(t3);
          r2.forEach(((t4) => {
            this.parent.insertBefore(t4, o2);
          })), i2 && this.parent.insertBefore(this.scroll.create("text", i2), o2);
        }
      }
      function h(t3) {
        let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        return null == t3 ? e3 : ("formats" in t3 && "function" == typeof t3.formats && (e3 = { ...e3, ...t3.formats() }, n3 && delete e3["code-token"]), null == t3.parent || "scroll" === t3.parent.statics.blotName || t3.parent.statics.scope !== t3.statics.scope ? e3 : h(t3.parent, e3, n3));
      }
      c.scope = s2.Scope.BLOCK_BLOT;
    }, 36: function(t2, e2, n2) {
      var s2 = n2(3);
      class i extends s2.EmbedBlot {
        static value() {
        }
        optimize() {
          (this.prev || this.next) && this.remove();
        }
        length() {
          return 0;
        }
        value() {
          return "";
        }
      }
      i.blotName = "break", i.tagName = "BR", e2.A = i;
    }, 580: function(t2, e2, n2) {
      var s2 = n2(3);
      class i extends s2.ContainerBlot {
      }
      e2.A = i;
    }, 541: function(t2, e2, n2) {
      var s2 = n2(3), i = n2(508);
      class r extends s2.EmbedBlot {
        static blotName = "cursor";
        static className = "ql-cursor";
        static tagName = "span";
        static CONTENTS = "\uFEFF";
        static value() {
        }
        constructor(t3, e3, n3) {
          super(t3, e3), this.selection = n3, this.textNode = document.createTextNode(r.CONTENTS), this.domNode.appendChild(this.textNode), this.savedLength = 0;
        }
        detach() {
          null != this.parent && this.parent.removeChild(this);
        }
        format(t3, e3) {
          if (0 !== this.savedLength) return void super.format(t3, e3);
          let n3 = this, i2 = 0;
          for (; null != n3 && n3.statics.scope !== s2.Scope.BLOCK_BLOT; ) i2 += n3.offset(n3.parent), n3 = n3.parent;
          null != n3 && (this.savedLength = r.CONTENTS.length, n3.optimize(), n3.formatAt(i2, r.CONTENTS.length, t3, e3), this.savedLength = 0);
        }
        index(t3, e3) {
          return t3 === this.textNode ? 0 : super.index(t3, e3);
        }
        length() {
          return this.savedLength;
        }
        position() {
          return [this.textNode, this.textNode.data.length];
        }
        remove() {
          super.remove(), this.parent = null;
        }
        restore() {
          if (this.selection.composing || null == this.parent) return null;
          const t3 = this.selection.getNativeRange();
          for (; null != this.domNode.lastChild && this.domNode.lastChild !== this.textNode; ) this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
          const e3 = this.prev instanceof i.A ? this.prev : null, n3 = e3 ? e3.length() : 0, s3 = this.next instanceof i.A ? this.next : null, o = s3 ? s3.text : "", { textNode: l } = this, a = l.data.split(r.CONTENTS).join("");
          let c;
          if (l.data = r.CONTENTS, e3) c = e3, (a || s3) && (e3.insertAt(e3.length(), a + o), s3 && s3.remove());
          else if (s3) c = s3, s3.insertAt(0, a);
          else {
            const t4 = document.createTextNode(a);
            c = this.scroll.create(t4), this.parent.insertBefore(c, this);
          }
          if (this.remove(), t3) {
            const i2 = (t4, i3) => e3 && t4 === e3.domNode ? i3 : t4 === l ? n3 + i3 - 1 : s3 && t4 === s3.domNode ? n3 + a.length + i3 : null, r2 = i2(t3.start.node, t3.start.offset), o2 = i2(t3.end.node, t3.end.offset);
            if (null !== r2 && null !== o2) return { startNode: c.domNode, startOffset: r2, endNode: c.domNode, endOffset: o2 };
          }
          return null;
        }
        update(t3, e3) {
          if (t3.some(((t4) => "characterData" === t4.type && t4.target === this.textNode))) {
            const t4 = this.restore();
            t4 && (e3.range = t4);
          }
        }
        optimize(t3) {
          super.optimize(t3);
          let { parent: e3 } = this;
          for (; e3; ) {
            if ("A" === e3.domNode.tagName) {
              this.savedLength = r.CONTENTS.length, e3.isolate(this.offset(e3), this.length()).unwrap(), this.savedLength = 0;
              break;
            }
            e3 = e3.parent;
          }
        }
        value() {
          return "";
        }
      }
      e2.A = r;
    }, 746: function(t2, e2, n2) {
      var s2 = n2(3), i = n2(508);
      const r = "\uFEFF";
      class o extends s2.EmbedBlot {
        constructor(t3, e3) {
          super(t3, e3), this.contentNode = document.createElement("span"), this.contentNode.setAttribute("contenteditable", "false"), Array.from(this.domNode.childNodes).forEach(((t4) => {
            this.contentNode.appendChild(t4);
          })), this.leftGuard = document.createTextNode(r), this.rightGuard = document.createTextNode(r), this.domNode.appendChild(this.leftGuard), this.domNode.appendChild(this.contentNode), this.domNode.appendChild(this.rightGuard);
        }
        index(t3, e3) {
          return t3 === this.leftGuard ? 0 : t3 === this.rightGuard ? 1 : super.index(t3, e3);
        }
        restore(t3) {
          let e3, n3 = null;
          const s3 = t3.data.split(r).join("");
          if (t3 === this.leftGuard) if (this.prev instanceof i.A) {
            const t4 = this.prev.length();
            this.prev.insertAt(t4, s3), n3 = { startNode: this.prev.domNode, startOffset: t4 + s3.length };
          } else e3 = document.createTextNode(s3), this.parent.insertBefore(this.scroll.create(e3), this), n3 = { startNode: e3, startOffset: s3.length };
          else t3 === this.rightGuard && (this.next instanceof i.A ? (this.next.insertAt(0, s3), n3 = { startNode: this.next.domNode, startOffset: s3.length }) : (e3 = document.createTextNode(s3), this.parent.insertBefore(this.scroll.create(e3), this.next), n3 = { startNode: e3, startOffset: s3.length }));
          return t3.data = r, n3;
        }
        update(t3, e3) {
          t3.forEach(((t4) => {
            if ("characterData" === t4.type && (t4.target === this.leftGuard || t4.target === this.rightGuard)) {
              const n3 = this.restore(t4.target);
              n3 && (e3.range = n3);
            }
          }));
        }
      }
      e2.A = o;
    }, 850: function(t2, e2, n2) {
      var s2 = n2(3), i = n2(36), r = n2(508);
      class o extends s2.InlineBlot {
        static allowedChildren = [o, i.A, s2.EmbedBlot, r.A];
        static order = ["cursor", "inline", "link", "underline", "strike", "italic", "bold", "script", "code"];
        static compare(t3, e3) {
          const n3 = o.order.indexOf(t3), s3 = o.order.indexOf(e3);
          return n3 >= 0 || s3 >= 0 ? n3 - s3 : t3 === e3 ? 0 : t3 < e3 ? -1 : 1;
        }
        formatAt(t3, e3, n3, i2) {
          if (o.compare(this.statics.blotName, n3) < 0 && this.scroll.query(n3, s2.Scope.BLOT)) {
            const s3 = this.isolate(t3, e3);
            i2 && s3.wrap(n3, i2);
          } else super.formatAt(t3, e3, n3, i2);
        }
        optimize(t3) {
          if (super.optimize(t3), this.parent instanceof o && o.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
            const t4 = this.parent.isolate(this.offset(), this.length());
            this.moveChildren(t4), t4.wrap(this);
          }
        }
      }
      e2.A = o;
    }, 508: function(t2, e2, n2) {
      n2.d(e2, { A: function() {
        return i;
      }, X: function() {
        return o;
      } });
      var s2 = n2(3);
      class i extends s2.TextBlot {
      }
      const r = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
      function o(t3) {
        return t3.replace(/[&<>"']/g, ((t4) => r[t4]));
      }
    }, 729: function(t2, e2, n2) {
      n2.d(e2, { default: function() {
        return B;
      } });
      var s2 = n2(543), i = n2(698), r = n2(36), o = n2(580), l = n2(541), a = n2(746), c = n2(850), h = n2(3), u = n2(398), d = n2(200);
      function f(t3) {
        return t3 instanceof i.Ay || t3 instanceof i.zo;
      }
      function p(t3) {
        return "function" == typeof t3.updateContent;
      }
      class m extends h.ScrollBlot {
        static blotName = "scroll";
        static className = "ql-editor";
        static tagName = "DIV";
        static defaultChild = i.Ay;
        static allowedChildren = [i.Ay, i.zo, o.A];
        constructor(t3, e3, n3) {
          let { emitter: s3 } = n3;
          super(t3, e3), this.emitter = s3, this.batch = false, this.optimize(), this.enable(), this.domNode.addEventListener("dragstart", ((t4) => this.handleDragStart(t4)));
        }
        batchStart() {
          Array.isArray(this.batch) || (this.batch = []);
        }
        batchEnd() {
          if (!this.batch) return;
          const t3 = this.batch;
          this.batch = false, this.update(t3);
        }
        emitMount(t3) {
          this.emitter.emit(d.A.events.SCROLL_BLOT_MOUNT, t3);
        }
        emitUnmount(t3) {
          this.emitter.emit(d.A.events.SCROLL_BLOT_UNMOUNT, t3);
        }
        emitEmbedUpdate(t3, e3) {
          this.emitter.emit(d.A.events.SCROLL_EMBED_UPDATE, t3, e3);
        }
        deleteAt(t3, e3) {
          const [n3, s3] = this.line(t3), [o2] = this.line(t3 + e3);
          if (super.deleteAt(t3, e3), null != o2 && n3 !== o2 && s3 > 0) {
            if (n3 instanceof i.zo || o2 instanceof i.zo) return void this.optimize();
            const t4 = o2.children.head instanceof r.A ? null : o2.children.head;
            n3.moveChildren(o2, t4), n3.remove();
          }
          this.optimize();
        }
        enable() {
          let t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          this.domNode.setAttribute("contenteditable", t3 ? "true" : "false");
        }
        formatAt(t3, e3, n3, s3) {
          super.formatAt(t3, e3, n3, s3), this.optimize();
        }
        insertAt(t3, e3, n3) {
          if (t3 >= this.length()) if (null == n3 || null == this.scroll.query(e3, h.Scope.BLOCK)) {
            const t4 = this.scroll.create(this.statics.defaultChild.blotName);
            this.appendChild(t4), null == n3 && e3.endsWith("\n") ? t4.insertAt(0, e3.slice(0, -1), n3) : t4.insertAt(0, e3, n3);
          } else {
            const t4 = this.scroll.create(e3, n3);
            this.appendChild(t4);
          }
          else super.insertAt(t3, e3, n3);
          this.optimize();
        }
        insertBefore(t3, e3) {
          if (t3.statics.scope === h.Scope.INLINE_BLOT) {
            const n3 = this.scroll.create(this.statics.defaultChild.blotName);
            n3.appendChild(t3), super.insertBefore(n3, e3);
          } else super.insertBefore(t3, e3);
        }
        insertContents(t3, e3) {
          const n3 = this.deltaToRenderBlocks(e3.concat(new u.Ay().insert("\n"))), s3 = n3.pop();
          if (null == s3) return;
          this.batchStart();
          const r2 = n3.shift();
          if (r2) {
            const e4 = "block" === r2.type && (0 === r2.delta.length() || !this.descendant(i.zo, t3)[0] && t3 < this.length()), n4 = "block" === r2.type ? r2.delta : new u.Ay().insert({ [r2.key]: r2.value });
            g(this, t3, n4);
            const s4 = "block" === r2.type ? 1 : 0, o3 = t3 + n4.length() + s4;
            e4 && this.insertAt(o3 - 1, "\n");
            const l3 = (0, i.Ji)(this.line(t3)[0]), a2 = u.xb.diff(l3, r2.attributes) || {};
            Object.keys(a2).forEach(((t4) => {
              this.formatAt(o3 - 1, 1, t4, a2[t4]);
            })), t3 = o3;
          }
          let [o2, l2] = this.children.find(t3);
          n3.length && (o2 && (o2 = o2.split(l2), l2 = 0), n3.forEach(((t4) => {
            if ("block" === t4.type) g(this.createBlock(t4.attributes, o2 || void 0), 0, t4.delta);
            else {
              const e4 = this.create(t4.key, t4.value);
              this.insertBefore(e4, o2 || void 0), Object.keys(t4.attributes).forEach(((n4) => {
                e4.format(n4, t4.attributes[n4]);
              }));
            }
          }))), "block" === s3.type && s3.delta.length() && g(this, o2 ? o2.offset(o2.scroll) + l2 : this.length(), s3.delta), this.batchEnd(), this.optimize();
        }
        isEnabled() {
          return "true" === this.domNode.getAttribute("contenteditable");
        }
        leaf(t3) {
          const e3 = this.path(t3).pop();
          if (!e3) return [null, -1];
          const [n3, s3] = e3;
          return n3 instanceof h.LeafBlot ? [n3, s3] : [null, -1];
        }
        line(t3) {
          return t3 === this.length() ? this.line(t3 - 1) : this.descendant(f, t3);
        }
        lines() {
          let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
          const n3 = (t4, e4, s3) => {
            let i2 = [], r2 = s3;
            return t4.children.forEachAt(e4, s3, ((t5, e5, s4) => {
              f(t5) ? i2.push(t5) : t5 instanceof h.ContainerBlot && (i2 = i2.concat(n3(t5, e5, r2))), r2 -= s4;
            })), i2;
          };
          return n3(this, t3, e3);
        }
        optimize() {
          let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.batch || (super.optimize(t3, e3), t3.length > 0 && this.emitter.emit(d.A.events.SCROLL_OPTIMIZE, t3, e3));
        }
        path(t3) {
          return super.path(t3).slice(1);
        }
        remove() {
        }
        update(t3) {
          if (this.batch) return void (Array.isArray(t3) && (this.batch = this.batch.concat(t3)));
          let e3 = d.A.sources.USER;
          "string" == typeof t3 && (e3 = t3), Array.isArray(t3) || (t3 = this.observer.takeRecords()), (t3 = t3.filter(((t4) => {
            let { target: e4 } = t4;
            const n3 = this.find(e4, true);
            return n3 && !p(n3);
          }))).length > 0 && this.emitter.emit(d.A.events.SCROLL_BEFORE_UPDATE, e3, t3), super.update(t3.concat([])), t3.length > 0 && this.emitter.emit(d.A.events.SCROLL_UPDATE, e3, t3);
        }
        updateEmbedAt(t3, e3, n3) {
          const [s3] = this.descendant(((t4) => t4 instanceof i.zo), t3);
          s3 && s3.statics.blotName === e3 && p(s3) && s3.updateContent(n3);
        }
        handleDragStart(t3) {
          t3.preventDefault();
        }
        deltaToRenderBlocks(t3) {
          const e3 = [];
          let n3 = new u.Ay();
          return t3.forEach(((t4) => {
            const s3 = t4?.insert;
            if (s3) if ("string" == typeof s3) {
              const i2 = s3.split("\n");
              i2.slice(0, -1).forEach(((s4) => {
                n3.insert(s4, t4.attributes), e3.push({ type: "block", delta: n3, attributes: t4.attributes ?? {} }), n3 = new u.Ay();
              }));
              const r2 = i2[i2.length - 1];
              r2 && n3.insert(r2, t4.attributes);
            } else {
              const i2 = Object.keys(s3)[0];
              if (!i2) return;
              this.query(i2, h.Scope.INLINE) ? n3.push(t4) : (n3.length() && e3.push({ type: "block", delta: n3, attributes: {} }), n3 = new u.Ay(), e3.push({ type: "blockEmbed", key: i2, value: s3[i2], attributes: t4.attributes ?? {} }));
            }
          })), n3.length() && e3.push({ type: "block", delta: n3, attributes: {} }), e3;
        }
        createBlock(t3, e3) {
          let n3;
          const s3 = {};
          Object.entries(t3).forEach(((t4) => {
            let [e4, i3] = t4;
            null != this.query(e4, h.Scope.BLOCK & h.Scope.BLOT) ? n3 = e4 : s3[e4] = i3;
          }));
          const i2 = this.create(n3 || this.statics.defaultChild.blotName, n3 ? t3[n3] : void 0);
          this.insertBefore(i2, e3 || void 0);
          const r2 = i2.length();
          return Object.entries(s3).forEach(((t4) => {
            let [e4, n4] = t4;
            i2.formatAt(0, r2, e4, n4);
          })), i2;
        }
      }
      function g(t3, e3, n3) {
        n3.reduce(((e4, n4) => {
          const s3 = u.Op.length(n4);
          let r2 = n4.attributes || {};
          if (null != n4.insert) {
            if ("string" == typeof n4.insert) {
              const s4 = n4.insert;
              t3.insertAt(e4, s4);
              const [o2] = t3.descendant(h.LeafBlot, e4), l2 = (0, i.Ji)(o2);
              r2 = u.xb.diff(l2, r2) || {};
            } else if ("object" == typeof n4.insert) {
              const s4 = Object.keys(n4.insert)[0];
              if (null == s4) return e4;
              if (t3.insertAt(e4, s4, n4.insert[s4]), null != t3.scroll.query(s4, h.Scope.INLINE)) {
                const [n5] = t3.descendant(h.LeafBlot, e4), s5 = (0, i.Ji)(n5);
                r2 = u.xb.diff(s5, r2) || {};
              }
            }
          }
          return Object.keys(r2).forEach(((n5) => {
            t3.formatAt(e4, s3, n5, r2[n5]);
          })), e4 + s3;
        }), e3);
      }
      var b = m, y = n2(508), A = n2(584), N = n2(266);
      class v extends N.A {
        static DEFAULTS = { delay: 1e3, maxStack: 100, userOnly: false };
        lastRecorded = 0;
        ignoreChange = false;
        stack = { undo: [], redo: [] };
        currentRange = null;
        constructor(t3, e3) {
          super(t3, e3), this.quill.on(s2.Ay.events.EDITOR_CHANGE, ((t4, e4, n3, i2) => {
            t4 === s2.Ay.events.SELECTION_CHANGE ? e4 && i2 !== s2.Ay.sources.SILENT && (this.currentRange = e4) : t4 === s2.Ay.events.TEXT_CHANGE && (this.ignoreChange || (this.options.userOnly && i2 !== s2.Ay.sources.USER ? this.transform(e4) : this.record(e4, n3)), this.currentRange = x(this.currentRange, e4));
          })), this.quill.keyboard.addBinding({ key: "z", shortKey: true }, this.undo.bind(this)), this.quill.keyboard.addBinding({ key: ["z", "Z"], shortKey: true, shiftKey: true }, this.redo.bind(this)), /Win/i.test(navigator.platform) && this.quill.keyboard.addBinding({ key: "y", shortKey: true }, this.redo.bind(this)), this.quill.root.addEventListener("beforeinput", ((t4) => {
            "historyUndo" === t4.inputType ? (this.undo(), t4.preventDefault()) : "historyRedo" === t4.inputType && (this.redo(), t4.preventDefault());
          }));
        }
        change(t3, e3) {
          if (0 === this.stack[t3].length) return;
          const n3 = this.stack[t3].pop();
          if (!n3) return;
          const i2 = this.quill.getContents(), r2 = n3.delta.invert(i2);
          this.stack[e3].push({ delta: r2, range: x(n3.range, r2) }), this.lastRecorded = 0, this.ignoreChange = true, this.quill.updateContents(n3.delta, s2.Ay.sources.USER), this.ignoreChange = false, this.restoreSelection(n3);
        }
        clear() {
          this.stack = { undo: [], redo: [] };
        }
        cutoff() {
          this.lastRecorded = 0;
        }
        record(t3, e3) {
          if (0 === t3.ops.length) return;
          this.stack.redo = [];
          let n3 = t3.invert(e3), s3 = this.currentRange;
          const i2 = Date.now();
          if (this.lastRecorded + this.options.delay > i2 && this.stack.undo.length > 0) {
            const t4 = this.stack.undo.pop();
            t4 && (n3 = n3.compose(t4.delta), s3 = t4.range);
          } else this.lastRecorded = i2;
          0 !== n3.length() && (this.stack.undo.push({ delta: n3, range: s3 }), this.stack.undo.length > this.options.maxStack && this.stack.undo.shift());
        }
        redo() {
          this.change("redo", "undo");
        }
        transform(t3) {
          E(this.stack.undo, t3), E(this.stack.redo, t3);
        }
        undo() {
          this.change("undo", "redo");
        }
        restoreSelection(t3) {
          if (t3.range) this.quill.setSelection(t3.range, s2.Ay.sources.USER);
          else {
            const e3 = (function(t4, e4) {
              const n3 = e4.reduce(((t5, e5) => t5 + (e5.delete || 0)), 0);
              let s3 = e4.length() - n3;
              return (function(t5, e5) {
                const n4 = e5.ops[e5.ops.length - 1];
                return null != n4 && (null != n4.insert ? "string" == typeof n4.insert && n4.insert.endsWith("\n") : null != n4.attributes && Object.keys(n4.attributes).some(((e6) => null != t5.query(e6, h.Scope.BLOCK))));
              })(t4, e4) && (s3 -= 1), s3;
            })(this.quill.scroll, t3.delta);
            this.quill.setSelection(e3, s2.Ay.sources.USER);
          }
        }
      }
      function E(t3, e3) {
        let n3 = e3;
        for (let e4 = t3.length - 1; e4 >= 0; e4 -= 1) {
          const s3 = t3[e4];
          t3[e4] = { delta: n3.transform(s3.delta, true), range: s3.range && x(s3.range, n3) }, n3 = s3.delta.transform(n3), 0 === t3[e4].delta.length() && t3.splice(e4, 1);
        }
      }
      function x(t3, e3) {
        if (!t3) return t3;
        const n3 = e3.transformPosition(t3.index);
        return { index: n3, length: e3.transformPosition(t3.index + t3.length) - n3 };
      }
      var L = n2(123);
      class S extends N.A {
        constructor(t3, e3) {
          super(t3, e3), t3.root.addEventListener("drop", ((e4) => {
            e4.preventDefault();
            let n3 = null;
            if (document.caretRangeFromPoint) n3 = document.caretRangeFromPoint(e4.clientX, e4.clientY);
            else if (document.caretPositionFromPoint) {
              const t4 = document.caretPositionFromPoint(e4.clientX, e4.clientY);
              n3 = document.createRange(), n3.setStart(t4.offsetNode, t4.offset), n3.setEnd(t4.offsetNode, t4.offset);
            }
            const s3 = n3 && t3.selection.normalizeNative(n3);
            if (s3) {
              const n4 = t3.selection.normalizedToRange(s3);
              e4.dataTransfer?.files && this.upload(n4, e4.dataTransfer.files);
            }
          }));
        }
        upload(t3, e3) {
          const n3 = [];
          Array.from(e3).forEach(((t4) => {
            t4 && this.options.mimetypes?.includes(t4.type) && n3.push(t4);
          })), n3.length > 0 && this.options.handler.call(this, t3, n3);
        }
      }
      S.DEFAULTS = { mimetypes: ["image/png", "image/jpeg"], handler(t3, e3) {
        if (!this.quill.scroll.query("image")) return;
        const n3 = e3.map(((t4) => new Promise(((e4) => {
          const n4 = new FileReader();
          n4.onload = () => {
            e4(n4.result);
          }, n4.readAsDataURL(t4);
        }))));
        Promise.all(n3).then(((e4) => {
          const n4 = e4.reduce(((t4, e5) => t4.insert({ image: e5 })), new u.Ay().retain(t3.index).delete(t3.length));
          this.quill.updateContents(n4, d.A.sources.USER), this.quill.setSelection(t3.index + e4.length, d.A.sources.SILENT);
        }));
      } };
      var T = S;
      const k = ["insertText", "insertReplacementText"];
      class O extends N.A {
        constructor(t3, e3) {
          super(t3, e3), t3.root.addEventListener("beforeinput", ((t4) => {
            this.handleBeforeInput(t4);
          })), /Android/i.test(navigator.userAgent) || t3.on(s2.Ay.events.COMPOSITION_BEFORE_START, (() => {
            this.handleCompositionStart();
          }));
        }
        deleteRange(t3) {
          (0, L.Xo)({ range: t3, quill: this.quill });
        }
        replaceText(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
          if (0 === t3.length) return false;
          if (e3) {
            const n3 = this.quill.getFormat(t3.index, 1);
            this.deleteRange(t3), this.quill.updateContents(new u.Ay().retain(t3.index).insert(e3, n3), s2.Ay.sources.USER);
          } else this.deleteRange(t3);
          return this.quill.setSelection(t3.index + e3.length, 0, s2.Ay.sources.SILENT), true;
        }
        handleBeforeInput(t3) {
          if (this.quill.composition.isComposing || t3.defaultPrevented || !k.includes(t3.inputType)) return;
          const e3 = t3.getTargetRanges ? t3.getTargetRanges()[0] : null;
          if (!e3 || true === e3.collapsed) return;
          const n3 = (function(t4) {
            return "string" == typeof t4.data ? t4.data : t4.dataTransfer?.types.includes("text/plain") ? t4.dataTransfer.getData("text/plain") : null;
          })(t3);
          if (null == n3) return;
          const s3 = this.quill.selection.normalizeNative(e3), i2 = s3 ? this.quill.selection.normalizedToRange(s3) : null;
          i2 && this.replaceText(i2, n3) && t3.preventDefault();
        }
        handleCompositionStart() {
          const t3 = this.quill.getSelection();
          t3 && this.replaceText(t3);
        }
      }
      var w = O;
      const C = /Mac/i.test(navigator.platform);
      class q extends N.A {
        isListening = false;
        selectionChangeDeadline = 0;
        constructor(t3, e3) {
          super(t3, e3), this.handleArrowKeys(), this.handleNavigationShortcuts();
        }
        handleArrowKeys() {
          this.quill.keyboard.addBinding({ key: ["ArrowLeft", "ArrowRight"], offset: 0, shiftKey: null, handler(t3, e3) {
            let { line: n3, event: i2 } = e3;
            if (!(n3 instanceof h.ParentBlot && n3.uiNode)) return true;
            const r2 = "rtl" === getComputedStyle(n3.domNode).direction;
            return !!(r2 && "ArrowRight" !== i2.key || !r2 && "ArrowLeft" !== i2.key) || (this.quill.setSelection(t3.index - 1, t3.length + (i2.shiftKey ? 1 : 0), s2.Ay.sources.USER), false);
          } });
        }
        handleNavigationShortcuts() {
          this.quill.root.addEventListener("keydown", ((t3) => {
            !t3.defaultPrevented && ((t4) => "ArrowLeft" === t4.key || "ArrowRight" === t4.key || "ArrowUp" === t4.key || "ArrowDown" === t4.key || "Home" === t4.key || !(!C || "a" !== t4.key || true !== t4.ctrlKey))(t3) && this.ensureListeningToSelectionChange();
          }));
        }
        ensureListeningToSelectionChange() {
          this.selectionChangeDeadline = Date.now() + 100, this.isListening || (this.isListening = true, document.addEventListener("selectionchange", (() => {
            this.isListening = false, Date.now() <= this.selectionChangeDeadline && this.handleSelectionChange();
          }), { once: true }));
        }
        handleSelectionChange() {
          const t3 = document.getSelection();
          if (!t3) return;
          const e3 = t3.getRangeAt(0);
          if (true !== e3.collapsed || 0 !== e3.startOffset) return;
          const n3 = this.quill.scroll.find(e3.startContainer);
          if (!(n3 instanceof h.ParentBlot && n3.uiNode)) return;
          const s3 = document.createRange();
          s3.setStartAfter(n3.uiNode), s3.setEndAfter(n3.uiNode), t3.removeAllRanges(), t3.addRange(s3);
        }
      }
      var R = q;
      s2.Ay.register({ "blots/block": i.Ay, "blots/block/embed": i.zo, "blots/break": r.A, "blots/container": o.A, "blots/cursor": l.A, "blots/embed": a.A, "blots/inline": c.A, "blots/scroll": b, "blots/text": y.A, "modules/clipboard": A.Ay, "modules/history": v, "modules/keyboard": L.Ay, "modules/uploader": T, "modules/input": w, "modules/uiNode": R });
      var B = s2.Ay;
    }, 200: function(t2, e2, n2) {
      n2.d(e2, { A: function() {
        return l;
      } });
      class s2 {
        listener;
        context;
        once;
        constructor(t3, e3, n3 = false) {
          this.listener = t3, this.context = e3, this.once = n3;
        }
      }
      class i {
        static prefixed = false;
        _events = /* @__PURE__ */ Object.create(null);
        _eventsCount = 0;
        #t(t3, e3, n3, i2) {
          if ("function" != typeof e3) throw new TypeError("The listener must be a function");
          const r2 = new s2(e3, n3 || this, i2), o2 = this._events[t3];
          return Array.isArray(o2) ? o2.push(r2) : o2 ? this._events[t3] = [o2, r2] : (this._events[t3] = r2, this._eventsCount++), this;
        }
        clearEvent(t3) {
          0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete this._events[t3];
        }
        eventNames() {
          return 0 === this._eventsCount ? [] : Reflect.ownKeys(this._events);
        }
        listeners(t3) {
          const e3 = this._events[t3];
          return e3 ? Array.isArray(e3) ? e3.map(((t4) => t4.listener)) : [e3.listener] : [];
        }
        listenerCount(t3) {
          const e3 = this._events[t3];
          return e3 ? Array.isArray(e3) ? e3.length : 1 : 0;
        }
        emit(t3, ...e3) {
          const n3 = this._events[t3];
          return !!n3 && (Array.isArray(n3) ? n3.slice(0).forEach(((n4) => {
            n4.once && this.removeListener(t3, n4.listener, void 0, true), n4.listener.call(n4.context, ...e3);
          })) : (n3.once && this.removeListener(t3, n3.listener, void 0, true), n3.listener.call(n3.context, ...e3)), true);
        }
        on(t3, e3, n3) {
          return this.#t(t3, e3, n3, false);
        }
        once(t3, e3, n3) {
          return this.#t(t3, e3, n3, true);
        }
        removeListener(t3, e3, n3, s3) {
          const i2 = this._events[t3];
          if (!i2) return this;
          if (!e3) return this.clearEvent(t3), this;
          if (Array.isArray(i2)) {
            const r2 = [];
            i2.forEach(((t4) => {
              (t4.listener !== e3 || s3 && !t4.once || n3 && t4.context !== n3) && r2.push(t4);
            })), r2.length ? this._events[t3] = 1 === r2.length ? r2[0] : r2 : this.clearEvent(t3);
          } else i2.listener !== e3 || s3 && !i2.once || n3 && i2.context !== n3 || this.clearEvent(t3);
          return this;
        }
        removeAllListeners(t3) {
          return t3 ? this._events[t3] && this.clearEvent(t3) : (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this;
        }
        off(t3, e3, n3, s3) {
          return this.removeListener(t3, e3, n3, s3);
        }
        addListener(t3, e3, n3) {
          return this.on(t3, e3, n3);
        }
      }
      const r = (0, n2(78).A)("quill:events"), o = [];
      ["selectionchange", "mousedown", "mouseup", "click"].forEach(((t3) => {
        document.addEventListener(t3, (function() {
          for (var t4 = arguments.length, e3 = new Array(t4), n3 = 0; n3 < t4; n3++) e3[n3] = arguments[n3];
          o.forEach(((t5) => {
            t5.handleDOM(...e3);
          }));
        }));
      }));
      var l = class extends i {
        static events = { EDITOR_CHANGE: "editor-change", SCROLL_BEFORE_UPDATE: "scroll-before-update", SCROLL_BLOT_MOUNT: "scroll-blot-mount", SCROLL_BLOT_UNMOUNT: "scroll-blot-unmount", SCROLL_OPTIMIZE: "scroll-optimize", SCROLL_UPDATE: "scroll-update", SCROLL_EMBED_UPDATE: "scroll-embed-update", SELECTION_CHANGE: "selection-change", TEXT_CHANGE: "text-change", COMPOSITION_BEFORE_START: "composition-before-start", COMPOSITION_START: "composition-start", COMPOSITION_BEFORE_END: "composition-before-end", COMPOSITION_END: "composition-end" };
        static sources = { API: "api", SILENT: "silent", USER: "user" };
        constructor() {
          super(), this.domListeners = {}, this.on("error", r.error);
        }
        connect() {
          o.push(this);
        }
        disconnect() {
          o.splice(o.indexOf(this), 1);
        }
        emit() {
          for (var t3 = arguments.length, e3 = new Array(t3), n3 = 0; n3 < t3; n3++) e3[n3] = arguments[n3];
          return r.log.call(r, ...e3), super.emit(...e3);
        }
        handleDOM(t3) {
          for (var e3 = arguments.length, n3 = new Array(e3 > 1 ? e3 - 1 : 0), s3 = 1; s3 < e3; s3++) n3[s3 - 1] = arguments[s3];
          const i2 = t3.composedPath()[0];
          (this.domListeners[t3.type] || []).forEach(((e4) => {
            let { node: s4, handler: r2 } = e4;
            (i2 === s4 || ((t4, e5) => {
              if (e5.getRootNode() === document) return t4.contains(e5);
              for (; !t4.contains(e5); ) {
                const t5 = e5.getRootNode();
                if (!t5) return false;
                const n4 = t5.host;
                if (!n4) return false;
                e5 = n4;
              }
              return true;
            })(s4, i2)) && r2(t3, ...n3);
          }));
        }
        listenDOM(t3, e3, n3) {
          this.domListeners[t3] || (this.domListeners[t3] = []), this.domListeners[t3].push({ node: e3, handler: n3 });
        }
      };
    }, 78: function(t2, e2) {
      const n2 = ["error", "warn", "log", "info"];
      let s2 = "warn";
      function i(t3) {
        if (s2 && n2.indexOf(t3) <= n2.indexOf(s2)) {
          for (var e3 = arguments.length, i2 = new Array(e3 > 1 ? e3 - 1 : 0), r2 = 1; r2 < e3; r2++) i2[r2 - 1] = arguments[r2];
          console[t3](...i2);
        }
      }
      function r(t3) {
        return n2.reduce(((e3, n3) => (e3[n3] = i.bind(console, n3, t3), e3)), {});
      }
      r.level = (t3) => {
        s2 = t3;
      }, i.level = r.level, e2.A = r;
    }, 266: function(t2, e2) {
      e2.A = class {
        static DEFAULTS = {};
        constructor(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.quill = t3, this.options = e3;
        }
      };
    }, 543: function(t2, e2, n2) {
      n2.d(e2, { Ay: function() {
        return B;
      } });
      var s2 = n2(3), i = n2(398), r = n2(698), o = n2(36), l = n2(541), a = n2(508), c = n2(298), h = n2(857), u = n2(697);
      const d = /^[ -~]*$/;
      function f(t3, e3, n3) {
        if (0 === t3.length) {
          const [t4] = g(n3.pop());
          return e3 <= 0 ? `</li></${t4}>` : `</li></${t4}>${f([], e3 - 1, n3)}`;
        }
        const [{ child: s3, offset: i2, length: r2, indent: o2, type: l2 }, ...a2] = t3, [c2, h2] = g(l2);
        if (o2 > e3) return n3.push(l2), o2 === e3 + 1 ? `<${c2}><li${h2}>${p(s3, i2, r2)}${f(a2, o2, n3)}` : `<${c2}><li>${f(t3, e3 + 1, n3)}`;
        const u2 = n3[n3.length - 1];
        if (o2 === e3 && l2 === u2) return `</li><li${h2}>${p(s3, i2, r2)}${f(a2, o2, n3)}`;
        const [d2] = g(n3.pop());
        return `</li></${d2}>${f(t3, e3 - 1, n3)}`;
      }
      function p(t3, e3, n3) {
        let i2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        if ("html" in t3 && "function" == typeof t3.html) return t3.html(e3, n3);
        if (t3 instanceof a.A) return (0, a.X)(t3.value().slice(e3, e3 + n3)).replaceAll(/  +/g, ((t4) => "&nbsp;".repeat(t4.length - 1) + " "));
        if (t3 instanceof s2.ParentBlot) {
          if ("list-container" === t3.statics.blotName) {
            const s4 = [];
            return t3.children.forEachAt(e3, n3, ((t4, e4, n4) => {
              const i3 = "formats" in t4 && "function" == typeof t4.formats ? t4.formats() : {};
              s4.push({ child: t4, offset: e4, length: n4, indent: i3.indent || 0, type: i3.list });
            })), f(s4, -1, []);
          }
          const s3 = [];
          if (t3.children.forEachAt(e3, n3, ((t4, e4, n4) => {
            s3.push(p(t4, e4, n4));
          })), i2 || "list" === t3.statics.blotName) return s3.join("");
          const { outerHTML: r2, innerHTML: o2 } = t3.domNode, [l2, a2] = r2.split(`>${o2}<`);
          return "<table" === l2 ? `<table style="border: 1px solid #000;">${s3.join("")}<${a2}` : `${l2}>${s3.join("")}<${a2}`;
        }
        return t3.domNode instanceof Element ? t3.domNode.outerHTML : "";
      }
      function m(t3, e3) {
        return Object.keys(e3).reduce(((n3, s3) => {
          if (null == t3[s3]) return n3;
          const i2 = e3[s3];
          return i2 === t3[s3] ? n3[s3] = i2 : Array.isArray(i2) ? i2.indexOf(t3[s3]) < 0 ? n3[s3] = i2.concat([t3[s3]]) : n3[s3] = i2 : n3[s3] = [i2, t3[s3]], n3;
        }), {});
      }
      function g(t3) {
        const e3 = "ordered" === t3 ? "ol" : "ul";
        switch (t3) {
          case "checked":
            return [e3, ' data-list="checked"'];
          case "unchecked":
            return [e3, ' data-list="unchecked"'];
          default:
            return [e3, ""];
        }
      }
      function b(t3) {
        return t3.reduce(((t4, e3) => {
          if ("string" == typeof e3.insert) {
            const n3 = e3.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
            return t4.insert(n3, e3.attributes);
          }
          return t4.push(e3);
        }), new i.Ay());
      }
      function y(t3, e3) {
        let { index: n3, length: s3 } = t3;
        return new c.Q(n3 + e3, s3);
      }
      var A = class {
        constructor(t3) {
          this.scroll = t3, this.delta = this.getDelta();
        }
        applyDelta(t3) {
          this.scroll.update();
          let e3 = this.scroll.length();
          this.scroll.batchStart();
          const n3 = b(t3), o2 = new i.Ay();
          return (function(t4) {
            const e4 = [];
            return t4.forEach(((t5) => {
              "string" == typeof t5.insert ? t5.insert.split("\n").forEach(((n4, s3) => {
                s3 && e4.push({ insert: "\n", attributes: t5.attributes }), n4 && e4.push({ insert: n4, attributes: t5.attributes });
              })) : e4.push(t5);
            })), e4;
          })(n3.ops.slice()).reduce(((t4, n4) => {
            const l2 = i.Op.length(n4);
            let c2 = n4.attributes || {}, h2 = false, u2 = false;
            if (null != n4.insert) {
              if (o2.retain(l2), "string" == typeof n4.insert) {
                const o3 = n4.insert;
                u2 = !o3.endsWith("\n") && (e3 <= t4 || !!this.scroll.descendant(r.zo, t4)[0]), this.scroll.insertAt(t4, o3);
                const [l3, a2] = this.scroll.line(t4);
                let h3 = Object.assign({}, (0, r.Ji)(l3));
                if (l3 instanceof r.Ay) {
                  const [t5] = l3.descendant(s2.LeafBlot, a2);
                  t5 && (h3 = Object.assign(h3, (0, r.Ji)(t5)));
                }
                c2 = i.xb.diff(h3, c2) || {};
              } else if ("object" == typeof n4.insert) {
                const o3 = Object.keys(n4.insert)[0];
                if (null == o3) return t4;
                const l3 = null != this.scroll.query(o3, s2.Scope.INLINE);
                if (l3) (e3 <= t4 || this.scroll.descendant(r.zo, t4)[0]) && (u2 = true);
                else if (t4 > 0) {
                  const [e4, n5] = this.scroll.descendant(s2.LeafBlot, t4 - 1);
                  e4 instanceof a.A ? "\n" !== e4.value()[n5] && (h2 = true) : e4 instanceof s2.EmbedBlot && e4.statics.scope === s2.Scope.INLINE_BLOT && (h2 = true);
                }
                if (this.scroll.insertAt(t4, o3, n4.insert[o3]), l3) {
                  const [e4] = this.scroll.descendant(s2.LeafBlot, t4);
                  if (e4) {
                    const t5 = Object.assign({}, (0, r.Ji)(e4));
                    c2 = i.xb.diff(t5, c2) || {};
                  }
                }
              }
              e3 += l2;
            } else if (o2.push(n4), null !== n4.retain && "object" == typeof n4.retain) {
              const e4 = Object.keys(n4.retain)[0];
              if (null == e4) return t4;
              this.scroll.updateEmbedAt(t4, e4, n4.retain[e4]);
            }
            Object.keys(c2).forEach(((e4) => {
              this.scroll.formatAt(t4, l2, e4, c2[e4]);
            }));
            const d2 = h2 ? 1 : 0, f2 = u2 ? 1 : 0;
            return e3 += d2 + f2, o2.retain(d2), o2.delete(f2), t4 + l2 + d2 + f2;
          }), 0), o2.reduce(((t4, e4) => "number" == typeof e4.delete ? (this.scroll.deleteAt(t4, e4.delete), t4) : t4 + i.Op.length(e4)), 0), this.scroll.batchEnd(), this.scroll.optimize(), this.update(n3);
        }
        deleteText(t3, e3) {
          return this.scroll.deleteAt(t3, e3), this.update(new i.Ay().retain(t3).delete(e3));
        }
        formatLine(t3, e3) {
          let n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          this.scroll.update(), Object.keys(n3).forEach(((s4) => {
            this.scroll.lines(t3, Math.max(e3, 1)).forEach(((t4) => {
              t4.format(s4, n3[s4]);
            }));
          })), this.scroll.optimize();
          const s3 = new i.Ay().retain(t3).retain(e3, (0, h.A)(n3));
          return this.update(s3);
        }
        formatText(t3, e3) {
          let n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          Object.keys(n3).forEach(((s4) => {
            this.scroll.formatAt(t3, e3, s4, n3[s4]);
          }));
          const s3 = new i.Ay().retain(t3).retain(e3, (0, h.A)(n3));
          return this.update(s3);
        }
        getContents(t3, e3) {
          return this.delta.slice(t3, t3 + e3);
        }
        getDelta() {
          return this.scroll.lines().reduce(((t3, e3) => t3.concat(e3.delta())), new i.Ay());
        }
        getFormat(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n3 = [], i2 = [];
          0 === e3 ? this.scroll.path(t3).forEach(((t4) => {
            const [e4] = t4;
            e4 instanceof r.Ay ? n3.push(e4) : e4 instanceof s2.LeafBlot && i2.push(e4);
          })) : (n3 = this.scroll.lines(t3, e3), i2 = this.scroll.descendants(s2.LeafBlot, t3, e3));
          const [o2, l2] = [n3, i2].map(((t4) => {
            const e4 = t4.shift();
            if (null == e4) return {};
            let n4 = (0, r.Ji)(e4);
            for (; Object.keys(n4).length > 0; ) {
              const e5 = t4.shift();
              if (null == e5) return n4;
              n4 = m((0, r.Ji)(e5), n4);
            }
            return n4;
          }));
          return { ...o2, ...l2 };
        }
        getHTML(t3, e3) {
          const [n3, s3] = this.scroll.line(t3);
          if (n3) {
            const i2 = n3.length();
            return n3.length() >= s3 + e3 && (0 !== s3 || e3 !== i2) ? p(n3, s3, e3, true) : p(this.scroll, t3, e3, true);
          }
          return "";
        }
        getText(t3, e3) {
          return this.getContents(t3, e3).filter(((t4) => "string" == typeof t4.insert)).map(((t4) => t4.insert)).join("");
        }
        insertContents(t3, e3) {
          const n3 = b(e3), s3 = new i.Ay().retain(t3).concat(n3);
          return this.scroll.insertContents(t3, n3), this.update(s3);
        }
        insertEmbed(t3, e3, n3) {
          return this.scroll.insertAt(t3, e3, n3), this.update(new i.Ay().retain(t3).insert({ [e3]: n3 }));
        }
        insertText(t3, e3) {
          let n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          return e3 = e3.replace(/\r\n/g, "\n").replace(/\r/g, "\n"), this.scroll.insertAt(t3, e3), Object.keys(n3).forEach(((s3) => {
            this.scroll.formatAt(t3, e3.length, s3, n3[s3]);
          })), this.update(new i.Ay().retain(t3).insert(e3, (0, h.A)(n3)));
        }
        isBlank() {
          if (0 === this.scroll.children.length) return true;
          if (this.scroll.children.length > 1) return false;
          const t3 = this.scroll.children.head;
          if (t3?.statics.blotName !== r.Ay.blotName) return false;
          const e3 = t3;
          return !(e3.children.length > 1) && e3.children.head instanceof o.A;
        }
        removeFormat(t3, e3) {
          const n3 = this.getText(t3, e3), [s3, r2] = this.scroll.line(t3 + e3);
          let o2 = 0, l2 = new i.Ay();
          null != s3 && (o2 = s3.length() - r2, l2 = s3.delta().slice(r2, r2 + o2 - 1).insert("\n"));
          const a2 = this.getContents(t3, e3 + o2).diff(new i.Ay().insert(n3).concat(l2)), c2 = new i.Ay().retain(t3).concat(a2);
          return this.applyDelta(c2);
        }
        update(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
          const s3 = this.delta;
          if (1 === e3.length && "characterData" === e3[0].type && e3[0].target.data.match(d) && this.scroll.find(e3[0].target)) {
            const o2 = this.scroll.find(e3[0].target), a2 = (0, r.Ji)(o2), c2 = o2.offset(this.scroll), h2 = e3[0].oldValue.replace(l.A.CONTENTS, ""), u2 = new i.Ay().insert(h2), d2 = new i.Ay().insert(o2.value()), f2 = n3 && { oldRange: y(n3.oldRange, -c2), newRange: y(n3.newRange, -c2) };
            t3 = new i.Ay().retain(c2).concat(u2.diff(d2, f2)).reduce(((t4, e4) => e4.insert ? t4.insert(e4.insert, a2) : t4.push(e4)), new i.Ay()), this.delta = s3.compose(t3);
          } else this.delta = this.getDelta(), t3 && (0, u.A)(s3.compose(t3), this.delta) || (t3 = s3.diff(this.delta, n3));
          return t3;
        }
      }, N = n2(200), v = /* @__PURE__ */ new WeakMap(), E = n2(78), x = n2(266), L = n2(746), S = class {
        isComposing = false;
        constructor(t3, e3) {
          this.scroll = t3, this.emitter = e3, this.setupListeners();
        }
        setupListeners() {
          this.scroll.domNode.addEventListener("compositionstart", ((t3) => {
            this.isComposing || this.handleCompositionStart(t3);
          })), this.scroll.domNode.addEventListener("compositionend", ((t3) => {
            this.isComposing && queueMicrotask((() => {
              this.handleCompositionEnd(t3);
            }));
          }));
        }
        handleCompositionStart(t3) {
          const e3 = t3.target instanceof Node ? this.scroll.find(t3.target, true) : null;
          !e3 || e3 instanceof L.A || (this.emitter.emit(N.A.events.COMPOSITION_BEFORE_START, t3), this.scroll.batchStart(), this.emitter.emit(N.A.events.COMPOSITION_START, t3), this.isComposing = true);
        }
        handleCompositionEnd(t3) {
          this.emitter.emit(N.A.events.COMPOSITION_BEFORE_END, t3), this.scroll.batchEnd(), this.emitter.emit(N.A.events.COMPOSITION_END, t3), this.isComposing = false;
        }
      }, T = n2(609);
      const k = (t3) => {
        const e3 = t3.getBoundingClientRect(), n3 = "offsetWidth" in t3 && Math.abs(e3.width) / t3.offsetWidth || 1, s3 = "offsetHeight" in t3 && Math.abs(e3.height) / t3.offsetHeight || 1;
        return { top: e3.top, right: e3.left + t3.clientWidth * n3, bottom: e3.top + t3.clientHeight * s3, left: e3.left };
      }, O = (t3) => {
        const e3 = parseInt(t3, 10);
        return Number.isNaN(e3) ? 0 : e3;
      }, w = (t3, e3, n3, s3, i2, r2) => t3 < n3 && e3 > s3 ? 0 : t3 < n3 ? -(n3 - t3 + i2) : e3 > s3 ? e3 - t3 > s3 - n3 ? t3 + i2 - n3 : e3 - s3 + r2 : 0;
      const C = ["block", "break", "cursor", "inline", "scroll", "text"];
      const q = (0, E.A)("quill"), R = new s2.Registry();
      s2.ParentBlot.uiClass = "ql-ui";
      class B {
        static DEFAULTS = { bounds: null, modules: { clipboard: true, keyboard: true, history: true, uploader: true }, placeholder: "", readOnly: false, registry: R, theme: "default" };
        static events = N.A.events;
        static sources = N.A.sources;
        static version = "2.0.3";
        static imports = { delta: i.Ay, parchment: s2, "core/module": x.A, "core/theme": T.A };
        static debug(t3) {
          true === t3 && (t3 = "log"), E.A.level(t3);
        }
        static find(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return v.get(t3) || R.find(t3, e3);
        }
        static import(t3) {
          return null == this.imports[t3] && q.error(`Cannot import ${t3}. Are you sure it was registered?`), this.imports[t3];
        }
        static register() {
          if ("string" != typeof (arguments.length <= 0 ? void 0 : arguments[0])) {
            const t3 = arguments.length <= 0 ? void 0 : arguments[0], e3 = !!(arguments.length <= 1 ? void 0 : arguments[1]), n3 = "attrName" in t3 ? t3.attrName : t3.blotName;
            "string" == typeof n3 ? this.register(`formats/${n3}`, t3, e3) : Object.keys(t3).forEach(((n4) => {
              this.register(n4, t3[n4], e3);
            }));
          } else {
            const t3 = arguments.length <= 0 ? void 0 : arguments[0], e3 = arguments.length <= 1 ? void 0 : arguments[1], n3 = !!(arguments.length <= 2 ? void 0 : arguments[2]);
            null == this.imports[t3] || n3 || q.warn(`Overwriting ${t3} with`, e3), this.imports[t3] = e3, (t3.startsWith("blots/") || t3.startsWith("formats/")) && e3 && "boolean" != typeof e3 && "abstract" !== e3.blotName && R.register(e3), "function" == typeof e3.register && e3.register(R);
          }
        }
        constructor(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if (this.options = (function(t4, e4) {
            const n4 = I(t4);
            if (!n4) throw new Error("Invalid Quill container");
            const i2 = !e4.theme || e4.theme === B.DEFAULTS.theme ? T.A : B.import(`themes/${e4.theme}`);
            if (!i2) throw new Error(`Invalid theme ${e4.theme}. Did you register it?`);
            const { modules: r3, ...o3 } = B.DEFAULTS, { modules: l2, ...a2 } = i2.DEFAULTS;
            let c2 = D(e4.modules);
            null != c2 && c2.toolbar && c2.toolbar.constructor !== Object && (c2 = { ...c2, toolbar: { container: c2.toolbar } });
            const h2 = { ...D(r3), ...D(l2), ...c2 }, u2 = { ...o3, ...M(a2), ...M(e4) };
            let d2 = e4.registry;
            return d2 ? e4.formats && q.warn('Ignoring "formats" option because "registry" is specified') : d2 = e4.formats ? ((t5, e5, n5) => {
              const i3 = new s2.Registry();
              return C.forEach(((t6) => {
                const n6 = e5.query(t6);
                n6 && i3.register(n6);
              })), t5.forEach(((t6) => {
                let s3 = e5.query(t6);
                s3 || n5.error(`Cannot register "${t6}" specified in "formats" config. Are you sure it was registered?`);
                let r4 = 0;
                for (; s3; ) if (i3.register(s3), s3 = "blotName" in s3 ? s3.requiredContainer ?? null : null, r4 += 1, r4 > 100) {
                  n5.error(`Cycle detected in registering blot requiredContainer: "${t6}"`);
                  break;
                }
              })), i3;
            })(e4.formats, u2.registry, q) : u2.registry, { ...u2, registry: d2, container: n4, theme: i2, modules: Object.entries(h2).reduce(((t5, e5) => {
              let [n5, s3] = e5;
              if (!s3) return t5;
              const i3 = B.import(`modules/${n5}`);
              return null == i3 ? (q.error(`Cannot load ${n5} module. Are you sure you registered it?`), t5) : { ...t5, [n5]: { ...i3.DEFAULTS || {}, ...s3 } };
            }), {}), bounds: I(u2.bounds) };
          })(t3, e3), this.container = this.options.container, null == this.container) return void q.error("Invalid Quill container", t3);
          this.options.debug && B.debug(this.options.debug);
          const n3 = this.container.innerHTML.trim();
          this.container.classList.add("ql-container"), this.container.innerHTML = "", v.set(this.container, this), this.root = this.addContainer("ql-editor"), this.root.classList.add("ql-blank"), this.emitter = new N.A();
          const r2 = s2.ScrollBlot.blotName, o2 = this.options.registry.query(r2);
          if (!o2 || !("blotName" in o2)) throw new Error(`Cannot initialize Quill without "${r2}" blot`);
          if (this.scroll = new o2(this.options.registry, this.root, { emitter: this.emitter }), this.editor = new A(this.scroll), this.selection = new c.A(this.scroll, this.emitter), this.composition = new S(this.scroll, this.emitter), this.theme = new this.options.theme(this, this.options), this.keyboard = this.theme.addModule("keyboard"), this.clipboard = this.theme.addModule("clipboard"), this.history = this.theme.addModule("history"), this.uploader = this.theme.addModule("uploader"), this.theme.addModule("input"), this.theme.addModule("uiNode"), this.theme.init(), this.emitter.on(N.A.events.EDITOR_CHANGE, ((t4) => {
            t4 === N.A.events.TEXT_CHANGE && this.root.classList.toggle("ql-blank", this.editor.isBlank());
          })), this.emitter.on(N.A.events.SCROLL_UPDATE, ((t4, e4) => {
            const n4 = this.selection.lastRange, [s3] = this.selection.getRange(), i2 = n4 && s3 ? { oldRange: n4, newRange: s3 } : void 0;
            U.call(this, (() => this.editor.update(null, e4, i2)), t4);
          })), this.emitter.on(N.A.events.SCROLL_EMBED_UPDATE, ((t4, e4) => {
            const n4 = this.selection.lastRange, [s3] = this.selection.getRange(), r3 = n4 && s3 ? { oldRange: n4, newRange: s3 } : void 0;
            U.call(this, (() => {
              const n5 = new i.Ay().retain(t4.offset(this)).retain({ [t4.statics.blotName]: e4 });
              return this.editor.update(n5, [], r3);
            }), B.sources.USER);
          })), n3) {
            const t4 = this.clipboard.convert({ html: `${n3}<p><br></p>`, text: "\n" });
            this.setContents(t4);
          }
          this.history.clear(), this.options.placeholder && this.root.setAttribute("data-placeholder", this.options.placeholder), this.options.readOnly && this.disable(), this.allowReadOnlyEdits = false;
        }
        addContainer(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
          if ("string" == typeof t3) {
            const e4 = t3;
            (t3 = document.createElement("div")).classList.add(e4);
          }
          return this.container.insertBefore(t3, e3), t3;
        }
        blur() {
          this.selection.setRange(null);
        }
        deleteText(t3, e3, n3) {
          return [t3, e3, , n3] = _(t3, e3, n3), U.call(this, (() => this.editor.deleteText(t3, e3)), n3, t3, -1 * e3);
        }
        disable() {
          this.enable(false);
        }
        editReadOnly(t3) {
          this.allowReadOnlyEdits = true;
          const e3 = t3();
          return this.allowReadOnlyEdits = false, e3;
        }
        enable() {
          let t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          this.scroll.enable(t3), this.container.classList.toggle("ql-disabled", !t3);
        }
        focus() {
          let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          this.selection.focus(), t3.preventScroll || this.scrollSelectionIntoView();
        }
        format(t3, e3) {
          let n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : N.A.sources.API;
          return U.call(this, (() => {
            if (!this.hasFocus()) {
              this.root.focus({ preventScroll: true });
              const t4 = this.selection.rangeToNative(this.selection.savedRange);
              this.selection.setNativeRange(...t4);
            }
            const [n4] = this.selection.getRange();
            let r2 = new i.Ay();
            if (null == n4) return r2;
            if (this.scroll.query(t3, s2.Scope.BLOCK)) r2 = this.editor.formatLine(n4.index, n4.length, { [t3]: e3 });
            else {
              if (0 === n4.length) return this.selection.format(t3, e3), r2;
              r2 = this.editor.formatText(n4.index, n4.length, { [t3]: e3 });
            }
            return this.setSelection(n4, N.A.sources.SILENT), r2;
          }), n3);
        }
        formatLine(t3, e3, n3, s3, i2) {
          let r2;
          return [t3, e3, r2, i2] = _(t3, e3, n3, s3, i2), U.call(this, (() => this.editor.formatLine(t3, e3, r2)), i2, t3, 0);
        }
        formatText(t3, e3, n3, s3, i2) {
          let r2;
          return [t3, e3, r2, i2] = _(t3, e3, n3, s3, i2), U.call(this, (() => this.editor.formatText(t3, e3, r2)), i2, t3, 0);
        }
        getBounds(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n3 = null;
          if (n3 = "number" == typeof t3 ? this.selection.getBounds(t3, e3) : this.selection.getBounds(t3.index, t3.length), !n3) return null;
          const s3 = this.container.getBoundingClientRect();
          return { bottom: n3.bottom - s3.top, height: n3.height, left: n3.left - s3.left, right: n3.right - s3.left, top: n3.top - s3.top, width: n3.width };
        }
        getContents() {
          let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t3;
          return [t3, e3] = _(t3, e3), this.editor.getContents(t3, e3);
        }
        getFormat() {
          let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getSelection(true), e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          return "number" == typeof t3 ? this.editor.getFormat(t3, e3) : this.editor.getFormat(t3.index, t3.length);
        }
        getIndex(t3) {
          return t3.offset(this.scroll);
        }
        getLength() {
          return this.scroll.length();
        }
        getLeaf(t3) {
          return this.scroll.leaf(t3);
        }
        getLine(t3) {
          return this.scroll.line(t3);
        }
        getLines() {
          let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
          return "number" != typeof t3 ? this.scroll.lines(t3.index, t3.length) : this.scroll.lines(t3, e3);
        }
        getModule(t3) {
          return this.theme.modules[t3];
        }
        getSelection() {
          return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && this.focus(), this.update(), this.selection.getRange()[0];
        }
        getSemanticHTML() {
          let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 ? arguments[1] : void 0;
          return "number" == typeof t3 && (e3 = e3 ?? this.getLength() - t3), [t3, e3] = _(t3, e3), this.editor.getHTML(t3, e3);
        }
        getText() {
          let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 ? arguments[1] : void 0;
          return "number" == typeof t3 && (e3 = e3 ?? this.getLength() - t3), [t3, e3] = _(t3, e3), this.editor.getText(t3, e3);
        }
        hasFocus() {
          return this.selection.hasFocus();
        }
        insertEmbed(t3, e3, n3) {
          let s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : B.sources.API;
          return U.call(this, (() => this.editor.insertEmbed(t3, e3, n3)), s3, t3);
        }
        insertText(t3, e3, n3, s3, i2) {
          let r2;
          return [t3, , r2, i2] = _(t3, 0, n3, s3, i2), U.call(this, (() => this.editor.insertText(t3, e3, r2)), i2, t3, e3.length);
        }
        isEnabled() {
          return this.scroll.isEnabled();
        }
        off() {
          return this.emitter.off(...arguments);
        }
        on() {
          return this.emitter.on(...arguments);
        }
        once() {
          return this.emitter.once(...arguments);
        }
        removeFormat(t3, e3, n3) {
          return [t3, e3, , n3] = _(t3, e3, n3), U.call(this, (() => this.editor.removeFormat(t3, e3)), n3, t3);
        }
        scrollRectIntoView(t3) {
          ((t4, e3) => {
            const n3 = t4.ownerDocument;
            let s3 = e3, i2 = t4;
            for (; i2; ) {
              const t5 = i2 === n3.body, e4 = t5 ? { top: 0, right: window.visualViewport?.width ?? n3.documentElement.clientWidth, bottom: window.visualViewport?.height ?? n3.documentElement.clientHeight, left: 0 } : k(i2), o2 = getComputedStyle(i2), l2 = w(s3.left, s3.right, e4.left, e4.right, O(o2.scrollPaddingLeft), O(o2.scrollPaddingRight)), a2 = w(s3.top, s3.bottom, e4.top, e4.bottom, O(o2.scrollPaddingTop), O(o2.scrollPaddingBottom));
              if (l2 || a2) if (t5) n3.defaultView?.scrollBy(l2, a2);
              else {
                const { scrollLeft: t6, scrollTop: e5 } = i2;
                a2 && (i2.scrollTop += a2), l2 && (i2.scrollLeft += l2);
                const n4 = i2.scrollLeft - t6, r3 = i2.scrollTop - e5;
                s3 = { left: s3.left - n4, top: s3.top - r3, right: s3.right - n4, bottom: s3.bottom - r3 };
              }
              i2 = t5 || "fixed" === o2.position ? null : (r2 = i2).parentElement || r2.getRootNode().host || null;
            }
            var r2;
          })(this.root, t3);
        }
        scrollIntoView() {
          console.warn("Quill#scrollIntoView() has been deprecated and will be removed in the near future. Please use Quill#scrollSelectionIntoView() instead."), this.scrollSelectionIntoView();
        }
        scrollSelectionIntoView() {
          const t3 = this.selection.lastRange, e3 = t3 && this.selection.getBounds(t3.index, t3.length);
          e3 && this.scrollRectIntoView(e3);
        }
        setContents(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : N.A.sources.API;
          return U.call(this, (() => {
            t3 = new i.Ay(t3);
            const e4 = this.getLength(), n3 = this.editor.deleteText(0, e4), s3 = this.editor.insertContents(0, t3), r2 = this.editor.deleteText(this.getLength() - 1, 1);
            return n3.compose(s3).compose(r2);
          }), e3);
        }
        setSelection(t3, e3, n3) {
          null == t3 ? this.selection.setRange(null, e3 || B.sources.API) : ([t3, e3, , n3] = _(t3, e3, n3), this.selection.setRange(new c.Q(Math.max(0, t3), e3), n3), n3 !== N.A.sources.SILENT && this.scrollSelectionIntoView());
        }
        setText(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : N.A.sources.API;
          const n3 = new i.Ay().insert(t3);
          return this.setContents(n3, e3);
        }
        update() {
          let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N.A.sources.USER;
          const e3 = this.scroll.update(t3);
          return this.selection.update(t3), e3;
        }
        updateContents(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : N.A.sources.API;
          return U.call(this, (() => (t3 = new i.Ay(t3), this.editor.applyDelta(t3))), e3, true);
        }
      }
      function I(t3) {
        return "string" == typeof t3 ? document.querySelector(t3) : t3;
      }
      function D(t3) {
        return Object.entries(t3 ?? {}).reduce(((t4, e3) => {
          let [n3, s3] = e3;
          return { ...t4, [n3]: true === s3 ? {} : s3 };
        }), {});
      }
      function M(t3) {
        return Object.fromEntries(Object.entries(t3).filter(((t4) => void 0 !== t4[1])));
      }
      function U(t3, e3, n3, s3) {
        if (!this.isEnabled() && e3 === N.A.sources.USER && !this.allowReadOnlyEdits) return new i.Ay();
        let r2 = null == n3 ? null : this.getSelection();
        const o2 = this.editor.delta, l2 = t3();
        if (null != r2 && (true === n3 && (n3 = r2.index), null == s3 ? r2 = j(r2, l2, e3) : 0 !== s3 && (r2 = j(r2, n3, s3, e3)), this.setSelection(r2, N.A.sources.SILENT)), l2.length() > 0) {
          const t4 = [N.A.events.TEXT_CHANGE, l2, o2, e3];
          this.emitter.emit(N.A.events.EDITOR_CHANGE, ...t4), e3 !== N.A.sources.SILENT && this.emitter.emit(...t4);
        }
        return l2;
      }
      function _(t3, e3, n3, s3, i2) {
        let r2 = {};
        return "number" == typeof t3.index && "number" == typeof t3.length ? "number" != typeof e3 ? (i2 = s3, s3 = n3, n3 = e3, e3 = t3.length, t3 = t3.index) : (e3 = t3.length, t3 = t3.index) : "number" != typeof e3 && (i2 = s3, s3 = n3, n3 = e3, e3 = 0), "object" == typeof n3 ? (r2 = n3, i2 = s3) : "string" == typeof n3 && (null != s3 ? r2[n3] = s3 : i2 = n3), [t3, e3, r2, i2 = i2 || N.A.sources.API];
      }
      function j(t3, e3, n3, s3) {
        const i2 = "number" == typeof n3 ? n3 : 0;
        if (null == t3) return null;
        let r2, o2;
        return e3 && "function" == typeof e3.transformPosition ? [r2, o2] = [t3.index, t3.index + t3.length].map(((t4) => e3.transformPosition(t4, s3 !== N.A.sources.USER))) : [r2, o2] = [t3.index, t3.index + t3.length].map(((t4) => t4 < e3 || t4 === e3 && s3 === N.A.sources.USER ? t4 : i2 >= 0 ? t4 + i2 : Math.max(e3, t4 + i2))), new c.Q(r2, o2 - r2);
      }
    }, 298: function(t2, e2, n2) {
      n2.d(e2, { Q: function() {
        return h;
      } });
      var s2 = n2(3), i = n2(200), r = n2(78), o = n2(857), l = n2(697);
      const a = (0, r.A)("quill:selection"), c = (t3) => {
        try {
          return "getSelection" in t3 && "function" == typeof t3.getSelection ? t3.getSelection() : window.getSelection();
        } catch {
          return null;
        }
      };
      class h {
        constructor(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          this.index = t3, this.length = e3;
        }
      }
      function u(t3, e3) {
        try {
          e3.parentNode;
        } catch (t4) {
          return false;
        }
        return t3.contains(e3);
      }
      e2.A = class {
        constructor(t3, e3) {
          this.emitter = e3, this.scroll = t3, this.composing = false, this.mouseDown = false, this.root = this.scroll.domNode, this.rootDocument = this.root.getRootNode(), this.cursor = this.scroll.create("cursor", this), this.savedRange = new h(0, 0), this.lastRange = this.savedRange, this.lastNative = null, this.handleComposition(), this.handleDragging(), this.emitter.listenDOM("selectionchange", this.rootDocument, (() => {
            this.mouseDown || this.composing || setTimeout(this.update.bind(this, i.A.sources.USER), 1);
          })), this.emitter.on(i.A.events.SCROLL_BEFORE_UPDATE, (() => {
            if (!this.hasFocus()) return;
            const t4 = this.getNativeRange();
            null != t4 && t4.start.node !== this.cursor.textNode && this.emitter.once(i.A.events.SCROLL_UPDATE, ((e4, n3) => {
              try {
                this.root.contains(t4.start.node) && this.root.contains(t4.end.node) && this.setNativeRange(t4.start.node, t4.start.offset, t4.end.node, t4.end.offset);
                const s3 = n3.some(((t5) => "characterData" === t5.type || "childList" === t5.type || "attributes" === t5.type && t5.target === this.root));
                this.update(s3 ? i.A.sources.SILENT : e4);
              } catch (t5) {
              }
            }));
          })), this.emitter.on(i.A.events.SCROLL_OPTIMIZE, ((t4, e4) => {
            if (e4.range) {
              const { startNode: t5, startOffset: n3, endNode: s3, endOffset: r2 } = e4.range;
              this.setNativeRange(t5, n3, s3, r2), this.update(i.A.sources.SILENT);
            }
          })), this.update(i.A.sources.SILENT);
        }
        handleComposition() {
          this.emitter.on(i.A.events.COMPOSITION_BEFORE_START, (() => {
            this.composing = true;
          })), this.emitter.on(i.A.events.COMPOSITION_END, (() => {
            if (this.composing = false, this.cursor.parent) {
              const t3 = this.cursor.restore();
              if (!t3) return;
              setTimeout((() => {
                this.setNativeRange(t3.startNode, t3.startOffset, t3.endNode, t3.endOffset);
              }), 1);
            }
          }));
        }
        handleDragging() {
          this.emitter.listenDOM("mousedown", document.body, (() => {
            this.mouseDown = true;
          })), this.emitter.listenDOM("mouseup", document.body, (() => {
            this.mouseDown = false, this.update(i.A.sources.USER);
          }));
        }
        focus() {
          this.hasFocus() || (this.root.focus({ preventScroll: true }), this.setRange(this.savedRange));
        }
        format(t3, e3) {
          this.scroll.update();
          const n3 = this.getNativeRange();
          if (null != n3 && n3.native.collapsed && !this.scroll.query(t3, s2.Scope.BLOCK)) {
            if (n3.start.node !== this.cursor.textNode) {
              const t4 = this.scroll.find(n3.start.node, false);
              if (null == t4) return;
              if (t4 instanceof s2.LeafBlot) {
                const e4 = t4.split(n3.start.offset);
                t4.parent.insertBefore(this.cursor, e4);
              } else t4.insertBefore(this.cursor, n3.start.node);
              this.cursor.attach();
            }
            this.cursor.format(t3, e3), this.scroll.optimize(), this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length), this.update();
          }
        }
        getBounds(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          const n3 = this.scroll.length();
          let s3;
          t3 = Math.min(t3, n3 - 1), e3 = Math.min(t3 + e3, n3 - 1) - t3;
          let [i2, r2] = this.scroll.leaf(t3);
          if (null == i2) return null;
          if (e3 > 0 && r2 === i2.length()) {
            const [e4] = this.scroll.leaf(t3 + 1);
            if (e4) {
              const [n4] = this.scroll.line(t3), [s4] = this.scroll.line(t3 + 1);
              n4 === s4 && (i2 = e4, r2 = 0);
            }
          }
          [s3, r2] = i2.position(r2, true);
          const o2 = document.createRange();
          if (e3 > 0) return o2.setStart(s3, r2), [i2, r2] = this.scroll.leaf(t3 + e3), null == i2 ? null : ([s3, r2] = i2.position(r2, true), o2.setEnd(s3, r2), o2.getBoundingClientRect());
          let l2, a2 = "left";
          if (s3 instanceof Text) {
            if (!s3.data.length) return null;
            r2 < s3.data.length ? (o2.setStart(s3, r2), o2.setEnd(s3, r2 + 1)) : (o2.setStart(s3, r2 - 1), o2.setEnd(s3, r2), a2 = "right"), l2 = o2.getBoundingClientRect();
          } else {
            if (!(i2.domNode instanceof Element)) return null;
            l2 = i2.domNode.getBoundingClientRect(), r2 > 0 && (a2 = "right");
          }
          return { bottom: l2.top + l2.height, height: l2.height, left: l2[a2], right: l2[a2], top: l2.top, width: 0 };
        }
        getNativeRange() {
          const t3 = ((t4) => {
            const e4 = c(t4);
            return e4?.anchorNode ? !e4 || !("getComposedRanges" in e4) || "function" != typeof e4.getComposedRanges || t4 instanceof ShadowRoot && "getSelection" in t4 ? e4.getRangeAt(0) : e4.getComposedRanges(t4)[0] : null;
          })(this.rootDocument);
          if (null == t3) return null;
          const e3 = this.normalizeNative(t3);
          return a.info("getNativeRange", e3), e3;
        }
        getRange() {
          const t3 = this.scroll.domNode;
          if ("isConnected" in t3 && !t3.isConnected) return [null, null];
          const e3 = this.getNativeRange();
          return null == e3 ? [null, null] : [this.normalizedToRange(e3), e3];
        }
        hasFocus() {
          const t3 = this.rootDocument;
          return t3.activeElement === this.root || null != t3.activeElement && u(this.root, t3.activeElement);
        }
        normalizedToRange(t3) {
          const e3 = [[t3.start.node, t3.start.offset]];
          t3.native.collapsed || e3.push([t3.end.node, t3.end.offset]);
          const n3 = e3.map(((t4) => {
            const [e4, n4] = t4, i3 = this.scroll.find(e4, true), r3 = i3.offset(this.scroll);
            return 0 === n4 ? r3 : i3 instanceof s2.LeafBlot ? r3 + i3.index(e4, n4) : r3 + i3.length();
          })), i2 = Math.min(Math.max(...n3), this.scroll.length() - 1), r2 = Math.min(i2, ...n3);
          return new h(r2, i2 - r2);
        }
        normalizeNative(t3) {
          if (!u(this.root, t3.startContainer) || !t3.collapsed && !u(this.root, t3.endContainer)) return null;
          const e3 = { start: { node: t3.startContainer, offset: t3.startOffset }, end: { node: t3.endContainer, offset: t3.endOffset }, native: t3 };
          return [e3.start, e3.end].forEach(((t4) => {
            let { node: e4, offset: n3 } = t4;
            for (; !(e4 instanceof Text) && e4.childNodes.length > 0; ) if (e4.childNodes.length > n3) e4 = e4.childNodes[n3], n3 = 0;
            else {
              if (e4.childNodes.length !== n3) break;
              e4 = e4.lastChild, n3 = e4 instanceof Text ? e4.data.length : e4.childNodes.length > 0 ? e4.childNodes.length : e4.childNodes.length + 1;
            }
            t4.node = e4, t4.offset = n3;
          })), e3;
        }
        rangeToNative(t3) {
          const e3 = this.scroll.length(), n3 = (t4, n4) => {
            t4 = Math.min(e3 - 1, t4);
            const [s3, i2] = this.scroll.leaf(t4);
            return s3 ? s3.position(i2, n4) : [null, -1];
          };
          return [...n3(t3.index, false), ...n3(t3.index + t3.length, true)];
        }
        setNativeRange(t3, e3) {
          let n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t3, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e3, i2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
          if (a.info("setNativeRange", t3, e3, n3, s3), null != t3 && (null == this.root.parentNode || null == t3.parentNode || null == n3.parentNode)) return;
          const r2 = c(this.rootDocument);
          if (null != r2) if (null != t3) {
            this.hasFocus() || this.root.focus({ preventScroll: true });
            const { native: o2 } = this.getNativeRange() || {};
            (null == o2 || i2 || t3 !== o2.startContainer || e3 !== o2.startOffset || n3 !== o2.endContainer || s3 !== o2.endOffset) && (t3 instanceof Element && "BR" === t3.tagName && (e3 = Array.from(t3.parentNode.childNodes).indexOf(t3), t3 = t3.parentNode), n3 instanceof Element && "BR" === n3.tagName && (s3 = Array.from(n3.parentNode.childNodes).indexOf(n3), n3 = n3.parentNode), t3 && n3 && "number" == typeof e3 && "number" == typeof s3 && r2.setBaseAndExtent(t3, e3, n3, s3));
          } else r2.removeAllRanges(), this.root.blur();
        }
        setRange(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i.A.sources.API;
          if ("string" == typeof e3 && (n3 = e3, e3 = false), a.info("setRange", t3), null != t3) {
            const n4 = this.rangeToNative(t3);
            this.setNativeRange(...n4, e3);
          } else this.setNativeRange(null);
          this.update(n3);
        }
        update() {
          let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i.A.sources.USER;
          const e3 = this.lastRange, [n3, s3] = this.getRange();
          if (this.lastRange = n3, this.lastNative = s3, null != this.lastRange && (this.savedRange = this.lastRange), !(0, l.A)(e3, this.lastRange)) {
            if (!this.composing && null != s3 && s3.native.collapsed && s3.start.node !== this.cursor.textNode) {
              const t4 = this.cursor.restore();
              t4 && this.setNativeRange(t4.startNode, t4.startOffset, t4.endNode, t4.endOffset);
            }
            const n4 = [i.A.events.SELECTION_CHANGE, (0, o.A)(this.lastRange), (0, o.A)(e3), t3];
            this.emitter.emit(i.A.events.EDITOR_CHANGE, ...n4), t3 !== i.A.sources.SILENT && this.emitter.emit(...n4);
          }
        }
      };
    }, 609: function(t2, e2) {
      class n2 {
        static DEFAULTS = { modules: {} };
        static themes = { default: n2 };
        modules = {};
        constructor(t3, e3) {
          this.quill = t3, this.options = e3;
        }
        init() {
          Object.keys(this.options.modules).forEach(((t3) => {
            null == this.modules[t3] && this.addModule(t3);
          }));
        }
        addModule(t3) {
          const e3 = this.quill.constructor.import(`modules/${t3}`);
          return this.modules[t3] = new e3(this.quill, this.options.modules[t3] || {}), this.modules[t3];
        }
      }
      e2.A = n2;
    }, 857: function(t2, e2) {
      e2.A = function(t3) {
        return JSON.parse(JSON.stringify(t3));
      };
    }, 697: function(t2, e2) {
      function n2(t3) {
        return t3 !== Object(t3);
      }
      e2.A = function t3(e3, s2) {
        if (e3 === s2) return true;
        if (n2(e3) || n2(s2)) return e3 === s2;
        if (Object.keys(e3).length !== Object.keys(s2).length) return false;
        for (const n3 in e3) {
          if (!(n3 in s2)) return false;
          if (!t3(e3[n3], s2[n3])) return false;
        }
        return true;
      };
    }, 276: function(t2, e2, n2) {
      n2.d(e2, { Hu: function() {
        return l;
      }, gS: function() {
        return r;
      }, qh: function() {
        return o;
      } });
      var s2 = n2(3);
      const i = { scope: s2.Scope.BLOCK, whitelist: ["right", "center", "justify"] }, r = new s2.Attributor("align", "align", i), o = new s2.ClassAttributor("align", "ql-align", i), l = new s2.StyleAttributor("align", "text-align", i);
    }, 922: function(t2, e2, n2) {
      n2.d(e2, { l: function() {
        return r;
      }, s: function() {
        return o;
      } });
      var s2 = n2(3), i = n2(638);
      const r = new s2.ClassAttributor("background", "ql-bg", { scope: s2.Scope.INLINE }), o = new i.a2("background", "background-color", { scope: s2.Scope.INLINE });
    }, 404: function(t2, e2, n2) {
      n2.d(e2, { Ay: function() {
        return u;
      }, Cy: function() {
        return d;
      } });
      var s2 = n2(698), i = n2(36), r = n2(541), o = n2(850), l = n2(508), a = n2(580), c = n2(543);
      class h extends a.A {
        static create(t3) {
          const e3 = super.create(t3);
          return e3.setAttribute("spellcheck", "false"), e3;
        }
        code(t3, e3) {
          return this.children.map(((t4) => t4.length() <= 1 ? "" : t4.domNode.innerText)).join("\n").slice(t3, t3 + e3);
        }
        html(t3, e3) {
          return `<pre>
${(0, l.X)(this.code(t3, e3))}
</pre>`;
        }
      }
      class u extends s2.Ay {
        static TAB = "  ";
        static register() {
          c.Ay.register(h);
        }
      }
      class d extends o.A {
      }
      d.blotName = "code", d.tagName = "CODE", u.blotName = "code-block", u.className = "ql-code-block", u.tagName = "DIV", h.blotName = "code-block-container", h.className = "ql-code-block-container", h.tagName = "DIV", h.allowedChildren = [u], u.allowedChildren = [l.A, i.A, r.A], u.requiredContainer = h;
    }, 638: function(t2, e2, n2) {
      n2.d(e2, { JM: function() {
        return o;
      }, a2: function() {
        return i;
      }, g3: function() {
        return r;
      } });
      var s2 = n2(3);
      class i extends s2.StyleAttributor {
        value(t3) {
          let e3 = super.value(t3);
          return e3.startsWith("rgb(") ? (e3 = e3.replace(/^[^\d]+/, "").replace(/[^\d]+$/, ""), `#${e3.split(",").map(((t4) => `00${parseInt(t4, 10).toString(16)}`.slice(-2))).join("")}`) : e3;
        }
      }
      const r = new s2.ClassAttributor("color", "ql-color", { scope: s2.Scope.INLINE }), o = new i("color", "color", { scope: s2.Scope.INLINE });
    }, 912: function(t2, e2, n2) {
      n2.d(e2, { Mc: function() {
        return r;
      }, VL: function() {
        return l;
      }, sY: function() {
        return o;
      } });
      var s2 = n2(3);
      const i = { scope: s2.Scope.BLOCK, whitelist: ["rtl"] }, r = new s2.Attributor("direction", "dir", i), o = new s2.ClassAttributor("direction", "ql-direction", i), l = new s2.StyleAttributor("direction", "direction", i);
    }, 772: function(t2, e2, n2) {
      n2.d(e2, { q: function() {
        return r;
      }, z: function() {
        return l;
      } });
      var s2 = n2(3);
      const i = { scope: s2.Scope.INLINE, whitelist: ["serif", "monospace"] }, r = new s2.ClassAttributor("font", "ql-font", i);
      class o extends s2.StyleAttributor {
        value(t3) {
          return super.value(t3).replace(/["']/g, "");
        }
      }
      const l = new o("font", "font-family", i);
    }, 664: function(t2, e2, n2) {
      n2.d(e2, { U: function() {
        return i;
      }, r: function() {
        return r;
      } });
      var s2 = n2(3);
      const i = new s2.ClassAttributor("size", "ql-size", { scope: s2.Scope.INLINE, whitelist: ["small", "large", "huge"] }), r = new s2.StyleAttributor("size", "font-size", { scope: s2.Scope.INLINE, whitelist: ["10px", "18px", "32px"] });
    }, 584: function(t2, e2, n2) {
      n2.d(e2, { Ay: function() {
        return O;
      } });
      var s2 = n2(3), i = n2(398), r = n2(698), o = n2(78), l = n2(266), a = n2(543), c = n2(276), h = n2(922), u = n2(404), d = n2(638), f = n2(912), p = n2(772), m = n2(664), g = n2(123);
      const b = /font-weight:\s*normal/, y = ["P", "OL", "UL"], A = (t3) => t3 && y.includes(t3.tagName), N = /\bmso-list:[^;]*ignore/i, v = /\bmso-list:[^;]*\bl(\d+)/i, E = /\bmso-list:[^;]*\blevel(\d+)/i, x = [function(t3) {
        "urn:schemas-microsoft-com:office:word" === t3.documentElement.getAttribute("xmlns:w") && ((t4) => {
          const e3 = Array.from(t4.querySelectorAll("[style*=mso-list]")), n3 = [], s3 = [];
          e3.forEach(((t5) => {
            (t5.getAttribute("style") || "").match(N) ? n3.push(t5) : s3.push(t5);
          })), n3.forEach(((t5) => t5.parentNode?.removeChild(t5)));
          const i2 = t4.documentElement.innerHTML, r2 = s3.map(((t5) => ((t6, e4) => {
            const n4 = t6.getAttribute("style"), s4 = n4?.match(v);
            if (!s4) return null;
            const i3 = Number(s4[1]), r3 = n4?.match(E), o2 = r3 ? Number(r3[1]) : 1, l2 = new RegExp(`@list l${i3}:level${o2}\\s*\\{[^\\}]*mso-level-number-format:\\s*([\\w-]+)`, "i"), a2 = e4.match(l2);
            return { id: i3, indent: o2, type: a2 && "bullet" === a2[1] ? "bullet" : "ordered", element: t6 };
          })(t5, i2))).filter(((t5) => t5));
          for (; r2.length; ) {
            const t5 = [];
            let e4 = r2.shift();
            for (; e4; ) t5.push(e4), e4 = r2.length && r2[0]?.element === e4.element.nextElementSibling && r2[0].id === e4.id ? r2.shift() : null;
            const n4 = document.createElement("ul");
            t5.forEach(((t6) => {
              const e5 = document.createElement("li");
              e5.setAttribute("data-list", t6.type), t6.indent > 1 && e5.setAttribute("class", "ql-indent-" + (t6.indent - 1)), e5.innerHTML = t6.element.innerHTML, n4.appendChild(e5);
            }));
            const s4 = t5[0]?.element, { parentNode: i3 } = s4 ?? {};
            s4 && i3?.replaceChild(n4, s4), t5.slice(1).forEach(((t6) => {
              let { element: e5 } = t6;
              i3?.removeChild(e5);
            }));
          }
        })(t3);
      }, function(t3) {
        t3.querySelector('[id^="docs-internal-guid-"]') && (((t4) => {
          Array.from(t4.querySelectorAll('b[style*="font-weight"]')).filter(((t5) => t5.getAttribute("style")?.match(b))).forEach(((e3) => {
            const n3 = t4.createDocumentFragment();
            n3.append(...e3.childNodes), e3.parentNode?.replaceChild(n3, e3);
          }));
        })(t3), ((t4) => {
          Array.from(t4.querySelectorAll("br")).filter(((t5) => A(t5.previousElementSibling) && A(t5.nextElementSibling))).forEach(((t5) => {
            t5.parentNode?.removeChild(t5);
          }));
        })(t3));
      }];
      const L = (0, o.A)("quill:clipboard"), S = [[Node.TEXT_NODE, function(t3, e3, n3) {
        let s3 = t3.data;
        if ("O:P" === t3.parentElement?.tagName) return e3.insert(s3.trim());
        if (!B(t3)) {
          if (0 === s3.trim().length && s3.includes("\n") && !(function(t4, e4) {
            return t4.previousElementSibling && t4.nextElementSibling && !q(t4.previousElementSibling, e4) && !q(t4.nextElementSibling, e4);
          })(t3, n3)) return e3;
          s3 = s3.replace(/[^\S\u00a0]/g, " "), s3 = s3.replace(/ {2,}/g, " "), (null == t3.previousSibling && null != t3.parentElement && q(t3.parentElement, n3) || t3.previousSibling instanceof Element && q(t3.previousSibling, n3)) && (s3 = s3.replace(/^ /, "")), (null == t3.nextSibling && null != t3.parentElement && q(t3.parentElement, n3) || t3.nextSibling instanceof Element && q(t3.nextSibling, n3)) && (s3 = s3.replace(/ $/, "")), s3 = s3.replaceAll("", " ");
        }
        return e3.insert(s3);
      }], [Node.TEXT_NODE, M], ["br", function(t3, e3) {
        return C(e3, "\n") || e3.insert("\n"), e3;
      }], [Node.ELEMENT_NODE, M], [Node.ELEMENT_NODE, function(t3, e3, n3) {
        const r2 = n3.query(t3);
        if (null == r2) return e3;
        if (r2.prototype instanceof s2.EmbedBlot) {
          const e4 = {}, s3 = r2.value(t3);
          if (null != s3) return e4[r2.blotName] = s3, new i.Ay().insert(e4, r2.formats(t3, n3));
        } else if (r2.prototype instanceof s2.BlockBlot && !C(e3, "\n") && e3.insert("\n"), "blotName" in r2 && "formats" in r2 && "function" == typeof r2.formats) return w(e3, r2.blotName, r2.formats(t3, n3), n3);
        return e3;
      }], [Node.ELEMENT_NODE, function(t3, e3, n3) {
        const i2 = s2.Attributor.keys(t3), r2 = s2.ClassAttributor.keys(t3), o2 = s2.StyleAttributor.keys(t3), l2 = {};
        return i2.concat(r2).concat(o2).forEach(((e4) => {
          let i3 = n3.query(e4, s2.Scope.ATTRIBUTE);
          null != i3 && (l2[i3.attrName] = i3.value(t3), l2[i3.attrName]) || (i3 = T[e4], null == i3 || i3.attrName !== e4 && i3.keyName !== e4 || (l2[i3.attrName] = i3.value(t3) || void 0), i3 = k[e4], null == i3 || i3.attrName !== e4 && i3.keyName !== e4 || (i3 = k[e4], l2[i3.attrName] = i3.value(t3) || void 0));
        })), Object.entries(l2).reduce(((t4, e4) => {
          let [s3, i3] = e4;
          return w(t4, s3, i3, n3);
        }), e3);
      }], [Node.ELEMENT_NODE, function(t3, e3, n3) {
        const s3 = {}, r2 = t3.style || {};
        return "italic" === r2.fontStyle && (s3.italic = true), "underline" === r2.textDecoration && (s3.underline = true), "line-through" === r2.textDecoration && (s3.strike = true), (r2.fontWeight?.startsWith("bold") || parseInt(r2.fontWeight, 10) >= 700) && (s3.bold = true), e3 = Object.entries(s3).reduce(((t4, e4) => {
          let [s4, i2] = e4;
          return w(t4, s4, i2, n3);
        }), e3), parseFloat(r2.textIndent || 0) > 0 ? new i.Ay().insert("	").concat(e3) : e3;
      }], ["li", function(t3, e3, n3) {
        const s3 = n3.query(t3);
        if (null == s3 || "list" !== s3.blotName || !C(e3, "\n")) return e3;
        let r2 = -1, o2 = t3.parentNode;
        for (; null != o2; ) ["OL", "UL"].includes(o2.tagName) && (r2 += 1), o2 = o2.parentNode;
        return r2 <= 0 ? e3 : e3.reduce(((t4, e4) => e4.insert ? e4.attributes && "number" == typeof e4.attributes.indent ? t4.push(e4) : t4.insert(e4.insert, { indent: r2, ...e4.attributes || {} }) : t4), new i.Ay());
      }], ["ol, ul", function(t3, e3, n3) {
        const s3 = t3;
        let i2 = "OL" === s3.tagName ? "ordered" : "bullet";
        const r2 = s3.getAttribute("data-checked");
        return r2 && (i2 = "true" === r2 ? "checked" : "unchecked"), w(e3, "list", i2, n3);
      }], ["pre", function(t3, e3, n3) {
        const s3 = n3.query("code-block");
        return w(e3, "code-block", !s3 || !("formats" in s3) || "function" != typeof s3.formats || s3.formats(t3, n3), n3);
      }], ["tr", function(t3, e3, n3) {
        const s3 = "TABLE" === t3.parentElement?.tagName ? t3.parentElement : t3.parentElement?.parentElement;
        return null != s3 ? w(e3, "table", Array.from(s3.querySelectorAll("tr")).indexOf(t3) + 1, n3) : e3;
      }], ["b", D("bold")], ["i", D("italic")], ["strike", D("strike")], ["style", function() {
        return new i.Ay();
      }]], T = [c.gS, f.Mc].reduce(((t3, e3) => (t3[e3.keyName] = e3, t3)), {}), k = [c.Hu, h.s, d.JM, f.VL, p.z, m.r].reduce(((t3, e3) => (t3[e3.keyName] = e3, t3)), {});
      class O extends l.A {
        static DEFAULTS = { matchers: [] };
        constructor(t3, e3) {
          super(t3, e3), this.quill.root.addEventListener("copy", ((t4) => this.onCaptureCopy(t4, false))), this.quill.root.addEventListener("cut", ((t4) => this.onCaptureCopy(t4, true))), this.quill.root.addEventListener("paste", this.onCapturePaste.bind(this)), this.matchers = [], S.concat(this.options.matchers ?? []).forEach(((t4) => {
            let [e4, n3] = t4;
            this.addMatcher(e4, n3);
          }));
        }
        addMatcher(t3, e3) {
          this.matchers.push([t3, e3]);
        }
        convert(t3) {
          let { html: e3, text: n3 } = t3, s3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if (s3[u.Ay.blotName]) return new i.Ay().insert(n3 || "", { [u.Ay.blotName]: s3[u.Ay.blotName] });
          if (!e3) return new i.Ay().insert(n3 || "", s3);
          const r2 = this.convertHTML(e3);
          return C(r2, "\n") && (null == r2.ops[r2.ops.length - 1].attributes || s3.table) ? r2.compose(new i.Ay().retain(r2.length() - 1).delete(1)) : r2;
        }
        normalizeHTML(t3) {
          ((t4) => {
            t4.documentElement && x.forEach(((e3) => {
              e3(t4);
            }));
          })(t3);
        }
        convertHTML(t3) {
          const e3 = new DOMParser().parseFromString(t3, "text/html");
          this.normalizeHTML(e3);
          const n3 = e3.body, s3 = /* @__PURE__ */ new WeakMap(), [i2, r2] = this.prepareMatching(n3, s3);
          return I(this.quill.scroll, n3, i2, r2, s3);
        }
        dangerouslyPasteHTML(t3, e3) {
          let n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : a.Ay.sources.API;
          if ("string" == typeof t3) {
            const n4 = this.convert({ html: t3, text: "" });
            this.quill.setContents(n4, e3), this.quill.setSelection(0, a.Ay.sources.SILENT);
          } else {
            const s3 = this.convert({ html: e3, text: "" });
            this.quill.updateContents(new i.Ay().retain(t3).concat(s3), n3), this.quill.setSelection(t3 + s3.length(), a.Ay.sources.SILENT);
          }
        }
        onCaptureCopy(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if (t3.defaultPrevented) return;
          t3.preventDefault();
          const [n3] = this.quill.selection.getRange();
          if (null == n3) return;
          const { html: s3, text: i2 } = this.onCopy(n3, e3);
          t3.clipboardData?.setData("text/plain", i2), t3.clipboardData?.setData("text/html", s3), e3 && (0, g.Xo)({ range: n3, quill: this.quill });
        }
        normalizeURIList(t3) {
          return t3.split(/\r?\n/).filter(((t4) => "#" !== t4[0])).join("\n");
        }
        onCapturePaste(t3) {
          if (t3.defaultPrevented || !this.quill.isEnabled()) return;
          t3.preventDefault();
          const e3 = this.quill.getSelection(true);
          if (null == e3) return;
          const n3 = t3.clipboardData?.getData("text/html");
          let s3 = t3.clipboardData?.getData("text/plain");
          if (!n3 && !s3) {
            const e4 = t3.clipboardData?.getData("text/uri-list");
            e4 && (s3 = this.normalizeURIList(e4));
          }
          const i2 = Array.from(t3.clipboardData?.files || []);
          if (!n3 && i2.length > 0) this.quill.uploader.upload(e3, i2);
          else {
            if (n3 && i2.length > 0) {
              const t4 = new DOMParser().parseFromString(n3, "text/html");
              if (1 === t4.body.childElementCount && "IMG" === t4.body.firstElementChild?.tagName) return void this.quill.uploader.upload(e3, i2);
            }
            this.onPaste(e3, { html: n3, text: s3 });
          }
        }
        onCopy(t3) {
          const e3 = this.quill.getText(t3);
          return { html: this.quill.getSemanticHTML(t3), text: e3 };
        }
        onPaste(t3, e3) {
          let { text: n3, html: s3 } = e3;
          const r2 = this.quill.getFormat(t3.index), o2 = this.convert({ text: n3, html: s3 }, r2);
          L.log("onPaste", o2, { text: n3, html: s3 });
          const l2 = new i.Ay().retain(t3.index).delete(t3.length).concat(o2);
          this.quill.updateContents(l2, a.Ay.sources.USER), this.quill.setSelection(l2.length() - t3.length, a.Ay.sources.SILENT), this.quill.scrollSelectionIntoView();
        }
        prepareMatching(t3, e3) {
          const n3 = [], s3 = [];
          return this.matchers.forEach(((i2) => {
            const [r2, o2] = i2;
            switch (r2) {
              case Node.TEXT_NODE:
                s3.push(o2);
                break;
              case Node.ELEMENT_NODE:
                n3.push(o2);
                break;
              default:
                Array.from(t3.querySelectorAll(r2)).forEach(((t4) => {
                  if (e3.has(t4)) {
                    const n4 = e3.get(t4);
                    n4?.push(o2);
                  } else e3.set(t4, [o2]);
                }));
            }
          })), [n3, s3];
        }
      }
      function w(t3, e3, n3, s3) {
        return s3.query(e3) ? t3.reduce(((t4, s4) => {
          if (!s4.insert) return t4;
          if (s4.attributes && s4.attributes[e3]) return t4.push(s4);
          const i2 = n3 ? { [e3]: n3 } : {};
          return t4.insert(s4.insert, { ...i2, ...s4.attributes });
        }), new i.Ay()) : t3;
      }
      function C(t3, e3) {
        let n3 = "";
        for (let s3 = t3.ops.length - 1; s3 >= 0 && n3.length < e3.length; --s3) {
          const e4 = t3.ops[s3];
          if ("string" != typeof e4.insert) break;
          n3 = e4.insert + n3;
        }
        return n3.slice(-1 * e3.length) === e3;
      }
      function q(t3, e3) {
        if (!(t3 instanceof Element)) return false;
        const n3 = e3.query(t3);
        return !(n3 && n3.prototype instanceof s2.EmbedBlot) && ["address", "article", "blockquote", "canvas", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "iframe", "li", "main", "nav", "ol", "output", "p", "pre", "section", "table", "td", "tr", "ul", "video"].includes(t3.tagName.toLowerCase());
      }
      const R = /* @__PURE__ */ new WeakMap();
      function B(t3) {
        return null != t3 && (R.has(t3) || ("PRE" === t3.tagName ? R.set(t3, true) : R.set(t3, B(t3.parentNode))), R.get(t3));
      }
      function I(t3, e3, n3, s3, r2) {
        return e3.nodeType === e3.TEXT_NODE ? s3.reduce(((n4, s4) => s4(e3, n4, t3)), new i.Ay()) : e3.nodeType === e3.ELEMENT_NODE ? Array.from(e3.childNodes || []).reduce(((i2, o2) => {
          let l2 = I(t3, o2, n3, s3, r2);
          return o2.nodeType === e3.ELEMENT_NODE && (l2 = n3.reduce(((e4, n4) => n4(o2, e4, t3)), l2), l2 = (r2.get(o2) || []).reduce(((e4, n4) => n4(o2, e4, t3)), l2)), i2.concat(l2);
        }), new i.Ay()) : new i.Ay();
      }
      function D(t3) {
        return (e3, n3, s3) => w(n3, t3, true, s3);
      }
      function M(t3, e3, n3) {
        if (!C(e3, "\n")) {
          if (q(t3, n3) && (t3.childNodes.length > 0 || t3 instanceof HTMLParagraphElement)) return e3.insert("\n");
          if (e3.length() > 0 && t3.nextSibling) {
            let s3 = t3.nextSibling;
            for (; null != s3; ) {
              if (q(s3, n3)) return e3.insert("\n");
              const t4 = n3.query(s3);
              if (t4 && t4.prototype instanceof r.zo) return e3.insert("\n");
              s3 = s3.firstChild;
            }
          }
        }
        return e3;
      }
    }, 123: function(t2, e2, n2) {
      n2.d(e2, { Ay: function() {
        return u;
      }, Xo: function() {
        return b;
      } });
      var s2 = n2(398), i = n2(3), r = n2(543), o = n2(78), l = n2(266), a = n2(697);
      const c = (0, o.A)("quill:keyboard"), h = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
      class u extends l.A {
        static match(t3, e3) {
          return !["altKey", "ctrlKey", "metaKey", "shiftKey"].some(((n3) => !!e3[n3] !== t3[n3] && null !== e3[n3])) && (e3.key === t3.key || e3.key === t3.which);
        }
        constructor(t3, e3) {
          super(t3, e3), this.bindings = {}, Object.keys(this.options.bindings).forEach(((t4) => {
            this.options.bindings[t4] && this.addBinding(this.options.bindings[t4]);
          })), this.addBinding({ key: "Enter", shiftKey: null }, this.handleEnter), this.addBinding({ key: "Enter", metaKey: null, ctrlKey: null, altKey: null }, (() => {
          })), /Firefox/i.test(navigator.userAgent) ? (this.addBinding({ key: "Backspace" }, { collapsed: true }, this.handleBackspace), this.addBinding({ key: "Delete" }, { collapsed: true }, this.handleDelete)) : (this.addBinding({ key: "Backspace" }, { collapsed: true, prefix: /^.?$/ }, this.handleBackspace), this.addBinding({ key: "Delete" }, { collapsed: true, suffix: /^.?$/ }, this.handleDelete)), this.addBinding({ key: "Backspace" }, { collapsed: false }, this.handleDeleteRange), this.addBinding({ key: "Delete" }, { collapsed: false }, this.handleDeleteRange), this.addBinding({ key: "Backspace", altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, this.handleBackspace), this.listen();
        }
        addBinding(t3) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          const s3 = (function(t4) {
            if ("string" == typeof t4 || "number" == typeof t4) t4 = { key: t4 };
            else {
              if ("object" != typeof t4) return null;
              t4 = { ...t4 };
            }
            return t4.shortKey && (t4[h] = t4.shortKey, delete t4.shortKey), t4;
          })(t3);
          null != s3 ? ("function" == typeof e3 && (e3 = { handler: e3 }), "function" == typeof n3 && (n3 = { handler: n3 }), (Array.isArray(s3.key) ? s3.key : [s3.key]).forEach(((t4) => {
            const i2 = { ...s3, key: t4, ...e3, ...n3 };
            this.bindings[i2.key] = this.bindings[i2.key] || [], this.bindings[i2.key].push(i2);
          }))) : c.warn("Attempted to add invalid keyboard binding", s3);
        }
        listen() {
          this.quill.root.addEventListener("keydown", ((t3) => {
            if (t3.defaultPrevented || t3.isComposing) return;
            if (229 === t3.keyCode && ("Enter" === t3.key || "Backspace" === t3.key)) return;
            const e3 = (this.bindings[t3.key] || []).concat(this.bindings[t3.which] || []).filter(((e4) => u.match(t3, e4)));
            if (0 === e3.length) return;
            const n3 = r.Ay.find(t3.target, true);
            if (n3 && n3.scroll !== this.quill.scroll) return;
            const s3 = this.quill.getSelection();
            if (null == s3 || !this.quill.hasFocus()) return;
            const [o2, l2] = this.quill.getLine(s3.index), [c2, h2] = this.quill.getLeaf(s3.index), [d2, f2] = 0 === s3.length ? [c2, h2] : this.quill.getLeaf(s3.index + s3.length), p2 = c2 instanceof i.TextBlot ? c2.value().slice(0, h2) : "", m2 = d2 instanceof i.TextBlot ? d2.value().slice(f2) : "", g2 = { collapsed: 0 === s3.length, empty: 0 === s3.length && o2.length() <= 1, format: this.quill.getFormat(s3), line: o2, offset: l2, prefix: p2, suffix: m2, event: t3 };
            e3.some(((t4) => {
              if (null != t4.collapsed && t4.collapsed !== g2.collapsed) return false;
              if (null != t4.empty && t4.empty !== g2.empty) return false;
              if (null != t4.offset && t4.offset !== g2.offset) return false;
              if (Array.isArray(t4.format)) {
                if (t4.format.every(((t5) => null == g2.format[t5]))) return false;
              } else if ("object" == typeof t4.format && !Object.keys(t4.format).every(((e4) => true === t4.format[e4] ? null != g2.format[e4] : false === t4.format[e4] ? null == g2.format[e4] : (0, a.A)(t4.format[e4], g2.format[e4])))) return false;
              return !(null != t4.prefix && !t4.prefix.test(g2.prefix) || null != t4.suffix && !t4.suffix.test(g2.suffix) || true === t4.handler.call(this, s3, g2, t4));
            })) && t3.preventDefault();
          }));
        }
        handleBackspace(t3, e3) {
          const n3 = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(e3.prefix) ? 2 : 1;
          if (0 === t3.index || this.quill.getLength() <= 1) return;
          let i2 = {};
          const [o2] = this.quill.getLine(t3.index);
          let l2 = new s2.Ay().retain(t3.index - n3).delete(n3);
          if (0 === e3.offset) {
            const [e4] = this.quill.getLine(t3.index - 1);
            if (e4 && !("block" === e4.statics.blotName && e4.length() <= 1)) {
              const e5 = o2.formats(), n4 = this.quill.getFormat(t3.index - 1, 1);
              if (i2 = s2.xb.diff(e5, n4) || {}, Object.keys(i2).length > 0) {
                const e6 = new s2.Ay().retain(t3.index + o2.length() - 2).retain(1, i2);
                l2 = l2.compose(e6);
              }
            }
          }
          this.quill.updateContents(l2, r.Ay.sources.USER), this.quill.focus();
        }
        handleDelete(t3, e3) {
          const n3 = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e3.suffix) ? 2 : 1;
          if (t3.index >= this.quill.getLength() - n3) return;
          let i2 = {};
          const [o2] = this.quill.getLine(t3.index);
          let l2 = new s2.Ay().retain(t3.index).delete(n3);
          if (e3.offset >= o2.length() - 1) {
            const [e4] = this.quill.getLine(t3.index + 1);
            if (e4) {
              const n4 = o2.formats(), r2 = this.quill.getFormat(t3.index, 1);
              i2 = s2.xb.diff(n4, r2) || {}, Object.keys(i2).length > 0 && (l2 = l2.retain(e4.length() - 1).retain(1, i2));
            }
          }
          this.quill.updateContents(l2, r.Ay.sources.USER), this.quill.focus();
        }
        handleDeleteRange(t3) {
          b({ range: t3, quill: this.quill }), this.quill.focus();
        }
        handleEnter(t3, e3) {
          const n3 = Object.keys(e3.format).reduce(((t4, n4) => (this.quill.scroll.query(n4, i.Scope.BLOCK) && !Array.isArray(e3.format[n4]) && (t4[n4] = e3.format[n4]), t4)), {}), o2 = new s2.Ay().retain(t3.index).delete(t3.length).insert("\n", n3);
          this.quill.updateContents(o2, r.Ay.sources.USER), this.quill.setSelection(t3.index + 1, r.Ay.sources.SILENT), this.quill.focus();
        }
      }
      const d = { bindings: { bold: m("bold"), italic: m("italic"), underline: m("underline"), indent: { key: "Tab", format: ["blockquote", "indent", "list"], handler(t3, e3) {
        return !(!e3.collapsed || 0 === e3.offset) || (this.quill.format("indent", "+1", r.Ay.sources.USER), false);
      } }, outdent: { key: "Tab", shiftKey: true, format: ["blockquote", "indent", "list"], handler(t3, e3) {
        return !(!e3.collapsed || 0 === e3.offset) || (this.quill.format("indent", "-1", r.Ay.sources.USER), false);
      } }, "outdent backspace": { key: "Backspace", collapsed: true, shiftKey: null, metaKey: null, ctrlKey: null, altKey: null, format: ["indent", "list"], offset: 0, handler(t3, e3) {
        null != e3.format.indent ? this.quill.format("indent", "-1", r.Ay.sources.USER) : null != e3.format.list && this.quill.format("list", false, r.Ay.sources.USER);
      } }, "indent code-block": f(true), "outdent code-block": f(false), "remove tab": { key: "Tab", shiftKey: true, collapsed: true, prefix: /\t$/, handler(t3) {
        this.quill.deleteText(t3.index - 1, 1, r.Ay.sources.USER);
      } }, tab: { key: "Tab", handler(t3, e3) {
        if (e3.format.table) return true;
        this.quill.history.cutoff();
        const n3 = new s2.Ay().retain(t3.index).delete(t3.length).insert("	");
        return this.quill.updateContents(n3, r.Ay.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t3.index + 1, r.Ay.sources.SILENT), false;
      } }, "blockquote empty enter": { key: "Enter", collapsed: true, format: ["blockquote"], empty: true, handler() {
        this.quill.format("blockquote", false, r.Ay.sources.USER);
      } }, "list empty enter": { key: "Enter", collapsed: true, format: ["list"], empty: true, handler(t3, e3) {
        const n3 = { list: false };
        e3.format.indent && (n3.indent = false), this.quill.formatLine(t3.index, t3.length, n3, r.Ay.sources.USER);
      } }, "checklist enter": { key: "Enter", collapsed: true, format: { list: "checked" }, handler(t3) {
        const [e3, n3] = this.quill.getLine(t3.index), i2 = { ...e3.formats(), list: "checked" }, o2 = new s2.Ay().retain(t3.index).insert("\n", i2).retain(e3.length() - n3 - 1).retain(1, { list: "unchecked" });
        this.quill.updateContents(o2, r.Ay.sources.USER), this.quill.setSelection(t3.index + 1, r.Ay.sources.SILENT), this.quill.scrollSelectionIntoView();
      } }, "header enter": { key: "Enter", collapsed: true, format: ["header"], suffix: /^$/, handler(t3, e3) {
        const [n3, i2] = this.quill.getLine(t3.index), o2 = new s2.Ay().retain(t3.index).insert("\n", e3.format).retain(n3.length() - i2 - 1).retain(1, { header: null });
        this.quill.updateContents(o2, r.Ay.sources.USER), this.quill.setSelection(t3.index + 1, r.Ay.sources.SILENT), this.quill.scrollSelectionIntoView();
      } }, "table backspace": { key: "Backspace", format: ["table"], collapsed: true, offset: 0, handler() {
      } }, "table delete": { key: "Delete", format: ["table"], collapsed: true, suffix: /^$/, handler() {
      } }, "table enter": { key: "Enter", shiftKey: null, format: ["table"], handler(t3) {
        const e3 = this.quill.getModule("table");
        if (e3) {
          const [n3, i2, o2, l2] = e3.getTable(t3), a2 = (function(t4, e4, n4, s3) {
            return null == e4.prev && null == e4.next ? null == n4.prev && null == n4.next ? 0 === s3 ? -1 : 1 : null == n4.prev ? -1 : 1 : null == e4.prev ? -1 : null == e4.next ? 1 : null;
          })(0, i2, o2, l2);
          if (null == a2) return;
          let c2 = n3.offset();
          if (a2 < 0) {
            const e4 = new s2.Ay().retain(c2).insert("\n");
            this.quill.updateContents(e4, r.Ay.sources.USER), this.quill.setSelection(t3.index + 1, t3.length, r.Ay.sources.SILENT);
          } else if (a2 > 0) {
            c2 += n3.length();
            const t4 = new s2.Ay().retain(c2).insert("\n");
            this.quill.updateContents(t4, r.Ay.sources.USER), this.quill.setSelection(c2, r.Ay.sources.USER);
          }
        }
      } }, "table tab": { key: "Tab", shiftKey: null, format: ["table"], handler(t3, e3) {
        const { event: n3, line: s3 } = e3, i2 = s3.offset(this.quill.scroll);
        n3.shiftKey ? this.quill.setSelection(i2 - 1, r.Ay.sources.USER) : this.quill.setSelection(i2 + s3.length(), r.Ay.sources.USER);
      } }, "list autofill": { key: " ", shiftKey: null, collapsed: true, format: { "code-block": false, blockquote: false, table: false }, prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/, handler(t3, e3) {
        if (null == this.quill.scroll.query("list")) return true;
        const { length: n3 } = e3.prefix, [i2, o2] = this.quill.getLine(t3.index);
        if (o2 > n3) return true;
        let l2;
        switch (e3.prefix.trim()) {
          case "[]":
          case "[ ]":
            l2 = "unchecked";
            break;
          case "[x]":
            l2 = "checked";
            break;
          case "-":
          case "*":
            l2 = "bullet";
            break;
          default:
            l2 = "ordered";
        }
        this.quill.insertText(t3.index, " ", r.Ay.sources.USER), this.quill.history.cutoff();
        const a2 = new s2.Ay().retain(t3.index - o2).delete(n3 + 1).retain(i2.length() - 2 - o2).retain(1, { list: l2 });
        return this.quill.updateContents(a2, r.Ay.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t3.index - n3, r.Ay.sources.SILENT), false;
      } }, "code exit": { key: "Enter", collapsed: true, format: ["code-block"], prefix: /^$/, suffix: /^\s*$/, handler(t3) {
        const [e3, n3] = this.quill.getLine(t3.index);
        let i2 = 2, o2 = e3;
        for (; null != o2 && o2.length() <= 1 && o2.formats()["code-block"]; ) if (o2 = o2.prev, i2 -= 1, i2 <= 0) {
          const i3 = new s2.Ay().retain(t3.index + e3.length() - n3 - 2).retain(1, { "code-block": null }).delete(1);
          return this.quill.updateContents(i3, r.Ay.sources.USER), this.quill.setSelection(t3.index - 1, r.Ay.sources.SILENT), false;
        }
        return true;
      } }, "embed left": p("ArrowLeft", false), "embed left shift": p("ArrowLeft", true), "embed right": p("ArrowRight", false), "embed right shift": p("ArrowRight", true), "table down": g(false), "table up": g(true) } };
      function f(t3) {
        return { key: "Tab", shiftKey: !t3, format: { "code-block": true }, handler(e3, n3) {
          let { event: s3 } = n3;
          const i2 = this.quill.scroll.query("code-block"), { TAB: o2 } = i2;
          if (0 === e3.length && !s3.shiftKey) return this.quill.insertText(e3.index, o2, r.Ay.sources.USER), void this.quill.setSelection(e3.index + o2.length, r.Ay.sources.SILENT);
          const l2 = 0 === e3.length ? this.quill.getLines(e3.index, 1) : this.quill.getLines(e3);
          let { index: a2, length: c2 } = e3;
          l2.forEach(((e4, n4) => {
            t3 ? (e4.insertAt(0, o2), 0 === n4 ? a2 += o2.length : c2 += o2.length) : e4.domNode.textContent.startsWith(o2) && (e4.deleteAt(0, o2.length), 0 === n4 ? a2 -= o2.length : c2 -= o2.length);
          })), this.quill.update(r.Ay.sources.USER), this.quill.setSelection(a2, c2, r.Ay.sources.SILENT);
        } };
      }
      function p(t3, e3) {
        return { key: t3, shiftKey: e3, altKey: null, ["ArrowLeft" === t3 ? "prefix" : "suffix"]: /^$/, handler(n3) {
          let { index: s3 } = n3;
          "ArrowRight" === t3 && (s3 += n3.length + 1);
          const [o2] = this.quill.getLeaf(s3);
          return !(o2 instanceof i.EmbedBlot && ("ArrowLeft" === t3 ? e3 ? this.quill.setSelection(n3.index - 1, n3.length + 1, r.Ay.sources.USER) : this.quill.setSelection(n3.index - 1, r.Ay.sources.USER) : e3 ? this.quill.setSelection(n3.index, n3.length + 1, r.Ay.sources.USER) : this.quill.setSelection(n3.index + n3.length + 1, r.Ay.sources.USER), 1));
        } };
      }
      function m(t3) {
        return { key: t3[0], shortKey: true, handler(e3, n3) {
          this.quill.format(t3, !n3.format[t3], r.Ay.sources.USER);
        } };
      }
      function g(t3) {
        return { key: t3 ? "ArrowUp" : "ArrowDown", collapsed: true, format: ["table"], handler(e3, n3) {
          const s3 = t3 ? "prev" : "next", i2 = n3.line, o2 = i2.parent[s3];
          if (null != o2) {
            if ("table-row" === o2.statics.blotName) {
              let t4 = o2.children.head, e4 = i2;
              for (; null != e4.prev; ) e4 = e4.prev, t4 = t4.next;
              const s4 = t4.offset(this.quill.scroll) + Math.min(n3.offset, t4.length() - 1);
              this.quill.setSelection(s4, 0, r.Ay.sources.USER);
            }
          } else {
            const e4 = i2.table()[s3];
            null != e4 && (t3 ? this.quill.setSelection(e4.offset(this.quill.scroll) + e4.length() - 1, 0, r.Ay.sources.USER) : this.quill.setSelection(e4.offset(this.quill.scroll), 0, r.Ay.sources.USER));
          }
          return false;
        } };
      }
      function b(t3) {
        let { quill: e3, range: n3 } = t3;
        const i2 = e3.getLines(n3);
        let o2 = {};
        if (i2.length > 1) {
          const t4 = i2[0].formats(), e4 = i2[i2.length - 1].formats();
          o2 = s2.xb.diff(e4, t4) || {};
        }
        e3.deleteText(n3, r.Ay.sources.USER), Object.keys(o2).length > 0 && e3.formatLine(n3.index, 1, o2, r.Ay.sources.USER), e3.setSelection(n3.index, r.Ay.sources.SILENT);
      }
      u.DEFAULTS = d;
    }, 398: function(t2, e2, n2) {
      n2.d(e2, { Ay: function() {
        return L;
      }, Op: function() {
        return A;
      }, xb: function() {
        return y;
      } });
      var s2, i, r = Object.create, o = Object.defineProperty, l = Object.getOwnPropertyDescriptor, a = Object.getOwnPropertyNames, c = Object.getPrototypeOf, h = Object.prototype.hasOwnProperty, u = ((t3, e3, n3) => (n3 = null != t3 ? r(c(t3)) : {}, ((t4, e4, n4, s3) => {
        if (e4 && "object" == typeof e4 || "function" == typeof e4) for (let n5 of a(e4)) h.call(t4, n5) || void 0 === n5 || o(t4, n5, { get: () => e4[n5], enumerable: !(s3 = l(e4, n5)) || s3.enumerable });
        return t4;
      })(t3 && t3.__esModule ? n3 : o(n3, "default", { value: t3, enumerable: true }), t3)))((s2 = { "node_modules/.pnpm/fast-diff@1.3.0/node_modules/fast-diff/diff.js"(t3, e3) {
        var n3 = -1;
        function s3(t4, e4, p3, m3, g3) {
          if (t4 === e4) return t4 ? [[0, t4]] : [];
          if (null != p3) {
            var b3 = (function(t5, e5, n4) {
              var s4 = "number" == typeof n4 ? { index: n4, length: 0 } : n4.oldRange, i3 = "number" == typeof n4 ? null : n4.newRange, r3 = t5.length, o3 = e5.length;
              if (0 === s4.length && (null === i3 || 0 === i3.length)) {
                var l3 = s4.index, a3 = t5.slice(0, l3), c3 = t5.slice(l3), h3 = i3 ? i3.index : null, u3 = l3 + o3 - r3;
                if ((null === h3 || h3 === u3) && !(u3 < 0 || u3 > o3)) {
                  var d3 = e5.slice(0, u3);
                  if ((m4 = e5.slice(u3)) === c3) {
                    var f3 = Math.min(l3, u3);
                    if ((b4 = a3.slice(0, f3)) === (N3 = d3.slice(0, f3))) return y2(b4, a3.slice(f3), d3.slice(f3), c3);
                  }
                }
                if (null === h3 || h3 === l3) {
                  var p4 = l3, m4 = (d3 = e5.slice(0, p4), e5.slice(p4));
                  if (d3 === a3) {
                    var g4 = Math.min(r3 - p4, o3 - p4);
                    if ((A4 = c3.slice(c3.length - g4)) === (v3 = m4.slice(m4.length - g4))) return y2(a3, c3.slice(0, c3.length - g4), m4.slice(0, m4.length - g4), A4);
                  }
                }
              }
              if (s4.length > 0 && i3 && 0 === i3.length) {
                var b4 = t5.slice(0, s4.index), A4 = t5.slice(s4.index + s4.length);
                if (!(o3 < (f3 = b4.length) + (g4 = A4.length))) {
                  var N3 = e5.slice(0, f3), v3 = e5.slice(o3 - g4);
                  if (b4 === N3 && A4 === v3) return y2(b4, t5.slice(f3, r3 - g4), e5.slice(f3, o3 - g4), A4);
                }
              }
              return null;
            })(t4, e4, p3);
            if (b3) return b3;
          }
          var A3 = r2(t4, e4), N2 = t4.substring(0, A3);
          A3 = l2(t4 = t4.substring(A3), e4 = e4.substring(A3));
          var v2 = t4.substring(t4.length - A3), E2 = (function(t5, e5) {
            var o3;
            if (!t5) return [[1, e5]];
            if (!e5) return [[n3, t5]];
            var a3 = t5.length > e5.length ? t5 : e5, c3 = t5.length > e5.length ? e5 : t5, h3 = a3.indexOf(c3);
            if (-1 !== h3) return o3 = [[1, a3.substring(0, h3)], [0, c3], [1, a3.substring(h3 + c3.length)]], t5.length > e5.length && (o3[0][0] = o3[2][0] = n3), o3;
            if (1 === c3.length) return [[n3, t5], [1, e5]];
            var u3 = (function(t6, e6) {
              var n4 = t6.length > e6.length ? t6 : e6, s4 = t6.length > e6.length ? e6 : t6;
              if (n4.length < 4 || 2 * s4.length < n4.length) return null;
              function i3(t7, e7, n5) {
                for (var s5, i4, o5, a5, c5 = t7.substring(n5, n5 + Math.floor(t7.length / 4)), h5 = -1, u5 = ""; -1 !== (h5 = e7.indexOf(c5, h5 + 1)); ) {
                  var d5 = r2(t7.substring(n5), e7.substring(h5)), f5 = l2(t7.substring(0, n5), e7.substring(0, h5));
                  u5.length < f5 + d5 && (u5 = e7.substring(h5 - f5, h5) + e7.substring(h5, h5 + d5), s5 = t7.substring(0, n5 - f5), i4 = t7.substring(n5 + d5), o5 = e7.substring(0, h5 - f5), a5 = e7.substring(h5 + d5));
                }
                return 2 * u5.length >= t7.length ? [s5, i4, o5, a5, u5] : null;
              }
              var o4, a4, c4, h4, u4, d4 = i3(n4, s4, Math.ceil(n4.length / 4)), f4 = i3(n4, s4, Math.ceil(n4.length / 2));
              return d4 || f4 ? (o4 = f4 ? d4 && d4[4].length > f4[4].length ? d4 : f4 : d4, t6.length > e6.length ? (a4 = o4[0], c4 = o4[1], h4 = o4[2], u4 = o4[3]) : (h4 = o4[0], u4 = o4[1], a4 = o4[2], c4 = o4[3]), [a4, c4, h4, u4, o4[4]]) : null;
            })(t5, e5);
            if (u3) {
              var d3 = u3[0], f3 = u3[1], p4 = u3[2], m4 = u3[3], g4 = u3[4], b4 = s3(d3, p4), y3 = s3(f3, m4);
              return b4.concat([[0, g4]], y3);
            }
            return (function(t6, e6) {
              for (var s4 = t6.length, r3 = e6.length, o4 = Math.ceil((s4 + r3) / 2), l3 = o4, a4 = 2 * o4, c4 = new Array(a4), h4 = new Array(a4), u4 = 0; u4 < a4; u4++) c4[u4] = -1, h4[u4] = -1;
              c4[l3 + 1] = 0, h4[l3 + 1] = 0;
              for (var d4 = s4 - r3, f4 = d4 % 2 != 0, p5 = 0, m5 = 0, g5 = 0, b5 = 0, y4 = 0; y4 < o4; y4++) {
                for (var A4 = -y4 + p5; A4 <= y4 - m5; A4 += 2) {
                  for (var N3 = l3 + A4, v3 = (T = A4 === -y4 || A4 !== y4 && c4[N3 - 1] < c4[N3 + 1] ? c4[N3 + 1] : c4[N3 - 1] + 1) - A4; T < s4 && v3 < r3 && t6.charAt(T) === e6.charAt(v3); ) T++, v3++;
                  if (c4[N3] = T, T > s4) m5 += 2;
                  else if (v3 > r3) p5 += 2;
                  else if (f4 && (L2 = l3 + d4 - A4) >= 0 && L2 < a4 && -1 !== h4[L2] && T >= (x2 = s4 - h4[L2])) return i2(t6, e6, T, v3);
                }
                for (var E3 = -y4 + g5; E3 <= y4 - b5; E3 += 2) {
                  for (var x2, L2 = l3 + E3, S = (x2 = E3 === -y4 || E3 !== y4 && h4[L2 - 1] < h4[L2 + 1] ? h4[L2 + 1] : h4[L2 - 1] + 1) - E3; x2 < s4 && S < r3 && t6.charAt(s4 - x2 - 1) === e6.charAt(r3 - S - 1); ) x2++, S++;
                  if (h4[L2] = x2, x2 > s4) b5 += 2;
                  else if (S > r3) g5 += 2;
                  else if (!f4) {
                    var T;
                    if ((N3 = l3 + d4 - E3) >= 0 && N3 < a4 && -1 !== c4[N3] && (v3 = l3 + (T = c4[N3]) - N3, T >= (x2 = s4 - x2))) return i2(t6, e6, T, v3);
                  }
                }
              }
              return [[n3, t6], [1, e6]];
            })(t5, e5);
          })(t4 = t4.substring(0, t4.length - A3), e4 = e4.substring(0, e4.length - A3));
          return N2 && E2.unshift([0, N2]), v2 && E2.push([0, v2]), f2(E2, g3), m3 && (function(t5) {
            for (var e5 = false, s4 = [], i3 = 0, r3 = null, p4 = 0, m4 = 0, g4 = 0, b4 = 0, y3 = 0; p4 < t5.length; ) 0 == t5[p4][0] ? (s4[i3++] = p4, m4 = b4, g4 = y3, b4 = 0, y3 = 0, r3 = t5[p4][1]) : (1 == t5[p4][0] ? b4 += t5[p4][1].length : y3 += t5[p4][1].length, r3 && r3.length <= Math.max(m4, g4) && r3.length <= Math.max(b4, y3) && (t5.splice(s4[i3 - 1], 0, [n3, r3]), t5[s4[i3 - 1] + 1][0] = 1, i3--, p4 = --i3 > 0 ? s4[i3 - 1] : -1, m4 = 0, g4 = 0, b4 = 0, y3 = 0, r3 = null, e5 = true)), p4++;
            for (e5 && f2(t5), (function(t6) {
              function e6(t7, e7) {
                if (!t7 || !e7) return 6;
                var n5 = t7.charAt(t7.length - 1), s6 = e7.charAt(0), i5 = n5.match(a2), r5 = s6.match(a2), o4 = i5 && n5.match(c2), l3 = r5 && s6.match(c2), f4 = o4 && n5.match(h2), p6 = l3 && s6.match(h2), m6 = f4 && t7.match(u2), g6 = p6 && e7.match(d2);
                return m6 || g6 ? 5 : f4 || p6 ? 4 : i5 && !o4 && l3 ? 3 : o4 || l3 ? 2 : i5 || r5 ? 1 : 0;
              }
              for (var n4 = 1; n4 < t6.length - 1; ) {
                if (0 == t6[n4 - 1][0] && 0 == t6[n4 + 1][0]) {
                  var s5 = t6[n4 - 1][1], i4 = t6[n4][1], r4 = t6[n4 + 1][1], o3 = l2(s5, i4);
                  if (o3) {
                    var f3 = i4.substring(i4.length - o3);
                    s5 = s5.substring(0, s5.length - o3), i4 = f3 + i4.substring(0, i4.length - o3), r4 = f3 + r4;
                  }
                  for (var p5 = s5, m5 = i4, g5 = r4, b5 = e6(s5, i4) + e6(i4, r4); i4.charAt(0) === r4.charAt(0); ) {
                    s5 += i4.charAt(0), i4 = i4.substring(1) + r4.charAt(0), r4 = r4.substring(1);
                    var y4 = e6(s5, i4) + e6(i4, r4);
                    y4 >= b5 && (b5 = y4, p5 = s5, m5 = i4, g5 = r4);
                  }
                  t6[n4 - 1][1] != p5 && (p5 ? t6[n4 - 1][1] = p5 : (t6.splice(n4 - 1, 1), n4--), t6[n4][1] = m5, g5 ? t6[n4 + 1][1] = g5 : (t6.splice(n4 + 1, 1), n4--));
                }
                n4++;
              }
            })(t5), p4 = 1; p4 < t5.length; ) {
              if (t5[p4 - 1][0] == n3 && 1 == t5[p4][0]) {
                var A4 = t5[p4 - 1][1], N3 = t5[p4][1], v3 = o2(A4, N3), E3 = o2(N3, A4);
                v3 >= E3 ? (v3 >= A4.length / 2 || v3 >= N3.length / 2) && (t5.splice(p4, 0, [0, N3.substring(0, v3)]), t5[p4 - 1][1] = A4.substring(0, A4.length - v3), t5[p4 + 1][1] = N3.substring(v3), p4++) : (E3 >= A4.length / 2 || E3 >= N3.length / 2) && (t5.splice(p4, 0, [0, A4.substring(0, E3)]), t5[p4 - 1][0] = 1, t5[p4 - 1][1] = N3.substring(0, N3.length - E3), t5[p4 + 1][0] = n3, t5[p4 + 1][1] = A4.substring(E3), p4++), p4++;
              }
              p4++;
            }
          })(E2), E2;
        }
        function i2(t4, e4, n4, i3) {
          var r3 = t4.substring(0, n4), o3 = e4.substring(0, i3), l3 = t4.substring(n4), a3 = e4.substring(i3), c3 = s3(r3, o3), h3 = s3(l3, a3);
          return c3.concat(h3);
        }
        function r2(t4, e4) {
          if (!t4 || !e4 || t4.charAt(0) !== e4.charAt(0)) return 0;
          for (var n4 = 0, s4 = Math.min(t4.length, e4.length), i3 = s4, r3 = 0; n4 < i3; ) t4.substring(r3, i3) == e4.substring(r3, i3) ? r3 = n4 = i3 : s4 = i3, i3 = Math.floor((s4 - n4) / 2 + n4);
          return p2(t4.charCodeAt(i3 - 1)) && i3--, i3;
        }
        function o2(t4, e4) {
          var n4 = t4.length, s4 = e4.length;
          if (0 == n4 || 0 == s4) return 0;
          n4 > s4 ? t4 = t4.substring(n4 - s4) : n4 < s4 && (e4 = e4.substring(0, n4));
          var i3 = Math.min(n4, s4);
          if (t4 == e4) return i3;
          for (var r3 = 0, o3 = 1; ; ) {
            var l3 = t4.substring(i3 - o3), a3 = e4.indexOf(l3);
            if (-1 == a3) return r3;
            o3 += a3, 0 != a3 && t4.substring(i3 - o3) != e4.substring(0, o3) || (r3 = o3, o3++);
          }
        }
        function l2(t4, e4) {
          if (!t4 || !e4 || t4.slice(-1) !== e4.slice(-1)) return 0;
          for (var n4 = 0, s4 = Math.min(t4.length, e4.length), i3 = s4, r3 = 0; n4 < i3; ) t4.substring(t4.length - i3, t4.length - r3) == e4.substring(e4.length - i3, e4.length - r3) ? r3 = n4 = i3 : s4 = i3, i3 = Math.floor((s4 - n4) / 2 + n4);
          return m2(t4.charCodeAt(t4.length - i3)) && i3--, i3;
        }
        var a2 = /[^a-zA-Z0-9]/, c2 = /\s/, h2 = /[\r\n]/, u2 = /\n\r?\n$/, d2 = /^\r?\n\r?\n/;
        function f2(t4, e4) {
          t4.push([0, ""]);
          for (var s4, i3 = 0, o3 = 0, a3 = 0, c3 = "", h3 = ""; i3 < t4.length; ) if (i3 < t4.length - 1 && !t4[i3][1]) t4.splice(i3, 1);
          else switch (t4[i3][0]) {
            case 1:
              a3++, h3 += t4[i3][1], i3++;
              break;
            case n3:
              o3++, c3 += t4[i3][1], i3++;
              break;
            case 0:
              var u3 = i3 - a3 - o3 - 1;
              if (e4) {
                if (u3 >= 0 && b2(t4[u3][1])) {
                  var d3 = t4[u3][1].slice(-1);
                  if (t4[u3][1] = t4[u3][1].slice(0, -1), c3 = d3 + c3, h3 = d3 + h3, !t4[u3][1]) {
                    t4.splice(u3, 1), i3--;
                    var p3 = u3 - 1;
                    t4[p3] && 1 === t4[p3][0] && (a3++, h3 = t4[p3][1] + h3, p3--), t4[p3] && t4[p3][0] === n3 && (o3++, c3 = t4[p3][1] + c3, p3--), u3 = p3;
                  }
                }
                g2(t4[i3][1]) && (d3 = t4[i3][1].charAt(0), t4[i3][1] = t4[i3][1].slice(1), c3 += d3, h3 += d3);
              }
              if (i3 < t4.length - 1 && !t4[i3][1]) {
                t4.splice(i3, 1);
                break;
              }
              if (c3.length > 0 || h3.length > 0) {
                c3.length > 0 && h3.length > 0 && (0 !== (s4 = r2(h3, c3)) && (u3 >= 0 ? t4[u3][1] += h3.substring(0, s4) : (t4.splice(0, 0, [0, h3.substring(0, s4)]), i3++), h3 = h3.substring(s4), c3 = c3.substring(s4)), 0 !== (s4 = l2(h3, c3)) && (t4[i3][1] = h3.substring(h3.length - s4) + t4[i3][1], h3 = h3.substring(0, h3.length - s4), c3 = c3.substring(0, c3.length - s4)));
                var m3 = a3 + o3;
                0 === c3.length && 0 === h3.length ? (t4.splice(i3 - m3, m3), i3 -= m3) : 0 === c3.length ? (t4.splice(i3 - m3, m3, [1, h3]), i3 = i3 - m3 + 1) : 0 === h3.length ? (t4.splice(i3 - m3, m3, [n3, c3]), i3 = i3 - m3 + 1) : (t4.splice(i3 - m3, m3, [n3, c3], [1, h3]), i3 = i3 - m3 + 2);
              }
              0 !== i3 && 0 === t4[i3 - 1][0] ? (t4[i3 - 1][1] += t4[i3][1], t4.splice(i3, 1)) : i3++, a3 = 0, o3 = 0, c3 = "", h3 = "";
          }
          "" === t4[t4.length - 1][1] && t4.pop();
          var y3 = false;
          for (i3 = 1; i3 < t4.length - 1; ) 0 === t4[i3 - 1][0] && 0 === t4[i3 + 1][0] && (t4[i3][1].substring(t4[i3][1].length - t4[i3 - 1][1].length) === t4[i3 - 1][1] ? (t4[i3][1] = t4[i3 - 1][1] + t4[i3][1].substring(0, t4[i3][1].length - t4[i3 - 1][1].length), t4[i3 + 1][1] = t4[i3 - 1][1] + t4[i3 + 1][1], t4.splice(i3 - 1, 1), y3 = true) : t4[i3][1].substring(0, t4[i3 + 1][1].length) == t4[i3 + 1][1] && (t4[i3 - 1][1] += t4[i3 + 1][1], t4[i3][1] = t4[i3][1].substring(t4[i3 + 1][1].length) + t4[i3 + 1][1], t4.splice(i3 + 1, 1), y3 = true)), i3++;
          y3 && f2(t4, e4);
        }
        function p2(t4) {
          return t4 >= 55296 && t4 <= 56319;
        }
        function m2(t4) {
          return t4 >= 56320 && t4 <= 57343;
        }
        function g2(t4) {
          return m2(t4.charCodeAt(0));
        }
        function b2(t4) {
          return p2(t4.charCodeAt(t4.length - 1));
        }
        function y2(t4, e4, s4, i3) {
          return b2(t4) || g2(i3) ? null : (function(t5) {
            for (var e5 = [], n4 = 0; n4 < t5.length; n4++) t5[n4][1].length > 0 && e5.push(t5[n4]);
            return e5;
          })([[0, t4], [n3, e4], [1, s4], [0, i3]]);
        }
        function A2(t4, e4, n4, i3) {
          return s3(t4, e4, n4, i3, true);
        }
        A2.INSERT = 1, A2.DELETE = n3, A2.EQUAL = 0, e3.exports = A2;
      } }, function() {
        return i || (0, s2[a(s2)[0]])((i = { exports: {} }).exports, i), i.exports;
      })()), d = function(t3) {
        return JSON.parse(JSON.stringify(t3));
      };
      function f(t3) {
        return t3 !== Object(t3);
      }
      var p, m, g = function t3(e3, n3) {
        if (e3 === n3) return true;
        if (f(e3) || f(n3)) return e3 === n3;
        if (Object.keys(e3).length !== Object.keys(n3).length) return false;
        for (let s3 in e3) {
          if (!(s3 in n3)) return false;
          if (!t3(e3[s3], n3[s3])) return false;
        }
        return true;
      };
      (m = p || (p = {})).compose = function(t3 = {}, e3 = {}, n3 = false) {
        "object" != typeof t3 && (t3 = {}), "object" != typeof e3 && (e3 = {});
        let s3 = d(e3);
        n3 || (s3 = Object.keys(s3).reduce(((t4, e4) => (null != s3[e4] && (t4[e4] = s3[e4]), t4)), {}));
        for (const n4 in t3) void 0 !== t3[n4] && void 0 === e3[n4] && (s3[n4] = t3[n4]);
        return Object.keys(s3).length > 0 ? s3 : void 0;
      }, m.diff = function(t3 = {}, e3 = {}) {
        "object" != typeof t3 && (t3 = {}), "object" != typeof e3 && (e3 = {});
        const n3 = Object.keys(t3).concat(Object.keys(e3)).reduce(((n4, s3) => (g(t3[s3], e3[s3]) || (n4[s3] = void 0 === e3[s3] ? null : e3[s3]), n4)), {});
        return Object.keys(n3).length > 0 ? n3 : void 0;
      }, m.invert = function(t3 = {}, e3 = {}) {
        t3 = t3 || {};
        const n3 = Object.keys(e3).reduce(((n4, s3) => (e3[s3] !== t3[s3] && void 0 !== t3[s3] && (n4[s3] = e3[s3]), n4)), {});
        return Object.keys(t3).reduce(((n4, s3) => (t3[s3] !== e3[s3] && void 0 === e3[s3] && (n4[s3] = null), n4)), n3);
      }, m.transform = function(t3, e3, n3 = false) {
        if ("object" != typeof t3) return e3;
        if ("object" != typeof e3) return;
        if (!n3) return e3;
        const s3 = Object.keys(e3).reduce(((n4, s4) => (void 0 === t3[s4] && (n4[s4] = e3[s4]), n4)), {});
        return Object.keys(s3).length > 0 ? s3 : void 0;
      };
      var b, y = p;
      (b || (b = {})).length = function(t3) {
        return "number" == typeof t3.delete ? t3.delete : "number" == typeof t3.retain ? t3.retain : "object" == typeof t3.retain && null !== t3.retain ? 1 : "string" == typeof t3.insert ? t3.insert.length : 1;
      };
      var A = b, N = class {
        ops;
        index;
        offset;
        constructor(t3) {
          this.ops = t3, this.index = 0, this.offset = 0;
        }
        hasNext() {
          return this.peekLength() < 1 / 0;
        }
        next(t3) {
          t3 || (t3 = 1 / 0);
          const e3 = this.ops[this.index];
          if (e3) {
            const n3 = this.offset, s3 = A.length(e3);
            if (t3 >= s3 - n3 ? (t3 = s3 - n3, this.index += 1, this.offset = 0) : this.offset += t3, "number" == typeof e3.delete) return { delete: t3 };
            {
              const s4 = {};
              return e3.attributes && (s4.attributes = e3.attributes), "number" == typeof e3.retain ? s4.retain = t3 : "object" == typeof e3.retain && null !== e3.retain ? s4.retain = e3.retain : "string" == typeof e3.insert ? s4.insert = e3.insert.substr(n3, t3) : s4.insert = e3.insert, s4;
            }
          }
          return { retain: 1 / 0 };
        }
        peek() {
          return this.ops[this.index];
        }
        peekLength() {
          return this.ops[this.index] ? A.length(this.ops[this.index]) - this.offset : 1 / 0;
        }
        peekType() {
          const t3 = this.ops[this.index];
          return t3 ? "number" == typeof t3.delete ? "delete" : "number" == typeof t3.retain || "object" == typeof t3.retain && null !== t3.retain ? "retain" : "insert" : "retain";
        }
        rest() {
          if (this.hasNext()) {
            if (0 === this.offset) return this.ops.slice(this.index);
            {
              const t3 = this.offset, e3 = this.index, n3 = this.next(), s3 = this.ops.slice(this.index);
              return this.offset = t3, this.index = e3, [n3].concat(s3);
            }
          }
          return [];
        }
      }, v = String.fromCharCode(0), E = (t3, e3) => {
        if ("object" != typeof t3 || null === t3) throw new Error("cannot retain a " + typeof t3);
        if ("object" != typeof e3 || null === e3) throw new Error("cannot retain a " + typeof e3);
        const n3 = Object.keys(t3)[0];
        if (!n3 || n3 !== Object.keys(e3)[0]) throw new Error(`embed types not matched: ${n3} != ${Object.keys(e3)[0]}`);
        return [n3, t3[n3], e3[n3]];
      }, x = class t3 {
        static Op = A;
        static OpIterator = N;
        static AttributeMap = y;
        static handlers = {};
        static registerEmbed(t4, e3) {
          this.handlers[t4] = e3;
        }
        static unregisterEmbed(t4) {
          delete this.handlers[t4];
        }
        static getHandler(t4) {
          const e3 = this.handlers[t4];
          if (!e3) throw new Error(`no handlers for embed type "${t4}"`);
          return e3;
        }
        ops;
        inverted;
        constructor(t4) {
          Array.isArray(t4) ? this.ops = t4 : null != t4 && Array.isArray(t4.ops) ? (this.ops = t4.ops, this.inverted = t4.inverted) : this.ops = [];
        }
        insert(t4, e3) {
          const n3 = {};
          return "string" == typeof t4 && 0 === t4.length ? this : (n3.insert = t4, null != e3 && "object" == typeof e3 && Object.keys(e3).length > 0 && (n3.attributes = e3), this.push(n3));
        }
        delete(t4) {
          return t4 <= 0 ? this : this.push({ delete: t4 });
        }
        retain(t4, e3) {
          if ("number" == typeof t4 && t4 <= 0) return this;
          const n3 = { retain: t4 };
          return null != e3 && "object" == typeof e3 && Object.keys(e3).length > 0 && (n3.attributes = e3), this.push(n3);
        }
        push(t4) {
          let e3 = this.ops.length, n3 = this.ops[e3 - 1];
          if (t4 = d(t4), "object" == typeof n3) {
            if ("number" == typeof t4.delete && "number" == typeof n3.delete) return this.ops[e3 - 1] = { delete: n3.delete + t4.delete }, this;
            if ("number" == typeof n3.delete && null != t4.insert && (e3 -= 1, n3 = this.ops[e3 - 1], "object" != typeof n3)) return this.ops.unshift(t4), this;
            if (g(t4.attributes, n3.attributes)) {
              if ("string" == typeof t4.insert && "string" == typeof n3.insert) return this.ops[e3 - 1] = { insert: n3.insert + t4.insert }, "object" == typeof t4.attributes && (this.ops[e3 - 1].attributes = t4.attributes), this;
              if ("number" == typeof t4.retain && "number" == typeof n3.retain) return this.ops[e3 - 1] = { retain: n3.retain + t4.retain }, "object" == typeof t4.attributes && (this.ops[e3 - 1].attributes = t4.attributes), this;
            }
          }
          return e3 === this.ops.length ? this.ops.push(t4) : this.ops.splice(e3, 0, t4), this;
        }
        chop() {
          const t4 = this.ops[this.ops.length - 1];
          return t4 && "number" == typeof t4.retain && !t4.attributes && this.ops.pop(), this;
        }
        filter(t4) {
          return this.ops.filter(t4);
        }
        forEach(t4) {
          this.ops.forEach(t4);
        }
        map(t4) {
          return this.ops.map(t4);
        }
        partition(t4) {
          const e3 = [], n3 = [];
          return this.forEach(((s3) => {
            (t4(s3) ? e3 : n3).push(s3);
          })), [e3, n3];
        }
        reduce(t4, e3) {
          return this.ops.reduce(t4, e3);
        }
        changeLength() {
          return this.reduce(((t4, e3) => e3.insert ? t4 + A.length(e3) : e3.delete ? t4 - e3.delete : t4), 0);
        }
        length() {
          return this.reduce(((t4, e3) => t4 + A.length(e3)), 0);
        }
        slice(e3 = 0, n3 = 1 / 0) {
          const s3 = [], i2 = new N(this.ops);
          let r2 = 0;
          for (; r2 < n3 && i2.hasNext(); ) {
            let t4;
            r2 < e3 ? t4 = i2.next(e3 - r2) : (t4 = i2.next(n3 - r2), s3.push(t4)), r2 += A.length(t4);
          }
          return new t3(s3);
        }
        compose(e3) {
          const n3 = new N(this.ops), s3 = new N(e3.ops), i2 = [], r2 = s3.peek();
          if (null != r2 && "number" == typeof r2.retain && null == r2.attributes) {
            let t4 = r2.retain;
            for (; "insert" === n3.peekType() && n3.peekLength() <= t4; ) t4 -= n3.peekLength(), i2.push(n3.next());
            r2.retain - t4 > 0 && s3.next(r2.retain - t4);
          }
          const o2 = new t3(i2);
          for (; n3.hasNext() || s3.hasNext(); ) if ("insert" === s3.peekType()) o2.push(s3.next());
          else if ("delete" === n3.peekType()) o2.push(n3.next());
          else {
            const e4 = Math.min(n3.peekLength(), s3.peekLength()), i3 = n3.next(e4), r3 = s3.next(e4);
            if (r3.retain) {
              const l2 = {};
              if ("number" == typeof i3.retain) l2.retain = "number" == typeof r3.retain ? e4 : r3.retain;
              else if ("number" == typeof r3.retain) null == i3.retain ? l2.insert = i3.insert : l2.retain = i3.retain;
              else {
                const e5 = null == i3.retain ? "insert" : "retain", [n4, s4, o3] = E(i3[e5], r3.retain), a3 = t3.getHandler(n4);
                l2[e5] = { [n4]: a3.compose(s4, o3, "retain" === e5) };
              }
              const a2 = y.compose(i3.attributes, r3.attributes, "number" == typeof i3.retain);
              if (a2 && (l2.attributes = a2), o2.push(l2), !s3.hasNext() && g(o2.ops[o2.ops.length - 1], l2)) {
                const e5 = new t3(n3.rest());
                return o2.concat(e5).chop();
              }
            } else "number" == typeof r3.delete && ("number" == typeof i3.retain || "object" == typeof i3.retain && null !== i3.retain) && o2.push(r3);
          }
          return o2.chop();
        }
        concat(e3) {
          const n3 = new t3(this.ops.slice());
          return e3.ops.length > 0 && (n3.push(e3.ops[0]), n3.ops = n3.ops.concat(e3.ops.slice(1))), n3;
        }
        diff(e3, n3) {
          if (this.ops === e3.ops) return new t3();
          const s3 = [this, e3].map(((t4) => t4.map(((n4) => {
            if (null != n4.insert) return "string" == typeof n4.insert ? n4.insert : v;
            throw new Error("diff() called " + (t4 === e3 ? "on" : "with") + " non-document");
          })).join(""))), i2 = new t3(), r2 = (0, u.default)(s3[0], s3[1], n3, true), o2 = new N(this.ops), l2 = new N(e3.ops);
          return r2.forEach(((t4) => {
            let e4 = t4[1].length;
            for (; e4 > 0; ) {
              let n4 = 0;
              switch (t4[0]) {
                case u.default.INSERT:
                  n4 = Math.min(l2.peekLength(), e4), i2.push(l2.next(n4));
                  break;
                case u.default.DELETE:
                  n4 = Math.min(e4, o2.peekLength()), o2.next(n4), i2.delete(n4);
                  break;
                case u.default.EQUAL:
                  n4 = Math.min(o2.peekLength(), l2.peekLength(), e4);
                  const t5 = o2.next(n4), s4 = l2.next(n4);
                  g(t5.insert, s4.insert) ? i2.retain(n4, y.diff(t5.attributes, s4.attributes)) : i2.push(s4).delete(n4);
              }
              e4 -= n4;
            }
          })), i2.chop();
        }
        eachLine(e3, n3 = "\n") {
          const s3 = new N(this.ops);
          let i2 = new t3(), r2 = 0;
          for (; s3.hasNext(); ) {
            if ("insert" !== s3.peekType()) return;
            const o2 = s3.peek(), l2 = A.length(o2) - s3.peekLength(), a2 = "string" == typeof o2.insert ? o2.insert.indexOf(n3, l2) - l2 : -1;
            if (a2 < 0) i2.push(s3.next());
            else if (a2 > 0) i2.push(s3.next(a2));
            else {
              if (false === e3(i2, s3.next(1).attributes || {}, r2)) return;
              r2 += 1, i2 = new t3();
            }
          }
          i2.length() > 0 && e3(i2, {}, r2);
        }
        invert(e3) {
          const n3 = new t3();
          return this.reduce(((s3, i2) => {
            if (i2.insert) n3.delete(A.length(i2));
            else {
              if ("number" == typeof i2.retain && null == i2.attributes) return n3.retain(i2.retain), s3 + i2.retain;
              if (i2.delete || "number" == typeof i2.retain) {
                const t4 = i2.delete || i2.retain;
                return e3.slice(s3, s3 + t4).forEach(((t5) => {
                  i2.delete ? n3.push(t5) : i2.retain && i2.attributes && n3.retain(A.length(t5), y.invert(i2.attributes, t5.attributes));
                })), s3 + t4;
              }
              if ("object" == typeof i2.retain && null !== i2.retain) {
                const r2 = e3.slice(s3, s3 + 1), o2 = new N(r2.ops).next(), [l2, a2, c2] = E(i2.retain, o2.insert), h2 = t3.getHandler(l2);
                return n3.retain({ [l2]: h2.invert(a2, c2) }, y.invert(i2.attributes, o2.attributes)), s3 + 1;
              }
            }
            return s3;
          }), 0), n3.chop();
        }
        transform(e3, n3 = false) {
          if (n3 = !!n3, "number" == typeof e3) return this.transformPosition(e3, n3);
          const s3 = e3, i2 = new N(this.ops), r2 = new N(s3.ops), o2 = new t3();
          for (; i2.hasNext() || r2.hasNext(); ) if ("insert" !== i2.peekType() || !n3 && "insert" === r2.peekType()) if ("insert" === r2.peekType()) o2.push(r2.next());
          else {
            const e4 = Math.min(i2.peekLength(), r2.peekLength()), s4 = i2.next(e4), l2 = r2.next(e4);
            if (s4.delete) continue;
            if (l2.delete) o2.push(l2);
            else {
              const i3 = s4.retain, r3 = l2.retain;
              let a2 = "object" == typeof r3 && null !== r3 ? r3 : e4;
              if ("object" == typeof i3 && null !== i3 && "object" == typeof r3 && null !== r3) {
                const e5 = Object.keys(i3)[0];
                if (e5 === Object.keys(r3)[0]) {
                  const s5 = t3.getHandler(e5);
                  s5 && (a2 = { [e5]: s5.transform(i3[e5], r3[e5], n3) });
                }
              }
              o2.retain(a2, y.transform(s4.attributes, l2.attributes, n3));
            }
          }
          else o2.retain(A.length(i2.next()));
          return o2.chop();
        }
        transformPosition(t4, e3 = false) {
          e3 = !!e3;
          const n3 = new N(this.ops);
          let s3 = 0;
          for (; n3.hasNext() && s3 <= t4; ) {
            const i2 = n3.peekLength(), r2 = n3.peekType();
            n3.next(), "delete" !== r2 ? ("insert" === r2 && (s3 < t4 || !e3) && (t4 += i2), s3 += i2) : t4 -= Math.min(i2, t4 - s3);
          }
          return t4;
        }
      }, L = x;
      "object" == typeof module && (module.exports = x, module.exports.default = x);
    }, 3: function(t2, e2, n2) {
      n2.r(e2), n2.d(e2, { Attributor: function() {
        return i;
      }, AttributorStore: function() {
        return d;
      }, BlockBlot: function() {
        return L;
      }, ClassAttributor: function() {
        return c;
      }, ContainerBlot: function() {
        return T;
      }, EmbedBlot: function() {
        return k;
      }, InlineBlot: function() {
        return E;
      }, LeafBlot: function() {
        return g;
      }, ParentBlot: function() {
        return N;
      }, Registry: function() {
        return l;
      }, Scope: function() {
        return s2;
      }, ScrollBlot: function() {
        return C;
      }, StyleAttributor: function() {
        return u;
      }, TextBlot: function() {
        return R;
      } });
      var s2 = ((t3) => (t3[t3.TYPE = 3] = "TYPE", t3[t3.LEVEL = 12] = "LEVEL", t3[t3.ATTRIBUTE = 13] = "ATTRIBUTE", t3[t3.BLOT = 14] = "BLOT", t3[t3.INLINE = 7] = "INLINE", t3[t3.BLOCK = 11] = "BLOCK", t3[t3.BLOCK_BLOT = 10] = "BLOCK_BLOT", t3[t3.INLINE_BLOT = 6] = "INLINE_BLOT", t3[t3.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", t3[t3.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", t3[t3.ANY = 15] = "ANY", t3))(s2 || {});
      class i {
        constructor(t3, e3, n3 = {}) {
          this.attrName = t3, this.keyName = e3;
          const i2 = s2.TYPE & s2.ATTRIBUTE;
          this.scope = null != n3.scope ? n3.scope & s2.LEVEL | i2 : s2.ATTRIBUTE, null != n3.whitelist && (this.whitelist = n3.whitelist);
        }
        static keys(t3) {
          return Array.from(t3.attributes).map(((t4) => t4.name));
        }
        add(t3, e3) {
          return !!this.canAdd(t3, e3) && (t3.setAttribute(this.keyName, e3), true);
        }
        canAdd(t3, e3) {
          return null == this.whitelist || ("string" == typeof e3 ? this.whitelist.indexOf(e3.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(e3) > -1);
        }
        remove(t3) {
          t3.removeAttribute(this.keyName);
        }
        value(t3) {
          const e3 = t3.getAttribute(this.keyName);
          return this.canAdd(t3, e3) && e3 ? e3 : "";
        }
      }
      class r extends Error {
        constructor(t3) {
          super(t3 = "[Parchment] " + t3), this.message = t3, this.name = this.constructor.name;
        }
      }
      const o = class t3 {
        constructor() {
          this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};
        }
        static find(t4, e3 = false) {
          if (null == t4) return null;
          if (this.blots.has(t4)) return this.blots.get(t4) || null;
          if (e3) {
            let n3 = null;
            try {
              n3 = t4.parentNode;
            } catch {
              return null;
            }
            return this.find(n3, e3);
          }
          return null;
        }
        create(e3, n3, s3) {
          const i2 = this.query(n3);
          if (null == i2) throw new r(`Unable to create ${n3} blot`);
          const o2 = i2, l2 = n3 instanceof Node || n3.nodeType === Node.TEXT_NODE ? n3 : o2.create(s3), a2 = new o2(e3, l2, s3);
          return t3.blots.set(a2.domNode, a2), a2;
        }
        find(e3, n3 = false) {
          return t3.find(e3, n3);
        }
        query(t4, e3 = s2.ANY) {
          let n3;
          return "string" == typeof t4 ? n3 = this.types[t4] || this.attributes[t4] : t4 instanceof Text || t4.nodeType === Node.TEXT_NODE ? n3 = this.types.text : "number" == typeof t4 ? t4 & s2.LEVEL & s2.BLOCK ? n3 = this.types.block : t4 & s2.LEVEL & s2.INLINE && (n3 = this.types.inline) : t4 instanceof Element && ((t4.getAttribute("class") || "").split(/\s+/).some(((t5) => (n3 = this.classes[t5], !!n3))), n3 = n3 || this.tags[t4.tagName]), null == n3 ? null : "scope" in n3 && e3 & s2.LEVEL & n3.scope && e3 & s2.TYPE & n3.scope ? n3 : null;
        }
        register(...t4) {
          return t4.map(((t5) => {
            const e3 = "blotName" in t5, n3 = "attrName" in t5;
            if (!e3 && !n3) throw new r("Invalid definition");
            if (e3 && "abstract" === t5.blotName) throw new r("Cannot register abstract class");
            const s3 = e3 ? t5.blotName : n3 ? t5.attrName : void 0;
            return this.types[s3] = t5, n3 ? "string" == typeof t5.keyName && (this.attributes[t5.keyName] = t5) : e3 && (t5.className && (this.classes[t5.className] = t5), t5.tagName && (Array.isArray(t5.tagName) ? t5.tagName = t5.tagName.map(((t6) => t6.toUpperCase())) : t5.tagName = t5.tagName.toUpperCase(), (Array.isArray(t5.tagName) ? t5.tagName : [t5.tagName]).forEach(((e4) => {
              (null == this.tags[e4] || null == t5.className) && (this.tags[e4] = t5);
            })))), t5;
          }));
        }
      };
      o.blots = /* @__PURE__ */ new WeakMap();
      let l = o;
      function a(t3, e3) {
        return (t3.getAttribute("class") || "").split(/\s+/).filter(((t4) => 0 === t4.indexOf(`${e3}-`)));
      }
      const c = class extends i {
        static keys(t3) {
          return (t3.getAttribute("class") || "").split(/\s+/).map(((t4) => t4.split("-").slice(0, -1).join("-")));
        }
        add(t3, e3) {
          return !!this.canAdd(t3, e3) && (this.remove(t3), t3.classList.add(`${this.keyName}-${e3}`), true);
        }
        remove(t3) {
          a(t3, this.keyName).forEach(((e3) => {
            t3.classList.remove(e3);
          })), 0 === t3.classList.length && t3.removeAttribute("class");
        }
        value(t3) {
          const e3 = (a(t3, this.keyName)[0] || "").slice(this.keyName.length + 1);
          return this.canAdd(t3, e3) ? e3 : "";
        }
      };
      function h(t3) {
        const e3 = t3.split("-"), n3 = e3.slice(1).map(((t4) => t4[0].toUpperCase() + t4.slice(1))).join("");
        return e3[0] + n3;
      }
      const u = class extends i {
        static keys(t3) {
          return (t3.getAttribute("style") || "").split(";").map(((t4) => t4.split(":")[0].trim()));
        }
        add(t3, e3) {
          return !!this.canAdd(t3, e3) && (t3.style[h(this.keyName)] = e3, true);
        }
        remove(t3) {
          t3.style[h(this.keyName)] = "", t3.getAttribute("style") || t3.removeAttribute("style");
        }
        value(t3) {
          const e3 = t3.style[h(this.keyName)];
          return this.canAdd(t3, e3) ? e3 : "";
        }
      }, d = class {
        constructor(t3) {
          this.attributes = {}, this.domNode = t3, this.build();
        }
        attribute(t3, e3) {
          e3 ? t3.add(this.domNode, e3) && (null != t3.value(this.domNode) ? this.attributes[t3.attrName] = t3 : delete this.attributes[t3.attrName]) : (t3.remove(this.domNode), delete this.attributes[t3.attrName]);
        }
        build() {
          this.attributes = {};
          const t3 = l.find(this.domNode);
          if (null == t3) return;
          const e3 = i.keys(this.domNode), n3 = c.keys(this.domNode), r2 = u.keys(this.domNode);
          e3.concat(n3).concat(r2).forEach(((e4) => {
            const n4 = t3.scroll.query(e4, s2.ATTRIBUTE);
            n4 instanceof i && (this.attributes[n4.attrName] = n4);
          }));
        }
        copy(t3) {
          Object.keys(this.attributes).forEach(((e3) => {
            const n3 = this.attributes[e3].value(this.domNode);
            t3.format(e3, n3);
          }));
        }
        move(t3) {
          this.copy(t3), Object.keys(this.attributes).forEach(((t4) => {
            this.attributes[t4].remove(this.domNode);
          })), this.attributes = {};
        }
        values() {
          return Object.keys(this.attributes).reduce(((t3, e3) => (t3[e3] = this.attributes[e3].value(this.domNode), t3)), {});
        }
      }, f = class {
        constructor(t3, e3) {
          this.scroll = t3, this.domNode = e3, l.blots.set(e3, this), this.prev = null, this.next = null;
        }
        static create(t3) {
          if (null == this.tagName) throw new r("Blot definition missing tagName");
          let e3, n3;
          return Array.isArray(this.tagName) ? ("string" == typeof t3 ? (n3 = t3.toUpperCase(), parseInt(n3, 10).toString() === n3 && (n3 = parseInt(n3, 10))) : "number" == typeof t3 && (n3 = t3), e3 = "number" == typeof n3 ? document.createElement(this.tagName[n3 - 1]) : n3 && this.tagName.indexOf(n3) > -1 ? document.createElement(n3) : document.createElement(this.tagName[0])) : e3 = document.createElement(this.tagName), this.className && e3.classList.add(this.className), e3;
        }
        get statics() {
          return this.constructor;
        }
        attach() {
        }
        clone() {
          const t3 = this.domNode.cloneNode(false);
          return this.scroll.create(t3);
        }
        detach() {
          null != this.parent && this.parent.removeChild(this), l.blots.delete(this.domNode);
        }
        deleteAt(t3, e3) {
          this.isolate(t3, e3).remove();
        }
        formatAt(t3, e3, n3, i2) {
          const r2 = this.isolate(t3, e3);
          if (null != this.scroll.query(n3, s2.BLOT) && i2) r2.wrap(n3, i2);
          else if (null != this.scroll.query(n3, s2.ATTRIBUTE)) {
            const t4 = this.scroll.create(this.statics.scope);
            r2.wrap(t4), t4.format(n3, i2);
          }
        }
        insertAt(t3, e3, n3) {
          const s3 = null == n3 ? this.scroll.create("text", e3) : this.scroll.create(e3, n3), i2 = this.split(t3);
          this.parent.insertBefore(s3, i2 || void 0);
        }
        isolate(t3, e3) {
          const n3 = this.split(t3);
          if (null == n3) throw new Error("Attempt to isolate at end");
          return n3.split(e3), n3;
        }
        length() {
          return 1;
        }
        offset(t3 = this.parent) {
          return null == this.parent || this === t3 ? 0 : this.parent.children.offset(this) + this.parent.offset(t3);
        }
        optimize(t3) {
          this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);
        }
        remove() {
          null != this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), this.detach();
        }
        replaceWith(t3, e3) {
          const n3 = "string" == typeof t3 ? this.scroll.create(t3, e3) : t3;
          return null != this.parent && (this.parent.insertBefore(n3, this.next || void 0), this.remove()), n3;
        }
        split(t3, e3) {
          return 0 === t3 ? this : this.next;
        }
        update(t3, e3) {
        }
        wrap(t3, e3) {
          const n3 = "string" == typeof t3 ? this.scroll.create(t3, e3) : t3;
          if (null != this.parent && this.parent.insertBefore(n3, this.next || void 0), "function" != typeof n3.appendChild) throw new r(`Cannot wrap ${t3}`);
          return n3.appendChild(this), n3;
        }
      };
      f.blotName = "abstract";
      let p = f;
      const m = class extends p {
        static value(t3) {
          return true;
        }
        index(t3, e3) {
          return this.domNode === t3 || this.domNode.compareDocumentPosition(t3) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(e3, 1) : -1;
        }
        position(t3, e3) {
          let n3 = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);
          return t3 > 0 && (n3 += 1), [this.parent.domNode, n3];
        }
        value() {
          return { [this.statics.blotName]: this.statics.value(this.domNode) || true };
        }
      };
      m.scope = s2.INLINE_BLOT;
      const g = m;
      class b {
        constructor() {
          this.head = null, this.tail = null, this.length = 0;
        }
        append(...t3) {
          if (this.insertBefore(t3[0], null), t3.length > 1) {
            const e3 = t3.slice(1);
            this.append(...e3);
          }
        }
        at(t3) {
          const e3 = this.iterator();
          let n3 = e3();
          for (; n3 && t3 > 0; ) t3 -= 1, n3 = e3();
          return n3;
        }
        contains(t3) {
          const e3 = this.iterator();
          let n3 = e3();
          for (; n3; ) {
            if (n3 === t3) return true;
            n3 = e3();
          }
          return false;
        }
        indexOf(t3) {
          const e3 = this.iterator();
          let n3 = e3(), s3 = 0;
          for (; n3; ) {
            if (n3 === t3) return s3;
            s3 += 1, n3 = e3();
          }
          return -1;
        }
        insertBefore(t3, e3) {
          null != t3 && (this.remove(t3), t3.next = e3, null != e3 ? (t3.prev = e3.prev, null != e3.prev && (e3.prev.next = t3), e3.prev = t3, e3 === this.head && (this.head = t3)) : null != this.tail ? (this.tail.next = t3, t3.prev = this.tail, this.tail = t3) : (t3.prev = null, this.head = this.tail = t3), this.length += 1);
        }
        offset(t3) {
          let e3 = 0, n3 = this.head;
          for (; null != n3; ) {
            if (n3 === t3) return e3;
            e3 += n3.length(), n3 = n3.next;
          }
          return -1;
        }
        remove(t3) {
          this.contains(t3) && (null != t3.prev && (t3.prev.next = t3.next), null != t3.next && (t3.next.prev = t3.prev), t3 === this.head && (this.head = t3.next), t3 === this.tail && (this.tail = t3.prev), this.length -= 1);
        }
        iterator(t3 = this.head) {
          return () => {
            const e3 = t3;
            return null != t3 && (t3 = t3.next), e3;
          };
        }
        find(t3, e3 = false) {
          const n3 = this.iterator();
          let s3 = n3();
          for (; s3; ) {
            const i2 = s3.length();
            if (t3 < i2 || e3 && t3 === i2 && (null == s3.next || 0 !== s3.next.length())) return [s3, t3];
            t3 -= i2, s3 = n3();
          }
          return [null, 0];
        }
        forEach(t3) {
          const e3 = this.iterator();
          let n3 = e3();
          for (; n3; ) t3(n3), n3 = e3();
        }
        forEachAt(t3, e3, n3) {
          if (e3 <= 0) return;
          const [s3, i2] = this.find(t3);
          let r2 = t3 - i2;
          const o2 = this.iterator(s3);
          let l2 = o2();
          for (; l2 && r2 < t3 + e3; ) {
            const s4 = l2.length();
            t3 > r2 ? n3(l2, t3 - r2, Math.min(e3, r2 + s4 - t3)) : n3(l2, 0, Math.min(s4, t3 + e3 - r2)), r2 += s4, l2 = o2();
          }
        }
        map(t3) {
          return this.reduce(((e3, n3) => (e3.push(t3(n3)), e3)), []);
        }
        reduce(t3, e3) {
          const n3 = this.iterator();
          let s3 = n3();
          for (; s3; ) e3 = t3(e3, s3), s3 = n3();
          return e3;
        }
      }
      function y(t3, e3) {
        const n3 = e3.find(t3);
        if (n3) return n3;
        try {
          return e3.create(t3);
        } catch {
          const n4 = e3.create(s2.INLINE);
          return Array.from(t3.childNodes).forEach(((t4) => {
            n4.domNode.appendChild(t4);
          })), t3.parentNode && t3.parentNode.replaceChild(n4.domNode, t3), n4.attach(), n4;
        }
      }
      const A = class t3 extends p {
        constructor(t4, e3) {
          super(t4, e3), this.uiNode = null, this.build();
        }
        appendChild(t4) {
          this.insertBefore(t4);
        }
        attach() {
          super.attach(), this.children.forEach(((t4) => {
            t4.attach();
          }));
        }
        attachUI(e3) {
          null != this.uiNode && this.uiNode.remove(), this.uiNode = e3, t3.uiClass && this.uiNode.classList.add(t3.uiClass), this.uiNode.setAttribute("contenteditable", "false"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);
        }
        build() {
          this.children = new b(), Array.from(this.domNode.childNodes).filter(((t4) => t4 !== this.uiNode)).reverse().forEach(((t4) => {
            try {
              const e3 = y(t4, this.scroll);
              this.insertBefore(e3, this.children.head || void 0);
            } catch (t5) {
              if (t5 instanceof r) return;
              throw t5;
            }
          }));
        }
        deleteAt(t4, e3) {
          if (0 === t4 && e3 === this.length()) return this.remove();
          this.children.forEachAt(t4, e3, ((t5, e4, n3) => {
            t5.deleteAt(e4, n3);
          }));
        }
        descendant(e3, n3 = 0) {
          const [s3, i2] = this.children.find(n3);
          return null == e3.blotName && e3(s3) || null != e3.blotName && s3 instanceof e3 ? [s3, i2] : s3 instanceof t3 ? s3.descendant(e3, i2) : [null, -1];
        }
        descendants(e3, n3 = 0, s3 = Number.MAX_VALUE) {
          let i2 = [], r2 = s3;
          return this.children.forEachAt(n3, s3, ((n4, s4, o2) => {
            (null == e3.blotName && e3(n4) || null != e3.blotName && n4 instanceof e3) && i2.push(n4), n4 instanceof t3 && (i2 = i2.concat(n4.descendants(e3, s4, r2))), r2 -= o2;
          })), i2;
        }
        detach() {
          this.children.forEach(((t4) => {
            t4.detach();
          })), super.detach();
        }
        enforceAllowedChildren() {
          let e3 = false;
          this.children.forEach(((n3) => {
            e3 || this.statics.allowedChildren.some(((t4) => n3 instanceof t4)) || (n3.statics.scope === s2.BLOCK_BLOT ? (null != n3.next && this.splitAfter(n3), null != n3.prev && this.splitAfter(n3.prev), n3.parent.unwrap(), e3 = true) : n3 instanceof t3 ? n3.unwrap() : n3.remove());
          }));
        }
        formatAt(t4, e3, n3, s3) {
          this.children.forEachAt(t4, e3, ((t5, e4, i2) => {
            t5.formatAt(e4, i2, n3, s3);
          }));
        }
        insertAt(t4, e3, n3) {
          const [s3, i2] = this.children.find(t4);
          if (s3) s3.insertAt(i2, e3, n3);
          else {
            const t5 = null == n3 ? this.scroll.create("text", e3) : this.scroll.create(e3, n3);
            this.appendChild(t5);
          }
        }
        insertBefore(t4, e3) {
          null != t4.parent && t4.parent.children.remove(t4);
          let n3 = null;
          this.children.insertBefore(t4, e3 || null), t4.parent = this, null != e3 && (n3 = e3.domNode), (this.domNode.parentNode !== t4.domNode || this.domNode.nextSibling !== n3) && this.domNode.insertBefore(t4.domNode, n3), t4.attach();
        }
        length() {
          return this.children.reduce(((t4, e3) => t4 + e3.length()), 0);
        }
        moveChildren(t4, e3) {
          this.children.forEach(((n3) => {
            t4.insertBefore(n3, e3);
          }));
        }
        optimize(t4) {
          if (super.optimize(t4), this.enforceAllowedChildren(), null != this.uiNode && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), 0 === this.children.length) if (null != this.statics.defaultChild) {
            const t5 = this.scroll.create(this.statics.defaultChild.blotName);
            this.appendChild(t5);
          } else this.remove();
        }
        path(e3, n3 = false) {
          const [s3, i2] = this.children.find(e3, n3), r2 = [[this, e3]];
          return s3 instanceof t3 ? r2.concat(s3.path(i2, n3)) : (null != s3 && r2.push([s3, i2]), r2);
        }
        removeChild(t4) {
          this.children.remove(t4);
        }
        replaceWith(e3, n3) {
          const s3 = "string" == typeof e3 ? this.scroll.create(e3, n3) : e3;
          return s3 instanceof t3 && this.moveChildren(s3), super.replaceWith(s3);
        }
        split(t4, e3 = false) {
          if (!e3) {
            if (0 === t4) return this;
            if (t4 === this.length()) return this.next;
          }
          const n3 = this.clone();
          return this.parent && this.parent.insertBefore(n3, this.next || void 0), this.children.forEachAt(t4, this.length(), ((t5, s3, i2) => {
            const r2 = t5.split(s3, e3);
            null != r2 && n3.appendChild(r2);
          })), n3;
        }
        splitAfter(t4) {
          const e3 = this.clone();
          for (; null != t4.next; ) e3.appendChild(t4.next);
          return this.parent && this.parent.insertBefore(e3, this.next || void 0), e3;
        }
        unwrap() {
          this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();
        }
        update(t4, e3) {
          const n3 = [], s3 = [];
          t4.forEach(((t5) => {
            t5.target === this.domNode && "childList" === t5.type && (n3.push(...t5.addedNodes), s3.push(...t5.removedNodes));
          })), s3.forEach(((t5) => {
            if (null != t5.parentNode && "IFRAME" !== t5.tagName && document.body.compareDocumentPosition(t5) & Node.DOCUMENT_POSITION_CONTAINED_BY) return;
            const e4 = this.scroll.find(t5);
            null != e4 && (null == e4.domNode.parentNode || e4.domNode.parentNode === this.domNode) && e4.detach();
          })), n3.filter(((t5) => t5.parentNode === this.domNode && t5 !== this.uiNode)).sort(((t5, e4) => t5 === e4 ? 0 : t5.compareDocumentPosition(e4) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1)).forEach(((t5) => {
            let e4 = null;
            null != t5.nextSibling && (e4 = this.scroll.find(t5.nextSibling));
            const n4 = y(t5, this.scroll);
            (n4.next !== e4 || null == n4.next) && (null != n4.parent && n4.parent.removeChild(this), this.insertBefore(n4, e4 || void 0));
          })), this.enforceAllowedChildren();
        }
      };
      A.uiClass = "";
      const N = A, v = class t3 extends N {
        static create(t4) {
          return super.create(t4);
        }
        static formats(e3, n3) {
          const s3 = n3.query(t3.blotName);
          if (null == s3 || e3.tagName !== s3.tagName) {
            if ("string" == typeof this.tagName) return true;
            if (Array.isArray(this.tagName)) return e3.tagName.toLowerCase();
          }
        }
        constructor(t4, e3) {
          super(t4, e3), this.attributes = new d(this.domNode);
        }
        format(e3, n3) {
          if (e3 !== this.statics.blotName || n3) {
            const t4 = this.scroll.query(e3, s2.INLINE);
            if (null == t4) return;
            t4 instanceof i ? this.attributes.attribute(t4, n3) : n3 && (e3 !== this.statics.blotName || this.formats()[e3] !== n3) && this.replaceWith(e3, n3);
          } else this.children.forEach(((e4) => {
            e4 instanceof t3 || (e4 = e4.wrap(t3.blotName, true)), this.attributes.copy(e4);
          })), this.unwrap();
        }
        formats() {
          const t4 = this.attributes.values(), e3 = this.statics.formats(this.domNode, this.scroll);
          return null != e3 && (t4[this.statics.blotName] = e3), t4;
        }
        formatAt(t4, e3, n3, i2) {
          null != this.formats()[n3] || this.scroll.query(n3, s2.ATTRIBUTE) ? this.isolate(t4, e3).format(n3, i2) : super.formatAt(t4, e3, n3, i2);
        }
        optimize(e3) {
          super.optimize(e3);
          const n3 = this.formats();
          if (0 === Object.keys(n3).length) return this.unwrap();
          const s3 = this.next;
          s3 instanceof t3 && s3.prev === this && (function(t4, e4) {
            if (Object.keys(t4).length !== Object.keys(e4).length) return false;
            for (const n4 in t4) if (t4[n4] !== e4[n4]) return false;
            return true;
          })(n3, s3.formats()) && (s3.moveChildren(this), s3.remove());
        }
        replaceWith(t4, e3) {
          const n3 = super.replaceWith(t4, e3);
          return this.attributes.copy(n3), n3;
        }
        update(t4, e3) {
          super.update(t4, e3), t4.some(((t5) => t5.target === this.domNode && "attributes" === t5.type)) && this.attributes.build();
        }
        wrap(e3, n3) {
          const s3 = super.wrap(e3, n3);
          return s3 instanceof t3 && this.attributes.move(s3), s3;
        }
      };
      v.allowedChildren = [v, g], v.blotName = "inline", v.scope = s2.INLINE_BLOT, v.tagName = "SPAN";
      const E = v, x = class t3 extends N {
        static create(t4) {
          return super.create(t4);
        }
        static formats(e3, n3) {
          const s3 = n3.query(t3.blotName);
          if (null == s3 || e3.tagName !== s3.tagName) {
            if ("string" == typeof this.tagName) return true;
            if (Array.isArray(this.tagName)) return e3.tagName.toLowerCase();
          }
        }
        constructor(t4, e3) {
          super(t4, e3), this.attributes = new d(this.domNode);
        }
        format(e3, n3) {
          const r2 = this.scroll.query(e3, s2.BLOCK);
          null != r2 && (r2 instanceof i ? this.attributes.attribute(r2, n3) : e3 !== this.statics.blotName || n3 ? n3 && (e3 !== this.statics.blotName || this.formats()[e3] !== n3) && this.replaceWith(e3, n3) : this.replaceWith(t3.blotName));
        }
        formats() {
          const t4 = this.attributes.values(), e3 = this.statics.formats(this.domNode, this.scroll);
          return null != e3 && (t4[this.statics.blotName] = e3), t4;
        }
        formatAt(t4, e3, n3, i2) {
          null != this.scroll.query(n3, s2.BLOCK) ? this.format(n3, i2) : super.formatAt(t4, e3, n3, i2);
        }
        insertAt(t4, e3, n3) {
          if (null == n3 || null != this.scroll.query(e3, s2.INLINE)) super.insertAt(t4, e3, n3);
          else {
            const s3 = this.split(t4);
            if (null == s3) throw new Error("Attempt to insertAt after block boundaries");
            {
              const t5 = this.scroll.create(e3, n3);
              s3.parent.insertBefore(t5, s3);
            }
          }
        }
        replaceWith(t4, e3) {
          const n3 = super.replaceWith(t4, e3);
          return this.attributes.copy(n3), n3;
        }
        update(t4, e3) {
          super.update(t4, e3), t4.some(((t5) => t5.target === this.domNode && "attributes" === t5.type)) && this.attributes.build();
        }
      };
      x.blotName = "block", x.scope = s2.BLOCK_BLOT, x.tagName = "P", x.allowedChildren = [E, x, g];
      const L = x, S = class extends N {
        checkMerge() {
          return null !== this.next && this.next.statics.blotName === this.statics.blotName;
        }
        deleteAt(t3, e3) {
          super.deleteAt(t3, e3), this.enforceAllowedChildren();
        }
        formatAt(t3, e3, n3, s3) {
          super.formatAt(t3, e3, n3, s3), this.enforceAllowedChildren();
        }
        insertAt(t3, e3, n3) {
          super.insertAt(t3, e3, n3), this.enforceAllowedChildren();
        }
        optimize(t3) {
          super.optimize(t3), this.children.length > 0 && null != this.next && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());
        }
      };
      S.blotName = "container", S.scope = s2.BLOCK_BLOT;
      const T = S, k = class extends g {
        static formats(t3, e3) {
        }
        format(t3, e3) {
          super.formatAt(0, this.length(), t3, e3);
        }
        formatAt(t3, e3, n3, s3) {
          0 === t3 && e3 === this.length() ? this.format(n3, s3) : super.formatAt(t3, e3, n3, s3);
        }
        formats() {
          return this.statics.formats(this.domNode, this.scroll);
        }
      }, O = { attributes: true, characterData: true, characterDataOldValue: true, childList: true, subtree: true }, w = class extends N {
        constructor(t3, e3) {
          super(null, e3), this.registry = t3, this.scroll = this, this.build(), this.observer = new MutationObserver(((t4) => {
            this.update(t4);
          })), this.observer.observe(this.domNode, O), this.attach();
        }
        create(t3, e3) {
          return this.registry.create(this, t3, e3);
        }
        find(t3, e3 = false) {
          const n3 = this.registry.find(t3, e3);
          return n3 ? n3.scroll === this ? n3 : e3 ? this.find(n3.scroll.domNode.parentNode, true) : null : null;
        }
        query(t3, e3 = s2.ANY) {
          return this.registry.query(t3, e3);
        }
        register(...t3) {
          return this.registry.register(...t3);
        }
        build() {
          null != this.scroll && super.build();
        }
        detach() {
          super.detach(), this.observer.disconnect();
        }
        deleteAt(t3, e3) {
          this.update(), 0 === t3 && e3 === this.length() ? this.children.forEach(((t4) => {
            t4.remove();
          })) : super.deleteAt(t3, e3);
        }
        formatAt(t3, e3, n3, s3) {
          this.update(), super.formatAt(t3, e3, n3, s3);
        }
        insertAt(t3, e3, n3) {
          this.update(), super.insertAt(t3, e3, n3);
        }
        optimize(t3 = [], e3 = {}) {
          super.optimize(e3);
          const n3 = e3.mutationsMap || /* @__PURE__ */ new WeakMap();
          let s3 = Array.from(this.observer.takeRecords());
          for (; s3.length > 0; ) t3.push(s3.pop());
          const i2 = (t4, e4 = true) => {
            null == t4 || t4 === this || null != t4.domNode.parentNode && (n3.has(t4.domNode) || n3.set(t4.domNode, []), e4 && i2(t4.parent));
          }, r2 = (t4) => {
            n3.has(t4.domNode) && (t4 instanceof N && t4.children.forEach(r2), n3.delete(t4.domNode), t4.optimize(e3));
          };
          let o2 = t3;
          for (let e4 = 0; o2.length > 0; e4 += 1) {
            if (e4 >= 100) throw new Error("[Parchment] Maximum optimize iterations reached");
            for (o2.forEach(((t4) => {
              const e5 = this.find(t4.target, true);
              null != e5 && (e5.domNode === t4.target && ("childList" === t4.type ? (i2(this.find(t4.previousSibling, false)), Array.from(t4.addedNodes).forEach(((t5) => {
                const e6 = this.find(t5, false);
                i2(e6, false), e6 instanceof N && e6.children.forEach(((t6) => {
                  i2(t6, false);
                }));
              }))) : "attributes" === t4.type && i2(e5.prev)), i2(e5));
            })), this.children.forEach(r2), o2 = Array.from(this.observer.takeRecords()), s3 = o2.slice(); s3.length > 0; ) t3.push(s3.pop());
          }
        }
        update(t3, e3 = {}) {
          t3 = t3 || this.observer.takeRecords();
          const n3 = /* @__PURE__ */ new WeakMap();
          t3.map(((t4) => {
            const e4 = this.find(t4.target, true);
            return null == e4 ? null : n3.has(e4.domNode) ? (n3.get(e4.domNode).push(t4), null) : (n3.set(e4.domNode, [t4]), e4);
          })).forEach(((t4) => {
            null != t4 && t4 !== this && n3.has(t4.domNode) && t4.update(n3.get(t4.domNode) || [], e3);
          })), e3.mutationsMap = n3, n3.has(this.domNode) && super.update(n3.get(this.domNode), e3), this.optimize(t3, e3);
        }
      };
      w.blotName = "scroll", w.defaultChild = L, w.allowedChildren = [L, T], w.scope = s2.BLOCK_BLOT, w.tagName = "DIV";
      const C = w, q = class t3 extends g {
        static create(t4) {
          return document.createTextNode(t4);
        }
        static value(t4) {
          return t4.data;
        }
        constructor(t4, e3) {
          super(t4, e3), this.text = this.statics.value(this.domNode);
        }
        deleteAt(t4, e3) {
          this.domNode.data = this.text = this.text.slice(0, t4) + this.text.slice(t4 + e3);
        }
        index(t4, e3) {
          return this.domNode === t4 ? e3 : -1;
        }
        insertAt(t4, e3, n3) {
          null == n3 ? (this.text = this.text.slice(0, t4) + e3 + this.text.slice(t4), this.domNode.data = this.text) : super.insertAt(t4, e3, n3);
        }
        length() {
          return this.text.length;
        }
        optimize(e3) {
          super.optimize(e3), this.text = this.statics.value(this.domNode), 0 === this.text.length ? this.remove() : this.next instanceof t3 && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());
        }
        position(t4, e3 = false) {
          return [this.domNode, t4];
        }
        split(t4, e3 = false) {
          if (!e3) {
            if (0 === t4) return this;
            if (t4 === this.length()) return this.next;
          }
          const n3 = this.scroll.create(this.domNode.splitText(t4));
          return this.parent.insertBefore(n3, this.next || void 0), this.text = this.statics.value(this.domNode), n3;
        }
        update(t4, e3) {
          t4.some(((t5) => "characterData" === t5.type && t5.target === this.domNode)) && (this.text = this.statics.value(this.domNode));
        }
        value() {
          return this.text;
        }
      };
      q.blotName = "text", q.scope = s2.INLINE_BLOT;
      const R = q;
    } }, e = {};
    function n(s2) {
      var i = e[s2];
      if (void 0 !== i) return i.exports;
      var r = e[s2] = { exports: {} };
      return t[s2](r, r.exports, n), r.exports;
    }
    n.d = function(t2, e2) {
      for (var s2 in e2) n.o(e2, s2) && !n.o(t2, s2) && Object.defineProperty(t2, s2, { enumerable: true, get: e2[s2] });
    }, n.o = function(t2, e2) {
      return Object.prototype.hasOwnProperty.call(t2, e2);
    }, n.r = function(t2) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
    };
    var s = {};
    return (function() {
      n.d(s, { default: function() {
        return K;
      } });
      var t2 = n(729), e2 = n(276), i = n(912), r = n(3);
      class o extends r.ClassAttributor {
        add(t3, e3) {
          let n2 = 0;
          if ("+1" === e3 || "-1" === e3) {
            const s2 = this.value(t3) || 0;
            n2 = "+1" === e3 ? s2 + 1 : s2 - 1;
          } else "number" == typeof e3 && (n2 = e3);
          return 0 === n2 ? (this.remove(t3), true) : super.add(t3, n2.toString());
        }
        canAdd(t3, e3) {
          return super.canAdd(t3, e3) || super.canAdd(t3, parseInt(e3, 10));
        }
        value(t3) {
          return parseInt(super.value(t3), 10) || void 0;
        }
      }
      var l = new o("indent", "ql-indent", { scope: r.Scope.BLOCK, whitelist: [1, 2, 3, 4, 5, 6, 7, 8] }), a = n(698);
      class c extends a.Ay {
        static blotName = "blockquote";
        static tagName = "blockquote";
      }
      var h = c;
      class u extends a.Ay {
        static blotName = "header";
        static tagName = ["H1", "H2", "H3", "H4", "H5", "H6"];
        static formats(t3) {
          return this.tagName.indexOf(t3.tagName) + 1;
        }
      }
      var d = u, f = n(580), p = n(543);
      class m extends f.A {
      }
      m.blotName = "list-container", m.tagName = "OL";
      class g extends a.Ay {
        static create(t3) {
          const e3 = super.create();
          return e3.setAttribute("data-list", t3), e3;
        }
        static formats(t3) {
          return t3.getAttribute("data-list") || void 0;
        }
        static register() {
          p.Ay.register(m);
        }
        constructor(t3, e3) {
          super(t3, e3);
          const n2 = e3.ownerDocument.createElement("span"), s2 = (n3) => {
            if (!t3.isEnabled()) return;
            const s3 = this.statics.formats(e3, t3);
            "checked" === s3 ? (this.format("list", "unchecked"), n3.preventDefault()) : "unchecked" === s3 && (this.format("list", "checked"), n3.preventDefault());
          };
          n2.addEventListener("mousedown", s2), n2.addEventListener("touchstart", s2), this.attachUI(n2);
        }
        format(t3, e3) {
          t3 === this.statics.blotName && e3 ? this.domNode.setAttribute("data-list", e3) : super.format(t3, e3);
        }
      }
      g.blotName = "list", g.tagName = "LI", m.allowedChildren = [g], g.requiredContainer = m;
      var b = n(922), y = n(638), A = n(772), N = n(664), v = n(850);
      class E extends v.A {
        static blotName = "bold";
        static tagName = ["STRONG", "B"];
        static create() {
          return super.create();
        }
        static formats() {
          return true;
        }
        optimize(t3) {
          super.optimize(t3), this.domNode.tagName !== this.statics.tagName[0] && this.replaceWith(this.statics.blotName);
        }
      }
      var x = E;
      class L extends v.A {
        static blotName = "link";
        static tagName = "A";
        static SANITIZED_URL = "about:blank";
        static PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel", "sms"];
        static create(t3) {
          const e3 = super.create(t3);
          return e3.setAttribute("href", this.sanitize(t3)), e3.setAttribute("rel", "noopener noreferrer"), e3.setAttribute("target", "_blank"), e3;
        }
        static formats(t3) {
          return t3.getAttribute("href");
        }
        static sanitize(t3) {
          return S(t3, this.PROTOCOL_WHITELIST) ? t3 : this.SANITIZED_URL;
        }
        format(t3, e3) {
          t3 === this.statics.blotName && e3 ? this.domNode.setAttribute("href", this.constructor.sanitize(e3)) : super.format(t3, e3);
        }
      }
      function S(t3, e3) {
        const n2 = document.createElement("a");
        n2.href = t3;
        const s2 = n2.href.slice(0, n2.href.indexOf(":"));
        return e3.indexOf(s2) > -1;
      }
      class T extends v.A {
        static blotName = "script";
        static tagName = ["SUB", "SUP"];
        static create(t3) {
          return "super" === t3 ? document.createElement("sup") : "sub" === t3 ? document.createElement("sub") : super.create(t3);
        }
        static formats(t3) {
          return "SUB" === t3.tagName ? "sub" : "SUP" === t3.tagName ? "super" : void 0;
        }
      }
      var k = T;
      class O extends v.A {
        static blotName = "underline";
        static tagName = "U";
      }
      var w = O;
      const C = ["alt", "height", "width"];
      class q extends r.EmbedBlot {
        static blotName = "image";
        static tagName = "IMG";
        static create(t3) {
          const e3 = super.create(t3);
          return "string" == typeof t3 && e3.setAttribute("src", this.sanitize(t3)), e3;
        }
        static formats(t3) {
          return C.reduce(((e3, n2) => (t3.hasAttribute(n2) && (e3[n2] = t3.getAttribute(n2)), e3)), {});
        }
        static match(t3) {
          return /\.(jpe?g|gif|png)$/.test(t3) || /^data:image\/.+;base64/.test(t3);
        }
        static sanitize(t3) {
          return S(t3, ["http", "https", "data"]) ? t3 : "//:0";
        }
        static value(t3) {
          return t3.getAttribute("src");
        }
        format(t3, e3) {
          C.indexOf(t3) > -1 ? e3 ? this.domNode.setAttribute(t3, e3) : this.domNode.removeAttribute(t3) : super.format(t3, e3);
        }
      }
      var R = q;
      const B = ["height", "width"];
      class I extends a.zo {
        static blotName = "video";
        static className = "ql-video";
        static tagName = "IFRAME";
        static create(t3) {
          const e3 = super.create(t3);
          return e3.setAttribute("frameborder", "0"), e3.setAttribute("allowfullscreen", "true"), e3.setAttribute("src", this.sanitize(t3)), e3;
        }
        static formats(t3) {
          return B.reduce(((e3, n2) => (t3.hasAttribute(n2) && (e3[n2] = t3.getAttribute(n2)), e3)), {});
        }
        static sanitize(t3) {
          return L.sanitize(t3);
        }
        static value(t3) {
          return t3.getAttribute("src");
        }
        format(t3, e3) {
          B.indexOf(t3) > -1 ? e3 ? this.domNode.setAttribute(t3, e3) : this.domNode.removeAttribute(t3) : super.format(t3, e3);
        }
        html() {
          const { video: t3 } = this.value();
          return `<a href="${t3}">${t3}</a>`;
        }
      }
      var D = I, M = n(404), U = n(398), _ = n(78), j = n(266);
      const P = (0, _.A)("quill:toolbar");
      class z extends j.A {
        constructor(t3, e3) {
          if (super(t3, e3), Array.isArray(this.options.container)) {
            const e4 = document.createElement("div");
            e4.setAttribute("role", "toolbar"), (function(t4, e5) {
              Array.isArray(e5[0]) || (e5 = [e5]), e5.forEach(((e6) => {
                const n2 = document.createElement("span");
                n2.classList.add("ql-formats"), e6.forEach(((t5) => {
                  if ("string" == typeof t5) F(n2, t5);
                  else {
                    const e7 = Object.keys(t5)[0], s2 = t5[e7];
                    Array.isArray(s2) ? (function(t6, e8, n3) {
                      const s3 = document.createElement("select");
                      s3.classList.add(`ql-${e8}`), n3.forEach(((t7) => {
                        const e9 = document.createElement("option");
                        false !== t7 ? e9.setAttribute("value", String(t7)) : e9.setAttribute("selected", "selected"), s3.appendChild(e9);
                      })), t6.appendChild(s3);
                    })(n2, e7, s2) : F(n2, e7, s2);
                  }
                })), t4.appendChild(n2);
              }));
            })(e4, this.options.container), t3.container?.parentNode?.insertBefore(e4, t3.container), this.container = e4;
          } else if ("string" == typeof this.options.container) {
            const e4 = t3.container.getRootNode();
            this.container = e4.querySelector(this.options.container);
          } else this.container = this.options.container;
          this.container instanceof HTMLElement ? (this.container.classList.add("ql-toolbar"), this.controls = [], this.handlers = {}, this.options.handlers && Object.keys(this.options.handlers).forEach(((t4) => {
            const e4 = this.options.handlers?.[t4];
            e4 && this.addHandler(t4, e4);
          })), Array.from(this.container.querySelectorAll("button, select")).forEach(((t4) => {
            this.attach(t4);
          })), this.quill.on(p.Ay.events.EDITOR_CHANGE, (() => {
            const [t4] = this.quill.selection.getRange();
            this.update(t4);
          }))) : P.error("Container required for toolbar", this.options);
        }
        addHandler(t3, e3) {
          this.handlers[t3] = e3;
        }
        attach(t3) {
          let e3 = Array.from(t3.classList).find(((t4) => 0 === t4.indexOf("ql-")));
          if (!e3) return;
          if (e3 = e3.slice(3), "BUTTON" === t3.tagName && t3.setAttribute("type", "button"), null == this.handlers[e3] && null == this.quill.scroll.query(e3)) return void P.warn("ignoring attaching to nonexistent format", e3, t3);
          const n2 = "SELECT" === t3.tagName ? "change" : "click";
          t3.addEventListener(n2, ((n3) => {
            let s2;
            if ("SELECT" === t3.tagName) {
              if (t3.selectedIndex < 0) return;
              const e4 = t3.options[t3.selectedIndex];
              s2 = !e4.hasAttribute("selected") && (e4.value || false);
            } else s2 = !t3.classList.contains("ql-active") && (t3.value || !t3.hasAttribute("value")), n3.preventDefault();
            this.quill.focus();
            const [i2] = this.quill.selection.getRange();
            if (null != this.handlers[e3]) this.handlers[e3].call(this, s2);
            else if (this.quill.scroll.query(e3).prototype instanceof r.EmbedBlot) {
              if (s2 = prompt(`Enter ${e3}`), !s2) return;
              this.quill.updateContents(new U.Ay().retain(i2.index).delete(i2.length).insert({ [e3]: s2 }), p.Ay.sources.USER);
            } else this.quill.format(e3, s2, p.Ay.sources.USER);
            this.update(i2);
          })), this.controls.push([e3, t3]);
        }
        update(t3) {
          const e3 = null == t3 ? {} : this.quill.getFormat(t3);
          this.controls.forEach(((n2) => {
            const [s2, i2] = n2;
            if ("SELECT" === i2.tagName) {
              let n3 = null;
              if (null == t3) n3 = null;
              else if (null == e3[s2]) n3 = i2.querySelector("option[selected]");
              else if (!Array.isArray(e3[s2])) {
                let t4 = e3[s2];
                "string" == typeof t4 && (t4 = t4.replace(/"/g, '\\"')), n3 = i2.querySelector(`option[value="${t4}"]`);
              }
              null == n3 ? (i2.value = "", i2.selectedIndex = -1) : n3.selected = true;
            } else if (null == t3) i2.classList.remove("ql-active"), i2.setAttribute("aria-pressed", "false");
            else if (i2.hasAttribute("value")) {
              const t4 = e3[s2], n3 = t4 === i2.getAttribute("value") || null != t4 && t4.toString() === i2.getAttribute("value") || null == t4 && !i2.getAttribute("value");
              i2.classList.toggle("ql-active", n3), i2.setAttribute("aria-pressed", n3.toString());
            } else {
              const t4 = null != e3[s2];
              i2.classList.toggle("ql-active", t4), i2.setAttribute("aria-pressed", t4.toString());
            }
          }));
        }
      }
      function F(t3, e3, n2) {
        const s2 = document.createElement("button");
        s2.setAttribute("type", "button"), s2.classList.add(`ql-${e3}`), s2.setAttribute("aria-pressed", "false"), null != n2 ? (s2.value = n2, s2.setAttribute("aria-label", `${e3}: ${n2}`)) : s2.setAttribute("aria-label", e3), t3.appendChild(s2);
      }
      z.DEFAULTS = {}, z.DEFAULTS = { container: null, handlers: { clean() {
        const t3 = this.quill.getSelection();
        if (null != t3) if (0 === t3.length) {
          const t4 = this.quill.getFormat();
          Object.keys(t4).forEach(((t5) => {
            null != this.quill.scroll.query(t5, r.Scope.INLINE) && this.quill.format(t5, false, p.Ay.sources.USER);
          }));
        } else this.quill.removeFormat(t3.index, t3.length, p.Ay.sources.USER);
      }, direction(t3) {
        const { align: e3 } = this.quill.getFormat();
        "rtl" === t3 && null == e3 ? this.quill.format("align", "right", p.Ay.sources.USER) : t3 || "right" !== e3 || this.quill.format("align", false, p.Ay.sources.USER), this.quill.format("direction", t3, p.Ay.sources.USER);
      }, indent(t3) {
        const e3 = this.quill.getSelection(), n2 = this.quill.getFormat(e3), s2 = parseInt(n2.indent || 0, 10);
        if ("+1" === t3 || "-1" === t3) {
          let e4 = "+1" === t3 ? 1 : -1;
          "rtl" === n2.direction && (e4 *= -1), this.quill.format("indent", s2 + e4, p.Ay.sources.USER);
        }
      }, link(t3) {
        true === t3 && (t3 = prompt("Enter link URL:")), this.quill.format("link", t3, p.Ay.sources.USER);
      }, list(t3) {
        const e3 = this.quill.getSelection(), n2 = this.quill.getFormat(e3);
        "check" === t3 ? "checked" === n2.list || "unchecked" === n2.list ? this.quill.format("list", false, p.Ay.sources.USER) : this.quill.format("list", "unchecked", p.Ay.sources.USER) : this.quill.format("list", t3, p.Ay.sources.USER);
      } } }, t2.default.register({ "attributors/attribute/direction": i.Mc, "attributors/class/align": e2.qh, "attributors/class/background": b.l, "attributors/class/color": y.g3, "attributors/class/direction": i.sY, "attributors/class/font": A.q, "attributors/class/size": N.U, "attributors/style/align": e2.Hu, "attributors/style/background": b.s, "attributors/style/color": y.JM, "attributors/style/direction": i.VL, "attributors/style/font": A.z, "attributors/style/size": N.r }, true), t2.default.register({ "formats/align": e2.qh, "formats/direction": i.sY, "formats/indent": l, "formats/background": b.s, "formats/color": y.JM, "formats/font": A.q, "formats/size": N.U, "formats/blockquote": h, "formats/code-block": M.Ay, "formats/header": d, "formats/list": g, "formats/bold": x, "formats/code": M.Cy, "formats/italic": class extends x {
        static blotName = "italic";
        static tagName = ["EM", "I"];
      }, "formats/link": L, "formats/script": k, "formats/strike": class extends x {
        static blotName = "strike";
        static tagName = ["S", "STRIKE"];
      }, "formats/underline": w, "formats/image": R, "formats/video": D, "modules/toolbar": z }, true);
      var K = t2.default;
    })(), s.default;
  })();
}));

// node_modules/@vaadin/rich-text-editor/src/vaadin-rich-text-editor-mixin.js
var Quill = window.Quill;
var QuillCodeBlockContainer = Quill.import("formats/code-block-container");
var CodeBlockContainer = class extends QuillCodeBlockContainer {
  html(index, length) {
    const markup = super.html(index, length);
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = markup;
    const preTag = tempDiv.querySelector("pre");
    if (preTag) {
      preTag.setAttribute("spellcheck", "false");
      return preTag.outerHTML;
    }
    return markup;
  }
};
Quill.register("formats/code-block-container", CodeBlockContainer, true);
var HANDLERS = [
  "bold",
  "italic",
  "underline",
  "strike",
  "header",
  "script",
  "list",
  "align",
  "blockquote",
  "code-block"
];
var SOURCE = {
  API: "api",
  USER: "user",
  SILENT: "silent"
};
var STATE = {
  DEFAULT: 0,
  FOCUSED: 1,
  CLICKED: 2
};
var DEFAULT_I18N = {
  undo: "undo",
  redo: "redo",
  bold: "bold",
  italic: "italic",
  underline: "underline",
  strike: "strike",
  color: "color",
  background: "background",
  h1: "h1",
  h2: "h2",
  h3: "h3",
  subscript: "subscript",
  superscript: "superscript",
  listOrdered: "list ordered",
  listBullet: "list bullet",
  outdent: "outdent",
  indent: "indent",
  alignLeft: "align left",
  alignCenter: "align center",
  alignRight: "align right",
  image: "image",
  link: "link",
  blockquote: "blockquote",
  codeBlock: "code block",
  clean: "clean",
  linkDialogTitle: "Link address",
  ok: "OK",
  cancel: "Cancel",
  remove: "Remove"
};
var RichTextEditorMixin = (superClass) => class RichTextEditorMixinClass extends I18nMixin(DEFAULT_I18N, superClass) {
  static get properties() {
    return {
      /**
       * Value is a list of the operations which describe change to the document.
       * Each of those operations describe the change at the current index.
       * They can be an `insert`, `delete` or `retain`. The format is as follows:
       *
       * ```js
       *  [
       *    { insert: 'Hello World' },
       *    { insert: '!', attributes: { bold: true }}
       *  ]
       * ```
       *
       * See also https://github.com/quilljs/delta for detailed documentation.
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        sync: true
      },
      /**
       * HTML representation of the rich text editor content.
       */
      htmlValue: {
        type: String,
        notify: true,
        readOnly: true
      },
      /**
       * When true, the user can not modify, nor copy the editor content.
       * @type {boolean}
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * When true, the user can not modify the editor content, but can copy it.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The list of colors used by the background and text color
       * selection controls. Should contain an array of HEX strings.
       *
       * When user selects `#000000` (black) as a text color,
       * or `#ffffff` (white) as a background color, it resets
       * the corresponding format for the selected text.
       */
      colorOptions: {
        type: Array,
        value: () => {
          return [
            "#000000",
            "#e60000",
            "#ff9900",
            "#ffff00",
            "#008a00",
            "#0066cc",
            "#9933ff",
            "#ffffff",
            "#facccc",
            "#ffebcc",
            "#ffffcc",
            "#cce8cc",
            "#cce0f5",
            "#ebd6ff",
            "#bbbbbb",
            "#f06666",
            "#ffc266",
            "#ffff66",
            "#66b966",
            "#66a3e0",
            "#c285ff",
            "#888888",
            "#a10000",
            "#b26b00",
            "#b2b200",
            "#006100",
            "#0047b2",
            "#6b24b2",
            "#444444",
            "#5c0000",
            "#663d00",
            "#666600",
            "#003700",
            "#002966",
            "#3d1466"
          ];
        }
      },
      /** @private */
      _editor: {
        type: Object,
        sync: true
      },
      /**
       * Stores old value
       * @private
       */
      __oldValue: String,
      /** @private */
      __lastCommittedChange: {
        type: String,
        value: ""
      },
      /** @private */
      _linkEditing: {
        type: Boolean,
        value: false
      },
      /** @private */
      _linkRange: {
        type: Object,
        value: null
      },
      /** @private */
      _linkIndex: {
        type: Number,
        value: null
      },
      /** @private */
      _linkUrl: {
        type: String,
        value: ""
      },
      /** @private */
      _colorEditing: {
        type: Boolean,
        value: false
      },
      /** @private */
      _colorValue: {
        type: String,
        value: ""
      },
      /** @private */
      _backgroundEditing: {
        type: Boolean,
        value: false
      },
      /** @private */
      _backgroundValue: {
        type: String,
        value: ""
      }
    };
  }
  static get observers() {
    return ["_valueChanged(value, _editor)", "_disabledChanged(disabled, readonly, _editor)"];
  }
  /**
   * The object used to localize this component. To change the default
   * localization, replace this with an object that provides all properties, or
   * just the individual properties you want to change.
   *
   * The properties are used e.g. as the tooltips for the editor toolbar
   * buttons.
   *
   * @return {!RichTextEditorI18n}
   */
  get i18n() {
    return super.i18n;
  }
  set i18n(value) {
    super.i18n = value;
  }
  /** @private */
  get _toolbarButtons() {
    return Array.from(this.shadowRoot.querySelectorAll('[part="toolbar"] button')).filter((btn) => {
      return btn.clientHeight > 0;
    });
  }
  /**
   * @param {string} prop
   * @param {?string} oldVal
   * @param {?string} newVal
   * @protected
   */
  attributeChangedCallback(prop, oldVal, newVal) {
    super.attributeChangedCallback(prop, oldVal, newVal);
    if (prop === "dir") {
      this.__dir = newVal;
      this.__setDirection(newVal);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this._editor.emitter.disconnect();
  }
  /** @private */
  __setDirection(dir) {
    if (!this._editor) {
      return;
    }
    const alignAttributor = Quill.import("attributors/class/align");
    alignAttributor.whitelist = [dir === "rtl" ? "left" : "right", "center", "justify"];
    Quill.register(alignAttributor, true);
    const alignGroup = this._toolbar.querySelector('[part~="toolbar-group-alignment"]');
    if (dir === "rtl") {
      alignGroup.querySelector('[part~="toolbar-button-align-left"]').value = "left";
      alignGroup.querySelector('[part~="toolbar-button-align-right"]').value = "";
    } else {
      alignGroup.querySelector('[part~="toolbar-button-align-left"]').value = "";
      alignGroup.querySelector('[part~="toolbar-button-align-right"]').value = "right";
    }
    this._editor.getModule("toolbar").update(this._editor.getSelection());
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this._editor.emitter.connect();
  }
  /** @protected */
  ready() {
    super.ready();
    this._toolbarConfig = this._prepareToolbar();
    this._toolbar = this._toolbarConfig.container;
    this._addToolbarListeners();
    const editor = this.shadowRoot.querySelector('[part="content"]');
    this._editor = new Quill(editor, {
      modules: {
        toolbar: this._toolbarConfig
      }
    });
    this.__patchToolbar();
    this.__patchKeyboard();
    this.__setDirection(this.__dir);
    const editorContent = editor.querySelector(".ql-editor");
    editorContent.setAttribute("role", "textbox");
    editorContent.setAttribute("aria-multiline", "true");
    this._editor.on("text-change", () => {
      const timeout = 200;
      this.__debounceSetValue = Debouncer.debounce(this.__debounceSetValue, timeOut.after(timeout), () => {
        this.value = JSON.stringify(this._editor.getContents().ops);
      });
    });
    this._editor.on("editor-change", () => {
      const selection = this._editor.getSelection();
      if (selection) {
        const format = this._editor.getFormat(selection.index, selection.length);
        this._toolbar.style.setProperty("--_color-value", format.color || null);
        this._toolbar.style.setProperty("--_background-value", format.background || null);
      }
    });
    editorContent.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        if (!this.__tabBindings) {
          this.__tabBindings = this._editor.keyboard.bindings.Tab;
          this._editor.keyboard.bindings.Tab = null;
        }
      } else if (this.__tabBindings) {
        this._editor.keyboard.bindings.Tab = this.__tabBindings;
        this.__tabBindings = null;
      }
    });
    editorContent.addEventListener("blur", () => {
      if (this.__tabBindings) {
        this._editor.keyboard.bindings.Tab = this.__tabBindings;
        this.__tabBindings = null;
      }
    });
    editorContent.addEventListener("focusout", () => {
      if (this._toolbarState === STATE.FOCUSED) {
        this._cleanToolbarState();
      } else {
        this.__emitChangeEvent();
      }
    });
    editorContent.addEventListener("focus", () => {
      if (this._toolbarState === STATE.CLICKED && !this._linkEditing) {
        this._cleanToolbarState();
      }
    });
    this._editor.on("selection-change", this.__announceFormatting.bind(this));
    this.__flushPendingHtmlValue();
    this.querySelector('[slot="color-popup"]').target = this.shadowRoot.querySelector("#btn-color");
    this.querySelector('[slot="background-popup"]').target = this.shadowRoot.querySelector("#btn-background");
    this._tooltip = document.createElement("vaadin-tooltip");
    this._tooltip.slot = "tooltip";
    this._tooltip.ariaTarget = null;
    this.append(this._tooltip);
    const buttons = this.shadowRoot.querySelectorAll('[part~="toolbar-button"]');
    buttons.forEach((button) => {
      button.addEventListener("mouseenter", this.__showTooltip.bind(this));
      button.addEventListener("focusin", this.__showTooltip.bind(this));
    });
  }
  /** @private */
  __showTooltip({ type, target }) {
    if (type === "focusin" && !isKeyboardActive()) {
      return;
    }
    this._tooltip.target = target;
    this._tooltip.text = target.ariaLabel;
    this._tooltip._stateController.open({
      focus: type === "focusin",
      hover: type === "mouseenter"
    });
  }
  /** @private */
  _prepareToolbar() {
    const clean = Quill.imports["modules/toolbar"].DEFAULTS.handlers.clean;
    const self = this;
    const toolbar2 = {
      container: this.shadowRoot.querySelector('[part="toolbar"]'),
      handlers: {
        clean() {
          self._markToolbarClicked();
          clean.call(this);
        }
      }
    };
    HANDLERS.forEach((handler) => {
      toolbar2.handlers[handler] = (value) => {
        this._markToolbarClicked();
        this._editor.format(handler, value, SOURCE.USER);
      };
    });
    return toolbar2;
  }
  /** @private */
  _addToolbarListeners() {
    const buttons = this._toolbarButtons;
    const toolbar2 = this._toolbar;
    buttons.forEach((button, index) => index > 0 && button.setAttribute("tabindex", "-1"));
    toolbar2.addEventListener("keydown", (e) => {
      if ([37, 39].indexOf(e.keyCode) > -1) {
        e.preventDefault();
        let index = buttons.indexOf(e.target);
        buttons[index].setAttribute("tabindex", "-1");
        let step;
        if (e.keyCode === 39) {
          step = 1;
        } else if (e.keyCode === 37) {
          step = -1;
        }
        index = (buttons.length + index + step) % buttons.length;
        buttons[index].removeAttribute("tabindex");
        buttons[index].focus();
      }
      if (e.keyCode === 27 || e.key === "Tab" && !e.shiftKey) {
        e.preventDefault();
        this._editor.focus();
      }
    });
    toolbar2.addEventListener("mousedown", (e) => {
      if (buttons.indexOf(e.composedPath()[0]) > -1) {
        this._markToolbarFocused();
      }
    });
  }
  /** @private */
  _markToolbarClicked() {
    this._toolbarState = STATE.CLICKED;
  }
  /** @private */
  _markToolbarFocused() {
    this._toolbarState = STATE.FOCUSED;
  }
  /** @private */
  _cleanToolbarState() {
    this._toolbarState = STATE.DEFAULT;
  }
  /** @private */
  __patchToolbar() {
    const toolbar2 = this._editor.getModule("toolbar");
    const update = toolbar2.update;
    toolbar2.controls.push(["link", this.shadowRoot.querySelector('[part~="toolbar-button-link"]')]);
    toolbar2.update = function(range) {
      update.call(toolbar2, range);
      toolbar2.controls.forEach((pair) => {
        const input = pair[1];
        const isActive = input.classList.contains("ql-active");
        input.part.toggle("toolbar-button-pressed", isActive);
      });
    };
  }
  /** @private */
  __patchKeyboard() {
    const focusToolbar = () => {
      this._markToolbarFocused();
      this._toolbar.querySelector("button:not([tabindex])").focus();
    };
    const keyboard = this._editor.keyboard;
    keyboard.addBinding({ key: "Tab", shiftKey: true, handler: focusToolbar });
    keyboard.addBinding({ key: "F10", altKey: true, handler: focusToolbar });
  }
  /** @private */
  __emitChangeEvent() {
    let lastCommittedChange = this.__lastCommittedChange;
    if (this.__debounceSetValue && this.__debounceSetValue.isActive()) {
      lastCommittedChange = this.value;
      this.__debounceSetValue.flush();
    }
    if (lastCommittedChange !== this.value) {
      this.dispatchEvent(new CustomEvent("change", { bubbles: true, cancelable: false }));
      this.__lastCommittedChange = this.value;
    }
  }
  /** @private */
  _onLinkClick() {
    const range = this._editor.getSelection();
    if (range) {
      const LinkBlot = Quill.imports["formats/link"];
      const [link, offset] = this._editor.scroll.descendant(LinkBlot, range.index);
      if (link != null) {
        this._linkRange = { index: range.index - offset, length: link.length() };
        this._linkUrl = LinkBlot.formats(link.domNode);
      } else if (range.length === 0) {
        this._linkIndex = range.index;
      }
      this._linkEditing = true;
    }
  }
  /** @private */
  _applyLink(link) {
    if (link) {
      this._markToolbarClicked();
      this._editor.focus();
      this._editor.format("link", link, SOURCE.USER);
      this._editor.getModule("toolbar").update(this._editor.selection.savedRange);
    }
    this._closeLinkDialog();
  }
  /** @private */
  _insertLink(link, position) {
    if (link) {
      this._markToolbarClicked();
      this._editor.insertText(position, link, { link });
      this._editor.setSelection(position, link.length);
    }
    this._closeLinkDialog();
  }
  /** @private */
  _updateLink(link, range) {
    this._markToolbarClicked();
    this._editor.formatText(range, "link", link, SOURCE.USER);
    this._closeLinkDialog();
  }
  /** @private */
  _removeLink() {
    this._markToolbarClicked();
    if (this._linkRange != null) {
      this._editor.formatText(this._linkRange, { link: false, color: false }, SOURCE.USER);
    }
    this._closeLinkDialog();
  }
  /** @private */
  _closeLinkDialog() {
    this._linkEditing = false;
    this._linkUrl = "";
    this._linkIndex = null;
    this._linkRange = null;
  }
  /** @private */
  _onLinkEditConfirm() {
    if (this._linkIndex != null) {
      this._insertLink(this._linkUrl, this._linkIndex);
    } else if (this._linkRange) {
      this._updateLink(this._linkUrl, this._linkRange);
    } else {
      this._applyLink(this._linkUrl);
    }
  }
  /** @private */
  _onLinkEditCancel() {
    this._closeLinkDialog();
    this._editor.focus();
  }
  /** @private */
  _onLinkEditRemove() {
    this._removeLink();
    this._closeLinkDialog();
  }
  /** @private */
  _onLinkKeydown(e) {
    if (e.keyCode === 13) {
      e.preventDefault();
      e.stopPropagation();
      this._onLinkEditConfirm();
      this._closeLinkDialog();
    }
  }
  /** @private */
  __onColorClick() {
    this._tooltip.opened = false;
    this._colorEditing = true;
  }
  /** @private */
  __onColorSelected(event) {
    const color = event.detail.color;
    this._colorValue = color === "#000000" ? null : color;
    this._markToolbarClicked();
    this._editor.focus();
    this._editor.format("color", this._colorValue, SOURCE.USER);
    this._toolbar.style.setProperty("--_color-value", this._colorValue);
    this._colorEditing = false;
  }
  /** @private */
  __onBackgroundClick() {
    this._tooltip.opened = false;
    this._backgroundEditing = true;
  }
  /** @private */
  __onBackgroundSelected(event) {
    const color = event.detail.color;
    this._backgroundValue = color === "#ffffff" ? null : color;
    this._markToolbarClicked();
    this._editor.focus();
    this._editor.format("background", this._backgroundValue, SOURCE.USER);
    this._toolbar.style.setProperty("--_background-value", this._backgroundValue);
    this._backgroundEditing = false;
  }
  /** @private */
  __updateHtmlValue() {
    let content2 = this._editor.getSemanticHTML();
    content2 = content2.replace(/class="([^"]*)"/gu, (_match, group1) => {
      const classes = group1.split(" ").filter((className) => {
        return !className.startsWith("ql-") || className.startsWith("ql-align") || className.startsWith("ql-indent");
      });
      return `class="${classes.join(" ")}"`;
    });
    content2 = this.__processQuillClasses(content2);
    this._setHtmlValue(content2);
  }
  /** @private */
  __processQuillClasses(content2) {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = content2;
    const elementsToProcess = tempDiv.querySelectorAll('[class*="ql-align"], [class*="ql-indent"]');
    elementsToProcess.forEach((element) => {
      this.__processAlignClasses(element);
      this.__processIndentClasses(element);
      element.removeAttribute("class");
    });
    return tempDiv.innerHTML;
  }
  /** @private */
  __processAlignClasses(element) {
    let styleText = element.getAttribute("style") || "";
    const alignments = [this.__dir === "rtl" ? "left" : "right", "center", "justify"];
    alignments.forEach((align) => {
      if (element.classList.contains(`ql-align-${align}`)) {
        const newStyle = `text-align: ${align}`;
        styleText = styleText ? `${styleText}; ${newStyle}` : newStyle;
        element.setAttribute("style", styleText);
        element.classList.remove(`ql-align-${align}`);
      }
    });
  }
  /** @private */
  __processIndentClasses(element) {
    const indentClass = Array.from(element.classList).find((className) => className.startsWith("ql-indent-"));
    if (indentClass) {
      const level = parseInt(indentClass.replace("ql-indent-", "").trim(), 10);
      const tabs = "	".repeat(level);
      const firstChild = element.firstChild;
      if (firstChild && firstChild.nodeType === Node.TEXT_NODE) {
        firstChild.textContent = tabs + firstChild.textContent;
      } else if (element.childNodes.length > 0) {
        const tabNode = document.createTextNode(tabs);
        element.insertBefore(tabNode, element.firstChild);
      } else {
        element.textContent = tabs;
      }
      element.classList.remove(indentClass);
    }
  }
  /**
   * Sets content represented by HTML snippet into the editor.
   * The snippet is interpreted by [Quill's Clipboard matchers](https://quilljs.com/docs/modules/clipboard/#matchers),
   * which may not produce the exactly input HTML.
   *
   * **NOTE:** Improper handling of HTML can lead to cross site scripting (XSS) and failure to sanitize
   * properly is both notoriously error-prone and a leading cause of web vulnerabilities.
   * This method is aptly named to ensure the developer has taken the necessary precautions.
   * @param {string} htmlValue
   */
  dangerouslySetHtmlValue(htmlValue) {
    if (!this._editor) {
      this.__savePendingHtmlValue(htmlValue);
      return;
    }
    if (!getComputedStyle(this).display) {
      this.__savePendingHtmlValue(htmlValue);
      const observer = new IntersectionObserver(() => {
        if (getComputedStyle(this).display) {
          this.__flushPendingHtmlValue();
          observer.disconnect();
        }
      });
      observer.observe(this);
      return;
    }
    const whitespaceCharacters = {
      "	": "__VAADIN_RICH_TEXT_EDITOR_TAB",
      "  ": "__VAADIN_RICH_TEXT_EDITOR_DOUBLE_SPACE"
    };
    Object.entries(whitespaceCharacters).forEach(([character, replacement]) => {
      htmlValue = htmlValue.replaceAll(/>[^<]*</gu, (match) => match.replaceAll(character, replacement));
    });
    const deltaFromHtml = this._editor.clipboard.convert({ html: htmlValue });
    Object.entries(whitespaceCharacters).forEach(([character, replacement]) => {
      deltaFromHtml.ops.forEach((op) => {
        if (typeof op.insert === "string") {
          op.insert = op.insert.replaceAll(replacement, character);
        }
      });
    });
    this._editor.setContents(deltaFromHtml, SOURCE.API);
  }
  /** @private */
  __savePendingHtmlValue(htmlValue) {
    this.__pendingHtmlValue = htmlValue;
    this.value = "";
  }
  /** @private */
  __flushPendingHtmlValue() {
    if (this.__pendingHtmlValue) {
      this.dangerouslySetHtmlValue(this.__pendingHtmlValue);
    }
  }
  /** @private */
  __announceFormatting() {
    const timeout = 200;
    const announcer = this.shadowRoot.querySelector(".announcer");
    announcer.textContent = "";
    this.__debounceAnnounceFormatting = Debouncer.debounce(
      this.__debounceAnnounceFormatting,
      timeOut.after(timeout),
      () => {
        const formatting = Array.from(this.shadowRoot.querySelectorAll('[part="toolbar"] .ql-active')).map((button) => button.getAttribute("aria-label")).join(", ");
        announcer.textContent = formatting;
      }
    );
  }
  /** @private */
  _clear() {
    this._editor.deleteText(0, this._editor.getLength(), SOURCE.SILENT);
    this.__updateHtmlValue();
  }
  /** @private */
  _undo(e) {
    e.preventDefault();
    this._editor.history.undo();
    this._editor.focus();
  }
  /** @private */
  _redo(e) {
    e.preventDefault();
    this._editor.history.redo();
    this._editor.focus();
  }
  /** @private */
  _toggleToolbarDisabled(disable) {
    const buttons = this._toolbarButtons;
    if (disable) {
      buttons.forEach((btn) => btn.setAttribute("disabled", "true"));
    } else {
      buttons.forEach((btn) => btn.removeAttribute("disabled"));
    }
  }
  /** @private */
  _onImageTouchEnd(e) {
    e.preventDefault();
    this._onImageClick();
  }
  /** @private */
  _onImageClick() {
    this.$.fileInput.value = "";
    this.$.fileInput.click();
  }
  /** @private */
  _uploadImage(e) {
    const fileInput = e.target;
    if (fileInput.files != null && fileInput.files[0] != null) {
      const reader = new FileReader();
      reader.onload = (e2) => {
        const image = e2.target.result;
        const range = this._editor.getSelection(true);
        this._editor.updateContents(
          new Quill.imports.delta().retain(range.index).delete(range.length).insert({ image }),
          SOURCE.USER
        );
        this._markToolbarClicked();
        this._editor.setSelection(range.index + 1, SOURCE.SILENT);
        fileInput.value = "";
      };
      reader.readAsDataURL(fileInput.files[0]);
    }
  }
  /** @private */
  _disabledChanged(disabled, readonly, editor) {
    if (disabled === void 0 || readonly === void 0 || editor === void 0) {
      return;
    }
    if (disabled || readonly) {
      editor.enable(false);
      if (disabled) {
        this._toggleToolbarDisabled(true);
      }
    } else {
      editor.enable();
      if (this.__oldDisabled) {
        this._toggleToolbarDisabled(false);
      }
    }
    this.__oldDisabled = disabled;
  }
  /** @private */
  _valueChanged(value, editor) {
    if (value && this.__pendingHtmlValue) {
      this.__pendingHtmlValue = void 0;
    }
    if (editor === void 0) {
      return;
    }
    if (value == null || value === '[{"insert":"\\n"}]') {
      this.value = "";
      return;
    }
    if (value === "") {
      this._clear();
      return;
    }
    let parsedValue;
    try {
      parsedValue = JSON.parse(value);
      if (Array.isArray(parsedValue)) {
        this.__oldValue = value;
      } else {
        throw new Error(`expected JSON string with array of objects, got: ${value}`);
      }
    } catch (err) {
      this.value = this.__oldValue;
      console.error("Invalid value set to rich-text-editor:", err);
      return;
    }
    const delta = new Quill.imports.delta(parsedValue);
    if (JSON.stringify(editor.getContents()) !== JSON.stringify(delta)) {
      editor.setContents(delta, SOURCE.SILENT);
    }
    this.__updateHtmlValue();
    if (this._toolbarState === STATE.CLICKED) {
      this._cleanToolbarState();
      this.__emitChangeEvent();
    } else if (!this._editor.hasFocus()) {
      this.__lastCommittedChange = this.value;
    }
  }
};

// node_modules/@vaadin/rich-text-editor/src/vaadin-rich-text-editor.js
var RichTextEditor = class extends RichTextEditorMixin(
  ElementMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))
) {
  static get is() {
    return "vaadin-rich-text-editor";
  }
  static get cvdlName() {
    return "vaadin-rich-text-editor";
  }
  static get styles() {
    return richTextEditorStyles;
  }
  static get lumoInjector() {
    return { ...super.lumoInjector, includeBaseStyles: true };
  }
  /** @protected */
  render() {
    return html`
      <div class="vaadin-rich-text-editor-container">
        <!-- Create toolbar container -->
        <div part="toolbar" role="toolbar">
          <span part="toolbar-group toolbar-group-history">
            <!-- Undo and Redo -->
            <button
              id="btn-undo"
              type="button"
              part="toolbar-button toolbar-button-undo"
              aria-label="${this.__effectiveI18n.undo}"
              @click="${this._undo}"
            ></button>

            <button
              id="btn-redo"
              type="button"
              part="toolbar-button toolbar-button-redo"
              aria-label="${this.__effectiveI18n.redo}"
              @click="${this._redo}"
            ></button>
          </span>

          <span part="toolbar-group toolbar-group-emphasis">
            <!-- Bold -->
            <button
              id="btn-bold"
              class="ql-bold"
              part="toolbar-button toolbar-button-bold"
              aria-label="${this.__effectiveI18n.bold}"
            ></button>

            <!-- Italic -->
            <button
              id="btn-italic"
              class="ql-italic"
              part="toolbar-button toolbar-button-italic"
              aria-label="${this.__effectiveI18n.italic}"
            ></button>

            <!-- Underline -->
            <button
              id="btn-underline"
              class="ql-underline"
              part="toolbar-button toolbar-button-underline"
              aria-label="${this.__effectiveI18n.underline}"
            ></button>

            <!-- Strike -->
            <button
              id="btn-strike"
              class="ql-strike"
              part="toolbar-button toolbar-button-strike"
              aria-label="${this.__effectiveI18n.strike}"
            ></button>
          </span>

          <span part="toolbar-group toolbar-group-style">
            <!-- Color -->
            <button
              id="btn-color"
              type="button"
              part="toolbar-button toolbar-button-color"
              aria-label="${this.__effectiveI18n.color}"
              @click="${this.__onColorClick}"
            ></button>
            <!-- Background -->
            <button
              id="btn-background"
              type="button"
              part="toolbar-button toolbar-button-background"
              aria-label="${this.__effectiveI18n.background}"
              @click="${this.__onBackgroundClick}"
            ></button>
          </span>

          <span part="toolbar-group toolbar-group-heading">
            <!-- Header buttons -->
            <button
              id="btn-h1"
              type="button"
              class="ql-header"
              value="1"
              part="toolbar-button toolbar-button-h1"
              aria-label="${this.__effectiveI18n.h1}"
            ></button>
            <button
              id="btn-h2"
              type="button"
              class="ql-header"
              value="2"
              part="toolbar-button toolbar-button-h2"
              aria-label="${this.__effectiveI18n.h2}"
            ></button>
            <button
              id="btn-h3"
              type="button"
              class="ql-header"
              value="3"
              part="toolbar-button toolbar-button-h3"
              aria-label="${this.__effectiveI18n.h3}"
            ></button>
          </span>

          <span part="toolbar-group toolbar-group-glyph-transformation">
            <!-- Subscript and superscript -->
            <button
              id="btn-subscript"
              class="ql-script"
              value="sub"
              part="toolbar-button toolbar-button-subscript"
              aria-label="${this.__effectiveI18n.subscript}"
            ></button>
            <button
              id="btn-superscript"
              class="ql-script"
              value="super"
              part="toolbar-button toolbar-button-superscript"
              aria-label="${this.__effectiveI18n.superscript}"
            ></button>
          </span>

          <span part="toolbar-group toolbar-group-list">
            <!-- List buttons -->
            <button
              id="btn-ol"
              type="button"
              class="ql-list"
              value="ordered"
              part="toolbar-button toolbar-button-list-ordered"
              aria-label="${this.__effectiveI18n.listOrdered}"
            ></button>
            <button
              id="btn-ul"
              type="button"
              class="ql-list"
              value="bullet"
              part="toolbar-button toolbar-button-list-bullet"
              aria-label="${this.__effectiveI18n.listBullet}"
            ></button>
          </span>

          <span part="toolbar-group toolbar-group-indent">
            <!-- Decrease -->
            <button
              id="btn-outdent"
              type="button"
              class="ql-indent"
              value="-1"
              part="toolbar-button toolbar-button-outdent"
              aria-label="${this.__effectiveI18n.outdent}"
            ></button>
            <!-- Increase -->
            <button
              id="btn-indent"
              type="button"
              class="ql-indent"
              value="+1"
              part="toolbar-button toolbar-button-indent"
              aria-label="${this.__effectiveI18n.indent}"
            ></button>
          </span>

          <span part="toolbar-group toolbar-group-alignment">
            <!-- Align buttons -->
            <button
              id="btn-left"
              type="button"
              class="ql-align"
              value=""
              part="toolbar-button toolbar-button-align-left"
              aria-label="${this.__effectiveI18n.alignLeft}"
            ></button>
            <button
              id="btn-center"
              type="button"
              class="ql-align"
              value="center"
              part="toolbar-button toolbar-button-align-center"
              aria-label="${this.__effectiveI18n.alignCenter}"
            ></button>
            <button
              id="btn-right"
              type="button"
              class="ql-align"
              value="right"
              part="toolbar-button toolbar-button-align-right"
              aria-label="${this.__effectiveI18n.alignRight}"
            ></button>
          </span>

          <span part="toolbar-group toolbar-group-rich-text">
            <!-- Image -->
            <button
              id="btn-image"
              type="button"
              part="toolbar-button toolbar-button-image"
              aria-label="${this.__effectiveI18n.image}"
              @touchend="${this._onImageTouchEnd}"
              @click="${this._onImageClick}"
            ></button>
            <!-- Link -->
            <button
              id="btn-link"
              type="button"
              part="toolbar-button toolbar-button-link"
              aria-label="${this.__effectiveI18n.link}"
              @click="${this._onLinkClick}"
            ></button>
          </span>

          <span part="toolbar-group toolbar-group-block">
            <!-- Blockquote -->
            <button
              id="btn-blockquote"
              type="button"
              class="ql-blockquote"
              part="toolbar-button toolbar-button-blockquote"
              aria-label="${this.__effectiveI18n.blockquote}"
            ></button>
            <!-- Code block -->
            <button
              id="btn-code"
              type="button"
              class="ql-code-block"
              part="toolbar-button toolbar-button-code-block"
              aria-label="${this.__effectiveI18n.codeBlock}"
            ></button>
          </span>

          <span part="toolbar-group toolbar-group-format">
            <!-- Clean -->
            <button
              id="btn-clean"
              type="button"
              class="ql-clean"
              part="toolbar-button toolbar-button-clean"
              aria-label="${this.__effectiveI18n.clean}"
            ></button>
          </span>

          <input
            id="fileInput"
            type="file"
            accept="image/png, image/gif, image/jpeg, image/bmp, image/x-icon"
            @change="${this._uploadImage}"
          />
        </div>

        <div part="content"></div>

        <div class="announcer" aria-live="polite"></div>
      </div>

      <slot name="tooltip"></slot>

      <slot name="link-dialog"></slot>

      <slot name="color-popup"></slot>

      <slot name="background-popup"></slot>
    `;
  }
  /**
   * Override update to render slotted overlays into light DOM after rendering shadow DOM.
   * @param changedProperties
   * @protected
   */
  update(changedProperties) {
    super.update(changedProperties);
    this.__renderSlottedOverlays();
  }
  /** @private */
  __renderSlottedOverlays() {
    render(
      html`
        <vaadin-confirm-dialog
          slot="link-dialog"
          cancel-button-visible
          reject-theme="error"
          .opened="${this._linkEditing}"
          .header="${this.__effectiveI18n.linkDialogTitle}"
          .confirmText="${this.__effectiveI18n.ok}"
          .rejectText="${this.__effectiveI18n.remove}"
          .cancelText="${this.__effectiveI18n.cancel}"
          .rejectButtonVisible="${!!this._linkRange}"
          @confirm="${this._onLinkEditConfirm}"
          @cancel="${this._onLinkEditCancel}"
          @reject="${this._onLinkEditRemove}"
          @opened-changed="${this._onLinkEditingChanged}"
        >
          <vaadin-text-field
            .value="${this._linkUrl}"
            style="width: 100%;"
            @keydown="${this._onLinkKeydown}"
            @value-changed="${this._onLinkUrlChanged}"
          ></vaadin-text-field>
        </vaadin-confirm-dialog>

        <vaadin-rich-text-editor-popup
          slot="color-popup"
          .colors="${["#000000", ...[...this.colorOptions].filter((c) => c !== "#000000")]}"
          .opened="${this._colorEditing}"
          @color-selected="${this.__onColorSelected}"
          @opened-changed="${this.__onColorEditingChanged}"
        ></vaadin-rich-text-editor-popup>

        <vaadin-rich-text-editor-popup
          slot="background-popup"
          .colors="${["#ffffff", ...[...this.colorOptions].filter((c) => c !== "#ffffff")]}"
          .opened="${this._backgroundEditing}"
          @color-selected="${this.__onBackgroundSelected}"
          @opened-changed="${this.__onBackgroundEditingChanged}"
        ></vaadin-rich-text-editor-popup>
      `,
      this,
      { host: this }
    );
  }
  /** @private */
  __onBackgroundEditingChanged(event) {
    this._backgroundEditing = event.detail.value;
  }
  /** @private */
  __onColorEditingChanged(event) {
    this._colorEditing = event.detail.value;
  }
  /** @private */
  _onLinkEditingChanged(event) {
    if (event.detail.value) {
      const confirmDialog = event.target;
      const urlField = confirmDialog.querySelector("vaadin-text-field");
      confirmDialog.$.overlay.addEventListener(
        "vaadin-overlay-open",
        () => {
          urlField.focus({ focusVisible: isKeyboardActive() });
        },
        { once: true }
      );
    }
    this._linkEditing = event.detail.value;
  }
  /** @private */
  _onLinkUrlChanged(event) {
    this._linkUrl = event.detail.value;
  }
};
defineCustomElement(RichTextEditor);
export {
  RichTextEditor
};
//# sourceMappingURL=@vaadin_rich-text-editor_src_vaadin-rich-text-editor__js.js.map
