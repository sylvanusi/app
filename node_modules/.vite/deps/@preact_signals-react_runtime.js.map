{
  "version": 3,
  "sources": ["../../use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../use-sync-external-store/shim/index.js", "../../@preact/signals-core/src/index.ts", "../../@preact/signals-react/runtime/src/index.ts"],
  "sourcesContent": ["/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn fn();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T, options?: SignalOptions<T>);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\t/** @internal */\n\t_watched?(this: Signal<T>): void;\n\n\t/** @internal */\n\t_unwatched?(this: Signal<T>): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tname?: string;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof BRAND_SYMBOL;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\nexport interface SignalOptions<T = any> {\n\twatched?: (this: Signal<T>) => void;\n\tunwatched?: (this: Signal<T>) => void;\n\tname?: string;\n}\n\n/** @internal */\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\nfunction Signal(this: Signal, value?: unknown, options?: SignalOptions) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n\tthis._watched = options?.watched;\n\tthis._unwatched = options?.unwatched;\n\tthis.name = options?.name;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tconst targets = this._targets;\n\tif (targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = targets;\n\t\tthis._targets = node;\n\n\t\tif (targets !== undefined) {\n\t\t\ttargets._prevTarget = node;\n\t\t} else {\n\t\t\tuntracked(() => {\n\t\t\t\tthis._watched?.call(this);\n\t\t\t});\n\t\t}\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t\tif (next === undefined) {\n\t\t\t\tuntracked(() => {\n\t\t\t\t\tthis._unwatched?.call(this);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\treturn effect(\n\t\t() => {\n\t\t\tconst value = this.value;\n\t\t\tconst prevContext = evalContext;\n\t\t\tevalContext = undefined;\n\t\t\ttry {\n\t\t\t\tfn(value);\n\t\t\t} finally {\n\t\t\t\tevalContext = prevContext;\n\t\t\t}\n\t\t},\n\t\t{ name: \"sub\" }\n\t);\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn this.value;\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget(this: Signal) {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tthrow new Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T, options?: SignalOptions<T>): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T, options?: SignalOptions<T>): Signal<T> {\n\treturn new Signal(value, options);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tif (\n\t\t\t// If the dependency has definitely been updated since its version number\n\t\t\t// was observed, then we need to recompute. This first check is not strictly\n\t\t\t// necessary for correctness, but allows us to skip the refresh call if the\n\t\t\t// dependency has already been updated.\n\t\t\tnode._source._version !== node._version ||\n\t\t\t// Refresh the dependency. If there's something blocking the refresh (e.g. a\n\t\t\t// dependency cycle), then we need to recompute.\n\t\t\t!node._source._refresh() ||\n\t\t\t// If the dependency got a new version after the refresh, then we need to recompute.\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head: Node | undefined = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\n/**\n * The base class for computed signals.\n */\ndeclare class Computed<T = any> extends Signal<T> {\n\t_fn: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(fn: () => T, options?: SignalOptions<T>);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\n/** @internal */\nfunction Computed(this: Computed, fn: () => unknown, options?: SignalOptions) {\n\tSignal.call(this, undefined);\n\n\tthis._fn = fn;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n\tthis._watched = options?.watched;\n\tthis._unwatched = options?.unwatched;\n\tthis.name = options?.name;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._fn();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget(this: Computed) {\n\t\tif (this._flags & RUNNING) {\n\t\t\tthrow new Error(\"Cycle detected\");\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n\treadonly value: T;\n\tpeek(): T;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\tvalueOf(): T;\n\ttoString(): string;\n\ttoJSON(): T;\n\tbrand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(\n\tfn: () => T,\n\toptions?: SignalOptions<T>\n): ReadonlySignal<T> {\n\treturn new Computed(fn, options);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._fn = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectFn =\n\t| ((this: { dispose: () => void }) => void | (() => void))\n\t| (() => void | (() => void));\n\n/**\n * The base class for reactive effects.\n */\ndeclare class Effect {\n\t_fn?: EffectFn;\n\t_cleanup?: () => void;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\tname?: string;\n\n\tconstructor(fn: EffectFn, options?: EffectOptions);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n\tdispose(): void;\n}\n\nexport interface EffectOptions {\n\tname?: string;\n}\n\n/** @internal */\nfunction Effect(this: Effect, fn: EffectFn, options?: EffectOptions) {\n\tthis._fn = fn;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n\tthis.name = options?.name;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._fn === undefined) return;\n\n\t\tconst cleanup = this._fn();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tthrow new Error(\"Cycle detected\");\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nEffect.prototype.dispose = function () {\n\tthis._dispose();\n};\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn, options?: EffectOptions): () => void {\n\tconst effect = new Effect(fn, options);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\tconst dispose = effect._dispose.bind(effect);\n\t(dispose as any)[Symbol.dispose] = dispose;\n\treturn dispose as any;\n}\n\nexport {\n\tcomputed,\n\teffect,\n\tbatch,\n\tuntracked,\n\tSignal,\n\tReadonlySignal,\n\tEffect,\n\tComputed,\n};\n", "import {\n\tsignal,\n\tcomputed,\n\teffect,\n\tSignal,\n\tReadonlySignal,\n\tSignalOptions,\n\tEffectOptions,\n} from \"@preact/signals-core\";\nimport {\n\tuseRef,\n\tuseMemo,\n\tuseEffect,\n\tuseLayoutEffect,\n\tversion as reactVersion,\n} from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nconst [major] = reactVersion.split(\".\").map(Number);\nconst Empty = [] as const;\n// V19 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\n// V18 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\nconst ReactElemType = Symbol.for(\n\tmajor >= 19 ? \"react.transitional.element\" : \"react.element\"\n);\n\nexport function wrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst symDispose: unique symbol =\n\t(Symbol as any).dispose || Symbol.for(\"Symbol.dispose\");\n\ninterface Effect {\n\t_sources: object | undefined;\n\t_start(): () => void;\n\t_callback(): void;\n\t_dispose(): void;\n}\n\n/**\n * Use this flag to represent a bare `useSignals` call that doesn't manually\n * close its effect store and relies on auto-closing when the next useSignals is\n * called or after a microtask\n */\nconst UNMANAGED = 0;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a component's render method. This is the default usage\n * that the react-transform plugin uses.\n */\nconst MANAGED_COMPONENT = 1;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a hook body. This is the default usage that the\n * react-transform plugin uses.\n */\nconst MANAGED_HOOK = 2;\n\n/**\n * An enum defining how this store is used. See the documentation for each enum\n * member for more details.\n * @see {@link UNMANAGED}\n * @see {@link MANAGED_COMPONENT}\n * @see {@link MANAGED_HOOK}\n */\ntype EffectStoreUsage =\n\t| typeof UNMANAGED\n\t| typeof MANAGED_COMPONENT\n\t| typeof MANAGED_HOOK;\n\nexport interface EffectStore {\n\t/**\n\t * An enum defining how this hook is used and whether it is invoked in a\n\t * component's body or hook body. See the comment on `EffectStoreUsage` for\n\t * more details.\n\t */\n\treadonly _usage: EffectStoreUsage;\n\treadonly effect: Effect;\n\tsubscribe(onStoreChange: () => void): () => void;\n\tgetSnapshot(): number;\n\t/** startEffect - begin tracking signals used in this component */\n\t_start(): void;\n\t/** finishEffect - stop tracking the signals used in this component */\n\tf(): void;\n\t[symDispose](): void;\n}\n\nlet currentStore: EffectStore | undefined;\n\nfunction startComponentEffect(\n\tprevStore: EffectStore | undefined,\n\tnextStore: EffectStore\n) {\n\tconst endEffect = nextStore.effect._start();\n\tcurrentStore = nextStore;\n\n\treturn finishComponentEffect.bind(nextStore, prevStore, endEffect);\n}\n\nfunction finishComponentEffect(\n\tthis: EffectStore,\n\tprevStore: EffectStore | undefined,\n\tendEffect: () => void\n) {\n\tendEffect();\n\tcurrentStore = prevStore;\n}\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a\n * 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the\n * component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the\n * `effect._callback' is called, we update our store version and tell React to\n * re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://react.dev/reference/react/useSyncExternalStore\n * @see\n * https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n *\n * @param _usage An enum defining how this hook is used and whether it is\n * invoked in a component's body or hook body. See the comment on\n * `EffectStoreUsage` for more details.\n */\nfunction createEffectStore(_usage: EffectStoreUsage): EffectStore {\n\tlet effectInstance!: Effect;\n\tlet endEffect: (() => void) | undefined;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(function (this: Effect) {\n\t\teffectInstance = this;\n\t});\n\teffectInstance._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\t_usage,\n\t\teffect: effectInstance,\n\t\tsubscribe(onStoreChange) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t\t_start() {\n\t\t\t// In general, we want to support two kinds of usages of useSignals:\n\t\t\t//\n\t\t\t// A) Managed: calling useSignals in a component or hook body wrapped in a\n\t\t\t//    try/finally (like what the react-transform plugin does)\n\t\t\t//\n\t\t\t// B) Unmanaged: Calling useSignals directly without wrapping in a\n\t\t\t//    try/finally\n\t\t\t//\n\t\t\t// For managed, we finish the effect in the finally block of the component\n\t\t\t// or hook body. For unmanaged, we finish the effect in the next\n\t\t\t// useSignals call or after a microtask.\n\t\t\t//\n\t\t\t// There are different tradeoffs which each approach. With managed, using\n\t\t\t// a try/finally ensures that only signals used in the component or hook\n\t\t\t// body are tracked. However, signals accessed in render props are missed\n\t\t\t// because the render prop is invoked in another component that may or may\n\t\t\t// not realize it is rendering signals accessed in the render prop it is\n\t\t\t// given.\n\t\t\t//\n\t\t\t// The other approach is \"unmanaged\": to call useSignals directly without\n\t\t\t// wrapping in a try/finally. This approach is easier to manually write in\n\t\t\t// situations where a build step isn't available but does open up the\n\t\t\t// possibility of catching signals accessed in other code before the\n\t\t\t// effect is closed (e.g. in a layout effect). Most situations where this\n\t\t\t// could happen are generally consider bad patterns or bugs. For example,\n\t\t\t// using a signal in a component and not having a call to `useSignals`\n\t\t\t// would be an bug. Or using a signal in `useLayoutEffect` is generally\n\t\t\t// not recommended since that layout effect won't update when the signals'\n\t\t\t// value change.\n\t\t\t//\n\t\t\t// To support both approaches, we need to track how each invocation of\n\t\t\t// useSignals is used, so we can properly transition between different\n\t\t\t// kinds of usages.\n\t\t\t//\n\t\t\t// The following table shows the different scenarios and how we should\n\t\t\t// handle them.\n\t\t\t//\n\t\t\t// Key:\n\t\t\t// 0 = UNMANAGED\n\t\t\t// 1 = MANAGED_COMPONENT\n\t\t\t// 2 = MANAGED_HOOK\n\t\t\t//\n\t\t\t// Pattern:\n\t\t\t// prev store usage -> this store usage: action to take\n\t\t\t//\n\t\t\t// - 0 -> 0: finish previous effect (unknown to unknown)\n\t\t\t//\n\t\t\t//   We don't know how the previous effect was used, so we need to finish\n\t\t\t//   it before starting the next effect.\n\t\t\t//\n\t\t\t// - 0 -> 1: finish previous effect\n\t\t\t//\n\t\t\t//   Assume previous invocation was another component or hook from another\n\t\t\t//   component. Nested component renders (renderToStaticMarkup within a\n\t\t\t//   component's render) won't be supported with bare useSignals calls.\n\t\t\t//\n\t\t\t// - 0 -> 2: capture & restore\n\t\t\t//\n\t\t\t//   Previous invocation could be a component or a hook. Either way,\n\t\t\t//   restore it after our invocation so that it can continue to capture\n\t\t\t//   any signals after we exit.\n\t\t\t//\n\t\t\t// - 1 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 1 -> 1: capture & restore (e.g. component calls renderToStaticMarkup)\n\t\t\t// - 1 -> 2: capture & restore (e.g. hook)\n\t\t\t//\n\t\t\t// - 2 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 2 -> 1: capture & restore (e.g. hook calls renderToStaticMarkup)\n\t\t\t// - 2 -> 2: capture & restore (e.g. nested hook calls)\n\n\t\t\tif (currentStore == undefined) {\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst prevUsage = currentStore._usage;\n\t\t\tconst thisUsage = this._usage;\n\n\t\t\tif (\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == UNMANAGED) || // 0 -> 0\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == MANAGED_COMPONENT) // 0 -> 1\n\t\t\t) {\n\t\t\t\t// finish previous effect\n\t\t\t\tcurrentStore.f();\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t} else if (\n\t\t\t\t(prevUsage == MANAGED_COMPONENT && thisUsage == UNMANAGED) || // 1 -> 0\n\t\t\t\t(prevUsage == MANAGED_HOOK && thisUsage == UNMANAGED) // 2 -> 0\n\t\t\t) {\n\t\t\t\t// Do nothing since it'll be captured by current effect store\n\t\t\t} else {\n\t\t\t\t// nested scenarios, so capture and restore the previous effect store\n\t\t\t\tendEffect = startComponentEffect(currentStore, this);\n\t\t\t}\n\t\t},\n\t\tf() {\n\t\t\tconst end = endEffect;\n\t\t\tendEffect = undefined;\n\t\t\tend?.();\n\t\t},\n\t\t[symDispose]() {\n\t\t\tthis.f();\n\t\t},\n\t};\n}\n\nconst noop = () => {};\n\nfunction createEmptyEffectStore(): EffectStore {\n\treturn {\n\t\t_usage: UNMANAGED,\n\t\teffect: {\n\t\t\t_sources: undefined,\n\t\t\t_callback() {},\n\t\t\t_start() {\n\t\t\t\treturn /* endEffect */ noop;\n\t\t\t},\n\t\t\t_dispose() {},\n\t\t},\n\t\tsubscribe() {\n\t\t\treturn /* unsubscribe */ noop;\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn 0;\n\t\t},\n\t\t_start() {},\n\t\tf() {},\n\t\t[symDispose]() {},\n\t};\n}\n\nconst emptyEffectStore = createEmptyEffectStore();\n\nconst _queueMicroTask = Promise.prototype.then.bind(Promise.resolve());\n\nlet finalCleanup: Promise<void> | undefined;\nexport function ensureFinalCleanup() {\n\tif (!finalCleanup) {\n\t\tfinalCleanup = _queueMicroTask(cleanupTrailingStore);\n\t}\n}\nfunction cleanupTrailingStore() {\n\tfinalCleanup = undefined;\n\tcurrentStore?.f();\n}\n\nconst useIsomorphicLayoutEffect =\n\ttypeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Custom hook to create the effect to track signals used during render and\n * subscribe to changes to rerender the component when the signals change.\n */\nexport function _useSignalsImplementation(\n\t_usage: EffectStoreUsage = UNMANAGED\n): EffectStore {\n\tensureFinalCleanup();\n\n\tconst storeRef = useRef<EffectStore>();\n\tif (storeRef.current == null) {\n\t\tif (typeof window === \"undefined\") {\n\t\t\tstoreRef.current = emptyEffectStore;\n\t\t} else {\n\t\t\tstoreRef.current = createEffectStore(_usage);\n\t\t}\n\t}\n\n\tconst store = storeRef.current;\n\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\tstore._start();\n\t// note: _usage is a constant here, so conditional is okay\n\tif (_usage === UNMANAGED) useIsomorphicLayoutEffect(cleanupTrailingStore);\n\n\treturn store;\n}\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node or JSX.\n */\nfunction SignalValue({ data }: { data: Signal }) {\n\tconst store = _useSignalsImplementation(1);\n\ttry {\n\t\treturn data.value;\n\t} finally {\n\t\tstore.f();\n\t}\n}\n\n// Decorate Signals so React renders them as <SignalValue> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignals(usage?: EffectStoreUsage): EffectStore {\n\treturn _useSignalsImplementation(usage);\n}\n\nexport function useSignal<T>(value: T, options?: SignalOptions<T>): Signal<T>;\nexport function useSignal<T = undefined>(): Signal<T | undefined>;\nexport function useSignal<T>(value?: T, options?: SignalOptions<T>) {\n\treturn useMemo(\n\t\t() => signal<T | undefined>(value, options as SignalOptions),\n\t\tEmpty\n\t);\n}\n\nexport function useComputed<T>(\n\tcompute: () => T,\n\toptions?: SignalOptions<T>\n): ReadonlySignal<T> {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current(), options), Empty);\n}\n\nexport function useSignalEffect(\n\tcb: () => void | (() => void),\n\toptions?: EffectOptions\n) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(function (this: Effect) {\n\t\t\treturn callback.current();\n\t\t}, options);\n\t}, Empty);\n}\n"],
  "mappings": "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",
  "names": ["x", "y", "BRAND_SYMBOL", "Symbol", "endBatch", "batchDepth", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "_nextBatchedEffect", "_flags", "needsToRecompute", "_callback", "err", "evalContext", "untracked", "fn", "prevContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "node", "_node", "_target", "_version", "_source", "_prevSource", "_sources", "_nextSource", "_prevTarget", "_nextTarget", "_rollbackNode", "_flags", "_subscribe", "Signal", "value", "options", "this", "_value", "_targets", "_watched", "watched", "_unwatched", "unwatched", "name", "prototype", "brand", "BRAND_SYMBOL", "_refresh", "_this", "targets", "_this$_watched", "call", "_unsubscribe", "_this2", "prev", "next", "_this2$_unwatched", "subscribe", "_this3", "effect", "valueOf", "toString", "toJSON", "peek", "Object", "defineProperty", "get", "set", "Error", "_notify", "endBatch", "needsToRecompute", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "undefined", "_fn", "_globalVersion", "err", "OUTDATED", "computed", "cleanupEffect", "cleanup", "_cleanup", "disposeEffect", "endEffect", "Effect", "_nextBatchedEffect", "_callback", "finish", "_start", "bind", "_dispose", "dispose", "Symbol", "major", "reactVersion", "split", "map", "Number", "Empty", "ReactElemType", "Symbol", "wrapJsx", "jsx", "type", "props", "i", "v", "Signal", "value", "call", "apply", "concat", "slice", "arguments", "currentStore", "symDispose", "dispose", "startComponentEffect", "prevStore", "nextStore", "endEffect", "effect", "_start", "finishComponentEffect", "bind", "_ref2", "finalCleanup", "noop", "emptyEffectStore", "_usage", "_sources", "_callback", "_dispose", "subscribe", "getSnapshot", "f", "_queueMicroTask", "Promise", "prototype", "then", "resolve", "ensureFinalCleanup", "cleanupTrailingStore", "_currentStore", "useIsomorphicLayoutEffect", "window", "useLayoutEffect", "useEffect", "_useSignalsImplementation", "storeRef", "useRef", "current", "_ref", "effectInstance", "onChangeNotifyReact", "version", "unsubscribe", "this", "onStoreChange", "undefined", "prevUsage", "thisUsage", "end", "store", "useSyncExternalStore", "Object", "defineProperties", "$$typeof", "configurable", "_ref3", "data", "get", "ref", "useSignals", "usage", "useSignal", "options", "useMemo", "signal", "useComputed", "compute", "$compute", "computed", "useSignalEffect", "cb", "callback"]
}
