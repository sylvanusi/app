import {
  ComboBoxDataProviderMixin,
  ComboBoxItemsMixin,
  comboBoxOverlayStyles,
  comboBoxStyles
} from "./chunk-IDX2ACNH.js";
import {
  PatternMixin
} from "./chunk-TDU75KT6.js";
import {
  ComboBoxItemMixin,
  ComboBoxOverlayMixin,
  ComboBoxScrollerMixin,
  comboBoxScrollerStyles
} from "./chunk-ZDU6TMZE.js";
import {
  InputControlMixin
} from "./chunk-ETYEORRM.js";
import {
  inputFieldShared
} from "./chunk-F6FMTQFS.js";
import {
  itemStyles
} from "./chunk-WEJ2XI2Y.js";
import {
  ifDefined
} from "./chunk-OSWHV746.js";
import {
  OverlayMixin,
  overlayStyles
} from "./chunk-PFI4EOEJ.js";
import {
  InputController
} from "./chunk-6KCLDTNY.js";
import {
  LabelledInputController
} from "./chunk-C63QNJWN.js";
import {
  ValidateMixin
} from "./chunk-ZZO67D7M.js";
import {
  TooltipController
} from "./chunk-XFKQJ73Z.js";
import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import {
  DirMixin
} from "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-item.js
var ComboBoxItem = class extends ComboBoxItemMixin(
  ThemableMixin(DirMixin(PolylitMixin(LumoInjectionMixin(LitElement))))
) {
  static get is() {
    return "vaadin-combo-box-item";
  }
  static get styles() {
    return itemStyles;
  }
  /** @protected */
  render() {
    return html`
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
};
defineCustomElement(ComboBoxItem);

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-overlay.js
var ComboBoxOverlay = class extends ComboBoxOverlayMixin(
  OverlayMixin(DirMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement)))))
) {
  static get is() {
    return "vaadin-combo-box-overlay";
  }
  static get styles() {
    return [overlayStyles, comboBoxOverlayStyles];
  }
  /** @protected */
  render() {
    return html`
      <div part="overlay" id="overlay">
        <div part="loader"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
};
defineCustomElement(ComboBoxOverlay);

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-scroller.js
var ComboBoxScroller = class extends ComboBoxScrollerMixin(PolylitMixin(LitElement)) {
  static get is() {
    return "vaadin-combo-box-scroller";
  }
  static get styles() {
    return comboBoxScrollerStyles;
  }
  /** @protected */
  render() {
    return html`
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
};
defineCustomElement(ComboBoxScroller);

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-mixin.js
function isValidValue(value) {
  return value !== void 0 && value !== null;
}
var ComboBoxMixin = (superClass) => class ComboBoxMixinClass extends ValidateMixin(ComboBoxItemsMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The `<vaadin-combo-box-item>` internal container DOM element.
       * - `comboBox` The reference to the `<vaadin-combo-box>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       * @type {ComboBoxRenderer | undefined}
       */
      renderer: {
        type: Object,
        sync: true
      },
      /**
       * If `true`, the user can input a value that is not present in the items list.
       * `value` property will be set to the input value in this case.
       * Also, when `value` is set programmatically, the input value will be set
       * to reflect that value.
       * @attr {boolean} allow-custom-value
       * @type {boolean}
       */
      allowCustomValue: {
        type: Boolean,
        value: false
      },
      /**
       * When set to `true`, "loading" attribute is added to host and the overlay element.
       * @type {boolean}
       */
      loading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * The selected item from the `items` array.
       * @type {ComboBoxItem | string | undefined}
       */
      selectedItem: {
        type: Object,
        notify: true,
        sync: true
      },
      /**
       * A function used to generate CSS class names for dropdown
       * items based on the item. The return value should be the
       * generated class name as a string, or multiple class names
       * separated by whitespace characters.
       */
      itemClassNameGenerator: {
        type: Object
      },
      /**
       * Path for the id of the item. If `items` is an array of objects,
       * the `itemIdPath` is used to compare and identify the same item
       * in `selectedItem` and `filteredItems` (items given by the
       * `dataProvider` callback).
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        sync: true
      },
      /** @private */
      __keepOverlayOpened: {
        type: Boolean,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "_openedOrItemsChanged(opened, _dropdownItems, loading, __keepOverlayOpened)",
      "_selectedItemChanged(selectedItem, itemValuePath, itemLabelPath)",
      "_updateScroller(opened, _dropdownItems, _focusedIndex, _theme)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    this._lastCommittedValue = this.value;
  }
  /**
   * Requests an update for the content of items.
   * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this._scroller) {
      return;
    }
    this._scroller.requestContentUpdate();
    this._getItemElements().forEach((item) => {
      item.requestContentUpdate();
    });
  }
  /**
   * @param {Object} props
   * @protected
   */
  updated(props) {
    super.updated(props);
    ["loading", "itemIdPath", "itemClassNameGenerator", "renderer", "selectedItem"].forEach((prop) => {
      if (props.has(prop)) {
        this._scroller[prop] = this[prop];
      }
    });
  }
  /** @private */
  _updateScroller(opened, items, focusedIndex, theme) {
    if (opened) {
      this._scroller.style.maxHeight = getComputedStyle(this).getPropertyValue(`--${this._tagNamePrefix}-overlay-max-height`) || "65vh";
    }
    this._scroller.setProperties({
      items: opened ? items : [],
      opened,
      focusedIndex,
      theme
    });
  }
  /** @private */
  _openedOrItemsChanged(opened, items, loading, keepOverlayOpened) {
    this._overlayOpened = opened && (keepOverlayOpened || loading || !!(items && items.length));
  }
  /**
   * Override method from `ComboBoxBaseMixin` to deselect
   * dropdown item by requesting content update on clear.
   * @param {Event} event
   * @protected
   */
  _onClearButtonClick(event) {
    super._onClearButtonClick(event);
    if (this.opened) {
      this.requestContentUpdate();
    }
  }
  /**
   * Override method inherited from `InputMixin`
   * to revert the input value to value.
   * @protected
   * @override
   */
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      this._revertInputValueToValue();
    }
  }
  /**
   * Override method from `ComboBoxBaseMixin` to handle loading.
   * @protected
   * @override
   */
  _closeOrCommit() {
    if (!this.opened && !this.loading) {
      this._commitValue();
    } else {
      this.close();
    }
  }
  /**
   * Override method from `ComboBoxBaseMixin` to handle valid value.
   * @protected
   * @override
   */
  _hasValidInputValue() {
    const hasInvalidOption = this._focusedIndex < 0 && this._inputElementValue !== "" && this._getItemLabel(this.selectedItem) !== this._inputElementValue;
    return this.allowCustomValue || !hasInvalidOption;
  }
  /**
   * Override method from `ComboBoxBaseMixin`.
   * @protected
   * @override
   */
  _onEscapeCancel() {
    this.cancel();
  }
  /**
   * Override method from `ComboBoxBaseMixin` to reset selected item.
   * @protected
   * @override
   */
  _onClearAction() {
    this.selectedItem = null;
    if (this.allowCustomValue) {
      this.value = "";
    }
    this._detectAndDispatchChange();
  }
  /**
   * Clears the current filter. Should be used instead of setting the property
   * directly in order to allow overriding this in multi-select combo box.
   * @protected
   */
  _clearFilter() {
    this.filter = "";
  }
  /**
   * Reverts back to original value.
   */
  cancel() {
    this._revertInputValueToValue();
    this._lastCommittedValue = this.value;
    this._closeOrCommit();
  }
  /**
   * Override method from `ComboBoxBaseMixin` to store last committed value.
   * @protected
   * @override
   */
  _onOpened() {
    this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-opened", { bubbles: true, composed: true }));
    this._lastCommittedValue = this.value;
  }
  /**
   * Override method from `ComboBoxBaseMixin` to dispatch an event.
   * @protected
   * @override
   */
  _onOverlayClosed() {
    this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-closed", { bubbles: true, composed: true }));
  }
  /**
   * Override method from `ComboBoxBaseMixin` to commit value on overlay closing.
   * @protected
   * @override
   */
  _onClosed() {
    if (!this.loading || this.allowCustomValue) {
      this._commitValue();
    }
  }
  /**
   * Override method from `ComboBoxBaseMixin` to implement value commit logic.
   * @protected
   * @override
   */
  _commitValue() {
    if (this._focusedIndex > -1) {
      const focusedItem = this._dropdownItems[this._focusedIndex];
      if (this.selectedItem !== focusedItem) {
        this.selectedItem = focusedItem;
      }
      this._inputElementValue = this._getItemLabel(this.selectedItem);
      this._focusedIndex = -1;
    } else if (this._inputElementValue === "" || this._inputElementValue === void 0) {
      this.selectedItem = null;
      if (this.allowCustomValue) {
        this.value = "";
      }
    } else {
      const items = [this.selectedItem, ...this._dropdownItems || []];
      const itemMatchingInputValue = items[this.__getItemIndexByLabel(items, this._inputElementValue)];
      if (this.allowCustomValue && // To prevent a repetitive input value being saved after pressing ESC and Tab.
      !itemMatchingInputValue) {
        const customValue = this._inputElementValue;
        this._lastCustomValue = customValue;
        const e = new CustomEvent("custom-value-set", {
          detail: customValue,
          composed: true,
          cancelable: true,
          bubbles: true
        });
        this.dispatchEvent(e);
        if (!e.defaultPrevented) {
          this.value = customValue;
        }
      } else if (!this.allowCustomValue && !this.opened && itemMatchingInputValue) {
        this.value = this._getItemValue(itemMatchingInputValue);
      } else {
        this._revertInputValueToValue();
      }
    }
    this._detectAndDispatchChange();
    this._clearSelectionRange();
    this._clearFilter();
  }
  /**
   * Override an event listener from `InputMixin`.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onChange(event) {
    event.stopPropagation();
  }
  /**
   * Override method from `ComboBoxBaseMixin` to handle reverting value.
   * @protected
   * @override
   */
  _revertInputValue() {
    if (this.filter !== "") {
      this._inputElementValue = this.filter;
    } else {
      this._revertInputValueToValue();
    }
    this._clearSelectionRange();
  }
  /** @private */
  _revertInputValueToValue() {
    if (this.allowCustomValue && !this.selectedItem) {
      this._inputElementValue = this.value;
    } else {
      this._inputElementValue = this._getItemLabel(this.selectedItem);
    }
  }
  /** @private */
  _selectedItemChanged(selectedItem) {
    if (selectedItem === null || selectedItem === void 0) {
      if (this.filteredItems) {
        if (!this.allowCustomValue) {
          this.value = "";
        }
        this._toggleHasValue(this._hasValue);
        this._inputElementValue = this.value;
      }
    } else {
      const value = this._getItemValue(selectedItem);
      if (this.value !== value) {
        this.value = value;
        if (this.value !== value) {
          return;
        }
      }
      this._toggleHasValue(true);
      this._inputElementValue = this._getItemLabel(selectedItem);
    }
  }
  /**
   * Override an observer from `InputMixin`.
   * @protected
   * @override
   */
  _valueChanged(value, oldVal) {
    if (value === "" && oldVal === void 0) {
      return;
    }
    if (isValidValue(value)) {
      if (this._getItemValue(this.selectedItem) !== value) {
        this._selectItemForValue(value);
      }
      if (!this.selectedItem && this.allowCustomValue) {
        this._inputElementValue = value;
      }
      this._toggleHasValue(this._hasValue);
    } else {
      this.selectedItem = null;
    }
    this._clearFilter();
    this._lastCommittedValue = void 0;
  }
  /** @private */
  _detectAndDispatchChange() {
    if (document.hasFocus()) {
      this._requestValidation();
    }
    if (this.value !== this._lastCommittedValue) {
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
      this._lastCommittedValue = this.value;
    }
  }
  /** @private */
  _selectItemForValue(value) {
    const valueIndex = this.__getItemIndexByValue(this.filteredItems, value);
    const previouslySelectedItem = this.selectedItem;
    if (valueIndex >= 0) {
      this.selectedItem = this.filteredItems[valueIndex];
    } else if (this.dataProvider && this.selectedItem === void 0) {
      this.selectedItem = void 0;
    } else {
      this.selectedItem = null;
    }
    if (this.selectedItem === null && previouslySelectedItem === null) {
      this._selectedItemChanged(this.selectedItem);
    }
  }
  /**
   * Provide items to be rendered in the dropdown.
   * Override this method to show custom items.
   *
   * @protected
   * @override
   */
  _setDropdownItems(newItems) {
    const oldItems = this._dropdownItems;
    this._dropdownItems = newItems;
    const focusedItem = oldItems ? oldItems[this._focusedIndex] : null;
    const valueIndex = this.__getItemIndexByValue(newItems, this.value);
    if ((this.selectedItem === null || this.selectedItem === void 0) && valueIndex >= 0) {
      this.selectedItem = newItems[valueIndex];
    }
    const focusedItemIndex = this.__getItemIndexByValue(newItems, this._getItemValue(focusedItem));
    if (focusedItemIndex > -1) {
      this._focusedIndex = focusedItemIndex;
    } else {
      this._focusedIndex = this.__getItemIndexByLabel(newItems, this.filter);
    }
  }
  /**
   * Override method from `ComboBoxBaseMixin`.
   * @protected
   * @override
   */
  _handleFocusOut() {
    if (!this.opened && this.allowCustomValue && this._inputElementValue === this._lastCustomValue) {
      delete this._lastCustomValue;
      return;
    }
    super._handleFocusOut();
  }
  /**
   * Fired when the value changes.
   *
   * @event value-changed
   * @param {Object} detail
   * @param {String} detail.value the combobox value
   */
  /**
   * Fired when selected item changes.
   *
   * @event selected-item-changed
   * @param {Object} detail
   * @param {Object|String} detail.value the selected item. Type is the same as the type of `items`.
   */
  /**
   * Fired when the user sets a custom value.
   * @event custom-value-set
   * @param {String} detail the custom value
   */
  /**
   * Fired when the user commits a value change.
   * @event change
   */
  /**
   * Fired after the `vaadin-combo-box-overlay` opens.
   *
   * @event vaadin-combo-box-dropdown-opened
   */
  /**
   * Fired after the `vaadin-combo-box-overlay` closes.
   *
   * @event vaadin-combo-box-dropdown-closed
   */
};

// node_modules/@vaadin/combo-box/src/vaadin-combo-box.js
var ComboBox = class extends ComboBoxDataProviderMixin(
  ComboBoxMixin(
    PatternMixin(InputControlMixin(ThemableMixin(ElementMixin(PolylitMixin(LumoInjectionMixin(LitElement))))))
  )
) {
  static get is() {
    return "vaadin-combo-box";
  }
  static get styles() {
    return [inputFieldShared, comboBoxStyles];
  }
  static get properties() {
    return {
      /**
       * @protected
       */
      _positionTarget: {
        type: Object
      }
    };
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  render() {
    return html`
      <div class="vaadin-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" @click="${this.focus}"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          .readonly="${this.readonly}"
          .disabled="${this.disabled}"
          .invalid="${this.invalid}"
          theme="${ifDefined(this._theme)}"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="field-button clear-button" slot="suffix" aria-hidden="true"></div>
          <div id="toggleButton" part="field-button toggle-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>

        <slot name="tooltip"></slot>
      </div>

      <vaadin-combo-box-overlay
        id="overlay"
        exportparts="overlay, content, loader"
        .owner="${this}"
        .dir="${this.dir}"
        .opened="${this._overlayOpened}"
        ?loading="${this.loading}"
        theme="${ifDefined(this._theme)}"
        .positionTarget="${this._positionTarget}"
        no-vertical-overlap
      >
        <slot name="overlay"></slot>
      </vaadin-combo-box-overlay>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this._tooltipController.setShouldShow((target) => !target.opened);
    this._positionTarget = this.shadowRoot.querySelector('[part="input-field"]');
    this._toggleElement = this.$.toggleButton;
  }
  /** @protected */
  updated(props) {
    super.updated(props);
    if (props.has("dataProvider") || props.has("value")) {
      this._warnDataProviderValue(this.dataProvider, this.value);
    }
  }
  /**
   * Override the method from `InputControlMixin`
   * to stop event propagation to prevent `ComboBoxMixin`
   * from handling this click event also on its own.
   *
   * @param {Event} event
   * @protected
   * @override
   */
  _onClearButtonClick(event) {
    event.stopPropagation();
    super._onClearButtonClick(event);
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onHostClick(event) {
    const path = event.composedPath();
    if (path.includes(this._labelNode) || path.includes(this._positionTarget)) {
      super._onHostClick(event);
    }
  }
  /** @private */
  _warnDataProviderValue(dataProvider, value) {
    if (dataProvider && value !== "" && (this.selectedItem === void 0 || this.selectedItem === null)) {
      const valueIndex = this.__getItemIndexByValue(this.filteredItems, value);
      if (valueIndex < 0 || !this._getItemLabel(this.filteredItems[valueIndex])) {
        console.warn(
          "Warning: unable to determine the label for the provided `value`. Nothing to display in the text field. This usually happens when setting an initial `value` before any items are returned from the `dataProvider` callback. Consider setting `selectedItem` instead of `value`"
        );
      }
    }
  }
};
defineCustomElement(ComboBox);

export {
  ComboBox
};
//# sourceMappingURL=chunk-JXPBI26F.js.map
