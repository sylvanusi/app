import {
  ElementMixin
} from "./chunk-V6ISAKNA.js";
import "./chunk-OWHE56FA.js";
import {
  addListener
} from "./chunk-5W5MB6YY.js";
import {
  LumoInjectionMixin
} from "./chunk-ML4P6KOO.js";
import "./chunk-ULNR4UH6.js";
import {
  ThemableMixin
} from "./chunk-MKNWHZM7.js";
import "./chunk-TMRBPE5K.js";
import "./chunk-56IVV4NW.js";
import {
  PolylitMixin
} from "./chunk-EQ5FNEVK.js";
import {
  defineCustomElement
} from "./chunk-D2WC5P34.js";
import {
  LitElement
} from "./chunk-4MR6LGSU.js";
import {
  html
} from "./chunk-ZCNTBWU5.js";
import {
  css
} from "./chunk-5IHOHWXL.js";
import "./chunk-MWWP2LZ3.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/split-layout/src/styles/vaadin-split-layout-base-styles.js
var splitLayoutStyles = css`
  :host {
    display: flex;
    contain: layout;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([orientation='vertical']) {
    flex-direction: column;
  }

  ::slotted(*) {
    flex: 1 1 auto;
    min-width: 0;
    min-height: 0;
  }

  [part='splitter'] {
    --_splitter-size: var(--vaadin-split-layout-splitter-size, 8px);
    --_splitter-target-size: var(--vaadin-split-layout-splitter-target-size, 8px);
    --_handle-size: var(--vaadin-split-layout-handle-size, 4px);
    --_handle-target-size: var(--vaadin-split-layout-handle-target-size, 32px);
    background: var(--vaadin-split-layout-splitter-background, var(--vaadin-background-container-strong));
    flex: none;
    position: relative;
    z-index: 1;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  [part='splitter']::after {
    content: '';
    inset: 0 calc((var(--_splitter-target-size) - var(--_splitter-size)) / -2);
    position: absolute;
  }

  :host([orientation='vertical']) [part='splitter']::after {
    inset: calc((var(--_splitter-target-size) - var(--_splitter-size)) / -2) 0;
  }

  :host(:not([orientation='vertical'])) > [part='splitter'] {
    cursor: ew-resize;
    width: var(--_splitter-size);
  }

  :host([orientation='vertical']) > [part='splitter'] {
    cursor: ns-resize;
    height: var(--_splitter-size);
  }

  [part='handle'] {
    background: var(--vaadin-split-layout-handle-background, var(--vaadin-text-color-secondary));
    border-radius: var(--vaadin-radius-m);
    flex: none;
    width: var(--_handle-size);
    height: var(--_handle-target-size);
    max-height: 50%;
    position: absolute;
  }

  :host([orientation='vertical']) [part='handle'] {
    width: var(--_handle-target-size);
    max-width: 50%;
    height: var(--_handle-size);
    max-height: none;
  }

  [part='handle']::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    height: var(--_handle-target-size);
    width: var(--_handle-target-size);
    transform: translate3d(-50%, -50%, 0);
    border-radius: 50%;
  }

  :host([theme~='small']) > [part='splitter'] {
    --vaadin-split-layout-splitter-size: 1px;
    --vaadin-split-layout-splitter-target-size: 5px;
    --vaadin-split-layout-handle-size: 3px;
  }

  :host([theme~='small']) [part='splitter'] [part='handle'] {
    opacity: 0;
  }

  :host([theme~='small']) [part='splitter']:active [part='handle'] {
    opacity: 1;
  }

  @media (any-hover: hover) {
    :host([theme~='small']) [part='splitter']:hover [part='handle'] {
      opacity: 1;
    }
  }

  @media (forced-colors: active) {
    [part~='splitter'] {
      border: 1px solid;
    }
  }
`;

// node_modules/@vaadin/split-layout/src/vaadin-split-layout-mixin.js
var SplitLayoutMixin = (superClass) => class SplitLayoutMixin extends superClass {
  static get properties() {
    return {
      /**
       * The split layout's orientation. Possible values are: `horizontal|vertical`.
       * @type {string}
       */
      orientation: {
        type: String,
        reflectToAttribute: true,
        value: "horizontal"
      },
      /** @private */
      _previousPrimaryPointerEvents: String,
      /** @private */
      _previousSecondaryPointerEvents: String
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this._processChildren();
    this.__observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        this._cleanupNodes(mutation.removedNodes);
      });
      this._processChildren();
    });
    this.__observer.observe(this, { childList: true });
    const splitter = this.$.splitter;
    addListener(splitter, "track", this._onHandleTrack.bind(this));
    addListener(splitter, "down", this._setPointerEventsNone.bind(this));
    addListener(splitter, "up", this._restorePointerEvents.bind(this));
  }
  /** @private */
  _cleanupNodes(nodes) {
    nodes.forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE && !(node.parentElement instanceof this.constructor)) {
        const slot = node.getAttribute("slot");
        if (slot) {
          this[`_${slot}Child`] = null;
          node.removeAttribute("slot");
        }
      }
    });
  }
  /** @private */
  _processChildren() {
    const children = [...this.children];
    children.filter((child) => child.hasAttribute("slot")).forEach((child) => this._processChildWithSlot(child));
    children.filter((child) => !child.hasAttribute("slot")).forEach((child, i) => this._processChildWithoutSlot(child, i));
  }
  /** @private */
  _processChildWithSlot(child) {
    const slot = child.getAttribute("slot");
    if (child.__autoSlotted) {
      this[`_${slot}Child`] = null;
      child.removeAttribute("slot");
    } else {
      this[`_${slot}Child`] = child;
    }
  }
  /** @private */
  _processChildWithoutSlot(child, idx) {
    let slotName;
    if (this._primaryChild || this._secondaryChild) {
      slotName = this._primaryChild ? "secondary" : "primary";
    } else {
      slotName = idx === 0 ? "primary" : "secondary";
    }
    this[`_${slotName}Child`] = child;
    child.setAttribute("slot", slotName);
    child.__autoSlotted = true;
  }
  /** @private */
  _setFlexBasis(element, flexBasis, containerSize) {
    flexBasis = Math.max(0, Math.min(flexBasis, containerSize));
    if (flexBasis === 0) {
      flexBasis = 1e-6;
    }
    element.style.flex = `1 1 ${flexBasis}px`;
  }
  /** @private */
  _setPointerEventsNone(event) {
    if (!this._primaryChild || !this._secondaryChild) {
      return;
    }
    this._previousPrimaryPointerEvents = this._primaryChild.style.pointerEvents;
    this._previousSecondaryPointerEvents = this._secondaryChild.style.pointerEvents;
    this._primaryChild.style.pointerEvents = "none";
    this._secondaryChild.style.pointerEvents = "none";
    event.preventDefault();
  }
  /** @private */
  _restorePointerEvents() {
    if (!this._primaryChild || !this._secondaryChild) {
      return;
    }
    this._primaryChild.style.pointerEvents = this._previousPrimaryPointerEvents;
    this._secondaryChild.style.pointerEvents = this._previousSecondaryPointerEvents;
  }
  /** @private */
  _onHandleTrack(event) {
    if (!this._primaryChild || !this._secondaryChild) {
      return;
    }
    const size = this.orientation === "vertical" ? "height" : "width";
    if (event.detail.state === "start") {
      this._startSize = {
        container: this.getBoundingClientRect()[size] - this.$.splitter.getBoundingClientRect()[size],
        primary: this._primaryChild.getBoundingClientRect()[size],
        secondary: this._secondaryChild.getBoundingClientRect()[size]
      };
      return;
    }
    const distance = this.orientation === "vertical" ? event.detail.dy : event.detail.dx;
    const isRtl = this.orientation !== "vertical" && this.__isRTL;
    const dirDistance = isRtl ? -distance : distance;
    this._setFlexBasis(this._primaryChild, this._startSize.primary + dirDistance, this._startSize.container);
    this._setFlexBasis(this._secondaryChild, this._startSize.secondary - dirDistance, this._startSize.container);
    if (event.detail.state === "end") {
      this.dispatchEvent(new CustomEvent("splitter-dragend"));
      delete this._startSize;
    }
  }
};

// node_modules/@vaadin/split-layout/src/vaadin-split-layout.js
var SplitLayout = class extends SplitLayoutMixin(ElementMixin(ThemableMixin(PolylitMixin(LumoInjectionMixin(LitElement))))) {
  static get is() {
    return "vaadin-split-layout";
  }
  static get styles() {
    return splitLayoutStyles;
  }
  static get lumoInjector() {
    return { ...super.lumoInjector, includeBaseStyles: true };
  }
  /** @protected */
  render() {
    return html`
      <slot id="primary" name="primary"></slot>
      <div part="splitter" id="splitter">
        <div part="handle"></div>
      </div>
      <slot id="secondary" name="secondary"></slot>
    `;
  }
  /**
   * Fired after dragging the splitter have ended.
   *
   * @event splitter-dragend
   */
};
defineCustomElement(SplitLayout);
export {
  SplitLayout
};
//# sourceMappingURL=@vaadin_split-layout_src_vaadin-split-layout__js.js.map
