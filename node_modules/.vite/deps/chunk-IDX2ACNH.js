import {
  loaderStyles
} from "./chunk-TG7PZOH5.js";
import {
  ComboBoxBaseMixin
} from "./chunk-ZDU6TMZE.js";
import {
  DataProviderController
} from "./chunk-6KHZPEKJ.js";
import {
  ComboBoxPlaceholder
} from "./chunk-KSMWKUVB.js";
import {
  get
} from "./chunk-EQ5FNEVK.js";
import {
  css
} from "./chunk-5IHOHWXL.js";

// node_modules/@vaadin/combo-box/src/styles/vaadin-combo-box-base-styles.js
var comboBoxStyles = css`
  :host([opened]) {
    pointer-events: auto;
  }

  [part~='toggle-button']::before {
    mask-image: var(--_vaadin-icon-chevron-down);
  }

  :host([readonly]) [part~='toggle-button'] {
    display: none;
  }
`;

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js
var ComboBoxDataProviderMixin = (superClass) => class DataProviderMixin extends superClass {
  static get properties() {
    return {
      /**
       * Number of items fetched at a time from the dataprovider.
       * @attr {number} page-size
       * @type {number}
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged",
        sync: true
      },
      /**
       * Total number of items.
       * @type {number | undefined}
       */
      size: {
        type: Number,
        observer: "_sizeChanged",
        sync: true
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       *
       * `params.pageSize` Current page size
       *
       * `params.filter` Currently applied filter
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items.
       * @type {ComboBoxDataProvider | undefined}
       */
      dataProvider: {
        type: Object,
        observer: "_dataProviderChanged",
        sync: true
      }
    };
  }
  static get observers() {
    return ["_dataProviderFilterChanged(filter)", "_ensureFirstPage(opened)"];
  }
  constructor() {
    super();
    this.__dataProviderInitialized = false;
    this.__previousDataProviderFilter;
    this.__dataProviderController = new DataProviderController(this, {
      placeholder: new ComboBoxPlaceholder(),
      isPlaceholder: (item) => item instanceof ComboBoxPlaceholder,
      dataProviderParams: () => ({ filter: this.filter })
    });
    this.__dataProviderController.addEventListener("page-requested", this.__onDataProviderPageRequested.bind(this));
    this.__dataProviderController.addEventListener("page-loaded", this.__onDataProviderPageLoaded.bind(this));
  }
  /** @protected */
  ready() {
    super.ready();
    this._scroller.addEventListener("index-requested", (e) => {
      if (!this._shouldFetchData()) {
        return;
      }
      const index = e.detail.index;
      if (index !== void 0) {
        this.__dataProviderController.ensureFlatIndexLoaded(index);
      }
    });
    this.__dataProviderInitialized = true;
    if (this.dataProvider) {
      this.__synchronizeControllerState();
    }
  }
  /** @private */
  _dataProviderFilterChanged(filter) {
    if (this.__previousDataProviderFilter === void 0 && filter === "") {
      this.__previousDataProviderFilter = filter;
      return;
    }
    if (this.__previousDataProviderFilter !== filter) {
      this.__previousDataProviderFilter = filter;
      this.__keepOverlayOpened = true;
      this.size = void 0;
      this.clearCache();
      this.__keepOverlayOpened = false;
    }
  }
  /** @protected */
  _shouldFetchData() {
    if (!this.dataProvider) {
      return false;
    }
    return this.opened || this.filter && this.filter.length;
  }
  /** @private */
  _ensureFirstPage(opened) {
    if (!this._shouldFetchData() || !opened) {
      return;
    }
    if (this._forceNextRequest || this.size === void 0) {
      this._forceNextRequest = false;
      this.__dataProviderController.loadFirstPage();
    } else if (this.size > 0) {
      this.__dataProviderController.ensureFlatIndexLoaded(0);
    }
  }
  /** @private */
  __onDataProviderPageRequested() {
    this.loading = true;
  }
  /** @private */
  __onDataProviderPageLoaded() {
    const { rootCache } = this.__dataProviderController;
    rootCache.items = [...rootCache.items];
    this.__synchronizeControllerState();
    if (!this.opened && !this._isInputFocused()) {
      this._commitValue();
    }
  }
  /**
   * Clears the cached pages and reloads data from dataprovider when needed.
   */
  clearCache() {
    if (!this.dataProvider) {
      return;
    }
    this.__dataProviderController.clearCache();
    this.__synchronizeControllerState();
    if (this._shouldFetchData()) {
      this._forceNextRequest = false;
      this.__dataProviderController.loadFirstPage();
    } else {
      this._forceNextRequest = true;
    }
  }
  /**
   * When the size change originates externally, synchronizes the new size with
   * the controller and request a content update to re-render the scroller.
   *
   * @private
   */
  _sizeChanged(size) {
    const { rootCache } = this.__dataProviderController;
    if (rootCache.size !== size) {
      rootCache.size = size;
      rootCache.items = [...rootCache.items];
      this.__synchronizeControllerState();
    }
  }
  /**
   * When the items change originates externally, synchronizes the new items with
   * the controller and requests a content update to re-render the scroller.
   *
   * @private
   * @override
   */
  _filteredItemsChanged(items) {
    super._filteredItemsChanged(items);
    if (this.dataProvider && items) {
      const { rootCache } = this.__dataProviderController;
      if (rootCache.items !== items) {
        rootCache.items = items;
        this.__synchronizeControllerState();
      }
    }
  }
  /**
   * Synchronizes the controller's state with the component, which can be
   * out of sync after the controller receives new data from the data provider
   * or if the state in the controller is directly manipulated.
   *
   * @private
   */
  __synchronizeControllerState() {
    if (this.__dataProviderInitialized && this.dataProvider) {
      const { rootCache } = this.__dataProviderController;
      this.size = rootCache.size;
      this.filteredItems = rootCache.items;
      this.loading = this.__dataProviderController.isLoading();
    }
  }
  /** @private */
  _pageSizeChanged(pageSize, oldPageSize) {
    if (Math.floor(pageSize) !== pageSize || pageSize < 1) {
      this.pageSize = oldPageSize;
      throw new Error("`pageSize` value must be an integer > 0");
    }
    this.__dataProviderController.setPageSize(pageSize);
    this.clearCache();
  }
  /** @private */
  _dataProviderChanged(dataProvider, oldDataProvider) {
    this._ensureItemsOrDataProvider(() => {
      this.dataProvider = oldDataProvider;
    });
    this.__dataProviderController.setDataProvider(dataProvider);
    this.clearCache();
  }
  /** @private */
  _ensureItemsOrDataProvider(restoreOldValueCallback) {
    if (this.items !== void 0 && this.dataProvider !== void 0) {
      restoreOldValueCallback();
      throw new Error("Using `items` and `dataProvider` together is not supported");
    }
  }
};

// node_modules/@vaadin/combo-box/src/styles/vaadin-combo-box-overlay-base-styles.js
var comboBoxOverlayStyles = [
  loaderStyles,
  css`
    :host {
      --vaadin-item-checkmark-display: block;
    }

    [part='overlay'] {
      position: relative;
      width: var(--vaadin-combo-box-overlay-width, var(--_vaadin-combo-box-overlay-default-width, auto));
    }

    [part='content'] {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    :host([loading]) [part='content'] {
      --_items-min-height: calc(var(--vaadin-icon-size, 1lh) + 4px);
    }

    @media (forced-colors: active) {
      [part='loader'] {
        forced-color-adjust: none;
        --vaadin-combo-box-spinner-color: CanvasText;
      }
    }

    [part='loader'] {
      position: absolute;
      inset: calc(var(--vaadin-item-overlay-padding, 4px) + 2px);
      inset-block-end: auto;
      inset-inline-start: auto;
    }
  `
];

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-items-mixin.js
function isValidValue(value) {
  return value !== void 0 && value !== null;
}
function findItemIndex(items, callback) {
  return items.findIndex((item) => {
    if (item instanceof ComboBoxPlaceholder) {
      return false;
    }
    return callback(item);
  });
}
var ComboBoxItemsMixin = (superClass) => class ComboBoxItemsMixinClass extends ComboBoxBaseMixin(superClass) {
  static get properties() {
    return {
      /**
       * A full set of items to filter the visible options from.
       * The items can be of either `String` or `Object` type.
       * @type {!Array<!ComboBoxItem | string> | undefined}
       */
      items: {
        type: Array,
        sync: true,
        observer: "_itemsChanged"
      },
      /**
       * A subset of items, filtered based on the user input. Filtered items
       * can be assigned directly to omit the internal filtering functionality.
       * The items can be of either `String` or `Object` type.
       * @type {!Array<!ComboBoxItem | string> | undefined}
       */
      filteredItems: {
        type: Array,
        observer: "_filteredItemsChanged",
        sync: true
      },
      /**
       * Filtering string the user has typed into the input field.
       * @type {string}
       */
      filter: {
        type: String,
        value: "",
        notify: true,
        sync: true
      },
      /**
       * A function that is used to generate the label for dropdown
       * items based on the item. Receives one argument:
       * - `item` The item to generate the label for.
       */
      itemLabelGenerator: {
        type: Object
      },
      /**
       * Path for label of the item. If `items` is an array of objects, the
       * `itemLabelPath` is used to fetch the displayed string label for each
       * item.
       *
       * The item label is also used for matching items when processing user
       * input, i.e., for filtering and selecting items.
       * @attr {string} item-label-path
       * @type {string}
       */
      itemLabelPath: {
        type: String,
        value: "label",
        observer: "_itemLabelPathChanged",
        sync: true
      },
      /**
       * Path for the value of the item. If `items` is an array of objects, the
       * `itemValuePath:` is used to fetch the string value for the selected
       * item.
       *
       * The item value is used in the `value` property of the combo box,
       * to provide the form value.
       * @attr {string} item-value-path
       * @type {string}
       */
      itemValuePath: {
        type: String,
        value: "value",
        sync: true
      }
    };
  }
  /**
   * @param {Object} props
   * @protected
   */
  updated(props) {
    super.updated(props);
    if (props.has("filter")) {
      this._filterChanged(this.filter);
    }
    if (props.has("itemLabelGenerator")) {
      this.requestContentUpdate();
    }
  }
  /**
   * Override an event listener from `ComboBoxBaseMixin` to handle
   * batched setting of both `opened` and `filter` properties.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onInput(event) {
    const filter = this._inputElementValue;
    const props = {};
    if (this.filter === filter) {
      this._filterChanged(this.filter);
    } else {
      props.filter = filter;
    }
    if (!this.opened && !this._isClearButton(event) && !this.autoOpenDisabled) {
      props.opened = true;
    }
    this.setProperties(props);
  }
  /**
   * Override method from `ComboBoxBaseMixin` to handle item label path.
   * @protected
   * @override
   */
  _getItemLabel(item) {
    if (typeof this.itemLabelGenerator === "function" && item) {
      return this.itemLabelGenerator(item) || "";
    }
    let label = item && this.itemLabelPath ? get(this.itemLabelPath, item) : void 0;
    if (label === void 0 || label === null) {
      label = item ? item.toString() : "";
    }
    return label;
  }
  /** @protected */
  _getItemValue(item) {
    let value = item && this.itemValuePath ? get(this.itemValuePath, item) : void 0;
    if (value === void 0) {
      value = item ? item.toString() : "";
    }
    return value;
  }
  /** @private */
  _itemLabelPathChanged(itemLabelPath) {
    if (typeof itemLabelPath !== "string") {
      console.error("You should set itemLabelPath to a valid string");
    }
  }
  /** @private */
  _filterChanged(filter) {
    this._scrollIntoView(0);
    this._focusedIndex = -1;
    if (this.items) {
      this.filteredItems = this._filterItems(this.items, filter);
    } else {
      this._filteredItemsChanged(this.filteredItems);
    }
  }
  /** @private */
  _itemsChanged(items, oldItems) {
    this._ensureItemsOrDataProvider(() => {
      this.items = oldItems;
    });
    if (items) {
      this.filteredItems = items.slice(0);
    } else if (oldItems) {
      this.filteredItems = null;
    }
  }
  /** @private */
  _filteredItemsChanged(filteredItems) {
    this._setDropdownItems(filteredItems);
  }
  /**
   * Provide items to be rendered in the dropdown.
   * Override to provide actual implementation.
   * @protected
   */
  _setDropdownItems() {
  }
  /** @private */
  _filterItems(arr, filter) {
    if (!arr) {
      return arr;
    }
    const filteredItems = arr.filter((item) => {
      filter = filter ? filter.toString().toLowerCase() : "";
      return this._getItemLabel(item).toString().toLowerCase().indexOf(filter) > -1;
    });
    return filteredItems;
  }
  /**
   * Returns the first item that matches the provided value.
   * @protected
   */
  __getItemIndexByValue(items, value) {
    if (!items || !isValidValue(value)) {
      return -1;
    }
    return findItemIndex(items, (item) => {
      return this._getItemValue(item) === value;
    });
  }
  /**
   * Returns the first item that matches the provided label.
   * Labels are matched against each other case insensitively.
   * @protected
   */
  __getItemIndexByLabel(items, label) {
    if (!items || !label) {
      return -1;
    }
    return findItemIndex(items, (item) => {
      return this._getItemLabel(item).toString().toLowerCase() === label.toString().toLowerCase();
    });
  }
};

export {
  comboBoxOverlayStyles,
  comboBoxStyles,
  ComboBoxDataProviderMixin,
  ComboBoxItemsMixin
};
//# sourceMappingURL=chunk-IDX2ACNH.js.map
